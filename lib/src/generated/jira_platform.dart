// Generated code - Do not edit manually

import '../api_utils.dart';

// ignore_for_file: deprecated_member_use_from_same_package

class JiraPlatformApi {
  final ApiClient _client;

  JiraPlatformApi(this._client);

  /// This resource represents application roles. Use it to get details of an
  /// application role or all application roles.
  late final applicationRoles = ApplicationRolesApi(_client);

  /// This resource represents audits that record activities undertaken in Jira.
  /// Use it to get a list of audit records.
  late final auditRecords = AuditRecordsApi(_client);

  /// This resource represents system and custom avatars. Use it to obtain the
  /// details of system or custom avatars as well as add and remove avatars from
  /// a project or issue type.
  late final avatars = AvatarsApi(_client);

  /// This resource represents dashboards. Use it to obtain the details of
  /// dashboards as well as add and remove item properties from dashboards.
  late final dashboards = DashboardsApi(_client);

  /// This resource represents
  /// [filters](https://confluence.atlassian.com/x/eQiiLQ). Use it to get,
  /// create, update, or delete filters. Also use it to configure the columns
  /// for a filter and set favorite filters.
  late final filters = FiltersApi(_client);

  /// This resource represents options for sharing
  /// [filters](#api-group-Filters). Use it to get share scopes as well as add
  /// and remove share scopes from filters.
  late final filterSharing = FilterSharingApi(_client);

  /// This resource represents a list of users and a list of groups. Use it to
  /// obtain the details to populate user and group picker suggestions list.
  late final groupAndUserPicker = GroupAndUserPickerApi(_client);

  /// This resource represents groups of users. Use it to get, create, find, and
  /// delete groups as well as add and remove users from groups.
  late final groups = GroupsApi(_client);

  /// This resource represents Jira issues. Use it to:
  ///
  ///  *  create or edit issues, individually or in bulk.
  ///  *  retrieve metadata about the options for creating or editing issues.
  ///  *  delete an issue.
  ///  *  assign a user to an issue.
  ///  *  get issue changelogs.
  ///  *  send notifications about an issue.
  ///  *  get details of the transitions available for an issue.
  ///  *  transition an issue.
  late final issues = IssuesApi(_client);

  /// This resource represents issue attachments and the attachment settings for
  /// Jira. Use it to get the metadata for an attachment, delete an attachment,
  /// and view the metadata for the contents of an attachment. Also, use it to
  /// get the attachment settings for Jira.
  late final issueAttachments = IssueAttachmentsApi(_client);

  /// This resource represents issue comments. Use it to:
  ///
  ///  *  get, create, update, and delete a comment from an issue.
  ///  *  get all comments from issue.
  ///  *  get a list of comments by comment ID.
  late final issueComments = IssueCommentsApi(_client);

  /// This resource represents [issue comment](#api-group-Issue-comments)
  /// properties, which provides for storing custom data against an issue
  /// comment. Use is to get, set, and delete issue comment properties as well
  /// as obtain the keys of all properties on a comment. Comment properties are
  /// a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  late final issueCommentProperties = IssueCommentPropertiesApi(_client);

  /// This resource represents issue fields, both system and custom fields. Use
  /// it to get fields, field configurations, and create custom fields.
  late final issueFields = IssueFieldsApi(_client);

  /// This resource represents issue field configurations. Use it to get, set,
  /// and delete field configurations and field configuration schemes.
  late final issueFieldConfigurations = IssueFieldConfigurationsApi(_client);

  /// This resource represents issue custom field contexts. Use it to:
  ///
  ///  *  get, create, update, and delete custom field contexts.
  ///  *  get context to issue types and projects mappings.
  ///  *  get custom field contexts for projects and issue types.
  ///  *  assign custom field contexts to projects.
  ///  *  remove custom field contexts from projects.
  ///  *  add issue types to custom field contexts.
  late final issueCustomFieldContexts = IssueCustomFieldContextsApi(_client);

  /// This resource represents custom issue field select list options created in
  /// Jira or using the REST API. This resource supports the following field
  /// types:
  ///
  ///  *  Checkboxes.
  ///  *  Radio Buttons.
  ///  *  Select List (single choice).
  ///  *  Select List (multiple choices).
  ///  *  Select List (cascading).
  ///
  /// See
  /// [Issue custom field options (apps)](#api-group-Issue-custom-field-options--apps-)
  /// to manipulate custom issue field select list options created by a Connect
  /// app.
  ///
  /// Use this resource to retrieve, create, update, order, and delete custom
  /// field options.
  late final issueCustomFieldOptions = IssueCustomFieldOptionsApi(_client);

  /// This resource represents custom issue field select list options created by
  /// a Connect app. See
  /// [Issue custom field options](#api-group-Issue-custom-field-options) to
  /// manipulate options created in Jira or using the REST API.
  ///
  /// A select list issue field is a type of
  /// [issue field](https://developer.atlassian.com/cloud/jira/platform/modules/issue-field/)
  /// that enables a user to select an option from a list. Use this resource to
  /// add, remove, and update the options of a select list issue field.
  late final issueCustomFieldOptionsApps =
      IssueCustomFieldOptionsAppsApi(_client);

  /// This resource represents links between issues. Use it to get, create, and
  /// delete links between issues.
  ///
  /// To use this resource, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  late final issueLinks = IssueLinksApi(_client);

  /// This resource represents [issue link](#api-group-Issue-links) types. Use
  /// it to get, create, update, and delete link issue types as well as get
  /// lists of all link issue types.
  ///
  /// To use this resource, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  late final issueLinkTypes = IssueLinkTypesApi(_client);

  /// This resource represents issue navigator settings. Use it to get and set
  /// issue navigator default columns.
  late final issueNavigatorSettings = IssueNavigatorSettingsApi(_client);

  /// This resource represents notification schemes, lists of events and the
  /// recipients who will receive notifications for those events. Use this
  /// resource to get details of a notification scheme and a list of
  /// notification schemes.
  late final issueNotificationSchemes = IssueNotificationSchemesApi(_client);

  /// This resource represents issue priorities. Use it to obtain a list of
  /// issue priorities and details for individual issue priorities.
  late final issuePriorities = IssuePrioritiesApi(_client);

  /// This resource represents [issue](#api-group-Issues) properties, which
  /// provides for storing custom data against an issue. Use it to get, set, and
  /// delete issue properties as well as obtain details of all properties on an
  /// issue. Operations to bulk update and delete issue properties are also
  /// provided. Issue properties are a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  late final issueProperties = IssuePropertiesApi(_client);

  /// This resource represents remote issue links, a way of linking Jira to
  /// information in other systems. Use this resource to get, create, update,
  /// and delete remote issue links either by ID or global ID. The global ID
  /// provides a way of accessing remote issue links using information about the
  /// item's remote system host and remote system identifier.
  late final issueRemoteLinks = IssueRemoteLinksApi(_client);

  /// This resource represents issue resolution values. Use it to obtain a list
  /// of all issue resolution values and the details of individual resolution
  /// values.
  late final issueResolutions = IssueResolutionsApi(_client);

  /// This resource represents various ways to search for issues. Use it to
  /// search for issues with a JQL query and find issues to populate an issue
  /// picker.
  late final issueSearch = IssueSearchApi(_client);

  /// This resource represents issue security levels. Use it to obtain the
  /// details of any issue security level. For more information about issue
  /// security levels, see
  /// [Configuring issue-level security](https://confluence.atlassian.com/x/J4lKLg).
  late final issueSecurityLevel = IssueSecurityLevelApi(_client);

  /// This resource represents issue security schemes. Use it to get an issue
  /// security scheme or list of issues security schemes.
  ///
  /// Issue security schemes control which users or groups of users can view an
  /// issue. When an issue security scheme is associated with a project, its
  /// security levels can be applied to issues in that project. Sub-tasks also
  /// inherit the security level of their parent issue.
  late final issueSecuritySchemes = IssueSecuritySchemesApi(_client);

  /// This resource represents issues types. Use it to:
  ///
  ///  *  get, create, update, and delete issue types.
  ///  *  get all issue types for a user.
  ///  *  get alternative issue types.
  ///  *  set an avatar for an issue type.
  late final issueTypes = IssueTypesApi(_client);

  /// This resource represents issue type schemes in classic projects. Use it
  /// to:
  ///
  ///  *  get issue type schemes and a list of the projects that use them.
  ///  *  associate issue type schemes with projects.
  ///  *  add issue types to issue type schemes.
  ///  *  delete issue types from issue type schemes.
  ///  *  create, update, and delete issue type schemes.
  ///  *  change the order of issue types in issue type schemes.
  late final issueTypeSchemes = IssueTypeSchemesApi(_client);

  /// This resource represents issue type screen schemes. Use it to:
  ///
  ///  *  get issue type screen schemes and a list of the projects that use
  /// them.
  ///  *  create issue type screen schemes.
  ///  *  update issue type screen schemes.
  ///  *  delete issue type screen schemes.
  ///  *  associate issue type screen schemes with projects.
  ///  *  append issue type to screen scheme mappings to issue type screen
  /// schemes.
  ///  *  remove issue type to screen scheme mappings from issue type screen
  /// schemes.
  ///  *  update default screen scheme of issue type screen scheme.
  late final issueTypeScreenSchemes = IssueTypeScreenSchemesApi(_client);

  /// This resource represents [issue type](#api-group-Issue-types) properties,
  /// which provides for storing custom data against an issue type. Use it to
  /// get, create, and delete issue type properties as well as obtain the keys
  /// of all properties on a issues type. Issue type properties are a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  late final issueTypeProperties = IssueTypePropertiesApi(_client);

  /// This resource represents votes cast by users on an issue. Use it to get
  /// details of votes on an issue as well as cast and withdrawal votes.
  late final issueVotes = IssueVotesApi(_client);

  /// This resource represents users watching an issue. Use it to get details of
  /// users watching an issue as well as start and stop a user watching an
  /// issue.
  late final issueWatchers = IssueWatchersApi(_client);

  /// This resource represents issue worklogs. Use it to:
  ///
  ///  *  get, create, update, and delete worklogs.
  ///  *  obtain lists of updated or deleted worklogs.
  late final issueWorklogs = IssueWorklogsApi(_client);

  /// This resource represents [issue worklog](#api-group-Issue-worklogs)
  /// properties, which provides for storing custom data against an issue
  /// worklog. Use it to get, create, and delete issue worklog properties as
  /// well as obtain the keys of all properties on a issue worklog. Issue
  /// worklog properties are a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  late final issueWorklogProperties = IssueWorklogPropertiesApi(_client);

  /// This resource is a collection of operations for
  /// [Jira expressions](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/).
  late final jiraExpressions = JiraExpressionsApi(_client);

  /// This resource represents various settings in Jira. Use it to get and
  /// update Jira settings and properties.
  late final jiraSettings = JiraSettingsApi(_client);

  /// This resource represents JQL search auto-complete details. Use it to
  /// obtain JQL search auto-complete data and suggestions for use in
  /// programmatic construction of queries or custom query builders. It also
  /// provides an operation to convert one or more JQL queries with user
  /// identifiers (username or user key) to equivalent JQL queries with account
  /// IDs.
  late final jql = JQLApi(_client);

  /// This resource represents available labels. Use it to get available labels
  /// for the global label field.
  late final labels = LabelsApi(_client);

  /// This resource represents information about the current user, such as basic
  /// details, group membership, application roles, preferences, and locale. Use
  /// it to get, create, update, and delete (restore default) values of the
  /// user's preferences and locale.
  late final myself = MyselfApi(_client);

  /// This resource represents permissions. Use it to obtain details of all
  /// permissions and determine whether the user has certain permissions.
  late final permissions = PermissionsApi(_client);

  /// This resource represents permission schemes. Use it to get, create,
  /// update, and delete permission schemes as well as get, create, update, and
  /// delete details of the permissions granted in those schemes.
  late final permissionSchemes = PermissionSchemesApi(_client);

  /// This resource represents projects. Use this resource to get, create,
  /// update, and delete projects. Also get statuses available to a project, a
  /// project's notification schemes, and update a project's type.
  late final projects = ProjectsApi(_client);

  /// This resource represents avatars associated with a project. Use it to get,
  /// load, set, and remove project avatars.
  late final projectAvatars = ProjectAvatarsApi(_client);

  /// This resource represents project categories. Use it to create, update, and
  /// delete project categories as well as obtain a list of all project
  /// categories and details of individual categories. For more information on
  /// managing project categories, see
  /// [Adding, assigning, and deleting project categories](https://confluence.atlassian.com/x/-A5WMg).
  late final projectCategories = ProjectCategoriesApi(_client);

  /// This resource represents project components. Uses to get, create, update,
  /// and delete project components. Also get components for project and get a
  /// count of issues by component.
  late final projectComponents = ProjectComponentsApi(_client);

  /// This resource represents the email address used to send a project's
  /// notifications. Use this resource to get and set the
  /// [project's sender email address](https://confluence.atlassian.com/x/dolKLg).
  late final projectEmail = ProjectEmailApi(_client);

  /// This resource provides validation for project keys and names.
  late final projectKeyAndNameValidation =
      ProjectKeyAndNameValidationApi(_client);

  /// This resource represents permission schemes for a project. Use this
  /// resource to:
  ///
  ///  *  get details of a project's issue security levels available to the
  /// calling user.
  ///  *  get the permission scheme associated with the project or assign
  /// different permission scheme to the project.
  ///  *  get details of a project's issue security scheme.
  ///
  /// See
  /// [Managing project permissions](https://confluence.atlassian.com/x/yodKLg)
  /// for more information about permission schemes.
  late final projectPermissionSchemes = ProjectPermissionSchemesApi(_client);

  /// This resource represents [project](#api-group-Projects) properties, which
  /// provides for storing custom data against a project. Use it to get, create,
  /// and delete project properties as well as get a list of property keys for a
  /// project. Project properties are a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  late final projectProperties = ProjectPropertiesApi(_client);

  /// This resource represents the roles that users can play in projects. Use
  /// this resource to get, create, update, and delete project roles.
  late final projectRoles = ProjectRolesApi(_client);

  /// This resource represents the users assigned to
  /// [project roles](#api-group-Issue-comments). Use this resource to get, add,
  /// and remove default users from project roles. Also use this resource to add
  /// and remove users from a project role associated with a project.
  late final projectRoleActors = ProjectRoleActorsApi(_client);

  /// This resource represents project types. Use it to obtain a list of all
  /// project types, a list of project types accessible to the calling user, and
  /// details of a project type.
  late final projectTypes = ProjectTypesApi(_client);

  /// This resource represents project versions. Use it to get, get lists of,
  /// create, update, move, merge, and delete project versions. This resource
  /// also provides counts of issues by version.
  late final projectVersions = ProjectVersionsApi(_client);

  /// This resource represents the screens used to record issue details. Use
  /// this resource to:
  ///
  ///  *  get details of all screens.
  ///  *  get details of all the fields available for use on screens.
  ///  *  create screens.
  ///  *  delete screens.
  ///  *  update screens.
  ///  *  add a field to the default screen.
  late final screens = ScreensApi(_client);

  /// This resource represents the screen tabs used to record issue details. Use
  /// this resource to get, create, update, move, and delete screen tabs.
  late final screenTabs = ScreenTabsApi(_client);

  /// This resource represents the screen tab fields used to record issue
  /// details. Use this resource to get, add, move, and remove fields from
  /// screen tabs.
  late final screenTabFields = ScreenTabFieldsApi(_client);

  /// This resource represents screen schemes in classic projects. Use it to
  /// get, create, update, and delete screen schemes.
  late final screenSchemes = ScreenSchemesApi(_client);

  /// This resource provides information about the Jira instance.
  late final serverInfo = ServerInfoApi(_client);

  /// This resource represents a
  /// [long-running asynchronous tasks](#async-operations). Use it to obtain
  /// details about the progress of a long-running task or cancel a long-running
  /// task.
  late final tasks = TasksApi(_client);

  /// This resource represents time tracking and time tracking providers. Use it
  /// to get and set the time tracking provider, get and set the time tracking
  /// options, and disable time tracking.
  late final timeTracking = TimeTrackingApi(_client);

  /// This resource represent users. Use this resource to:
  ///
  ///  *  get, get a list of, create, and delete users.
  ///  *  get, set, and reset a user's default issue table columns.
  ///  *  get a list of the groups the user belongs to.
  ///  *  get a list of user account IDs for a list of usernames or user keys.
  late final users = UsersApi(_client);

  /// This resource represents [user](#api-group-Users) properties and provides
  /// for storing custom data against a user. Use it to get, create, and delete
  /// user properties as well as get a list of property keys for a user. This
  /// resourse is designed for integrations and apps to store per-user data and
  /// settings. This enables data used to customized the user experience to be
  /// kept in the Jira Cloud instance's database. User properties are a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  ///
  /// This resource does not access the
  /// [user properties](https://confluence.atlassian.com/x/8YxjL) created and
  /// maintained in Jira.
  late final userProperties = UserPropertiesApi(_client);

  /// This resource represents various ways to search for and find users. Use it
  /// to obtain list of users including users assignable to projects and issues,
  /// users with permissions, user lists for pickup fields, and user lists
  /// generated using structured queries. Note that the operations in this
  /// resource only return users found within the first 1000 users.
  late final userSearch = UserSearchApi(_client);

  /// This resource represents webhooks. Webhooks are calls sent to a URL when
  /// an event occurs in Jira for issues specified by a JQL query. Only Connect
  /// apps can register webhooks. For more information, see
  /// [Webhooks](https://developer.atlassian.com/cloud/jira/platform/webhooks/#registering-a-webhook-via-the-jira-rest-api-for-connect-apps).
  late final webhooks = WebhooksApi(_client);

  /// This resource represents workflows. Use it to get a list of workflows.
  late final workflows = WorkflowsApi(_client);

  /// This resource represents workflow transition rules. Workflow transition
  /// rules define a Connect app routine, such as a
  /// [workflow post functions](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-post-function/)
  /// that is executed in association with the workflow. Use this resource to
  /// read and modify configuration of workflow transition rules.
  late final workflowTransitionRules = WorkflowTransitionRulesApi(_client);

  /// This resource represents workflow schemes. Use this resource to manage
  /// workflow schemes and the workflow scheme's workflows and issue types.
  ///
  /// A workflow scheme maps issue types to workflows. A workflow scheme can be
  /// associated with one or more projects, which enables the projects to use
  /// the workflow-issue type mappings.
  ///
  /// Active workflow schemes (workflow schemes that are used by projects)
  /// cannot be edited. When an active workflow scheme is edited, a draft copy
  /// of the scheme is created. The draft workflow scheme is then be edited and
  /// published (replacing the active scheme).
  ///
  /// See
  /// [Configuring workflow schemes](https://confluence.atlassian.com/x/tohKLg)
  /// for more information.
  late final workflowSchemes = WorkflowSchemesApi(_client);

  /// This resource represents the associations between workflow schemes and
  /// projects.
  ///
  /// For more information, see
  /// [Managing your workflows](https://confluence.atlassian.com/x/q4hKLg).
  late final workflowSchemeProjectAssociations =
      WorkflowSchemeProjectAssociationsApi(_client);

  /// This resource represents draft workflow schemes. Use this resource to
  /// manage drafts of workflow schemes.
  ///
  /// A workflow scheme maps issue types to workflows. A workflow scheme can be
  /// associated with one or more projects, which enables the projects to use
  /// the workflow-issue type mappings.
  ///
  /// Active workflow schemes (workflow schemes that are used by projects)
  /// cannot be edited. Editing an active workflow scheme creates a draft copy
  /// of the scheme. The draft workflow scheme can then be edited and published
  /// (replacing the active scheme).
  ///
  /// See
  /// [Configuring workflow schemes](https://confluence.atlassian.com/x/tohKLg)
  /// for more information.
  late final workflowSchemeDrafts = WorkflowSchemeDraftsApi(_client);

  /// This resource represents issue workflow statuses. Use it to obtain a list
  /// of all statuses associated with workflows and the details of a status.
  late final workflowStatuses = WorkflowStatusesApi(_client);

  /// This resource represents status categories. Use it to obtain a list of all
  /// status categories and the details of a category. Status categories
  /// provided a mechanism for categorizing
  /// [statuses](#api-group-Workflow-statuses).
  late final workflowStatusCategories = WorkflowStatusCategoriesApi(_client);

  /// This resource represents workflow transition properties, which provides
  /// for storing custom data against a workflow transition. Use it to get,
  /// create, and delete workflow transition properties as well as get a list of
  /// property keys for a workflow transition. Workflow transition properties
  /// are a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  late final workflowTransitionProperties =
      WorkflowTransitionPropertiesApi(_client);

  /// This resource represents app properties. Use it to store arbitrary data
  /// for your
  /// [Connect app](https://developer.atlassian.com/cloud/jira/platform/integrating-with-jira-cloud/#atlassian-connect).
  late final appProperties = AppPropertiesApi(_client);

  /// This resource represents
  /// [modules registered dynamically](https://developer.atlassian.com/cloud/jira/platform/dynamic-modules/)
  /// by
  /// [Connect apps](https://developer.atlassian.com/cloud/jira/platform/integrating-with-jira-cloud/#atlassian-connect).
  late final dynamicModules = DynamicModulesApi(_client);

  void close() => _client.close();
}

/// Jira Cloud platform REST API documentation

class ApplicationRolesApi {
  final ApiClient _client;

  ApplicationRolesApi(this._client);

  /// Returns all application roles. In Jira, application roles are managed
  /// using the
  /// [Application access configuration](https://confluence.atlassian.com/x/3YxjL)
  /// page.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<ApplicationRole>> getAllApplicationRoles() async {
    return (await _client.send(
      'get',
      'rest/api/3/applicationrole',
    ) as List<Object?>)
        .map((i) =>
            ApplicationRole.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns an application role.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ApplicationRole> getApplicationRole(String key) async {
    return ApplicationRole.fromJson(await _client.send(
      'get',
      'rest/api/3/applicationrole/{key}',
      pathParameters: {
        'key': key,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class AuditRecordsApi {
  final ApiClient _client;

  AuditRecordsApi(this._client);

  /// Returns a list of audit records. The list can be filtered to include
  /// items:
  ///
  ///  *  containing a string in at least one field. For example, providing *up*
  /// will return all audit records where one or more fields contains words such
  /// as *update*.
  ///  *  created on or after a date and time.
  ///  *  created or or before a date and time.
  ///  *  created during a time period.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<AuditRecords> getAuditRecords(
      {int? offset,
      int? limit,
      String? filter,
      DateTime? from,
      DateTime? to}) async {
    return AuditRecords.fromJson(await _client.send(
      'get',
      'rest/api/3/auditing/record',
      queryParameters: {
        if (offset != null) 'offset': '$offset',
        if (limit != null) 'limit': '$limit',
        if (filter != null) 'filter': filter,
        if (from != null) 'from': '$from',
        if (to != null) 'to': '$to',
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class AvatarsApi {
  final ApiClient _client;

  AvatarsApi(this._client);

  /// Returns a list of system avatar details by owner type, where the owner
  /// types are issue type, project, or user.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<SystemAvatars> getAllSystemAvatars(String type) async {
    return SystemAvatars.fromJson(await _client.send(
      'get',
      'rest/api/3/avatar/{type}/system',
      pathParameters: {
        'type': type,
      },
    ));
  }

  /// Returns the system and custom avatars for a project or issue type.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  for custom project avatars, *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project the avatar belongs to.
  ///  *  for custom issue type avatars, *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for at
  /// least one project the issue type is used in.
  ///  *  for system avatars, none.
  Future<Avatars> getAvatars(
      {required String type, required String entityId}) async {
    return Avatars.fromJson(await _client.send(
      'get',
      'rest/api/3/universal_avatar/type/{type}/owner/{entityId}',
      pathParameters: {
        'type': type,
        'entityId': entityId,
      },
    ));
  }

  /// Loads a custom avatar for a project or issue type.
  ///
  /// Specify the avatar's local file location in the body of the request. Also,
  /// include the following headers:
  ///
  ///  *  `X-Atlassian-Token: no-check` To prevent XSRF protection blocking the
  /// request, for more information see
  /// [Special Headers](#special-request-headers).
  ///  *  `Content-Type: image/image type` Valid image types are JPEG, GIF, or
  /// PNG.
  ///
  /// For example:
  /// `curl --request POST `
  ///
  /// `--user email@example.com:<api_token> `
  ///
  /// `--header 'X-Atlassian-Token: no-check' `
  ///
  /// `--header 'Content-Type: image/< image_type>' `
  ///
  /// `--data-binary "<@/path/to/file/with/your/avatar>" `
  ///
  /// `--url
  /// 'https://your-domain.atlassian.net/rest/api/3/universal_avatar/type/{type}/owner/{entityId}'`
  ///
  /// The avatar is cropped to a square. If no crop parameters are specified,
  /// the square originates at the top left of the image. The length of the
  /// square's sides is set to the smaller of the height or width of the image.
  ///
  /// The cropped image is then used to create avatars of 16x16, 24x24, 32x32,
  /// and 48x48 in size.
  ///
  /// After creating the avatar use:
  ///
  ///  *  [Update issue type](#api-rest-api-3-issuetype-id-put) to set it as the
  /// issue type's displayed avatar.
  ///  *
  /// [Set project avatar](#api-rest-api-3-project-projectIdOrKey-avatar-put) to
  /// set it as the project's displayed avatar.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Avatar> storeAvatar(
      {required String type,
      required String entityId,
      int? x,
      int? y,
      required int size,
      required dynamic body}) async {
    return Avatar.fromJson(await _client.send(
      'post',
      'rest/api/3/universal_avatar/type/{type}/owner/{entityId}',
      pathParameters: {
        'type': type,
        'entityId': entityId,
      },
      queryParameters: {
        if (x != null) 'x': '$x',
        if (y != null) 'y': '$y',
        'size': '$size',
      },
      body: body,
    ));
  }

  /// Deletes an avatar from a project or issue type.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteAvatar(
      {required String type,
      required String owningObjectId,
      required int id}) async {
    await _client.send(
      'delete',
      'rest/api/3/universal_avatar/type/{type}/owner/{owningObjectId}/avatar/{id}',
      pathParameters: {
        'type': type,
        'owningObjectId': owningObjectId,
        'id': '$id',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class DashboardsApi {
  final ApiClient _client;

  DashboardsApi(this._client);

  /// Returns a list of dashboards owned by or shared with the user. The list
  /// may be filtered to include only favorite or owned dashboards.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<PageOfDashboards> getAllDashboards(
      {String? filter, int? startAt, int? maxResults}) async {
    return PageOfDashboards.fromJson(await _client.send(
      'get',
      'rest/api/3/dashboard',
      queryParameters: {
        if (filter != null) 'filter': filter,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Creates a dashboard.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<Dashboard> createDashboard({required DashboardDetails body}) async {
    return Dashboard.fromJson(await _client.send(
      'post',
      'rest/api/3/dashboard',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of dashboards. This operation is
  /// similar to [Get dashboards](#api-rest-api-3-dashboard-get) except that the
  /// results can be refined to include dashboards that have specific
  /// attributes. For example, dashboards with a particular name. When multiple
  /// attributes are specified only filters matching all attributes are
  /// returned.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** The following dashboards that
  /// match the query parameters are returned:
  ///
  ///  *  Dashboards owned by the user. Not returned for anonymous users.
  ///  *  Dashboards shared with a group that the user is a member of. Not
  /// returned for anonymous users.
  ///  *  Dashboards shared with a private project that the user can browse. Not
  /// returned for anonymous users.
  ///  *  Dashboards shared with a public project.
  ///  *  Dashboards shared with the public.
  Future<PageBeanDashboard> getDashboardsPaginated(
      {String? dashboardName,
      String? accountId,
      String? owner,
      String? groupname,
      int? projectId,
      String? orderBy,
      int? startAt,
      int? maxResults,
      String? expand}) async {
    return PageBeanDashboard.fromJson(await _client.send(
      'get',
      'rest/api/3/dashboard/search',
      queryParameters: {
        if (dashboardName != null) 'dashboardName': dashboardName,
        if (accountId != null) 'accountId': accountId,
        if (owner != null) 'owner': owner,
        if (groupname != null) 'groupname': groupname,
        if (projectId != null) 'projectId': '$projectId',
        if (orderBy != null) 'orderBy': orderBy,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns the keys of all properties for a dashboard item.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** The user must be the owner of
  /// the dashboard or be shared the dashboard. Note, users with the *Administer
  /// Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) are
  /// considered owners of the System dashboard. The System dashboard is
  /// considered to be shared with all other users.
  Future<PropertyKeys> getDashboardItemPropertyKeys(
      {required String dashboardId, required String itemId}) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties',
      pathParameters: {
        'dashboardId': dashboardId,
        'itemId': itemId,
      },
    ));
  }

  /// Returns the key and value of a dashboard item property.
  ///
  /// A dashboard item enables an app to add user-specific information to a user
  /// dashboard. Dashboard items are exposed to users as gadgets that users can
  /// add to their dashboards. For more information on how users do this, see
  /// [Adding and customizing gadgets](https://confluence.atlassian.com/x/7AeiLQ).
  ///
  /// When an app creates a dashboard item it registers a callback to receive
  /// the dashboard item ID. The callback fires whenever the item is rendered
  /// or, where the item is configurable, the user edits the item. The app then
  /// uses this resource to store the item's content or configuration details.
  /// For more information on working with dashboard items, see
  /// [ Building a dashboard item for a JIRA Connect add-on](https://developer.atlassian.com/server/jira/platform/guide-building-a-dashboard-item-for-a-jira-connect-add-on-33746254/)
  /// and the
  /// [Dashboard Item](https://developer.atlassian.com/cloud/jira/platform/modules/dashboard-item/)
  /// documentation.
  ///
  /// There is no resource to set or get dashboard items.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** The user must be the owner of
  /// the dashboard or be shared the dashboard. Note, users with the *Administer
  /// Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) are
  /// considered owners of the System dashboard. The System dashboard is
  /// considered to be shared with all other users.
  Future<EntityProperty> getDashboardItemProperty(
      {required String dashboardId,
      required String itemId,
      required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}',
      pathParameters: {
        'dashboardId': dashboardId,
        'itemId': itemId,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Sets the value of a dashboard item property. Use this resource in apps to
  /// store custom data against a dashboard item.
  ///
  /// A dashboard item enables an app to add user-specific information to a user
  /// dashboard. Dashboard items are exposed to users as gadgets that users can
  /// add to their dashboards. For more information on how users do this, see
  /// [Adding and customizing gadgets](https://confluence.atlassian.com/x/7AeiLQ).
  ///
  /// When an app creates a dashboard item it registers a callback to receive
  /// the dashboard item ID. The callback fires whenever the item is rendered
  /// or, where the item is configurable, the user edits the item. The app then
  /// uses this resource to store the item's content or configuration details.
  /// For more information on working with dashboard items, see
  /// [ Building a dashboard item for a JIRA Connect add-on](https://developer.atlassian.com/server/jira/platform/guide-building-a-dashboard-item-for-a-jira-connect-add-on-33746254/)
  /// and the
  /// [Dashboard Item](https://developer.atlassian.com/cloud/jira/platform/modules/dashboard-item/)
  /// documentation.
  ///
  /// There is no resource to set or get dashboard items.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** The user must be the owner of
  /// the dashboard. Note, users with the *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) are
  /// considered owners of the System dashboard.
  Future<void> setDashboardItemProperty(
      {required String dashboardId,
      required String itemId,
      required String propertyKey,
      required dynamic body}) async {
    await _client.send(
      'put',
      'rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}',
      pathParameters: {
        'dashboardId': dashboardId,
        'itemId': itemId,
        'propertyKey': propertyKey,
      },
      body: body,
    );
  }

  /// Deletes a dashboard item property.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** The user must be the owner of
  /// the dashboard. Note, users with the *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) are
  /// considered owners of the System dashboard.
  Future<void> deleteDashboardItemProperty(
      {required String dashboardId,
      required String itemId,
      required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}',
      pathParameters: {
        'dashboardId': dashboardId,
        'itemId': itemId,
        'propertyKey': propertyKey,
      },
    );
  }

  /// Returns a dashboard.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  ///
  /// However, to get a dashboard, the dashboard must be shared with the user or
  /// the user must own it. Note, users with the *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) are
  /// considered owners of the System dashboard. The System dashboard is
  /// considered to be shared with all other users.
  Future<Dashboard> getDashboard(String id) async {
    return Dashboard.fromJson(await _client.send(
      'get',
      'rest/api/3/dashboard/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Updates a dashboard, replacing all the dashboard details with those
  /// provided.
  ///
  /// **[Permissions](#permissions) required:** None
  ///
  /// The dashboard to be updated must be owned by the user.
  Future<Dashboard> updateDashboard(
      {required String id, required DashboardDetails body}) async {
    return Dashboard.fromJson(await _client.send(
      'put',
      'rest/api/3/dashboard/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a dashboard.
  ///
  /// **[Permissions](#permissions) required:** None
  ///
  /// The dashboard to be deleted must be owned by the user.
  Future<void> deleteDashboard(String id) async {
    await _client.send(
      'delete',
      'rest/api/3/dashboard/{id}',
      pathParameters: {
        'id': id,
      },
    );
  }

  /// Copies a dashboard. Any values provided in the `dashboard` parameter
  /// replace those in the copied dashboard.
  ///
  /// **[Permissions](#permissions) required:** None
  ///
  /// The dashboard to be copied must be owned by or shared with the user.
  Future<Dashboard> copyDashboard(
      {required String id, required DashboardDetails body}) async {
    return Dashboard.fromJson(await _client.send(
      'post',
      'rest/api/3/dashboard/{id}/copy',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class FiltersApi {
  final ApiClient _client;

  FiltersApi(this._client);

  /// Returns all filters. Deprecated, use
  /// [ Search for filters](#api-rest-api-3-filter-search-get) that supports
  /// search and pagination.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None, however, only the
  /// following filters are returned:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<List<Filter>> getFilters({String? expand}) async {
    return (await _client.send(
      'get',
      'rest/api/3/filter',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ) as List<Object?>)
        .map((i) => Filter.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a filter. The filter is shared according to the
  /// [default share scope](#api-rest-api-3-filter-post). The filter is not
  /// selected as a favorite.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<Filter> createFilter({String? expand, required Filter body}) async {
    return Filter.fromJson(await _client.send(
      'post',
      'rest/api/3/filter',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Returns the visible favorite filters of the user.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** A favorite filter is only
  /// visible to the user where the filter is:
  ///
  ///  *  owned by the user.
  ///  *  shared with a group that the user is a member of.
  ///  *  shared with a private project that the user has *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for.
  ///  *  shared with a public project.
  ///  *  shared with the public.
  ///
  /// For example, if the user favorites a public filter that is subsequently
  /// made private that filter is not returned by this operation.
  Future<List<Filter>> getFavouriteFilters({String? expand}) async {
    return (await _client.send(
      'get',
      'rest/api/3/filter/favourite',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ) as List<Object?>)
        .map((i) => Filter.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns the filters owned by the user. If `includeFavourites` is `true`,
  /// the user's visible favorite filters are also returned.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, a favorite filters is only visible to the user where the filter
  /// is:
  ///
  ///  *  owned by the user.
  ///  *  shared with a group that the user is a member of.
  ///  *  shared with a private project that the user has *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for.
  ///  *  shared with a public project.
  ///  *  shared with the public.
  ///
  /// For example, if the user favorites a public filter that is subsequently
  /// made private that filter is not returned by this operation.
  Future<List<Filter>> getMyFilters(
      {String? expand, bool? includeFavourites}) async {
    return (await _client.send(
      'get',
      'rest/api/3/filter/my',
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (includeFavourites != null)
          'includeFavourites': '$includeFavourites',
      },
    ) as List<Object?>)
        .map((i) => Filter.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a [paginated](#pagination) list of filters. Use this operation to
  /// get:
  ///
  ///  *  specific filters, by defining `id` only.
  ///  *  filters that match all of the specified attributes. For example, all
  /// filters for a user with a particular word in their name. When multiple
  /// attributes are specified only filters matching all attributes are
  /// returned.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None, however, only the
  /// following filters that match the query parameters are returned:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<PageBeanFilterDetails> getFiltersPaginated(
      {String? filterName,
      String? accountId,
      String? owner,
      String? groupname,
      int? projectId,
      List<int>? id,
      String? orderBy,
      int? startAt,
      int? maxResults,
      String? expand}) async {
    return PageBeanFilterDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/filter/search',
      queryParameters: {
        if (filterName != null) 'filterName': filterName,
        if (accountId != null) 'accountId': accountId,
        if (owner != null) 'owner': owner,
        if (groupname != null) 'groupname': groupname,
        if (projectId != null) 'projectId': '$projectId',
        if (id != null) 'id': '$id',
        if (orderBy != null) 'orderBy': orderBy,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns a filter.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None, however, the filter is
  /// only returned where it is:
  ///
  ///  *  owned by the user.
  ///  *  shared with a group that the user is a member of.
  ///  *  shared with a private project that the user has *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for.
  ///  *  shared with a public project.
  ///  *  shared with the public.
  Future<Filter> getFilter({required int id, String? expand}) async {
    return Filter.fromJson(await _client.send(
      'get',
      'rest/api/3/filter/{id}',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates a filter. Use this operation to update a filter's name,
  /// description, JQL, or sharing.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however the user must own the filter.
  Future<Filter> updateFilter(
      {required int id, String? expand, required Filter body}) async {
    return Filter.fromJson(await _client.send(
      'put',
      'rest/api/3/filter/{id}',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Delete a filter.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however filters can only be deleted by the creator of the filter or a user
  /// with *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteFilter(int id) async {
    await _client.send(
      'delete',
      'rest/api/3/filter/{id}',
      pathParameters: {
        'id': '$id',
      },
    );
  }

  /// Returns the columns configured for a filter. The column configuration is
  /// used when the filter's results are viewed in *List View* with the
  /// *Columns* set to *Filter*.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None, however, column details
  /// are only returned for:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<List<ColumnItem>> getColumns(int id) async {
    return (await _client.send(
      'get',
      'rest/api/3/filter/{id}/columns',
      pathParameters: {
        'id': '$id',
      },
    ) as List<Object?>)
        .map((i) => ColumnItem.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Sets the columns for a filter. Only navigable fields can be set as
  /// columns. Use [Get fields](#api-rest-api-3-field-get) to get the list
  /// fields in Jira. A navigable field has `navigable` set to `true`.
  ///
  /// The parameters for this resource are expressed as HTML form data. For
  /// example, in curl:
  ///
  /// `curl -X PUT -d columns=summary -d columns=description
  /// https://your-domain.atlassian.net/rest/api/3/filter/10000/columns`
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, columns are only set for:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<void> setColumns({required int id, required List<String> body}) async {
    await _client.send(
      'put',
      'rest/api/3/filter/{id}/columns',
      pathParameters: {
        'id': '$id',
      },
      body: body,
    );
  }

  /// Reset the user's column configuration for the filter to the default.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, columns are only reset for:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<void> resetColumns(int id) async {
    await _client.send(
      'delete',
      'rest/api/3/filter/{id}/columns',
      pathParameters: {
        'id': '$id',
      },
    );
  }

  /// Add a filter as a favorite for the user.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, the user can only favorite:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<Filter> setFavouriteForFilter(
      {required int id, String? expand}) async {
    return Filter.fromJson(await _client.send(
      'put',
      'rest/api/3/filter/{id}/favourite',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Removes a filter as a favorite for the user. Note that this operation only
  /// removes filters visible to the user from the user's favorites list. For
  /// example, if the user favorites a public filter that is subsequently made
  /// private (and is therefore no longer visible on their favorites list) they
  /// cannot remove it from their favorites list.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<Filter> deleteFavouriteForFilter(
      {required int id, String? expand}) async {
    return Filter.fromJson(await _client.send(
      'delete',
      'rest/api/3/filter/{id}/favourite',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class FilterSharingApi {
  final ApiClient _client;

  FilterSharingApi(this._client);

  /// Returns the default sharing settings for new filters and dashboards for a
  /// user.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<DefaultShareScope> getDefaultShareScope() async {
    return DefaultShareScope.fromJson(await _client.send(
      'get',
      'rest/api/3/filter/defaultShareScope',
    ));
  }

  /// Sets the default sharing for new filters and dashboards for a user.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<DefaultShareScope> setDefaultShareScope(
      {required DefaultShareScope body}) async {
    return DefaultShareScope.fromJson(await _client.send(
      'put',
      'rest/api/3/filter/defaultShareScope',
      body: body.toJson(),
    ));
  }

  /// Returns the share permissions for a filter. A filter can be shared with
  /// groups, projects, all logged-in users, or the public. Sharing with all
  /// logged-in users or the public is known as a global share permission.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None, however, share permissions
  /// are only returned for:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<List<SharePermission>> getSharePermissions(int id) async {
    return (await _client.send(
      'get',
      'rest/api/3/filter/{id}/permission',
      pathParameters: {
        'id': '$id',
      },
    ) as List<Object?>)
        .map((i) =>
            SharePermission.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Add a share permissions to a filter. If you add a global share permission
  /// (one for all logged-in users or the public) it will overwrite all share
  /// permissions for the filter.
  ///
  /// Be aware that this operation uses different objects for updating share
  /// permissions compared to [Update filter](#api-rest-api-3-filter-id-put).
  ///
  /// **[Permissions](#permissions) required:** *Share dashboards and filters*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) and the
  /// user must own the filter.
  Future<List<SharePermission>> addSharePermission(
      {required int id, required SharePermissionInputBean body}) async {
    return (await _client.send(
      'post',
      'rest/api/3/filter/{id}/permission',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ) as List<Object?>)
        .map((i) =>
            SharePermission.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a share permission for a filter. A filter can be shared with
  /// groups, projects, all logged-in users, or the public. Sharing with all
  /// logged-in users or the public is known as a global share permission.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None, however, a share
  /// permission is only returned for:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<SharePermission> getSharePermission(
      {required int id, required int permissionId}) async {
    return SharePermission.fromJson(await _client.send(
      'get',
      'rest/api/3/filter/{id}/permission/{permissionId}',
      pathParameters: {
        'id': '$id',
        'permissionId': '$permissionId',
      },
    ));
  }

  /// Deletes a share permission from a filter.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira and
  /// the user must own the filter.
  Future<void> deleteSharePermission(
      {required int id, required int permissionId}) async {
    await _client.send(
      'delete',
      'rest/api/3/filter/{id}/permission/{permissionId}',
      pathParameters: {
        'id': '$id',
        'permissionId': '$permissionId',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class GroupAndUserPickerApi {
  final ApiClient _client;

  GroupAndUserPickerApi(this._client);

  /// Returns a list of users and groups matching a string. The string is used:
  ///
  ///  *  for users, to find a case-insensitive match with display name and
  /// e-mail address. Note that if a user has hidden their email address in
  /// their user profile, partial matches of the email address will not find the
  /// user. An exact match is required.
  ///  *  for groups, to find a case-sensitive match with group name.
  ///
  /// For example, if the string *tin* is used, records with the display name
  /// *Tina*, email address *sarah@tinplatetraining.com*, and the group
  /// *accounting* would be returned.
  ///
  /// Optionally, the search can be refined to:
  ///
  ///  *  the projects and issue types associated with a custom field, such as a
  /// user picker. The search can then be further refined to return only users
  /// and groups that have permission to view specific:
  ///
  ///      *  projects.
  ///      *  issue types.
  ///
  ///     If multiple projects or issue types are specified, they must be a
  /// subset of those enabled for the custom field or no results are returned.
  /// For example, if a field is enabled for projects A, B, and C then the
  /// search could be limited to projects B and C. However, if the search is
  /// limited to projects B and D, nothing is returned.
  ///  *  not return Connect app users and groups.
  ///  *  return groups that have a case-insensitive match with the query.
  ///
  /// The primary use case for this resource is to populate a picker field
  /// suggestion list with users or groups. To this end, the returned object
  /// includes an `html` field for each list. This field highlights the matched
  /// query term in the item name with the HTML strong tag. Also, each list is
  /// wrapped in a response object that contains a header for use in a picker,
  /// specifically *Showing X of Y matching groups*.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/yodKLg).
  Future<FoundUsersAndGroups> findUsersAndGroups(
      {required String query,
      int? maxResults,
      bool? showAvatar,
      String? fieldId,
      List<String>? projectId,
      List<String>? issueTypeId,
      String? avatarSize,
      bool? caseInsensitive,
      bool? excludeConnectAddons}) async {
    return FoundUsersAndGroups.fromJson(await _client.send(
      'get',
      'rest/api/3/groupuserpicker',
      queryParameters: {
        'query': query,
        if (maxResults != null) 'maxResults': '$maxResults',
        if (showAvatar != null) 'showAvatar': '$showAvatar',
        if (fieldId != null) 'fieldId': fieldId,
        if (projectId != null) 'projectId': '$projectId',
        if (issueTypeId != null) 'issueTypeId': '$issueTypeId',
        if (avatarSize != null) 'avatarSize': avatarSize,
        if (caseInsensitive != null) 'caseInsensitive': '$caseInsensitive',
        if (excludeConnectAddons != null)
          'excludeConnectAddons': '$excludeConnectAddons',
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class GroupsApi {
  final ApiClient _client;

  GroupsApi(this._client);

  /// This operation is deprecated, use
  /// [`group/member`](#api-rest-api-3-group-member-get).
  ///
  /// Returns all users in a group.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Group> getGroup({required String groupname, String? expand}) async {
    return Group.fromJson(await _client.send(
      'get',
      'rest/api/3/group',
      queryParameters: {
        'groupname': groupname,
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Creates a group.
  ///
  /// **[Permissions](#permissions) required:** Site administration (that is,
  /// member of the *site-admin*
  /// [group](https://confluence.atlassian.com/x/24xjL)).
  Future<Group> createGroup({required AddGroupBean body}) async {
    return Group.fromJson(await _client.send(
      'post',
      'rest/api/3/group',
      body: body.toJson(),
    ));
  }

  /// Deletes a group.
  ///
  /// **[Permissions](#permissions) required:** Site administration (that is,
  /// member of the *site-admin* strategic
  /// [group](https://confluence.atlassian.com/x/24xjL)).
  Future<void> removeGroup(
      {required String groupname, String? swapGroup}) async {
    await _client.send(
      'delete',
      'rest/api/3/group',
      queryParameters: {
        'groupname': groupname,
        if (swapGroup != null) 'swapGroup': swapGroup,
      },
    );
  }

  /// Returns a [paginated](#pagination) list of groups.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanGroupDetails> bulkGetGroups(
      {int? startAt,
      int? maxResults,
      List<String>? groupId,
      List<String>? groupName}) async {
    return PageBeanGroupDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/group/bulk',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (groupId != null) 'groupId': '$groupId',
        if (groupName != null) 'groupName': '$groupName',
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of all users in a group.
  ///
  /// Note that users are ordered by username, however the username is not
  /// returned in the results due to privacy reasons.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanUserDetails> getUsersFromGroup(
      {required String groupname,
      bool? includeInactiveUsers,
      int? startAt,
      int? maxResults}) async {
    return PageBeanUserDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/group/member',
      queryParameters: {
        'groupname': groupname,
        if (includeInactiveUsers != null)
          'includeInactiveUsers': '$includeInactiveUsers',
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Adds a user to a group.
  ///
  /// **[Permissions](#permissions) required:** Site administration (that is,
  /// member of the *site-admin*
  /// [group](https://confluence.atlassian.com/x/24xjL)).
  Future<Group> addUserToGroup(
      {required String groupname, required UpdateUserToGroupBean body}) async {
    return Group.fromJson(await _client.send(
      'post',
      'rest/api/3/group/user',
      queryParameters: {
        'groupname': groupname,
      },
      body: body.toJson(),
    ));
  }

  /// Removes a user from a group.
  ///
  /// **[Permissions](#permissions) required:** Site administration (that is,
  /// member of the *site-admin*
  /// [group](https://confluence.atlassian.com/x/24xjL)).
  Future<void> removeUserFromGroup(
      {required String groupname,
      String? username,
      required String accountId}) async {
    await _client.send(
      'delete',
      'rest/api/3/group/user',
      queryParameters: {
        'groupname': groupname,
        if (username != null) 'username': username,
        'accountId': accountId,
      },
    );
  }

  /// Returns a list of groups whose names contain a query string. A list of
  /// group names can be provided to exclude groups from the results.
  ///
  /// The primary use case for this resource is to populate a group picker
  /// suggestions list. To this end, the returned object includes the `html`
  /// field where the matched query term is highlighted in the group name with
  /// the HTML strong tag. Also, the groups list is wrapped in a response object
  /// that contains a header for use in the picker, specifically *Showing X of Y
  /// matching groups*.
  ///
  /// The list returns with the groups sorted. If no groups match the list
  /// criteria, an empty list is returned.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg). Anonymous
  /// calls and calls by users without the required permission return an empty
  /// list.
  Future<FoundGroups> findGroups(
      {String? accountId,
      String? query,
      List<String>? exclude,
      int? maxResults,
      String? userName}) async {
    return FoundGroups.fromJson(await _client.send(
      'get',
      'rest/api/3/groups/picker',
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (query != null) 'query': query,
        if (exclude != null) 'exclude': '$exclude',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (userName != null) 'userName': userName,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssuesApi {
  final ApiClient _client;

  IssuesApi(this._client);

  /// Creates an issue or, where the option to create subtasks is enabled in
  /// Jira, a subtask. A transition may be applied, to move the issue or subtask
  /// to a workflow step other than the default start step, and issue properties
  /// set.
  ///
  /// The content of the issue or subtask is defined using `update` and
  /// `fields`. The fields that can be set in the issue or subtask are
  /// determined using the
  /// [ Get create issue metadata](#api-rest-api-3-issue-createmeta-get). These
  /// are the same fields that appear on the issue's create screen. Note that
  /// the `description`, `environment`, and any `textarea` type custom fields
  /// (multi-line text fields) take Atlassian Document Format content. Single
  /// line custom fields (`textfield`) accept a string and don't handle
  /// Atlassian Document Format content.
  ///
  /// Creating a subtask differs from creating an issue as follows:
  ///
  ///  *  `issueType` must be set to a subtask issue type (use
  /// [ Get create issue metadata](#api-rest-api-3-issue-createmeta-get) to find
  /// subtask issue types).
  ///  *  `parent` must contain the ID or key of the parent issue.
  ///
  /// In a next-gen project any issue may be made a child providing that the
  /// parent and child are members of the same project. In a classic project the
  /// parent field is only valid for subtasks.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects* and *Create
  /// issues* [project permissions](https://confluence.atlassian.com/x/yodKLg)
  /// for the project in which the issue or subtask is created.
  Future<CreatedIssue> createIssue(
      {bool? updateHistory, required IssueUpdateDetails body}) async {
    return CreatedIssue.fromJson(await _client.send(
      'post',
      'rest/api/3/issue',
      queryParameters: {
        if (updateHistory != null) 'updateHistory': '$updateHistory',
      },
      body: body.toJson(),
    ));
  }

  /// Creates issues and, where the option to create subtasks is enabled in
  /// Jira, subtasks. Transitions may be applied, to move the issues or subtasks
  /// to a workflow step other than the default start step, and issue properties
  /// set.
  ///
  /// The content of each issue or subtask is defined using `update` and
  /// `fields`. The fields that can be set in the issue or subtask are
  /// determined using the
  /// [ Get create issue metadata](#api-rest-api-3-issue-createmeta-get). These
  /// are the same fields that appear on the issues' create screens. Note that
  /// the `description`, `environment`, and any `textarea` type custom fields
  /// (multi-line text fields) take Atlassian Document Format content. Single
  /// line custom fields (`textfield`) accept a string and don't handle
  /// Atlassian Document Format content.
  ///
  /// Creating a subtask differs from creating an issue as follows:
  ///
  ///  *  `issueType` must be set to a subtask issue type (use
  /// [ Get create issue metadata](#api-rest-api-3-issue-createmeta-get) to find
  /// subtask issue types).
  ///  *  `parent` the must contain the ID or key of the parent issue.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects* and *Create
  /// issues* [project permissions](https://confluence.atlassian.com/x/yodKLg)
  /// for the project in which each issue or subtask is created.
  Future<CreatedIssues> createIssues({required IssuesUpdateBean body}) async {
    return CreatedIssues.fromJson(await _client.send(
      'post',
      'rest/api/3/issue/bulk',
      body: body.toJson(),
    ));
  }

  /// Returns details of projects, issue types within projects, and, when
  /// requested, the create screen fields for each issue type for the user. Use
  /// the information to populate the requests in
  /// [ Create issue](#api-rest-api-3-issue-post) and
  /// [Create issues](#api-rest-api-3-issue-bulk-post).
  ///
  /// The request can be restricted to specific projects or issue types using
  /// the query parameters. The response will contain information for the valid
  /// projects, issue types, or project and issue type combinations requested.
  /// Note that invalid project, issue type, or project and issue type
  /// combinations do not generate errors.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Create issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) in the
  /// requested projects.
  Future<IssueCreateMetadata> getCreateIssueMeta(
      {List<String>? projectIds,
      List<String>? projectKeys,
      List<String>? issuetypeIds,
      List<String>? issuetypeNames,
      String? expand}) async {
    return IssueCreateMetadata.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/createmeta',
      queryParameters: {
        if (projectIds != null) 'projectIds': '$projectIds',
        if (projectKeys != null) 'projectKeys': '$projectKeys',
        if (issuetypeIds != null) 'issuetypeIds': '$issuetypeIds',
        if (issuetypeNames != null) 'issuetypeNames': '$issuetypeNames',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns the details for an issue.
  ///
  /// The issue is identified by its ID or key, however, if the identifier
  /// doesn't match an issue, a case-insensitive search and check for moved
  /// issues is performed. If a matching issue is found its details are
  /// returned, a 302 or other redirect is **not** returned. The issue key
  /// returned in the response is the key of the issue found.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<IssueBean> getIssue(
      {required String issueIdOrKey,
      List<String>? fields,
      bool? fieldsByKeys,
      String? expand,
      List<String>? properties,
      bool? updateHistory}) async {
    return IssueBean.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (fields != null) 'fields': '$fields',
        if (fieldsByKeys != null) 'fieldsByKeys': '$fieldsByKeys',
        if (expand != null) 'expand': expand,
        if (properties != null) 'properties': '$properties',
        if (updateHistory != null) 'updateHistory': '$updateHistory',
      },
    ));
  }

  /// Edits an issue. A transition may be applied and issue properties updated
  /// as part of the edit.
  ///
  /// The edits to the issue's fields are defined using `update` and `fields`.
  /// The fields that can be edited are determined using
  /// [ Get edit issue metadata](#api-rest-api-3-issue-issueIdOrKey-editmeta-get).
  ///
  /// The parent field may be set by key or ID. For standard issue types, the
  /// parent may be removed by setting `update.parent.set.none` to *true*. Note
  /// that the `description`, `environment`, and any `textarea` type custom
  /// fields (multi-line text fields) take Atlassian Document Format content.
  /// Single line custom fields (`textfield`) accept a string and don't handle
  /// Atlassian Document Format content.
  ///
  /// Connect app users with admin permissions (from user permissions and app
  /// scopes) can override the screen security configuration using
  /// `overrideScreenSecurity` and `overrideEditableFlag`.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Edit issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> editIssue(
      {required String issueIdOrKey,
      bool? notifyUsers,
      bool? overrideScreenSecurity,
      bool? overrideEditableFlag,
      required IssueUpdateDetails body}) async {
    await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (notifyUsers != null) 'notifyUsers': '$notifyUsers',
        if (overrideScreenSecurity != null)
          'overrideScreenSecurity': '$overrideScreenSecurity',
        if (overrideEditableFlag != null)
          'overrideEditableFlag': '$overrideEditableFlag',
      },
      body: body.toJson(),
    );
  }

  /// Deletes an issue.
  ///
  /// An issue cannot be deleted if it has one or more subtasks. To delete an
  /// issue with subtasks, set `deleteSubtasks`. This causes the issue's
  /// subtasks to be deleted with the issue.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Delete issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> deleteIssue(
      {required String issueIdOrKey, String? deleteSubtasks}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (deleteSubtasks != null) 'deleteSubtasks': deleteSubtasks,
      },
    );
  }

  /// Assigns an issue to a user. Use this operation when the calling user does
  /// not have the *Edit Issues* permission but has the *Assign issue*
  /// permission for the project that the issue is in.
  ///
  /// If `name` or `accountId` is set to:
  ///
  ///  *  `"-1"`, the issue is assigned to the default assignee for the project.
  ///  *  `null`, the issue is set to unassigned.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse Projects* and *Assign Issues*
  /// [ project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> assignIssue(
      {required String issueIdOrKey, required User body}) async {
    await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}/assignee',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      body: body.toJson(),
    );
  }

  /// Returns a [paginated](#pagination) list of all changelogs for an issue
  /// sorted by date, starting from the oldest.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<PageBeanChangelog> getChangeLogs(
      {required String issueIdOrKey, int? startAt, int? maxResults}) async {
    return PageBeanChangelog.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/changelog',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Returns the edit screen fields for an issue that are visible to and
  /// editable by the user. Use the information to populate the requests in
  /// [Edit issue](#api-rest-api-3-issue-issueIdOrKey-put).
  ///
  /// Connect app users with admin permissions (from user permissions and app
  /// scopes) can return additional details using:
  ///
  ///  *  `overrideScreenSecurity` Returns hidden fields.
  ///  *  `overrideEditableFlag` Returns uneditable fields. For example, where
  /// an issue has a workflow status of closed none of its fields are editable.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///
  /// Note: For any fields to be editable the user must have the *Edit issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// issue.
  Future<IssueUpdateMetadata> getEditIssueMeta(
      {required String issueIdOrKey,
      bool? overrideScreenSecurity,
      bool? overrideEditableFlag}) async {
    return IssueUpdateMetadata.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/editmeta',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (overrideScreenSecurity != null)
          'overrideScreenSecurity': '$overrideScreenSecurity',
        if (overrideEditableFlag != null)
          'overrideEditableFlag': '$overrideEditableFlag',
      },
    ));
  }

  /// Creates an email notification for an issue and adds it to the mail queue.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> notify(
      {required String issueIdOrKey, required Notification body}) async {
    await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/notify',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      body: body.toJson(),
    );
  }

  /// Returns either all transitions or a transition that can be performed by
  /// the user on an issue, based on the issue's status.
  ///
  /// Note, if a request is made for a transition that does not exist or cannot
  /// be performed on the issue, given its status, the response will return any
  /// empty transitions list.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required: A list or transition is returned
  /// only when the user has:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///
  /// However, if the user does not have the *Transition issues*
  /// [ project permission](https://confluence.atlassian.com/x/yodKLg) the
  /// response will not list any transitions.
  Future<Transitions> getTransitions(
      {required String issueIdOrKey,
      String? expand,
      String? transitionId,
      bool? skipRemoteOnlyCondition,
      bool? includeUnavailableTransitions,
      bool? sortByOpsBarAndStatus}) async {
    return Transitions.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/transitions',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (transitionId != null) 'transitionId': transitionId,
        if (skipRemoteOnlyCondition != null)
          'skipRemoteOnlyCondition': '$skipRemoteOnlyCondition',
        if (includeUnavailableTransitions != null)
          'includeUnavailableTransitions': '$includeUnavailableTransitions',
        if (sortByOpsBarAndStatus != null)
          'sortByOpsBarAndStatus': '$sortByOpsBarAndStatus',
      },
    ));
  }

  /// Performs an issue transition and, if the transition has a screen, updates
  /// the fields from the transition screen.
  ///
  /// sortByCategory To update the fields on the transition screen, specify the
  /// fields in the `fields` or `update` parameters in the request body. Get
  /// details about the fields using
  /// [ Get transitions](#api-rest-api-3-issue-issueIdOrKey-transitions-get)
  /// with the `transitions.fields` expand.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Transition issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> doTransition(
      {required String issueIdOrKey, required IssueUpdateDetails body}) async {
    await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/transitions',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueAttachmentsApi {
  final ApiClient _client;

  IssueAttachmentsApi(this._client);

  /// Returns the attachment settings, that is, whether attachments are enabled
  /// and the maximum attachment size allowed.
  ///
  /// Note that there are also
  /// [project permissions](https://confluence.atlassian.com/x/yodKLg) that
  /// restrict whether users can create and delete attachments.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<AttachmentSettings> getAttachmentMeta() async {
    return AttachmentSettings.fromJson(await _client.send(
      'get',
      'rest/api/3/attachment/meta',
    ));
  }

  /// Returns the metadata for an attachment. Note that the attachment itself is
  /// not returned.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<AttachmentMetadata> getAttachment(String id) async {
    return AttachmentMetadata.fromJson(await _client.send(
      'get',
      'rest/api/3/attachment/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Deletes an attachment from an issue.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** For the project holding the
  /// issue containing the attachment:
  ///
  ///  *  *Delete own attachments*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to delete
  /// an attachment created by the calling user.
  ///  *  *Delete all attachments*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to delete
  /// an attachment created by any user.
  Future<void> removeAttachment(String id) async {
    await _client.send(
      'delete',
      'rest/api/3/attachment/{id}',
      pathParameters: {
        'id': id,
      },
    );
  }

  /// Returns the metadata for the contents of an attachment, if it is an
  /// archive, and metadata for the attachment itself. For example, if the
  /// attachment is a ZIP archive, then information about the files in the
  /// archive is returned and metadata for the ZIP archive. Currently, only the
  /// ZIP archive format is supported.
  ///
  /// Use this operation to retrieve data that is presented to the user, as this
  /// operation returns the metadata for the attachment itself, such as the
  /// attachment's ID and name. Otherwise, use
  /// [ Get contents metadata for an expanded attachment](#api-rest-api-3-attachment-id-expand-raw-get),
  /// which only returns the metadata for the attachment's contents.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** For the issue containing the
  /// attachment:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<AttachmentArchiveMetadataReadable> expandAttachmentForHumans(
      String id) async {
    return AttachmentArchiveMetadataReadable.fromJson(await _client.send(
      'get',
      'rest/api/3/attachment/{id}/expand/human',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Returns the metadata for the contents of an attachment, if it is an
  /// archive. For example, if the attachment is a ZIP archive, then information
  /// about the files in the archive is returned. Currently, only the ZIP
  /// archive format is supported.
  ///
  /// Use this operation if you are processing the data without presenting it to
  /// the user, as this operation only returns the metadata for the contents of
  /// the attachment. Otherwise, to retrieve data to present to the user, use
  /// [ Get all metadata for an expanded attachment](#api-rest-api-3-attachment-id-expand-human-get)
  /// which also returns the metadata for the attachment itself, such as the
  /// attachment's ID and name.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** For the issue containing the
  /// attachment:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<AttachmentArchiveImpl> expandAttachmentForMachines(String id) async {
    return AttachmentArchiveImpl.fromJson(await _client.send(
      'get',
      'rest/api/3/attachment/{id}/expand/raw',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Adds one or more attachments to an issue. Attachments are posted as
  /// multipart/form-data ([RFC 1867](https://www.ietf.org/rfc/rfc1867.txt)).
  ///
  /// Note that:
  ///
  ///  *  The request must have a `X-Atlassian-Token: no-check` header, if not
  /// it is blocked. See [Special headers](#special-request-headers) for more
  /// information.
  ///  *  The name of the multipart/form-data parameter that contains the
  /// attachments must be `file`.
  ///
  /// The following example uploads a file called *myfile.txt* to the issue
  /// *TEST-123*:
  ///
  /// `curl -D- -u admin:admin -X POST -H "X-Atlassian-Token: no-check" -F
  /// "file=@myfile.txt"
  /// https://your-domain.atlassian.net/rest/api/3/issue/TEST-123/attachments`
  ///
  /// Tip: Use a client library. Many client libraries have classes for handling
  /// multipart POST operations. For example, in Java, the Apache HTTP
  /// Components library provides a
  /// [MultiPartEntity](http://hc.apache.org/httpcomponents-client-ga/httpmime/apidocs/org/apache/http/entity/mime/MultipartEntity.html)
  /// class for multipart POST operations.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse Projects* and *Create attachments*
  /// [ project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<List<Attachment>> addAttachment(
      {required String issueIdOrKey, required MultipartFile file}) async {
    return (await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/attachments',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      file: file,
    ) as List<Object?>)
        .map((i) => Attachment.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }
}

/// Jira Cloud platform REST API documentation

class IssueCommentsApi {
  final ApiClient _client;

  IssueCommentsApi(this._client);

  /// Returns a [paginated](#pagination) list of just the comments for a list of
  /// comments specified by comment IDs.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Comments are returned where the
  /// user:
  ///
  ///  *  has *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the comment.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the comment has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<PageBeanComment> getCommentsByIds(
      {String? expand, required IssueCommentListRequestBean body}) async {
    return PageBeanComment.fromJson(await _client.send(
      'post',
      'rest/api/3/comment/list',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Returns all comments for an issue.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Comments are included in the
  /// response where the user has:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the comment.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the comment has visibility restrictions, belongs to the group or
  /// has the role visibility is role visibility is restricted to.
  Future<PageOfComments> getComments(
      {required String issueIdOrKey,
      int? startAt,
      int? maxResults,
      String? orderBy,
      String? expand}) async {
    return PageOfComments.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/comment',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (orderBy != null) 'orderBy': orderBy,
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Adds a comment to an issue.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Add comments*
  /// [ project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue containing the comment is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<Comment> addComment(
      {required String issueIdOrKey,
      String? expand,
      required Comment body}) async {
    return Comment.fromJson(await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/comment',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Returns a comment.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the comment.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the comment has visibility restrictions, the user belongs to the
  /// group or has the role visibility is restricted to.
  Future<Comment> getComment(
      {required String issueIdOrKey,
      required String id,
      String? expand}) async {
    return Comment.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/comment/{id}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'id': id,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates a comment.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue containing the comment is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Edit all
  /// comments*[ project permission](https://confluence.atlassian.com/x/yodKLg)
  /// to update any comment or *Edit own comments* to update comment created by
  /// the user.
  ///  *  If the comment has visibility restrictions, the user belongs to the
  /// group or has the role visibility is restricted to.
  Future<Comment> updateComment(
      {required String issueIdOrKey,
      required String id,
      String? expand,
      required Comment body}) async {
    return Comment.fromJson(await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}/comment/{id}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'id': id,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a comment.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue containing the comment is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Delete all
  /// comments*[ project permission](https://confluence.atlassian.com/x/yodKLg)
  /// to delete any comment or *Delete own comments* to delete comment created
  /// by the user,
  ///  *  If the comment has visibility restrictions, the user belongs to the
  /// group or has the role visibility is restricted to.
  Future<void> deleteComment(
      {required String issueIdOrKey, required String id}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/comment/{id}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'id': id,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueCommentPropertiesApi {
  final ApiClient _client;

  IssueCommentPropertiesApi(this._client);

  /// Returns the keys of all the properties of a comment.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the comment has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<PropertyKeys> getCommentPropertyKeys(String commentId) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/comment/{commentId}/properties',
      pathParameters: {
        'commentId': commentId,
      },
    ));
  }

  /// Returns the value of a comment property.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the comment has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<EntityProperty> getCommentProperty(
      {required String commentId, required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/comment/{commentId}/properties/{propertyKey}',
      pathParameters: {
        'commentId': commentId,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Creates or updates the value of a property for a comment. Use this
  /// resource to store custom data against a comment.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// **[Permissions](#permissions) required:** either of:
  ///
  ///  *  *Edit All Comments*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to create
  /// or update the value of a property on any comment.
  ///  *  *Edit Own Comments*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to create
  /// or update the value of a property on a comment created by the user.
  ///
  /// Also, when the visibility of a comment is restricted to a role or group
  /// the user must be a member of that role or group.
  Future<void> setCommentProperty(
      {required String commentId,
      required String propertyKey,
      required dynamic body}) async {
    await _client.send(
      'put',
      'rest/api/3/comment/{commentId}/properties/{propertyKey}',
      pathParameters: {
        'commentId': commentId,
        'propertyKey': propertyKey,
      },
      body: body,
    );
  }

  /// Deletes a comment property.
  ///
  /// **[Permissions](#permissions) required:** either of:
  ///
  ///  *  *Edit All Comments*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to delete
  /// a property from any comment.
  ///  *  *Edit Own Comments*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to delete
  /// a property from a comment created by the user.
  ///
  /// Also, when the visibility of a comment is restricted to a role or group
  /// the user must be a member of that role or group.
  Future<void> deleteCommentProperty(
      {required String commentId, required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/comment/{commentId}/properties/{propertyKey}',
      pathParameters: {
        'commentId': commentId,
        'propertyKey': propertyKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueFieldsApi {
  final ApiClient _client;

  IssueFieldsApi(this._client);

  /// Returns system and custom issue fields according to the following rules:
  ///
  ///  *  Fields that cannot be added to the issue navigator are always
  /// returned.
  ///  *  Fields that cannot be placed on an issue screen are always returned.
  ///  *  Fields that depend on global Jira settings are only returned if the
  /// setting is enabled. That is, timetracking fields, subtasks, votes, and
  /// watches.
  ///  *  For all other fields, this operation only returns the fields that the
  /// user has permission to view (that is, the field is used in at least one
  /// project that the user has *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for.)
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<List<FieldDetails>> getFields() async {
    return (await _client.send(
      'get',
      'rest/api/3/field',
    ) as List<Object?>)
        .map((i) =>
            FieldDetails.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a custom field.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<FieldDetails> createCustomField(
      {required CustomFieldDefinitionJsonBean body}) async {
    return FieldDetails.fromJson(await _client.send(
      'post',
      'rest/api/3/field',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of fields for Classic Jira
  /// projects. The list can include:
  ///
  ///  *  all fields.
  ///  *  specific fields, by defining `id`.
  ///  *  fields that contain a string in the field name or description, by
  /// defining `query`.
  ///  *  specific fields that contain a string in the field name or
  /// description, by defining `id` and `query`.
  ///
  /// Only custom fields can be queried, `type` must be set to `custom`.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanField> getFieldsPaginated(
      {int? startAt,
      int? maxResults,
      List<String>? type,
      List<String>? id,
      String? query,
      String? orderBy,
      String? expand}) async {
    return PageBeanField.fromJson(await _client.send(
      'get',
      'rest/api/3/field/search',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (type != null) 'type': '$type',
        if (id != null) 'id': '$id',
        if (query != null) 'query': query,
        if (orderBy != null) 'orderBy': orderBy,
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates a custom field.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> updateCustomField(
      {required String fieldId, required UpdateCustomFieldDetails body}) async {
    await _client.send(
      'put',
      'rest/api/3/field/{fieldId}',
      pathParameters: {
        'fieldId': fieldId,
      },
      body: body.toJson(),
    );
  }

  /// Returns a [paginated](#pagination) list of the contexts a field is used
  /// in. Deprecated, use
  /// [ Get custom field contexts](#api-rest-api-3-field-fieldId-context-get).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanContext> getContextsForFieldDeprecated(
      {required String fieldId, int? startAt, int? maxResults}) async {
    return PageBeanContext.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/contexts',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueFieldConfigurationsApi {
  final ApiClient _client;

  IssueFieldConfigurationsApi(this._client);

  /// Returns a [paginated](#pagination) list of all field configurations.
  ///
  /// Only field configurations used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanFieldConfiguration> getAllFieldConfigurations(
      {int? startAt, int? maxResults, List<int>? id, bool? isDefault}) async {
    return PageBeanFieldConfiguration.fromJson(await _client.send(
      'get',
      'rest/api/3/fieldconfiguration',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': '$id',
        if (isDefault != null) 'isDefault': '$isDefault',
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of all fields for a configuration.
  ///
  /// Only the fields from configurations used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanFieldConfigurationItem> getFieldConfigurationItems(
      {required int id, int? startAt, int? maxResults}) async {
    return PageBeanFieldConfigurationItem.fromJson(await _client.send(
      'get',
      'rest/api/3/fieldconfiguration/{id}/fields',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of field configuration schemes.
  ///
  /// Only field configuration schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanFieldConfigurationScheme> getAllFieldConfigurationSchemes(
      {int? startAt, int? maxResults, List<int>? id}) async {
    return PageBeanFieldConfigurationScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/fieldconfigurationscheme',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': '$id',
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of field configuration issue type
  /// items.
  ///
  /// Only items used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanFieldConfigurationIssueTypeItem>
      getFieldConfigurationSchemeMappings(
          {int? startAt,
          int? maxResults,
          List<int>? fieldConfigurationSchemeId}) async {
    return PageBeanFieldConfigurationIssueTypeItem.fromJson(await _client.send(
      'get',
      'rest/api/3/fieldconfigurationscheme/mapping',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (fieldConfigurationSchemeId != null)
          'fieldConfigurationSchemeId': '$fieldConfigurationSchemeId',
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of field configuration schemes
  /// and, for each scheme, a list of the projects that use it.
  ///
  /// The list is sorted by field configuration scheme ID. The first item
  /// contains the list of project IDs assigned to the default field
  /// configuration scheme.
  ///
  /// Only field configuration schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanFieldConfigurationSchemeProjects>
      getFieldConfigurationSchemeProjectMapping(
          {int? startAt, int? maxResults, required List<int> projectId}) async {
    return PageBeanFieldConfigurationSchemeProjects.fromJson(await _client.send(
      'get',
      'rest/api/3/fieldconfigurationscheme/project',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        'projectId': '$projectId',
      },
    ));
  }

  /// Assigns a field configuration scheme to a project. If the field
  /// configuration scheme ID is `null`, the operation assigns the default field
  /// configuration scheme.
  ///
  /// Field configuration schemes can only be assigned to classic projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> assignFieldConfigurationSchemeToProject(
      {required FieldConfigurationSchemeProjectAssociation body}) async {
    await _client.send(
      'put',
      'rest/api/3/fieldconfigurationscheme/project',
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueCustomFieldContextsApi {
  final ApiClient _client;

  IssueCustomFieldContextsApi(this._client);

  /// Returns a [paginated](#pagination) list of
  /// [ contexts](https://confluence.atlassian.com/adminjiracloud/what-are-custom-field-contexts-991923859.html)
  /// for a custom field. Contexts can be returned as follows:
  ///
  ///  *  With no other parameters set, all contexts.
  ///  *  By defining `id` only, all contexts from the list of IDs.
  ///  *  By defining `isAnyIssueType`, limit the list of contexts returned to
  /// either those that apply to all issue types (true) or those that apply to
  /// only a subset of issue types (false)
  ///  *  By defining `isGlobalContext`, limit the list of contexts return to
  /// either those that apply to all projects (global contexts) (true) or those
  /// that apply to only a subset of projects (false).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanCustomFieldContext> getContextsForField(
      {required String fieldId,
      bool? isAnyIssueType,
      bool? isGlobalContext,
      List<int>? contextId,
      int? startAt,
      int? maxResults}) async {
    return PageBeanCustomFieldContext.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/context',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (isAnyIssueType != null) 'isAnyIssueType': '$isAnyIssueType',
        if (isGlobalContext != null) 'isGlobalContext': '$isGlobalContext',
        if (contextId != null) 'contextId': '$contextId',
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Creates a custom field context.
  ///
  /// If `projectIds` is empty, a global context is created. A global context is
  /// one that applies to all project. If `issueTypeIds` is empty, the context
  /// applies to all issue types.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<CreateCustomFieldContext> createCustomFieldContext(
      {required String fieldId, required CreateCustomFieldContext body}) async {
    return CreateCustomFieldContext.fromJson(await _client.send(
      'post',
      'rest/api/3/field/{fieldId}/context',
      pathParameters: {
        'fieldId': fieldId,
      },
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of defaults for a custom field.
  /// The results can be filtered by `contextId`, otherwise all values are
  /// returned. If no defaults are set for a context, nothing is returned.
  /// The returned object depends on type of the custom field:
  ///
  ///  *  `CustomFieldContextDefaultValueSingleOption` (type `option.single`)
  /// for single choice select lists and radio buttons.
  ///  *  `CustomFieldContextDefaultValueMultipleOption` (type
  /// `option.multiple`) for multiple choice select lists and checkboxes.
  ///  *  `CustomFieldContextDefaultValueCascadingOption` (type
  /// `option.cascading`) for cascading select lists.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanCustomFieldContextDefaultValue> getDefaultValues(
      {required String fieldId,
      List<int>? contextId,
      int? startAt,
      int? maxResults}) async {
    return PageBeanCustomFieldContextDefaultValue.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/context/defaultValue',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (contextId != null) 'contextId': '$contextId',
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Sets default for contexts of a custom field. Default are defined using
  /// these objects:
  ///
  ///  *  `CustomFieldContextDefaultValueSingleOption` (type `option.single`)
  /// for single choice select lists and radio buttons.
  ///  *  `CustomFieldContextDefaultValueMultipleOption` (type
  /// `option.multiple`) for multiple choice select lists and checkboxes.
  ///  *  `CustomFieldContextDefaultValueCascadingOption` (type
  /// `option.cascading`) for cascading select lists.
  ///
  /// Only one type of default object can be included in a request. To remove a
  /// default for a context, set the default parameter to `null`.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> setDefaultValues(
      {required String fieldId,
      required CustomFieldContextDefaultValueUpdate body}) async {
    await _client.send(
      'put',
      'rest/api/3/field/{fieldId}/context/defaultValue',
      pathParameters: {
        'fieldId': fieldId,
      },
      body: body.toJson(),
    );
  }

  /// Returns a [paginated](#pagination) list of context to issue type mappings
  /// for a custom field. Mappings are returned for all contexts or a list of
  /// contexts. Mappings are ordered first by context ID and then by issue type
  /// ID.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeToContextMapping> getIssueTypeMappingsForContexts(
      {required String fieldId,
      List<int>? contextId,
      int? startAt,
      int? maxResults}) async {
    return PageBeanIssueTypeToContextMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/context/issuetypemapping',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (contextId != null) 'contextId': '$contextId',
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of project and issue type mappings
  /// and, for each mapping, the ID of a
  /// [custom field context](https://confluence.atlassian.com/x/k44fOw) that
  /// applies to the project and issue type.
  ///
  /// If there is no custom field context assigned to the project then, if
  /// present, the custom field context that applies to all projects is returned
  /// if it also applies to the issue type or all issue types. If a custom field
  /// context is not found, the returned custom field context ID is `null`.
  ///
  /// Duplicate project and issue type mappings cannot be provided in the
  /// request.
  ///
  /// The order of the returned values is the same as provided in the request.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanContextForProjectAndIssueType>
      getCustomFieldContextsForProjectsAndIssueTypes(
          {required String fieldId,
          int? startAt,
          int? maxResults,
          required ProjectIssueTypeMappings body}) async {
    return PageBeanContextForProjectAndIssueType.fromJson(await _client.send(
      'post',
      'rest/api/3/field/{fieldId}/context/mapping',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of context to project mappings for
  /// a custom field. The result can be filtered by `contextId`, or otherwise
  /// all mappings are returned. Invalid IDs are ignored.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanCustomFieldContextProjectMapping> getProjectContextMapping(
      {required String fieldId,
      List<int>? contextId,
      int? startAt,
      int? maxResults}) async {
    return PageBeanCustomFieldContextProjectMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/context/projectmapping',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (contextId != null) 'contextId': '$contextId',
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Updates a
  /// [ custom field context](https://confluence.atlassian.com/adminjiracloud/what-are-custom-field-contexts-991923859.html).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> updateCustomFieldContext(
      {required String fieldId,
      required int contextId,
      required CustomFieldContextUpdateDetails body}) async {
    await _client.send(
      'put',
      'rest/api/3/field/{fieldId}/context/{contextId}',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    );
  }

  /// Deletes a
  /// [ custom field context](https://confluence.atlassian.com/adminjiracloud/what-are-custom-field-contexts-991923859.html).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteCustomFieldContext(
      {required String fieldId, required int contextId}) async {
    await _client.send(
      'delete',
      'rest/api/3/field/{fieldId}/context/{contextId}',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
    );
  }

  /// Adds issue types to a custom field context, appending the issue types to
  /// the issue types list.
  ///
  /// A custom field context without any issue types applies to all issue types.
  /// Adding issue types to such a custom field context would result in it
  /// applying to only the listed issue types.
  ///
  /// If any of the issue types exists in the custom field context, the
  /// operation fails and no issue types are added.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> addIssueTypesToContext(
      {required String fieldId,
      required int contextId,
      required IssueTypeIds body}) async {
    await _client.send(
      'put',
      'rest/api/3/field/{fieldId}/context/{contextId}/issuetype',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    );
  }

  /// Removes issue types from a custom field context.
  ///
  /// A custom field context without any issue types applies to all issue types.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> removeIssueTypesFromContext(
      {required String fieldId,
      required int contextId,
      required IssueTypeIds body}) async {
    await _client.send(
      'post',
      'rest/api/3/field/{fieldId}/context/{contextId}/issuetype/remove',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    );
  }

  /// Assigns a custom field context to projects.
  ///
  /// If any project in the request is assigned to any context of the custom
  /// field, the operation fails.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> assignProjectsToCustomFieldContext(
      {required String fieldId,
      required int contextId,
      required ProjectIds body}) async {
    await _client.send(
      'put',
      'rest/api/3/field/{fieldId}/context/{contextId}/project',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    );
  }

  /// Removes a custom field context from projects.
  ///
  /// A custom field context without any projects applies to all projects.
  /// Removing all projects from a custom field context would result in it
  /// applying to all projects.
  ///
  /// If any project in the request is not assigned to the context, or the
  /// operation would result in two global contexts for the field, the operation
  /// fails.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> removeCustomFieldContextFromProjects(
      {required String fieldId,
      required int contextId,
      required ProjectIds body}) async {
    await _client.send(
      'post',
      'rest/api/3/field/{fieldId}/context/{contextId}/project/remove',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueCustomFieldOptionsApi {
  final ApiClient _client;

  IssueCustomFieldOptionsApi(this._client);

  /// This operation is deprecated and becomes unavailable on 8 May 2021. Use
  /// [Get custom field options (context)](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-custom-field-options/#api-rest-api-3-field-fieldid-context-contextid-option-get)
  /// instead. See
  /// [Deprecation of custom field options](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-removal-of-custom-field-options-operations/)
  /// for details.
  ///
  /// Returns a [paginated](#pagination) list of options and, where the custom
  /// select field is of the type *Select List (cascading)*, cascading options
  /// for custom select fields. Cascading options are included in the item count
  /// when determining pagination. Only options from the global context are
  /// returned.
  ///
  /// Note that this operation **only works for issue field select list options
  /// created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource**, it cannot be used with issue field select list options created
  /// by Connect apps.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanCustomFieldOptionDetails> getOptionsForField(
      {required int fieldId, int? startAt, int? maxResults}) async {
    return PageBeanCustomFieldOptionDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/customField/{fieldId}/option',
      pathParameters: {
        'fieldId': '$fieldId',
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// This operation is deprecated and becomes unavailable on 8 May 2021. Use
  /// [Update custom field options (context)](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-custom-field-options/#api-rest-api-3-field-fieldid-context-contextid-option-put)
  /// instead. See
  /// [Deprecation of custom field options](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-removal-of-custom-field-options-operations/)
  /// for details.
  ///
  /// Updates the options on a custom select field. Where an updated option is
  /// in use on an issue, the value on the issue is also updated. Options that
  /// are not found are ignored. A maximum of 1000 options, including
  /// sub-options of *Select List (cascading)* fields, can be updated per
  /// request. The options are updated on the global context of the field.
  ///
  /// Note that this operation **only works for issue field select list options
  /// created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource**, it cannot be used with issue field select list options created
  /// by Connect apps.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> updateCustomFieldOptions(
      {required int fieldId, required UpdateCustomFieldOption body}) async {
    await _client.send(
      'put',
      'rest/api/3/customField/{fieldId}/option',
      pathParameters: {
        'fieldId': '$fieldId',
      },
      body: body.toJson(),
    );
  }

  /// This operation is deprecated and becomes unavailable on 8 May 2021. Use
  /// [Create custom field options (context)](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-custom-field-options/#api-rest-api-3-field-fieldid-context-contextid-option-post)
  /// instead. See
  /// [Deprecation of custom field options](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-removal-of-custom-field-options-operations/)
  /// for details.
  ///
  /// Creates options and, where the custom select field is of the type *Select
  /// List (cascading)*, cascading options for a custom select field. The
  /// options are added to the global context of the field.
  ///
  /// Note that this operation **only works for issue field select list options
  /// created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource**, it cannot be used with issue field select list options created
  /// by Connect apps.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> createCustomFieldOptions(
      {required int fieldId,
      required BulkCreateCustomFieldOptionRequest body}) async {
    await _client.send(
      'post',
      'rest/api/3/customField/{fieldId}/option',
      pathParameters: {
        'fieldId': '$fieldId',
      },
      body: body.toJson(),
    );
  }

  /// This operation is deprecated and becomes unavailable on 8 May 2021. Use
  /// [Get custom field options (context)](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-custom-field-options/#api-rest-api-3-field-fieldid-context-contextid-option-get)
  /// instead. See
  /// [Deprecation of custom field options](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-removal-of-custom-field-options-operations/)
  /// for details.
  ///
  /// Returns a custom field option. For example, an option in a select list.
  ///
  /// Note that this operation **only works for issue field select list options
  /// created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource**, it cannot be used with issue field select list options created
  /// by Connect apps.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** The custom field option is
  /// returned as follows:
  ///
  ///  *  if the user has the *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///  *  if the user has the *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for at
  /// least one project the custom field is used in, and the field is visible in
  /// at least one layout the user has permission to view.
  Future<CustomFieldOption> getCustomFieldOption(String id) async {
    return CustomFieldOption.fromJson(await _client.send(
      'get',
      'rest/api/3/customFieldOption/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of all custom field option for a
  /// context. Options are returned first then cascading options, in the order
  /// they display in Jira.
  ///
  /// This operation works for custom field options created in Jira or the
  /// operations from this resource. **To work with issue field select list
  /// options created for Connect apps use the
  /// [Issue custom field options (apps)](#api-group-issue-custom-field-options--apps-)
  /// operations.**
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanCustomFieldContextOption> getOptionsForContext(
      {required String fieldId,
      required int contextId,
      int? optionId,
      bool? onlyOptions,
      int? startAt,
      int? maxResults}) async {
    return PageBeanCustomFieldContextOption.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/context/{contextId}/option',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      queryParameters: {
        if (optionId != null) 'optionId': '$optionId',
        if (onlyOptions != null) 'onlyOptions': '$onlyOptions',
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Updates the options of a custom field.
  ///
  /// If any of the options are not found, no options are updated. Options where
  /// the values in the request match the current values aren't updated and
  /// aren't reported in the response.
  ///
  /// Note that this operation **only works for issue field select list options
  /// created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource**, it cannot be used with issue field select list options created
  /// by Connect apps.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<CustomFieldUpdatedContextOptionsList> updateCustomFieldOption(
      {required String fieldId,
      required int contextId,
      required BulkCustomFieldOptionUpdateRequest body}) async {
    return CustomFieldUpdatedContextOptionsList.fromJson(await _client.send(
      'put',
      'rest/api/3/field/{fieldId}/context/{contextId}/option',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    ));
  }

  /// Creates options and, where the custom select field is of the type Select
  /// List (cascading), cascading options for a custom select field. The options
  /// are added to a context of the field.
  ///
  /// The maximum number of options that can be created per request is 1000 and
  /// each field can have a maximum of 10000 options.
  ///
  /// This operation works for custom field options created in Jira or the
  /// operations from this resource. **To work with issue field select list
  /// options created for Connect apps use the
  /// [Issue custom field options (apps)](#api-group-issue-custom-field-options--apps-)
  /// operations.**
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<CustomFieldCreatedContextOptionsList> createCustomFieldOption(
      {required String fieldId,
      required int contextId,
      required BulkCustomFieldOptionCreateRequest body}) async {
    return CustomFieldCreatedContextOptionsList.fromJson(await _client.send(
      'post',
      'rest/api/3/field/{fieldId}/context/{contextId}/option',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    ));
  }

  /// Changes the order of custom field options or cascading options in a
  /// context.
  ///
  /// This operation works for custom field options created in Jira or the
  /// operations from this resource. **To work with issue field select list
  /// options created for Connect apps use the
  /// [Issue custom field options (apps)](#api-group-issue-custom-field-options--apps-)
  /// operations.**
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> reorderCustomFieldOptions(
      {required String fieldId,
      required int contextId,
      required OrderOfCustomFieldOptions body}) async {
    await _client.send(
      'put',
      'rest/api/3/field/{fieldId}/context/{contextId}/option/move',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    );
  }

  /// Deletes a custom field option.
  ///
  /// Options with cascading options cannot be deleted without deleting the
  /// cascading options first.
  ///
  /// This operation works for custom field options created in Jira or the
  /// operations from this resource. **To work with issue field select list
  /// options created for Connect apps use the
  /// [Issue custom field options (apps)](#api-group-issue-custom-field-options--apps-)
  /// operations.**
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteCustomFieldOption(
      {required String fieldId,
      required int contextId,
      required int optionId}) async {
    await _client.send(
      'delete',
      'rest/api/3/field/{fieldId}/context/{contextId}/option/{optionId}',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
        'optionId': '$optionId',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueCustomFieldOptionsAppsApi {
  final ApiClient _client;

  IssueCustomFieldOptionsAppsApi(this._client);

  /// Returns a [paginated](#pagination) list of all the options of a select
  /// list issue field. A select list issue field is a type of
  /// [issue field](https://developer.atlassian.com/cloud/jira/platform/modules/issue-field/)
  /// that enables a user to select a value from a list of options.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the app providing the field.
  Future<PageBeanIssueFieldOption> getAllIssueFieldOptions(
      {int? startAt, int? maxResults, required String fieldKey}) async {
    return PageBeanIssueFieldOption.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldKey}/option',
      pathParameters: {
        'fieldKey': fieldKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Creates an option for a select list issue field.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the app providing the field.
  Future<IssueFieldOption> createIssueFieldOption(
      {required String fieldKey,
      required IssueFieldOptionCreateBean body}) async {
    return IssueFieldOption.fromJson(await _client.send(
      'post',
      'rest/api/3/field/{fieldKey}/option',
      pathParameters: {
        'fieldKey': fieldKey,
      },
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of options for a select list issue
  /// field that can be viewed and selected by the user.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PageBeanIssueFieldOption> getSelectableIssueFieldOptions(
      {int? startAt,
      int? maxResults,
      int? projectId,
      required String fieldKey}) async {
    return PageBeanIssueFieldOption.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldKey}/option/suggestions/edit',
      pathParameters: {
        'fieldKey': fieldKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (projectId != null) 'projectId': '$projectId',
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of options for a select list issue
  /// field that can be viewed by the user.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PageBeanIssueFieldOption> getVisibleIssueFieldOptions(
      {int? startAt,
      int? maxResults,
      int? projectId,
      required String fieldKey}) async {
    return PageBeanIssueFieldOption.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldKey}/option/suggestions/search',
      pathParameters: {
        'fieldKey': fieldKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (projectId != null) 'projectId': '$projectId',
      },
    ));
  }

  /// Returns an option from a select list issue field.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the app providing the field.
  Future<IssueFieldOption> getIssueFieldOption(
      {required String fieldKey, required int optionId}) async {
    return IssueFieldOption.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldKey}/option/{optionId}',
      pathParameters: {
        'fieldKey': fieldKey,
        'optionId': '$optionId',
      },
    ));
  }

  /// Updates or creates an option for a select list issue field. This operation
  /// requires that the option ID is provided when creating an option,
  /// therefore, the option ID needs to be specified as a path and body
  /// parameter. The option ID provided in the path and body must be identical.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the app providing the field.
  Future<IssueFieldOption> updateIssueFieldOption(
      {required String fieldKey,
      required int optionId,
      required IssueFieldOption body}) async {
    return IssueFieldOption.fromJson(await _client.send(
      'put',
      'rest/api/3/field/{fieldKey}/option/{optionId}',
      pathParameters: {
        'fieldKey': fieldKey,
        'optionId': '$optionId',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes an option from a select list issue field.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the app providing the field.
  Future<void> deleteIssueFieldOption(
      {required String fieldKey, required int optionId}) async {
    await _client.send(
      'delete',
      'rest/api/3/field/{fieldKey}/option/{optionId}',
      pathParameters: {
        'fieldKey': fieldKey,
        'optionId': '$optionId',
      },
    );
  }

  /// Deselects an issue-field select-list option from all issues where it is
  /// selected. A different option can be selected to replace the deselected
  /// option. The update can also be limited to a smaller set of issues by using
  /// a JQL query.
  ///
  /// This is an [asynchronous operation](#async). The response object contains
  /// a link to the long-running task.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the app providing the field.
  Future<TaskProgressBeanRemoveOptionFromIssuesResult> replaceIssueFieldOption(
      {int? replaceWith,
      String? jql,
      required String fieldKey,
      required int optionId}) async {
    return TaskProgressBeanRemoveOptionFromIssuesResult.fromJson(
        await _client.send(
      'delete',
      'rest/api/3/field/{fieldKey}/option/{optionId}/issue',
      pathParameters: {
        'fieldKey': fieldKey,
        'optionId': '$optionId',
      },
      queryParameters: {
        if (replaceWith != null) 'replaceWith': '$replaceWith',
        if (jql != null) 'jql': jql,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueLinksApi {
  final ApiClient _client;

  IssueLinksApi(this._client);

  /// Creates a link between two issues. Use this operation to indicate a
  /// relationship between two issues and optionally add a comment to the from
  /// (outward) issue. To use this resource the site must have
  /// [Issue Linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  ///
  /// This resource returns nothing on the creation of an issue link. To obtain
  /// the ID of the issue link, use
  /// `https://your-domain.atlassian.net/rest/api/3/issue/[linked issue key]?fields=issuelinks`.
  ///
  /// If the link request duplicates a link, the response indicates that the
  /// issue link was created. If the request included a comment, the comment is
  /// added.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse project*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for all
  /// the projects containing the issues to be linked,
  ///  *  *Link issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) on the
  /// project containing the from (outward) issue,
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the comment has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<void> linkIssues({required LinkIssueRequestJsonBean body}) async {
    await _client.send(
      'post',
      'rest/api/3/issueLink',
      body: body.toJson(),
    );
  }

  /// Returns an issue link.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse project*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for all
  /// the projects containing the linked issues.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, permission to view both of the issues.
  Future<IssueLink> getIssueLink(String linkId) async {
    return IssueLink.fromJson(await _client.send(
      'get',
      'rest/api/3/issueLink/{linkId}',
      pathParameters: {
        'linkId': linkId,
      },
    ));
  }

  /// Deletes an issue link.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  Browse project
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for all
  /// the projects containing the issues in the link.
  ///  *  *Link issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for at
  /// least one of the projects containing issues in the link.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, permission to view both of the issues.
  Future<void> deleteIssueLink(String linkId) async {
    await _client.send(
      'delete',
      'rest/api/3/issueLink/{linkId}',
      pathParameters: {
        'linkId': linkId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueLinkTypesApi {
  final ApiClient _client;

  IssueLinkTypesApi(this._client);

  /// Returns a list of all issue link types.
  ///
  /// To use this operation, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for a
  /// project in the site.
  Future<IssueLinkTypes> getIssueLinkTypes() async {
    return IssueLinkTypes.fromJson(await _client.send(
      'get',
      'rest/api/3/issueLinkType',
    ));
  }

  /// Creates an issue link type. Use this operation to create descriptions of
  /// the reasons why issues are linked. The issue link type consists of a name
  /// and descriptions for a link's inward and outward relationships.
  ///
  /// To use this operation, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueLinkType> createIssueLinkType(
      {required IssueLinkType body}) async {
    return IssueLinkType.fromJson(await _client.send(
      'post',
      'rest/api/3/issueLinkType',
      body: body.toJson(),
    ));
  }

  /// Returns an issue link type.
  ///
  /// To use this operation, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for a
  /// project in the site.
  Future<IssueLinkType> getIssueLinkType(String issueLinkTypeId) async {
    return IssueLinkType.fromJson(await _client.send(
      'get',
      'rest/api/3/issueLinkType/{issueLinkTypeId}',
      pathParameters: {
        'issueLinkTypeId': issueLinkTypeId,
      },
    ));
  }

  /// Updates an issue link type.
  ///
  /// To use this operation, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueLinkType> updateIssueLinkType(
      {required String issueLinkTypeId, required IssueLinkType body}) async {
    return IssueLinkType.fromJson(await _client.send(
      'put',
      'rest/api/3/issueLinkType/{issueLinkTypeId}',
      pathParameters: {
        'issueLinkTypeId': issueLinkTypeId,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes an issue link type.
  ///
  /// To use this operation, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteIssueLinkType(String issueLinkTypeId) async {
    await _client.send(
      'delete',
      'rest/api/3/issueLinkType/{issueLinkTypeId}',
      pathParameters: {
        'issueLinkTypeId': issueLinkTypeId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueNavigatorSettingsApi {
  final ApiClient _client;

  IssueNavigatorSettingsApi(this._client);

  /// Returns the default issue navigator columns.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<ColumnItem>> getIssueNavigatorDefaultColumns() async {
    return (await _client.send(
      'get',
      'rest/api/3/settings/columns',
    ) as List<Object?>)
        .map((i) => ColumnItem.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Sets the default issue navigator columns.
  ///
  /// The `columns` parameter accepts a navigable field value and is expressed
  /// as HTML form data. To specify multiple columns, pass multiple `columns`
  /// parameters. For example, in curl:
  ///
  /// `curl -X PUT -d columns=summary -d columns=description
  /// https://your-domain.atlassian.net/rest/api/3/settings/columns`
  ///
  /// If no column details are sent, then all default columns are removed.
  ///
  /// A navigable field is one that can be used as a column on the issue
  /// navigator. Find details of navigable issue columns using
  /// [Get fields](#api-rest-api-3-field-get).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> setIssueNavigatorDefaultColumns(
      {required List<String> body}) async {
    await _client.send(
      'put',
      'rest/api/3/settings/columns',
      body: body,
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueNotificationSchemesApi {
  final ApiClient _client;

  IssueNotificationSchemesApi(this._client);

  /// Returns a [paginated](#pagination) list of
  /// [notification schemes](https://confluence.atlassian.com/x/8YdKLg) ordered
  /// by display name.
  ///
  /// ### About notification schemes ###
  ///
  /// A notification scheme is a list of events and recipients who will receive
  /// notifications for those events. The list is contained within the
  /// `notificationSchemeEvents` object and contains pairs of `events` and
  /// `notifications`:
  ///
  ///  *  `event` Identifies the type of event. The events can be
  /// [Jira system events](https://confluence.atlassian.com/x/8YdKLg#Creatinganotificationscheme-eventsEvents)
  /// or [custom events](https://confluence.atlassian.com/x/AIlKLg).
  ///  *  `notifications` Identifies the
  /// [recipients](https://confluence.atlassian.com/x/8YdKLg#Creatinganotificationscheme-recipientsRecipients)
  /// of notifications for each event. Recipients can be any of the following
  /// types:
  ///
  ///      *  `CurrentAssignee`
  ///      *  `Reporter`
  ///      *  `CurrentUser`
  ///      *  `ProjectLead`
  ///      *  `ComponentLead`
  ///      *  `User` (the `parameter` is the user key)
  ///      *  `Group` (the `parameter` is the group name)
  ///      *  `ProjectRole` (the `parameter` is the project role ID)
  ///      *  `EmailAddress`
  ///      *  `AllWatchers`
  ///      *  `UserCustomField` (the `parameter` is the ID of the custom field)
  ///      *  `GroupCustomField`(the `parameter` is the ID of the custom field)
  ///
  /// *Note that you should allow for events without recipients to appear in
  /// responses.*
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however the user must have permission to administer at least one project
  /// associated with a notification scheme for it to be returned.
  Future<PageBeanNotificationScheme> getNotificationSchemes(
      {int? startAt, int? maxResults, String? expand}) async {
    return PageBeanNotificationScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/notificationscheme',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns a
  /// [notification scheme](https://confluence.atlassian.com/x/8YdKLg),
  /// including the list of events and the recipients who will receive
  /// notifications for those events.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however the user must have permission to administer at least one project
  /// associated with the notification scheme.
  Future<NotificationScheme> getNotificationScheme(
      {required int id, String? expand}) async {
    return NotificationScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/notificationscheme/{id}',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssuePrioritiesApi {
  final ApiClient _client;

  IssuePrioritiesApi(this._client);

  /// Returns the list of all issue priorities.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<List<Priority>> getPriorities() async {
    return (await _client.send(
      'get',
      'rest/api/3/priority',
    ) as List<Object?>)
        .map((i) => Priority.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns an issue priority.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<Priority> getPriority(String id) async {
    return Priority.fromJson(await _client.send(
      'get',
      'rest/api/3/priority/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssuePropertiesApi {
  final ApiClient _client;

  IssuePropertiesApi(this._client);

  /// Sets the values of entity properties on issues. It can set up to 10 entity
  /// properties on up to 10,000 issues.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON. The maximum
  /// length of single issue property value is 32768 characters. This operation
  /// can be accessed anonymously.
  ///
  /// This operation is:
  ///
  ///  *  transactional, either all properties are updated in all eligible
  /// issues or, when errors occur, no properties are updated.
  ///  *  [asynchronous](#async). Follow the `location` link in the response to
  /// determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Edit issues*
  /// [project permissions](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> bulkSetIssuesProperties(
      {required IssueEntityProperties body}) async {
    await _client.send(
      'post',
      'rest/api/3/issue/properties',
      body: body.toJson(),
    );
  }

  /// Sets a property value on multiple issues.
  ///
  /// The value set can be a constant or determined by a
  /// [Jira expression](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/).
  /// Expressions must be computable with constant complexity when applied to a
  /// set of issues. Expressions must also comply with the
  /// [restrictions](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#restrictions)
  /// that apply to all Jira expressions.
  ///
  /// The issues to be updated can be specified by a filter.
  ///
  /// The filter identifies issues eligible for update using these criteria:
  ///
  ///  *  `entityIds` Only issues from this list are eligible.
  ///  *  `currentValue` Only issues with the property set to this value are
  /// eligible.
  ///  *  `hasProperty`:
  ///
  ///      *  If *true*, only issues with the property are eligible.
  ///      *  If *false*, only issues without the property are eligible.
  ///
  /// If more than one criteria is specified, they are joined with the logical
  /// *AND*: only issues that satisfy all criteria are eligible.
  ///
  /// If an invalid combination of criteria is provided, an error is returned.
  /// For example, specifying a `currentValue` and `hasProperty` as *false*
  /// would not match any issues (because without the property the property
  /// cannot have a value).
  ///
  /// The filter is optional. Without the filter all the issues visible to the
  /// user and where the user has the EDIT_ISSUES permission for the issue are
  /// considered eligible.
  ///
  /// This operation is:
  ///
  ///  *  transactional, either all eligible issues are updated or, when errors
  /// occur, none are updated.
  ///  *  [asynchronous](#async). Follow the `location` link in the response to
  /// determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for each
  /// project containing issues.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Edit issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for each
  /// issue.
  Future<void> bulkSetIssueProperty(
      {required String propertyKey,
      required BulkIssuePropertyUpdateRequest body}) async {
    await _client.send(
      'put',
      'rest/api/3/issue/properties/{propertyKey}',
      pathParameters: {
        'propertyKey': propertyKey,
      },
      body: body.toJson(),
    );
  }

  /// Deletes a property value from multiple issues. The issues to be updated
  /// can be specified by filter criteria.
  ///
  /// The criteria the filter used to identify eligible issues are:
  ///
  ///  *  `entityIds` Only issues from this list are eligible.
  ///  *  `currentValue` Only issues with the property set to this value are
  /// eligible.
  ///
  /// If both criteria is specified, they are joined with the logical *AND*:
  /// only issues that satisfy both criteria are considered eligible.
  ///
  /// If no filter criteria are specified, all the issues visible to the user
  /// and where the user has the EDIT_ISSUES permission for the issue are
  /// considered eligible.
  ///
  /// This operation is:
  ///
  ///  *  transactional, either the property is deleted from all eligible issues
  /// or, when errors occur, no properties are deleted.
  ///  *  [asynchronous](#async). Follow the `location` link in the response to
  /// determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [ project permission](https://confluence.atlassian.com/x/yodKLg) for each
  /// project containing issues.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Edit issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for each
  /// issue.
  Future<void> bulkDeleteIssueProperty(
      {required String propertyKey,
      required IssueFilterForBulkPropertyDelete body}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/properties/{propertyKey}',
      pathParameters: {
        'propertyKey': propertyKey,
      },
      body: body.toJson(),
    );
  }

  /// Returns the URLs and keys of an issue's properties.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Property details are only
  /// returned where the user has:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<PropertyKeys> getIssuePropertyKeys(String issueIdOrKey) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/properties',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
    ));
  }

  /// Returns the key and value of an issue's property.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<EntityProperty> getIssueProperty(
      {required String issueIdOrKey, required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/properties/{propertyKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Sets the value of an issue's property. Use this resource to store custom
  /// data against an issue.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Edit issues*
  /// [project permissions](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> setIssueProperty(
      {required String issueIdOrKey,
      required String propertyKey,
      required dynamic body}) async {
    await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}/properties/{propertyKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'propertyKey': propertyKey,
      },
      body: body,
    );
  }

  /// Deletes an issue's property.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Edit issues*
  /// [project permissions](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> deleteIssueProperty(
      {required String issueIdOrKey, required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/properties/{propertyKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'propertyKey': propertyKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueRemoteLinksApi {
  final ApiClient _client;

  IssueRemoteLinksApi(this._client);

  /// Returns the remote issue links for an issue. When a remote issue link
  /// global ID is provided the record with that global ID is returned,
  /// otherwise all remote issue links are returned. Where a global ID includes
  /// reserved URL characters these must be escaped in the request. For example,
  /// pass `system=http://www.mycompany.com/support&id=1` as
  /// `system%3Dhttp%3A%2F%2Fwww.mycompany.com%2Fsupport%26id%3D1`.
  ///
  /// This operation requires
  /// [issue linking to be active](https://confluence.atlassian.com/x/yoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<RemoteIssueLink> getRemoteIssueLinks(
      {required String issueIdOrKey, String? globalId}) async {
    return RemoteIssueLink.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/remotelink',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (globalId != null) 'globalId': globalId,
      },
    ));
  }

  /// Creates or updates a remote issue link for an issue.
  ///
  /// If a `globalId` is provided and a remote issue link with that global ID is
  /// found it is updated. Any fields without values in the request are set to
  /// null. Otherwise, the remote issue link is created.
  ///
  /// This operation requires
  /// [issue linking to be active](https://confluence.atlassian.com/x/yoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Link issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<RemoteIssueLinkIdentifies> createOrUpdateRemoteIssueLink(
      {required String issueIdOrKey,
      required RemoteIssueLinkRequest body}) async {
    return RemoteIssueLinkIdentifies.fromJson(await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/remotelink',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the remote issue link from the issue using the link's global ID.
  /// Where the global ID includes reserved URL characters these must be escaped
  /// in the request. For example, pass
  /// `system=http://www.mycompany.com/support&id=1` as
  /// `system%3Dhttp%3A%2F%2Fwww.mycompany.com%2Fsupport%26id%3D1`.
  ///
  /// This operation requires
  /// [issue linking to be active](https://confluence.atlassian.com/x/yoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Link issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is implemented, issue-level security permission to view the issue.
  Future<void> deleteRemoteIssueLinkByGlobalId(
      {required String issueIdOrKey, required String globalId}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/remotelink',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        'globalId': globalId,
      },
    );
  }

  /// Returns a remote issue link for an issue.
  ///
  /// This operation requires
  /// [issue linking to be active](https://confluence.atlassian.com/x/yoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<RemoteIssueLink> getRemoteIssueLinkById(
      {required String issueIdOrKey, required String linkId}) async {
    return RemoteIssueLink.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/remotelink/{linkId}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'linkId': linkId,
      },
    ));
  }

  /// Updates a remote issue link for an issue.
  ///
  /// Note: Fields without values in the request are set to null.
  ///
  /// This operation requires
  /// [issue linking to be active](https://confluence.atlassian.com/x/yoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Link issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> updateRemoteIssueLink(
      {required String issueIdOrKey,
      required String linkId,
      required RemoteIssueLinkRequest body}) async {
    await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}/remotelink/{linkId}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'linkId': linkId,
      },
      body: body.toJson(),
    );
  }

  /// Deletes a remote issue link from an issue.
  ///
  /// This operation requires
  /// [issue linking to be active](https://confluence.atlassian.com/x/yoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*, *Edit issues*, and *Link issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> deleteRemoteIssueLinkById(
      {required String issueIdOrKey, required String linkId}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/remotelink/{linkId}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'linkId': linkId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueResolutionsApi {
  final ApiClient _client;

  IssueResolutionsApi(this._client);

  /// Returns a list of all issue resolution values.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<List<Resolution>> getResolutions() async {
    return (await _client.send(
      'get',
      'rest/api/3/resolution',
    ) as List<Object?>)
        .map((i) => Resolution.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns an issue resolution value.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<Resolution> getResolution(String id) async {
    return Resolution.fromJson(await _client.send(
      'get',
      'rest/api/3/resolution/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueSearchApi {
  final ApiClient _client;

  IssueSearchApi(this._client);

  /// Returns lists of issues matching a query string. Use this resource to
  /// provide auto-completion suggestions when the user is looking for an issue
  /// using a word or string.
  ///
  /// This operation returns two lists:
  ///
  ///  *  `History Search` which includes issues from the user's history of
  /// created, edited, or viewed issues that contain the string in the `query`
  /// parameter.
  ///  *  `Current Search` which includes issues that match the JQL expression
  /// in `currentJQL` and contain the string in the `query` parameter.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<IssuePickerSuggestions> getIssuePickerResource(
      {String? query,
      String? currentJql,
      String? currentIssueKey,
      String? currentProjectId,
      bool? showSubTasks,
      bool? showSubTaskParent}) async {
    return IssuePickerSuggestions.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/picker',
      queryParameters: {
        if (query != null) 'query': query,
        if (currentJql != null) 'currentJQL': currentJql,
        if (currentIssueKey != null) 'currentIssueKey': currentIssueKey,
        if (currentProjectId != null) 'currentProjectId': currentProjectId,
        if (showSubTasks != null) 'showSubTasks': '$showSubTasks',
        if (showSubTaskParent != null)
          'showSubTaskParent': '$showSubTaskParent',
      },
    ));
  }

  /// Checks whether one or more issues would be returned by one or more JQL
  /// queries.
  ///
  /// **[Permissions](#permissions) required:** None, however, issues are only
  /// matched against JQL queries where the user has:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<IssueMatches> matchIssues({required IssuesAndJQLQueries body}) async {
    return IssueMatches.fromJson(await _client.send(
      'post',
      'rest/api/3/jql/match',
      body: body.toJson(),
    ));
  }

  /// Searches for issues using
  /// [JQL](https://confluence.atlassian.com/x/egORLQ).
  ///
  /// If the JQL query expression is too large to be encoded as a query
  /// parameter, use the [POST](#api-rest-api-3-search-post) version of this
  /// resource.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Issues are included in the
  /// response where the user has:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<SearchResults> searchForIssuesUsingJql(
      {String? jql,
      int? startAt,
      int? maxResults,
      String? validateQuery,
      List<String>? fields,
      String? expand,
      List<String>? properties,
      bool? fieldsByKeys}) async {
    return SearchResults.fromJson(await _client.send(
      'get',
      'rest/api/3/search',
      queryParameters: {
        if (jql != null) 'jql': jql,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (validateQuery != null) 'validateQuery': validateQuery,
        if (fields != null) 'fields': '$fields',
        if (expand != null) 'expand': expand,
        if (properties != null) 'properties': '$properties',
        if (fieldsByKeys != null) 'fieldsByKeys': '$fieldsByKeys',
      },
    ));
  }

  /// Searches for issues using
  /// [JQL](https://confluence.atlassian.com/x/egORLQ).
  ///
  /// There is a [GET](#api-rest-api-3-search-get) version of this resource that
  /// can be used for smaller JQL query expressions.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Issues are included in the
  /// response where the user has:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<SearchResults> searchForIssuesUsingJqlPost(
      {required SearchRequestBean body}) async {
    return SearchResults.fromJson(await _client.send(
      'post',
      'rest/api/3/search',
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueSecurityLevelApi {
  final ApiClient _client;

  IssueSecurityLevelApi(this._client);

  /// Returns issue security level members.
  ///
  /// Only issue security level members in context of classic projects are
  /// returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueSecurityLevelMember> getIssueSecurityLevelMembers(
      {required int issueSecuritySchemeId,
      int? startAt,
      int? maxResults,
      List<int>? issueSecurityLevelId,
      String? expand}) async {
    return PageBeanIssueSecurityLevelMember.fromJson(await _client.send(
      'get',
      'rest/api/3/issuesecurityschemes/{issueSecuritySchemeId}/members',
      pathParameters: {
        'issueSecuritySchemeId': '$issueSecuritySchemeId',
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (issueSecurityLevelId != null)
          'issueSecurityLevelId': '$issueSecurityLevelId',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns details of an issue security level.
  ///
  /// Use
  /// [Get issue security scheme](#api-rest-api-3-issuesecurityschemes-id-get)
  /// to obtain the IDs of issue security levels associated with the issue
  /// security scheme.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<SecurityLevel> getIssueSecurityLevel(String id) async {
    return SecurityLevel.fromJson(await _client.send(
      'get',
      'rest/api/3/securitylevel/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueSecuritySchemesApi {
  final ApiClient _client;

  IssueSecuritySchemesApi(this._client);

  /// Returns all
  /// [issue security schemes](https://confluence.atlassian.com/x/J4lKLg).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<SecuritySchemes> getIssueSecuritySchemes() async {
    return SecuritySchemes.fromJson(await _client.send(
      'get',
      'rest/api/3/issuesecurityschemes',
    ));
  }

  /// Returns an issue security scheme along with its security levels.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///  *  *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for a
  /// project that uses the requested issue security scheme.
  Future<SecurityScheme> getIssueSecurityScheme(int id) async {
    return SecurityScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/issuesecurityschemes/{id}',
      pathParameters: {
        'id': '$id',
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueTypesApi {
  final ApiClient _client;

  IssueTypesApi(this._client);

  /// Returns all issue types.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Issue types are only returned as
  /// follows:
  ///
  ///  *  if the user has the *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), all issue
  /// types are returned.
  ///  *  if the user has the *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for one or
  /// more projects, the issue types associated with the projects the user has
  /// permission to browse are returned.
  Future<List<IssueTypeDetails>> getIssueAllTypes() async {
    return (await _client.send(
      'get',
      'rest/api/3/issuetype',
    ) as List<Object?>)
        .map((i) =>
            IssueTypeDetails.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates an issue type and adds it to the default issue type scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeDetails> createIssueType(
      {required IssueTypeCreateBean body}) async {
    return IssueTypeDetails.fromJson(await _client.send(
      'post',
      'rest/api/3/issuetype',
      body: body.toJson(),
    ));
  }

  /// Returns an issue type.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) in a
  /// project the issue type is associated with or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeDetails> getIssueType(String id) async {
    return IssueTypeDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetype/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Updates the issue type.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeDetails> updateIssueType(
      {required String id, required IssueTypeUpdateBean body}) async {
    return IssueTypeDetails.fromJson(await _client.send(
      'put',
      'rest/api/3/issuetype/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the issue type. If the issue type is in use, all uses are updated
  /// with the alternative issue type (`alternativeIssueTypeId`). A list of
  /// alternative issue types are obtained from the
  /// [Get alternative issue types](#api-rest-api-3-issuetype-id-alternatives-get)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteIssueType(
      {required String id, String? alternativeIssueTypeId}) async {
    await _client.send(
      'delete',
      'rest/api/3/issuetype/{id}',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        if (alternativeIssueTypeId != null)
          'alternativeIssueTypeId': alternativeIssueTypeId,
      },
    );
  }

  /// Returns a list of issue types that can be used to replace the issue type.
  /// The alternative issue types are those assigned to the same workflow
  /// scheme, field configuration scheme, and screen scheme.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<List<IssueTypeDetails>> getAlternativeIssueTypes(String id) async {
    return (await _client.send(
      'get',
      'rest/api/3/issuetype/{id}/alternatives',
      pathParameters: {
        'id': id,
      },
    ) as List<Object?>)
        .map((i) =>
            IssueTypeDetails.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Loads an avatar for the issue type.
  ///
  /// Specify the avatar's local file location in the body of the request. Also,
  /// include the following headers:
  ///
  ///  *  `X-Atlassian-Token: no-check` To prevent XSRF protection blocking the
  /// request, for more information see
  /// [Special Headers](#special-request-headers).
  ///  *  `Content-Type: image/image type` Valid image types are JPEG, GIF, or
  /// PNG.
  ///
  /// For example:
  /// `curl --request POST  --user email@example.com:<api_token>  --header
  /// 'X-Atlassian-Token: no-check'  --header 'Content-Type: image/<
  /// image_type>'  --data-binary "<@/path/to/file/with/your/avatar>"  --url
  /// 'https://your-domain.atlassian.net/rest/api/3/issuetype/{issueTypeId}'This`
  ///
  /// The avatar is cropped to a square. If no crop parameters are specified,
  /// the square originates at the top left of the image. The length of the
  /// square's sides is set to the smaller of the height or width of the image.
  ///
  /// The cropped image is then used to create avatars of 16x16, 24x24, 32x32,
  /// and 48x48 in size.
  ///
  /// After creating the avatar, use
  /// [ Update issue type](#api-rest-api-3-issuetype-id-put) to set it as the
  /// issue type's displayed avatar.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Avatar> createIssueTypeAvatar(
      {required String id,
      int? x,
      int? y,
      required int size,
      required dynamic body}) async {
    return Avatar.fromJson(await _client.send(
      'post',
      'rest/api/3/issuetype/{id}/avatar2',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        if (x != null) 'x': '$x',
        if (y != null) 'y': '$y',
        'size': '$size',
      },
      body: body,
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueTypeSchemesApi {
  final ApiClient _client;

  IssueTypeSchemesApi(this._client);

  /// Returns a [paginated](#pagination) list of issue type schemes.
  ///
  /// Only issue type schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeScheme> getAllIssueTypeSchemes(
      {int? startAt, int? maxResults, List<int>? id}) async {
    return PageBeanIssueTypeScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescheme',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': '$id',
      },
    ));
  }

  /// Creates an issue type scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeSchemeID> createIssueTypeScheme(
      {required IssueTypeSchemeDetails body}) async {
    return IssueTypeSchemeID.fromJson(await _client.send(
      'post',
      'rest/api/3/issuetypescheme',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of issue type scheme items.
  ///
  /// Only issue type scheme items used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeSchemeMapping> getIssueTypeSchemesMapping(
      {int? startAt, int? maxResults, List<int>? issueTypeSchemeId}) async {
    return PageBeanIssueTypeSchemeMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescheme/mapping',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (issueTypeSchemeId != null)
          'issueTypeSchemeId': '$issueTypeSchemeId',
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of issue type schemes and, for
  /// each issue type scheme, a list of the projects that use it.
  ///
  /// Only issue type schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeSchemeProjects> getIssueTypeSchemeForProjects(
      {int? startAt, int? maxResults, required List<int> projectId}) async {
    return PageBeanIssueTypeSchemeProjects.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescheme/project',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        'projectId': '$projectId',
      },
    ));
  }

  /// Assigns an issue type scheme to a project.
  ///
  /// If any issues in the project are assigned issue types not present in the
  /// new scheme, the operation will fail. To complete the assignment those
  /// issues must be updated to use issue types in the new scheme.
  ///
  /// Issue type schemes can only be assigned to classic projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> assignIssueTypeSchemeToProject(
      {required IssueTypeSchemeProjectAssociation body}) async {
    await _client.send(
      'put',
      'rest/api/3/issuetypescheme/project',
      body: body.toJson(),
    );
  }

  /// Updates an issue type scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> updateIssueTypeScheme(
      {required int issueTypeSchemeId,
      required IssueTypeSchemeUpdateDetails body}) async {
    await _client.send(
      'put',
      'rest/api/3/issuetypescheme/{issueTypeSchemeId}',
      pathParameters: {
        'issueTypeSchemeId': '$issueTypeSchemeId',
      },
      body: body.toJson(),
    );
  }

  /// Deletes an issue type scheme.
  ///
  /// Only issue type schemes used in classic projects can be deleted.
  ///
  /// Any projects assigned to the scheme are reassigned to the default issue
  /// type scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteIssueTypeScheme(int issueTypeSchemeId) async {
    await _client.send(
      'delete',
      'rest/api/3/issuetypescheme/{issueTypeSchemeId}',
      pathParameters: {
        'issueTypeSchemeId': '$issueTypeSchemeId',
      },
    );
  }

  /// Adds issue types to an issue type scheme.
  ///
  /// The added issue types are appended to the issue types list.
  ///
  /// If any of the issue types exist in the issue type scheme, the operation
  /// fails and no issue types are added.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> addIssueTypesToIssueTypeScheme(
      {required int issueTypeSchemeId, required IssueTypeIds body}) async {
    await _client.send(
      'put',
      'rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype',
      pathParameters: {
        'issueTypeSchemeId': '$issueTypeSchemeId',
      },
      body: body.toJson(),
    );
  }

  /// Changes the order of issue types in an issue type scheme.
  ///
  /// The request body parameters must meet the following requirements:
  ///
  ///  *  all of the issue types must belong to the issue type scheme.
  ///  *  either `after` or `position` must be provided.
  ///  *  the issue type in `after` must not be in the issue type list.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> reorderIssueTypesInIssueTypeScheme(
      {required int issueTypeSchemeId, required OrderOfIssueTypes body}) async {
    await _client.send(
      'put',
      'rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype/move',
      pathParameters: {
        'issueTypeSchemeId': '$issueTypeSchemeId',
      },
      body: body.toJson(),
    );
  }

  /// Removes an issue type from an issue type scheme.
  ///
  /// This operation cannot remove:
  ///
  ///  *  any issue type used by issues.
  ///  *  any issue types from the default issue type scheme.
  ///  *  the last standard issue type from an issue type scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> removeIssueTypeFromIssueTypeScheme(
      {required int issueTypeSchemeId, required int issueTypeId}) async {
    await _client.send(
      'delete',
      'rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype/{issueTypeId}',
      pathParameters: {
        'issueTypeSchemeId': '$issueTypeSchemeId',
        'issueTypeId': '$issueTypeId',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueTypeScreenSchemesApi {
  final ApiClient _client;

  IssueTypeScreenSchemesApi(this._client);

  /// Returns a [paginated](#pagination) list of issue type screen schemes.
  ///
  /// Only issue type screen schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeScreenScheme> getIssueTypeScreenSchemes(
      {int? startAt, int? maxResults, List<int>? id}) async {
    return PageBeanIssueTypeScreenScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescreenscheme',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': '$id',
      },
    ));
  }

  /// Creates an issue type screen scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeScreenSchemeId> createIssueTypeScreenScheme(
      {required IssueTypeScreenSchemeDetails body}) async {
    return IssueTypeScreenSchemeId.fromJson(await _client.send(
      'post',
      'rest/api/3/issuetypescreenscheme',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of issue type screen scheme items.
  ///
  /// Only issue type screen schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeScreenSchemeItem> getIssueTypeScreenSchemeMappings(
      {int? startAt,
      int? maxResults,
      List<int>? issueTypeScreenSchemeId}) async {
    return PageBeanIssueTypeScreenSchemeItem.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescreenscheme/mapping',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (issueTypeScreenSchemeId != null)
          'issueTypeScreenSchemeId': '$issueTypeScreenSchemeId',
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of issue type screen schemes and,
  /// for each issue type screen scheme, a list of the projects that use it.
  ///
  /// Only issue type screen schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeScreenSchemesProjects>
      getIssueTypeScreenSchemeProjectAssociations(
          {int? startAt, int? maxResults, required List<int> projectId}) async {
    return PageBeanIssueTypeScreenSchemesProjects.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescreenscheme/project',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        'projectId': '$projectId',
      },
    ));
  }

  /// Assigns an issue type screen scheme to a project.
  ///
  /// Issue type screen schemes can only be assigned to classic projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> assignIssueTypeScreenSchemeToProject(
      {required IssueTypeScreenSchemeProjectAssociation body}) async {
    await _client.send(
      'put',
      'rest/api/3/issuetypescreenscheme/project',
      body: body.toJson(),
    );
  }

  /// Updates an issue type screen scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> updateIssueTypeScreenScheme(
      {required String issueTypeScreenSchemeId,
      required IssueTypeScreenSchemeUpdateDetails body}) async {
    await _client.send(
      'put',
      'rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}',
      pathParameters: {
        'issueTypeScreenSchemeId': issueTypeScreenSchemeId,
      },
      body: body.toJson(),
    );
  }

  /// Deletes an issue type screen scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteIssueTypeScreenScheme(
      String issueTypeScreenSchemeId) async {
    await _client.send(
      'delete',
      'rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}',
      pathParameters: {
        'issueTypeScreenSchemeId': issueTypeScreenSchemeId,
      },
    );
  }

  /// Appends issue type to screen scheme mappings to an issue type screen
  /// scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> appendMappingsForIssueTypeScreenScheme(
      {required String issueTypeScreenSchemeId,
      required IssueTypeScreenSchemeMappingDetails body}) async {
    await _client.send(
      'put',
      'rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping',
      pathParameters: {
        'issueTypeScreenSchemeId': issueTypeScreenSchemeId,
      },
      body: body.toJson(),
    );
  }

  /// Updates the default screen scheme of an issue type screen scheme. The
  /// default screen scheme is used for all unmapped issue types.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> updateDefaultScreenScheme(
      {required String issueTypeScreenSchemeId,
      required UpdateDefaultScreenScheme body}) async {
    await _client.send(
      'put',
      'rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping/default',
      pathParameters: {
        'issueTypeScreenSchemeId': issueTypeScreenSchemeId,
      },
      body: body.toJson(),
    );
  }

  /// Removes issue type to screen scheme mappings from an issue type screen
  /// scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> removeMappingsFromIssueTypeScreenScheme(
      {required String issueTypeScreenSchemeId,
      required IssueTypeIds body}) async {
    await _client.send(
      'post',
      'rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping/remove',
      pathParameters: {
        'issueTypeScreenSchemeId': issueTypeScreenSchemeId,
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueTypePropertiesApi {
  final ApiClient _client;

  IssueTypePropertiesApi(this._client);

  /// Returns all the
  /// [issue type property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties)
  /// keys of the issue type.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) to get the
  /// property keys of any issue type.
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to get the
  /// property keys of any issue types associated with the projects the user has
  /// permission to browse.
  Future<PropertyKeys> getIssueTypePropertyKeys(String issueTypeId) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetype/{issueTypeId}/properties',
      pathParameters: {
        'issueTypeId': issueTypeId,
      },
    ));
  }

  /// Returns the key and value of the
  /// [issue type property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) to get the
  /// details of any issue type.
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to get the
  /// details of any issue types associated with the projects the user has
  /// permission to browse.
  Future<EntityProperty> getIssueTypeProperty(
      {required String issueTypeId, required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetype/{issueTypeId}/properties/{propertyKey}',
      pathParameters: {
        'issueTypeId': issueTypeId,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Creates or updates the value of the
  /// [issue type property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties).
  /// Use this resource to store and update data against an issue type.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> setIssueTypeProperty(
      {required String issueTypeId,
      required String propertyKey,
      required dynamic body}) async {
    await _client.send(
      'put',
      'rest/api/3/issuetype/{issueTypeId}/properties/{propertyKey}',
      pathParameters: {
        'issueTypeId': issueTypeId,
        'propertyKey': propertyKey,
      },
      body: body,
    );
  }

  /// Deletes the
  /// [issue type property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteIssueTypeProperty(
      {required String issueTypeId, required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/issuetype/{issueTypeId}/properties/{propertyKey}',
      pathParameters: {
        'issueTypeId': issueTypeId,
        'propertyKey': propertyKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueVotesApi {
  final ApiClient _client;

  IssueVotesApi(this._client);

  /// Returns details about the votes on an issue.
  ///
  /// This operation requires the **Allow users to vote on issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is ini
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///
  /// Note that users with the necessary permissions for this operation but
  /// without the *View voters and watchers* project permissions are not
  /// returned details in the `voters` field.
  Future<Votes> getVotes(String issueIdOrKey) async {
    return Votes.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/votes',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
    ));
  }

  /// Adds the user's vote to an issue. This is the equivalent of the user
  /// clicking *Vote* on an issue in Jira.
  ///
  /// This operation requires the **Allow users to vote on issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> addVote(String issueIdOrKey) async {
    await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/votes',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
    );
  }

  /// Deletes a user's vote from an issue. This is the equivalent of the user
  /// clicking *Unvote* on an issue in Jira.
  ///
  /// This operation requires the **Allow users to vote on issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> removeVote(String issueIdOrKey) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/votes',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueWatchersApi {
  final ApiClient _client;

  IssueWatchersApi(this._client);

  /// Returns the watchers for an issue.
  ///
  /// This operation requires the **Allow users to watch issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is ini
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  To see details of users on the watchlist other than themselves, *View
  /// voters and watchers*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  Future<Watchers> getIssueWatchers(String issueIdOrKey) async {
    return Watchers.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/watchers',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
    ));
  }

  /// Adds a user as a watcher of an issue by passing the account ID of the
  /// user. For example, `"5b10ac8d82e05b22cc7d4ef5"`. If no user is specified
  /// the calling user is added.
  ///
  /// This operation requires the **Allow users to watch issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  To add users other than themselves to the watchlist, *Manage watcher
  /// list* [project permission](https://confluence.atlassian.com/x/yodKLg) for
  /// the project that the issue is in.
  Future<void> addWatcher(
      {required String issueIdOrKey, required String body}) async {
    await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/watchers',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      body: body,
    );
  }

  /// Deletes a user as a watcher of an issue.
  ///
  /// This operation requires the **Allow users to watch issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  To remove users other than themselves from the watchlist, *Manage
  /// watcher list*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  Future<void> removeWatcher(
      {required String issueIdOrKey,
      String? username,
      String? accountId}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/watchers',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (username != null) 'username': username,
        if (accountId != null) 'accountId': accountId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueWorklogsApi {
  final ApiClient _client;

  IssueWorklogsApi(this._client);

  /// Returns worklogs for an issue, starting from the oldest worklog or from
  /// the worklog started on or after a date and time.
  ///
  /// Time tracking must be enabled in Jira, otherwise this operation returns an
  /// error. For more information, see
  /// [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Workloads are only returned
  /// where the user has:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<PageOfWorklogs> getIssueWorklog(
      {required String issueIdOrKey,
      int? startAt,
      int? maxResults,
      int? startedAfter,
      String? expand}) async {
    return PageOfWorklogs.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/worklog',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (startedAfter != null) 'startedAfter': '$startedAfter',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Adds a worklog to an issue.
  ///
  /// Time tracking must be enabled in Jira, otherwise this operation returns an
  /// error. For more information, see
  /// [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Work on issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<Worklog> addWorklog(
      {required String issueIdOrKey,
      bool? notifyUsers,
      String? adjustEstimate,
      String? newEstimate,
      String? reduceBy,
      String? expand,
      bool? overrideEditableFlag,
      required Worklog body}) async {
    return Worklog.fromJson(await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/worklog',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (notifyUsers != null) 'notifyUsers': '$notifyUsers',
        if (adjustEstimate != null) 'adjustEstimate': adjustEstimate,
        if (newEstimate != null) 'newEstimate': newEstimate,
        if (reduceBy != null) 'reduceBy': reduceBy,
        if (expand != null) 'expand': expand,
        if (overrideEditableFlag != null)
          'overrideEditableFlag': '$overrideEditableFlag',
      },
      body: body.toJson(),
    ));
  }

  /// Returns a worklog.
  ///
  /// Time tracking must be enabled in Jira, otherwise this operation returns an
  /// error. For more information, see
  /// [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<Worklog> getWorklog(
      {required String issueIdOrKey,
      required String id,
      String? expand}) async {
    return Worklog.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{id}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'id': id,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates a worklog.
  ///
  /// Time tracking must be enabled in Jira, otherwise this operation returns an
  /// error. For more information, see
  /// [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Edit all
  /// worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg)
  /// to update any worklog or *Edit own worklogs* to update worklogs created by
  /// the user.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<Worklog> updateWorklog(
      {required String issueIdOrKey,
      required String id,
      bool? notifyUsers,
      String? adjustEstimate,
      String? newEstimate,
      String? expand,
      bool? overrideEditableFlag,
      required Worklog body}) async {
    return Worklog.fromJson(await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{id}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'id': id,
      },
      queryParameters: {
        if (notifyUsers != null) 'notifyUsers': '$notifyUsers',
        if (adjustEstimate != null) 'adjustEstimate': adjustEstimate,
        if (newEstimate != null) 'newEstimate': newEstimate,
        if (expand != null) 'expand': expand,
        if (overrideEditableFlag != null)
          'overrideEditableFlag': '$overrideEditableFlag',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a worklog from an issue.
  ///
  /// Time tracking must be enabled in Jira, otherwise this operation returns an
  /// error. For more information, see
  /// [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Delete all
  /// worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg)
  /// to delete any worklog or *Delete own worklogs* to delete worklogs created
  /// by the user,
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<void> deleteWorklog(
      {required String issueIdOrKey,
      required String id,
      bool? notifyUsers,
      String? adjustEstimate,
      String? newEstimate,
      String? increaseBy,
      bool? overrideEditableFlag}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{id}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'id': id,
      },
      queryParameters: {
        if (notifyUsers != null) 'notifyUsers': '$notifyUsers',
        if (adjustEstimate != null) 'adjustEstimate': adjustEstimate,
        if (newEstimate != null) 'newEstimate': newEstimate,
        if (increaseBy != null) 'increaseBy': increaseBy,
        if (overrideEditableFlag != null)
          'overrideEditableFlag': '$overrideEditableFlag',
      },
    );
  }

  /// Returns a list of IDs and delete timestamps for worklogs deleted after a
  /// date and time.
  ///
  /// This resource is paginated, with a limit of 1000 worklogs per page. Each
  /// page lists worklogs from oldest to youngest. If the number of items in the
  /// date range exceeds 1000, `until` indicates the timestamp of the youngest
  /// item on the page. Also, `nextPage` provides the URL for the next page of
  /// worklogs. The `lastPage` parameter is set to true on the last page of
  /// worklogs.
  ///
  /// This resource does not return worklogs deleted during the minute preceding
  /// the request.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<ChangedWorklogs> getIdsOfWorklogsDeletedSince({int? since}) async {
    return ChangedWorklogs.fromJson(await _client.send(
      'get',
      'rest/api/3/worklog/deleted',
      queryParameters: {
        if (since != null) 'since': '$since',
      },
    ));
  }

  /// Returns worklog details for a list of worklog IDs.
  ///
  /// The returned list of worklogs is limited to 1000 items.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, worklogs are only returned where either of the following is true:
  ///
  ///  *  the worklog is set as *Viewable by All Users*.
  ///  *  the user is a member of a project role or group with permission to
  /// view the worklog.
  Future<List<Worklog>> getWorklogsForIds(
      {String? expand, required WorklogIdsRequestBean body}) async {
    return (await _client.send(
      'post',
      'rest/api/3/worklog/list',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ) as List<Object?>)
        .map((i) => Worklog.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a list of IDs and update timestamps for worklogs updated after a
  /// date and time.
  ///
  /// This resource is paginated, with a limit of 1000 worklogs per page. Each
  /// page lists worklogs from oldest to youngest. If the number of items in the
  /// date range exceeds 1000, `until` indicates the timestamp of the youngest
  /// item on the page. Also, `nextPage` provides the URL for the next page of
  /// worklogs. The `lastPage` parameter is set to true on the last page of
  /// worklogs.
  ///
  /// This resource does not return worklogs updated during the minute preceding
  /// the request.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, worklogs are only returned where either of the following is true:
  ///
  ///  *  the worklog is set as *Viewable by All Users*.
  ///  *  the user is a member of a project role or group with permission to
  /// view the worklog.
  Future<ChangedWorklogs> getIdsOfWorklogsModifiedSince(
      {int? since, String? expand}) async {
    return ChangedWorklogs.fromJson(await _client.send(
      'get',
      'rest/api/3/worklog/updated',
      queryParameters: {
        if (since != null) 'since': '$since',
        if (expand != null) 'expand': expand,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueWorklogPropertiesApi {
  final ApiClient _client;

  IssueWorklogPropertiesApi(this._client);

  /// Returns the keys of all properties for a worklog.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<PropertyKeys> getWorklogPropertyKeys(
      {required String issueIdOrKey, required String worklogId}) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'worklogId': worklogId,
      },
    ));
  }

  /// Returns the value of a worklog property.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<EntityProperty> getWorklogProperty(
      {required String issueIdOrKey,
      required String worklogId,
      required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'worklogId': worklogId,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Sets the value of a worklog property. Use this operation to store custom
  /// data against the worklog.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Edit all
  /// worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg)
  /// to update any worklog or *Edit own worklogs* to update worklogs created by
  /// the user.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<void> setWorklogProperty(
      {required String issueIdOrKey,
      required String worklogId,
      required String propertyKey,
      required dynamic body}) async {
    await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'worklogId': worklogId,
        'propertyKey': propertyKey,
      },
      body: body,
    );
  }

  /// Deletes a worklog property.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<void> deleteWorklogProperty(
      {required String issueIdOrKey,
      required String worklogId,
      required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'worklogId': worklogId,
        'propertyKey': propertyKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class JiraExpressionsApi {
  final ApiClient _client;

  JiraExpressionsApi(this._client);

  /// Analyses and validates Jira expressions.
  ///
  /// As an experimental feature, this operation can also attempt to type-check
  /// the expressions.
  ///
  /// Learn more about Jira expressions in the
  /// [documentation](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/).
  ///
  /// **[Permissions](#permissions) required**: None.
  Future<JiraExpressionsAnalysis> analyseExpression(
      {String? check, required JiraExpressionForAnalysis body}) async {
    return JiraExpressionsAnalysis.fromJson(await _client.send(
      'post',
      'rest/api/3/expression/analyse',
      queryParameters: {
        if (check != null) 'check': check,
      },
      body: body.toJson(),
    ));
  }

  /// Evaluates a Jira expression and returns its value.
  ///
  /// This resource can be used to test Jira expressions that you plan to use
  /// elsewhere, or to fetch data in a flexible way. Consult the
  /// [Jira expressions documentation](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/)
  /// for more details.
  ///
  /// #### Context variables ####
  ///
  /// The following context variables are available to Jira expressions
  /// evaluated by this resource. Their presence depends on various factors;
  /// usually you need to manually request them in the context object sent in
  /// the payload, but some of them are added automatically under certain
  /// conditions.
  ///
  ///  *  `user`
  /// ([User](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user)):
  /// The current user. Always available and equal to `null` if the request is
  /// anonymous.
  ///  *  `app`
  /// ([App](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#app)):
  /// The Connect app that made the request. Available only for authenticated
  /// requests made by Connect Apps (read more here:
  /// [Authentication for Connect apps](https://developer.atlassian.com/cloud/jira/platform/security-for-connect-apps/)).
  ///  *  `issue`
  /// ([Issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue)):
  /// The current issue. Available only when the issue is provided in the
  /// request context object.
  ///  *  `issues`
  /// ([List](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#list)
  /// of
  /// [Issues](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue)):
  /// A collection of issues matching a JQL query. Available only when JQL is
  /// provided in the request context object.
  ///  *  `project`
  /// ([Project](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#project)):
  /// The current project. Available only when the project is provided in the
  /// request context object.
  ///  *  `sprint`
  /// ([Sprint](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#sprint)):
  /// The current sprint. Available only when the sprint is provided in the
  /// request context object.
  ///  *  `board`
  /// ([Board](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#board)):
  /// The current board. Available only when the board is provided in the
  /// request context object.
  ///  *  `serviceDesk`
  /// ([ServiceDesk](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#servicedesk)):
  /// The current service desk. Available only when the service desk is provided
  /// in the request context object.
  ///  *  `customerRequest`
  /// ([CustomerRequest](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#customerrequest)):
  /// The current customer request. Available only when the customer request is
  /// provided in the request context object.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required**: None. However, an expression may
  /// return different results for different users depending on their
  /// permissions. For example, different users may see different comments on
  /// the same issue.
  /// Permission to access Jira Software is required to access Jira Software
  /// context variables (`board` and `sprint`) or fields (for example,
  /// `issue.sprint`).
  Future<JiraExpressionResult> evaluateJiraExpression(
      {String? expand, required JiraExpressionEvalRequestBean body}) async {
    return JiraExpressionResult.fromJson(await _client.send(
      'post',
      'rest/api/3/expression/eval',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class JiraSettingsApi {
  final ApiClient _client;

  JiraSettingsApi(this._client);

  /// Returns all application properties or an application property.
  ///
  /// If you specify a value for the `key` parameter, then an application
  /// property is returned as an object (not in an array). Otherwise, an array
  /// of all editable application properties is returned. See
  /// [Set application property](#api-rest-api-3-application-properties-id-put)
  /// for descriptions of editable properties.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<ApplicationProperty>> getApplicationProperty(
      {String? key, String? permissionLevel, String? keyFilter}) async {
    return (await _client.send(
      'get',
      'rest/api/3/application-properties',
      queryParameters: {
        if (key != null) 'key': key,
        if (permissionLevel != null) 'permissionLevel': permissionLevel,
        if (keyFilter != null) 'keyFilter': keyFilter,
      },
    ) as List<Object?>)
        .map((i) => ApplicationProperty.fromJson(
            i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns the application properties that are accessible on the *Advanced
  /// Settings* page. To navigate to the *Advanced Settings* page in Jira,
  /// choose the Jira icon > **Jira settings** > **System**, **General
  /// Configuration** and then click **Advanced Settings** (in the upper right).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<ApplicationProperty>> getAdvancedSettings() async {
    return (await _client.send(
      'get',
      'rest/api/3/application-properties/advanced-settings',
    ) as List<Object?>)
        .map((i) => ApplicationProperty.fromJson(
            i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Changes the value of an application property. For example, you can change
  /// the value of the `jira.clone.prefix` from its default value of *CLONE -*
  /// to *Clone -* if you prefer sentence case capitalization. Editable
  /// properties are described below along with their default values.
  ///
  /// #### Advanced settings ####
  ///
  /// The advanced settings below are also accessible in
  /// [Jira](https://confluence.atlassian.com/x/vYXKM).
  ///
  /// | Key | Description | Default value |
  /// | -- | -- | -- |
  /// | `jira.clone.prefix` | The string of text prefixed to the title of a
  /// cloned issue. | `CLONE -` |
  /// | `jira.date.picker.java.format` | The date format for the Java
  /// (server-side) generated dates. This must be the same as the
  /// `jira.date.picker.javascript.format` format setting. | `d/MMM/yy` |
  /// | `jira.date.picker.javascript.format` | The date format for the
  /// JavaScript (client-side) generated dates. This must be the same as the
  /// `jira.date.picker.java.format` format setting. | `%e/%b/%y` |
  /// | `jira.date.time.picker.java.format` | The date format for the Java
  /// (server-side) generated date times. This must be the same as the
  /// `jira.date.time.picker.javascript.format` format setting. | `dd/MMM/yy
  /// h:mm a` |
  /// | `jira.date.time.picker.javascript.format` | The date format for the
  /// JavaScript (client-side) generated date times. This must be the same as
  /// the `jira.date.time.picker.java.format` format setting. | `%e/%b/%y %I:%M
  /// %p` |
  /// | `jira.issue.actions.order` | The default order of actions (such as
  /// *Comments* or *Change history*) displayed on the issue view. | `asc` |
  /// | `jira.table.cols.subtasks` | The columns to show while viewing subtask
  /// issues in a table. For example, a list of subtasks on an issue. |
  /// `issuetype, status, assignee, progress` |
  /// | `jira.view.issue.links.sort.order` | The sort order of the list of issue
  /// links on the issue view. | `type, status, priority` |
  /// | `jira.comment.collapsing.minimum.hidden` | The minimum number of
  /// comments required for comment collapsing to occur. A value of `0` disables
  /// comment collapsing. | `4` |
  /// | `jira.newsletter.tip.delay.days` | The number of days before a prompt to
  /// sign up to the Jira Insiders newsletter is shown. A value of `-1` disables
  /// this feature. | `7` |
  ///
  ///
  /// #### Look and feel ####
  ///
  /// The settings listed below adjust the
  /// [look and feel](https://confluence.atlassian.com/x/VwCLLg).
  ///
  /// | Key | Description | Default value |
  /// | -- | -- | -- |
  /// | `jira.lf.date.time` | The
  /// [ time format](https://docs.oracle.com/javase/6/docs/api/index.html?java/text/SimpleDateFormat.html).
  /// | `h:mm a` |
  /// | `jira.lf.date.day` | The
  /// [ day format](https://docs.oracle.com/javase/6/docs/api/index.html?java/text/SimpleDateFormat.html).
  /// | `EEEE h:mm a` |
  /// | `jira.lf.date.complete` | The
  /// [ date and time format](https://docs.oracle.com/javase/6/docs/api/index.html?java/text/SimpleDateFormat.html).
  /// | `dd/MMM/yy h:mm a` |
  /// | `jira.lf.date.dmy` | The
  /// [ date format](https://docs.oracle.com/javase/6/docs/api/index.html?java/text/SimpleDateFormat.html).
  /// | `dd/MMM/yy` |
  /// | `jira.date.time.picker.use.iso8061` | When enabled, sets Monday as the
  /// first day of the week in the date picker, as specified by the ISO8601
  /// standard. | `false` |
  /// | `jira.lf.logo.url` | The URL of the logo image file. |
  /// `/images/icon-jira-logo.png` |
  /// | `jira.lf.logo.show.application.title` | Controls the visibility of the
  /// application title on the sidebar. | `false` |
  /// | `jira.lf.favicon.url` | The URL of the favicon. | `/favicon.ico` |
  /// | `jira.lf.favicon.hires.url` | The URL of the high-resolution favicon. |
  /// `/images/64jira.png` |
  /// | `jira.lf.top.adg3.bgcolour` | The background color of the sidebar. |
  /// `#0747A6` |
  /// | `jira.lf.top.adg3.textcolour` | The color of the text and logo of the
  /// sidebar. | `#DEEBFF` |
  /// | `jira.lf.hero.button.base.bg.colour` | The background color of the hero
  /// button. | `#3b7fc4` |
  /// | `jira.title` | The text for the application title. The application title
  /// can also be set in *General settings*. | `Jira` |
  /// | `jira.option.globalsharing` | Whether filters and dashboards can be
  /// shared with anyone signed into Jira. | `true` |
  /// | `xflow.product.suggestions.enabled` | Whether to expose product
  /// suggestions for other Atlassian products within Jira. | `true` |
  ///
  ///
  /// #### Other settings ####
  ///
  /// | Key | Description | Default value |
  /// | -- | -- | -- |
  /// | `jira.issuenav.criteria.autoupdate` | Whether instant updates to search
  /// criteria is active. | `true` |
  ///
  ///
  /// *Note: Be careful when changing
  /// [application properties and advanced settings](https://confluence.atlassian.com/x/vYXKM).*
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ApplicationProperty> setApplicationProperty(
      {required String id, required SimpleApplicationPropertyBean body}) async {
    return ApplicationProperty.fromJson(await _client.send(
      'put',
      'rest/api/3/application-properties/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }

  /// Returns the [global settings](https://confluence.atlassian.com/x/qYXKM) in
  /// Jira. These settings determine whether optional features (for example,
  /// subtasks, time tracking, and others) are enabled. If time tracking is
  /// enabled, this operation also returns the time tracking configuration.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<Configuration> getConfiguration() async {
    return Configuration.fromJson(await _client.send(
      'get',
      'rest/api/3/configuration',
    ));
  }
}

/// Jira Cloud platform REST API documentation

class JQLApi {
  final ApiClient _client;

  JQLApi(this._client);

  /// Returns reference data for JQL searches. This is a downloadable version of
  /// the documentation provided in
  /// [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ)
  /// and
  /// [Advanced searching - functions reference](https://confluence.atlassian.com/x/hgORLQ),
  /// along with a list of JQL-reserved words. Use this information to assist
  /// with the programmatic creation of JQL queries or the validation of queries
  /// built in a custom query builder.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<JQLReferenceData> getAutoComplete() async {
    return JQLReferenceData.fromJson(await _client.send(
      'get',
      'rest/api/3/jql/autocompletedata',
    ));
  }

  /// Returns the JQL search auto complete suggestions for a field.
  ///
  /// Suggestions can be obtained by providing:
  ///
  ///  *  `fieldName` to get a list of all values for the field.
  ///  *  `fieldName` and `fieldValue` to get a list of values containing the
  /// text in `fieldValue`.
  ///  *  `fieldName` and `predicateName` to get a list of all predicate values
  /// for the field.
  ///  *  `fieldName`, `predicateName`, and `predicateValue` to get a list of
  /// predicate values containing the text in `predicateValue`.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<AutoCompleteSuggestions> getFieldAutoCompleteForQueryString(
      {String? fieldName,
      String? fieldValue,
      String? predicateName,
      String? predicateValue}) async {
    return AutoCompleteSuggestions.fromJson(await _client.send(
      'get',
      'rest/api/3/jql/autocompletedata/suggestions',
      queryParameters: {
        if (fieldName != null) 'fieldName': fieldName,
        if (fieldValue != null) 'fieldValue': fieldValue,
        if (predicateName != null) 'predicateName': predicateName,
        if (predicateValue != null) 'predicateValue': predicateValue,
      },
    ));
  }

  /// Parses and validates JQL queries.
  ///
  /// Validation is performed in context of the current user.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<ParsedJqlQueries> parseJqlQueries(
      {String? validation, required JqlQueriesToParse body}) async {
    return ParsedJqlQueries.fromJson(await _client.send(
      'post',
      'rest/api/3/jql/parse',
      queryParameters: {
        if (validation != null) 'validation': validation,
      },
      body: body.toJson(),
    ));
  }

  /// Converts one or more JQL queries with user identifiers (username or user
  /// key) to equivalent JQL queries with account IDs.
  ///
  /// You may wish to use this operation if your system stores JQL queries and
  /// you want to make them GDPR-compliant. For more information about
  /// GDPR-related changes, see the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/).
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<ConvertedJQLQueries> migrateQueries(
      {required JQLPersonalDataMigrationRequest body}) async {
    return ConvertedJQLQueries.fromJson(await _client.send(
      'post',
      'rest/api/3/jql/pdcleaner',
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class LabelsApi {
  final ApiClient _client;

  LabelsApi(this._client);

  /// Returns a [paginated](#pagination) list of labels.
  Future<PageBeanString> getAllLabels({int? startAt, int? maxResults}) async {
    return PageBeanString.fromJson(await _client.send(
      'get',
      'rest/api/3/label',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class MyselfApi {
  final ApiClient _client;

  MyselfApi(this._client);

  /// Returns the value of a preference of the current user.
  ///
  /// Note that these keys are deprecated:
  ///
  ///  *  *jira.user.locale* The locale of the user. By default this is not set
  /// and the user takes the locale of the instance.
  ///  *  *jira.user.timezone* The time zone of the user. By default this is not
  /// set and the user takes the timezone of the instance.
  ///
  /// Use
  /// [ Update a user profile](https://developer.atlassian.com/cloud/admin/user-management/rest/#api-users-account-id-manage-profile-patch)
  /// from the user management REST API to manage timezone and locale instead.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<String> getPreference(String key) async {
    return await _client.send(
      'get',
      'rest/api/3/mypreferences',
      queryParameters: {
        'key': key,
      },
    ) as String;
  }

  /// Creates a preference for the user or updates a preference's value by
  /// sending a plain text string. For example, `false`. An arbitrary preference
  /// can be created with the value containing up to 255 characters. In
  /// addition, the following keys define system preferences that can be set or
  /// created:
  ///
  ///  *  *user.notifications.mimetype* The mime type used in notifications sent
  /// to the user. Defaults to `html`.
  ///  *  *user.notify.own.changes* Whether the user gets notified of their own
  /// changes. Defaults to `false`.
  ///  *  *user.default.share.private* Whether new
  /// [ filters](https://confluence.atlassian.com/x/eQiiLQ) are set to private.
  /// Defaults to `true`.
  ///  *  *user.keyboard.shortcuts.disabled* Whether keyboard shortcuts are
  /// disabled. Defaults to `false`.
  ///  *  *user.autowatch.disabled* Whether the user automatically watches
  /// issues they create or add a comment to. By default, not set: the user
  /// takes the instance autowatch setting.
  ///
  /// Note that these keys are deprecated:
  ///
  ///  *  *jira.user.locale* The locale of the user. By default, not set. The
  /// user takes the instance locale.
  ///  *  *jira.user.timezone* The time zone of the user. By default, not set.
  /// The user takes the instance timezone.
  ///
  /// Use
  /// [ Update a user profile](https://developer.atlassian.com/cloud/admin/user-management/rest/#api-users-account-id-manage-profile-patch)
  /// from the user management REST API to manage timezone and locale instead.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<void> setPreference(
      {required String key, required String body}) async {
    await _client.send(
      'put',
      'rest/api/3/mypreferences',
      queryParameters: {
        'key': key,
      },
      body: body,
    );
  }

  /// Deletes a preference of the user, which restores the default value of
  /// system defined settings.
  ///
  /// Note that these keys are deprecated:
  ///
  ///  *  *jira.user.locale* The locale of the user. By default, not set. The
  /// user takes the instance locale.
  ///  *  *jira.user.timezone* The time zone of the user. By default, not set.
  /// The user takes the instance timezone.
  ///
  /// Use
  /// [ Update a user profile](https://developer.atlassian.com/cloud/admin/user-management/rest/#api-users-account-id-manage-profile-patch)
  /// from the user management REST API to manage timezone and locale instead.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<void> removePreference(String key) async {
    await _client.send(
      'delete',
      'rest/api/3/mypreferences',
      queryParameters: {
        'key': key,
      },
    );
  }

  /// Returns the locale for the user.
  ///
  /// If the user has no language preference set (which is the default setting)
  /// or this resource is accessed anonymous, the browser locale detected by
  /// Jira is returned. Jira detects the browser locale using the
  /// *Accept-Language* header in the request. However, if this doesn't match a
  /// locale available Jira, the site default locale is returned.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<Locale> getLocale() async {
    return Locale.fromJson(await _client.send(
      'get',
      'rest/api/3/mypreferences/locale',
    ));
  }

  /// Deprecated, use
  /// [ Update a user profile](https://developer.atlassian.com/cloud/admin/user-management/rest/#api-users-account-id-manage-profile-patch)
  /// from the user management REST API instead.
  ///
  /// Sets the locale of the user. The locale must be one supported by the
  /// instance of Jira.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<void> setLocale({required Locale body}) async {
    await _client.send(
      'put',
      'rest/api/3/mypreferences/locale',
      body: body.toJson(),
    );
  }

  /// Deprecated, use
  /// [ Update a user profile](https://developer.atlassian.com/cloud/admin/user-management/rest/#api-users-account-id-manage-profile-patch)
  /// from the user management REST API instead.
  ///
  /// Deletes the locale of the user, which restores the default setting.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<void> deleteLocale() async {
    await _client.send(
      'delete',
      'rest/api/3/mypreferences/locale',
    );
  }

  /// Returns details for the current user.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<User> getCurrentUser({String? expand}) async {
    return User.fromJson(await _client.send(
      'get',
      'rest/api/3/myself',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class PermissionsApi {
  final ApiClient _client;

  PermissionsApi(this._client);

  /// Returns a list of permissions indicating which permissions the user has.
  /// Details of the user's permissions can be obtained in a global, project, or
  /// issue context.
  ///
  /// The user is reported as having a project permission:
  ///
  ///  *  in the global context, if the user has the project permission in any
  /// project.
  ///  *  for a project, where the project permission is determined using issue
  /// data, if the user meets the permission's criteria for any issue in the
  /// project. Otherwise, if the user has the project permission in the project.
  ///  *  for an issue, where a project permission is determined using issue
  /// data, if the user has the permission in the issue. Otherwise, if the user
  /// has the project permission in the project containing the issue.
  ///
  /// This means that users may be shown as having an issue permission (such as
  /// EDIT_ISSUES) in the global context or a project context but may not have
  /// the permission for any or all issues. For example, if Reporters have the
  /// EDIT_ISSUES permission a user would be shown as having this permission in
  /// the global context or the context of a project, because any user can be a
  /// reporter. However, if they are not the user who reported the issue queried
  /// they would not have EDIT_ISSUES permission for that issue.
  ///
  /// Global permissions are unaffected by context.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<Permissions> getMyPermissions(
      {String? projectKey,
      String? projectId,
      String? issueKey,
      String? issueId,
      String? permissions,
      String? projectUuid,
      String? projectConfigurationUuid}) async {
    return Permissions.fromJson(await _client.send(
      'get',
      'rest/api/3/mypermissions',
      queryParameters: {
        if (projectKey != null) 'projectKey': projectKey,
        if (projectId != null) 'projectId': projectId,
        if (issueKey != null) 'issueKey': issueKey,
        if (issueId != null) 'issueId': issueId,
        if (permissions != null) 'permissions': permissions,
        if (projectUuid != null) 'projectUuid': projectUuid,
        if (projectConfigurationUuid != null)
          'projectConfigurationUuid': projectConfigurationUuid,
      },
    ));
  }

  /// Returns all permissions, including:
  ///
  ///  *  global permissions.
  ///  *  project permissions.
  ///  *  global permissions added by plugins.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Permissions> getAllPermissions() async {
    return Permissions.fromJson(await _client.send(
      'get',
      'rest/api/3/permissions',
    ));
  }

  /// Returns:
  ///
  ///  *  for a list of global permissions, the global permissions granted to a
  /// user.
  ///  *  for a list of project permissions and lists of projects and issues,
  /// for each project permission a list of the projects and issues a user can
  /// access or manipulate.
  ///
  /// If no account ID is provided, the operation returns details for the logged
  /// in user.
  ///
  /// Note that:
  ///
  ///  *  Invalid project and issue IDs are ignored.
  ///  *  A maximum of 1000 projects and 1000 issues can be checked.
  ///  *  Null values in `globalPermissions`, `projectPermissions`,
  /// `projectPermissions.projects`, and `projectPermissions.issues` are
  /// ignored.
  ///  *  Empty strings in `projectPermissions.permissions` are ignored.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) to check
  /// the permissions for other users, otherwise none. However, Connect apps can
  /// make a call from the app server to the product to obtain permission
  /// details for any user, without admin permission. This Connect app ability
  /// doesn't apply to calls made using AP.request() in a browser.
  Future<BulkPermissionGrants> getBulkPermissions(
      {required BulkPermissionsRequestBean body}) async {
    return BulkPermissionGrants.fromJson(await _client.send(
      'post',
      'rest/api/3/permissions/check',
      body: body.toJson(),
    ));
  }

  /// Returns all the projects where the user is granted a list of project
  /// permissions.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<PermittedProjects> getPermittedProjects(
      {required PermissionsKeysBean body}) async {
    return PermittedProjects.fromJson(await _client.send(
      'post',
      'rest/api/3/permissions/project',
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class PermissionSchemesApi {
  final ApiClient _client;

  PermissionSchemesApi(this._client);

  /// Returns all permission schemes.
  ///
  /// ### About permission schemes and grants ###
  ///
  /// A permission scheme is a collection of permission grants. A permission
  /// grant consists of a `holder` and a `permission`.
  ///
  /// #### Holder object ####
  ///
  /// The `holder` object contains information about the user or group being
  /// granted the permission. For example, the *Administer projects* permission
  /// is granted to a group named *Teams in space administrators*. In this case,
  /// the type is `"type": "group"`, and the parameter is the group name,
  /// `"parameter": "Teams in space administrators"`. The `holder` object is
  /// defined by the following properties:
  ///
  ///  *  `type` Identifies the user or group (see the list of types below).
  ///  *  `parameter` The value of this property depends on the `type`. For
  /// example, if the `type` is a group, then you need to specify the group
  /// name.
  ///
  /// The following `types` are available. The expected values for the
  /// `parameter` are given in parenthesis (some `types` may not have a
  /// `parameter`):
  ///
  ///  *  `anyone` Grant for anonymous users.
  ///  *  `applicationRole` Grant for users with access to the specified
  /// application (application name). See
  /// [Update product access settings](https://confluence.atlassian.com/x/3YxjL)
  /// for more information.
  ///  *  `assignee` Grant for the user currently assigned to an issue.
  ///  *  `group` Grant for the specified group (group name).
  ///  *  `groupCustomField` Grant for a user in the group selected in the
  /// specified custom field (custom field ID).
  ///  *  `projectLead` Grant for a project lead.
  ///  *  `projectRole` Grant for the specified project role (project role ID).
  ///  *  `reporter` Grant for the user who reported the issue.
  ///  *  `sd.customer.portal.only` Jira Service Desk only. Grants customers
  /// permission to access the customer portal but not Jira. See
  /// [Customizing Jira Service Desk permissions](https://confluence.atlassian.com/x/24dKLg)
  /// for more information.
  ///  *  `user` Grant for the specified user (user ID - historically this was
  /// the userkey but that is deprecated and the account ID should be used).
  ///  *  `userCustomField` Grant for a user selected in the specified custom
  /// field (custom field ID).
  ///
  /// #### Built-in permissions ####
  ///
  /// The [built-in Jira permissions](https://confluence.atlassian.com/x/yodKLg)
  /// are listed below. Apps can also define custom permissions. See the
  /// [project permission](https://developer.atlassian.com/cloud/jira/platform/modules/project-permission/)
  /// and
  /// [global permission](https://developer.atlassian.com/cloud/jira/platform/modules/global-permission/)
  /// module documentation for more information.
  ///
  /// **Project permissions**
  ///
  ///  *  `ADMINISTER_PROJECTS`
  ///  *  `BROWSE_PROJECTS`
  ///  *  `MANAGE_SPRINTS_PERMISSION` (Jira Software only)
  ///  *  `SERVICEDESK_AGENT` (Jira Service Desk only)
  ///  *  `VIEW_DEV_TOOLS` (Jira Software only)
  ///  *  `VIEW_READONLY_WORKFLOW`
  ///
  /// **Issue permissions**
  ///
  ///  *  `ASSIGNABLE_USER`
  ///  *  `ASSIGN_ISSUES`
  ///  *  `CLOSE_ISSUES`
  ///  *  `CREATE_ISSUES`
  ///  *  `DELETE_ISSUES`
  ///  *  `EDIT_ISSUES`
  ///  *  `LINK_ISSUES`
  ///  *  `MODIFY_REPORTER`
  ///  *  `MOVE_ISSUES`
  ///  *  `RESOLVE_ISSUES`
  ///  *  `SCHEDULE_ISSUES`
  ///  *  `SET_ISSUE_SECURITY`
  ///  *  `TRANSITION_ISSUES`
  ///
  /// **Voters and watchers permissions**
  ///
  ///  *  `MANAGE_WATCHERS`
  ///  *  `VIEW_VOTERS_AND_WATCHERS`
  ///
  /// **Comments permissions**
  ///
  ///  *  `ADD_COMMENTS`
  ///  *  `DELETE_ALL_COMMENTS`
  ///  *  `DELETE_OWN_COMMENTS`
  ///  *  `EDIT_ALL_COMMENTS`
  ///  *  `EDIT_OWN_COMMENTS`
  ///
  /// **Attachments permissions**
  ///
  ///  *  `CREATE_ATTACHMENTS`
  ///  *  `DELETE_ALL_ATTACHMENTS`
  ///  *  `DELETE_OWN_ATTACHMENTS`
  ///
  /// **Time tracking permissions**
  ///
  ///  *  `DELETE_ALL_WORKLOGS`
  ///  *  `DELETE_OWN_WORKLOGS`
  ///  *  `EDIT_ALL_WORKLOGS`
  ///  *  `EDIT_OWN_WORKLOGS`
  ///  *  `WORK_ON_ISSUES`
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PermissionSchemes> getAllPermissionSchemes({String? expand}) async {
    return PermissionSchemes.fromJson(await _client.send(
      'get',
      'rest/api/3/permissionscheme',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Creates a new permission scheme. You can create a permission scheme with
  /// or without defining a set of permission grants.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PermissionScheme> createPermissionScheme(
      {String? expand, required PermissionScheme body}) async {
    return PermissionScheme.fromJson(await _client.send(
      'post',
      'rest/api/3/permissionscheme',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Returns a permission scheme.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PermissionScheme> getPermissionScheme(
      {required int schemeId, String? expand}) async {
    return PermissionScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/permissionscheme/{schemeId}',
      pathParameters: {
        'schemeId': '$schemeId',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates a permission scheme. Below are some important things to note when
  /// using this resource:
  ///
  ///  *  If a permissions list is present in the request, then it is set in the
  /// permission scheme, overwriting *all existing* grants.
  ///  *  If you want to update only the name and description, then do not send
  /// a permissions list in the request.
  ///  *  Sending an empty list will remove all permission grants from the
  /// permission scheme.
  ///
  /// If you want to add or delete a permission grant instead of updating the
  /// whole list, see
  /// [Create permission grant](#api-rest-api-3-permissionscheme-schemeId-permission-post)
  /// or
  /// [Delete permission scheme entity](#api-rest-api-3-permissionscheme-schemeId-permission-permissionId-delete).
  ///
  /// See
  /// [About permission schemes and grants](../api-group-permission-schemes/#about-permission-schemes-and-grants)
  /// for more details.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PermissionScheme> updatePermissionScheme(
      {required int schemeId,
      String? expand,
      required PermissionScheme body}) async {
    return PermissionScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/permissionscheme/{schemeId}',
      pathParameters: {
        'schemeId': '$schemeId',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a permission scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deletePermissionScheme(int schemeId) async {
    await _client.send(
      'delete',
      'rest/api/3/permissionscheme/{schemeId}',
      pathParameters: {
        'schemeId': '$schemeId',
      },
    );
  }

  /// Returns all permission grants for a permission scheme.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PermissionGrants> getPermissionSchemeGrants(
      {required int schemeId, String? expand}) async {
    return PermissionGrants.fromJson(await _client.send(
      'get',
      'rest/api/3/permissionscheme/{schemeId}/permission',
      pathParameters: {
        'schemeId': '$schemeId',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Creates a permission grant in a permission scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PermissionGrant> createPermissionGrant(
      {required int schemeId,
      String? expand,
      required PermissionGrant body}) async {
    return PermissionGrant.fromJson(await _client.send(
      'post',
      'rest/api/3/permissionscheme/{schemeId}/permission',
      pathParameters: {
        'schemeId': '$schemeId',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Returns a permission grant.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PermissionGrant> getPermissionSchemeGrant(
      {required int schemeId,
      required int permissionId,
      String? expand}) async {
    return PermissionGrant.fromJson(await _client.send(
      'get',
      'rest/api/3/permissionscheme/{schemeId}/permission/{permissionId}',
      pathParameters: {
        'schemeId': '$schemeId',
        'permissionId': '$permissionId',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Deletes a permission grant from a permission scheme. See
  /// [About permission schemes and grants](../api-group-permission-schemes/#about-permission-schemes-and-grants)
  /// for more details.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deletePermissionSchemeEntity(
      {required int schemeId, required int permissionId}) async {
    await _client.send(
      'delete',
      'rest/api/3/permissionscheme/{schemeId}/permission/{permissionId}',
      pathParameters: {
        'schemeId': '$schemeId',
        'permissionId': '$permissionId',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class ProjectsApi {
  final ApiClient _client;

  ProjectsApi(this._client);

  /// Returns all projects visible to the user. Deprecated, use
  /// [ Get projects paginated](#api-rest-api-3-project-search-get) that
  /// supports search and pagination.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Projects are returned only where
  /// the user has *Browse Projects* or *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<List<Project>> getAllProjects(
      {String? expand, int? recent, List<String>? properties}) async {
    return (await _client.send(
      'get',
      'rest/api/3/project',
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (recent != null) 'recent': '$recent',
        if (properties != null) 'properties': '$properties',
      },
    ) as List<Object?>)
        .map((i) => Project.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a project based on a project type template, as shown in the
  /// following table:
  ///
  /// | Project Type Key | Project Template Key |
  /// |--|--|
  /// | `business` |
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-content-management`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-document-approval`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-lead-tracking`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-process-control`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-procurement`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-project-management`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-recruitment`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-task-tracking`
  /// |
  /// | `service_desk` | `com.atlassian.servicedesk:simplified-it-service-desk`,
  /// `com.atlassian.servicedesk:simplified-internal-service-desk`,
  /// `com.atlassian.servicedesk:simplified-external-service-desk` |
  /// | `software` | `com.pyxis.greenhopper.jira:gh-simplified-agility-kanban`,
  /// `com.pyxis.greenhopper.jira:gh-simplified-agility-scrum`,
  /// `com.pyxis.greenhopper.jira:gh-simplified-basic`,
  /// `com.pyxis.greenhopper.jira:gh-simplified-kanban-classic`,
  /// `com.pyxis.greenhopper.jira:gh-simplified-scrum-classic` |
  /// The project types are available according to the installed Jira features
  /// as follows:
  ///
  ///  *  Jira Core, the default, enables `business` projects.
  ///  *  Jira Service Management enables `service_desk` projects.
  ///  *  Jira Software enables `software` projects.
  ///
  /// To determine which features are installed, go to **Jira settings** >
  /// **Apps** > **Manage apps** and review the System Apps list. To add Jira
  /// Software or Jira Service Management into a JIRA instance, use **Jira
  /// settings** > **Apps** > **Finding new apps**. For more information, see
  /// [ Managing add-ons](https://confluence.atlassian.com/x/S31NLg).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectIdentifiers> createProject(
      {required ProjectInputBean body}) async {
    return ProjectIdentifiers.fromJson(await _client.send(
      'post',
      'rest/api/3/project',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of projects visible to the user.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Projects are returned only where
  /// the user has one of:
  ///
  ///  *  *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  ///  *  *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanProject> searchProjects(
      {int? startAt,
      int? maxResults,
      String? orderBy,
      String? query,
      String? typeKey,
      int? categoryId,
      String? action,
      String? expand,
      List<String>? status,
      List<StringList>? properties,
      String? propertyQuery}) async {
    return PageBeanProject.fromJson(await _client.send(
      'get',
      'rest/api/3/project/search',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (orderBy != null) 'orderBy': orderBy,
        if (query != null) 'query': query,
        if (typeKey != null) 'typeKey': typeKey,
        if (categoryId != null) 'categoryId': '$categoryId',
        if (action != null) 'action': action,
        if (expand != null) 'expand': expand,
        if (status != null) 'status': '$status',
        if (properties != null) 'properties': '$properties',
        if (propertyQuery != null) 'propertyQuery': propertyQuery,
      },
    ));
  }

  /// Returns the [project details](https://confluence.atlassian.com/x/ahLpNw)
  /// for a project.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<Project> getProject(
      {required String projectIdOrKey,
      String? expand,
      List<String>? properties}) async {
    return Project.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (properties != null) 'properties': '$properties',
      },
    ));
  }

  /// Updates the [project details](https://confluence.atlassian.com/x/ahLpNw)
  /// of a project.
  ///
  /// All parameters are optional in the body of the request.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Project> updateProject(
      {required String projectIdOrKey,
      String? expand,
      required ProjectInputBean body}) async {
    return Project.fromJson(await _client.send(
      'put',
      'rest/api/3/project/{projectIdOrKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a project.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteProject(
      {required String projectIdOrKey, bool? enableUndo}) async {
    await _client.send(
      'delete',
      'rest/api/3/project/{projectIdOrKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (enableUndo != null) 'enableUndo': '$enableUndo',
      },
    );
  }

  /// Archives a project. Archived projects cannot be deleted. To delete an
  /// archived project, restore the project and then delete it. To restore a
  /// project, use the Jira UI.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> archiveProject(String projectIdOrKey) async {
    await _client.send(
      'post',
      'rest/api/3/project/{projectIdOrKey}/archive',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    );
  }

  /// Deletes a project asynchronously.
  ///
  /// This operation is:
  ///
  ///  *  transactional, that is, if part of the delete fails the project is not
  /// deleted.
  ///  *  [asynchronous](#async). Follow the `location` link in the response to
  /// determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TaskProgressBeanObject> deleteProjectAsynchronously(
      String projectIdOrKey) async {
    return TaskProgressBeanObject.fromJson(await _client.send(
      'post',
      'rest/api/3/project/{projectIdOrKey}/delete',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ));
  }

  /// Restores a project from the Jira recycle bin.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Project> restore(String projectIdOrKey) async {
    return Project.fromJson(await _client.send(
      'post',
      'rest/api/3/project/{projectIdOrKey}/restore',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ));
  }

  /// Returns the valid statuses for a project. The statuses are grouped by
  /// issue type, as each project has a set of valid issue types and each issue
  /// type has a set of valid statuses.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<List<IssueTypeWithStatus>> getAllStatuses(
      String projectIdOrKey) async {
    return (await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/statuses',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ) as List<Object?>)
        .map((i) => IssueTypeWithStatus.fromJson(
            i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Deprecated, this feature is no longer supported and no alternatives are
  /// available, see
  /// [Convert project to a different template or type](https://confluence.atlassian.com/x/yEKeOQ).
  /// Updates a [project type](https://confluence.atlassian.com/x/GwiiLQ). The
  /// project type can be updated for classic projects only, project type cannot
  /// be updated for next-gen projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Project> updateProjectType(
      {required String projectIdOrKey,
      required String newProjectTypeKey}) async {
    return Project.fromJson(await _client.send(
      'put',
      'rest/api/3/project/{projectIdOrKey}/type/{newProjectTypeKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'newProjectTypeKey': newProjectTypeKey,
      },
    ));
  }

  /// Get the issue type hierarchy for a next-gen project.
  ///
  /// The issue type hierarchy for a project consists of:
  ///
  ///  *  *Epic* at level 1 (optional).
  ///  *  One or more issue types at level 0 such as *Story*, *Task*, or *Bug*.
  /// Where the issue type *Epic* is defined, these issue types are used to
  /// break down the content of an epic.
  ///  *  *Subtask* at level -1 (optional). This issue type enables level 0
  /// issue types to be broken down into components. Issues based on a level -1
  /// issue type must have a parent issue.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<ProjectIssueTypeHierarchy> getHierarchy(int projectId) async {
    return ProjectIssueTypeHierarchy.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectId}/hierarchy',
      pathParameters: {
        'projectId': '$projectId',
      },
    ));
  }

  /// Gets a [notification scheme](https://confluence.atlassian.com/x/8YdKLg)
  /// associated with the project. See the
  /// [Get notification scheme](#api-rest-api-3-notificationscheme-id-get)
  /// resource for more information about notification schemes.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg).
  Future<NotificationScheme> getNotificationSchemeForProject(
      {required String projectKeyOrId, String? expand}) async {
    return NotificationScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectKeyOrId}/notificationscheme',
      pathParameters: {
        'projectKeyOrId': projectKeyOrId,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ProjectAvatarsApi {
  final ApiClient _client;

  ProjectAvatarsApi(this._client);

  /// Sets the avatar displayed for a project.
  ///
  /// Use
  /// [Load project avatar](#api-rest-api-3-project-projectIdOrKey-avatar2-post)
  /// to store avatars against the project, before using this operation to set
  /// the displayed avatar.
  ///
  /// **[Permissions](#permissions) required:** *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg).
  Future<void> updateProjectAvatar(
      {required String projectIdOrKey, required Avatar body}) async {
    await _client.send(
      'put',
      'rest/api/3/project/{projectIdOrKey}/avatar',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      body: body.toJson(),
    );
  }

  /// Deletes a custom avatar from a project. Note that system avatars cannot be
  /// deleted.
  ///
  /// **[Permissions](#permissions) required:** *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg).
  Future<void> deleteProjectAvatar(
      {required String projectIdOrKey, required int id}) async {
    await _client.send(
      'delete',
      'rest/api/3/project/{projectIdOrKey}/avatar/{id}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'id': '$id',
      },
    );
  }

  /// Loads an avatar for a project.
  ///
  /// Specify the avatar's local file location in the body of the request. Also,
  /// include the following headers:
  ///
  ///  *  `X-Atlassian-Token: no-check` To prevent XSRF protection blocking the
  /// request, for more information see
  /// [Special Headers](#special-request-headers).
  ///  *  `Content-Type: image/image type` Valid image types are JPEG, GIF, or
  /// PNG.
  ///
  /// For example:
  /// `curl --request POST `
  ///
  /// `--user email@example.com:<api_token> `
  ///
  /// `--header 'X-Atlassian-Token: no-check' `
  ///
  /// `--header 'Content-Type: image/< image_type>' `
  ///
  /// `--data-binary "<@/path/to/file/with/your/avatar>" `
  ///
  /// `--url
  /// 'https://your-domain.atlassian.net/rest/api/3/project/{projectIdOrKey}/avatar2'`
  ///
  /// The avatar is cropped to a square. If no crop parameters are specified,
  /// the square originates at the top left of the image. The length of the
  /// square's sides is set to the smaller of the height or width of the image.
  ///
  /// The cropped image is then used to create avatars of 16x16, 24x24, 32x32,
  /// and 48x48 in size.
  ///
  /// After creating the avatar use
  /// [Set project avatar](#api-rest-api-3-project-projectIdOrKey-avatar-put) to
  /// set it as the project's displayed avatar.
  ///
  /// **[Permissions](#permissions) required:** *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg).
  Future<Avatar> createProjectAvatar(
      {required String projectIdOrKey,
      int? x,
      int? y,
      int? size,
      required dynamic body}) async {
    return Avatar.fromJson(await _client.send(
      'post',
      'rest/api/3/project/{projectIdOrKey}/avatar2',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (x != null) 'x': '$x',
        if (y != null) 'y': '$y',
        if (size != null) 'size': '$size',
      },
      body: body,
    ));
  }

  /// Returns all project avatars, grouped by system and custom avatars.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<ProjectAvatars> getAllProjectAvatars(String projectIdOrKey) async {
    return ProjectAvatars.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/avatars',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ProjectCategoriesApi {
  final ApiClient _client;

  ProjectCategoriesApi(this._client);

  /// Returns all project categories.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<List<ProjectCategory>> getAllProjectCategories() async {
    return (await _client.send(
      'get',
      'rest/api/3/projectCategory',
    ) as List<Object?>)
        .map((i) =>
            ProjectCategory.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a project category.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectCategory> createProjectCategory(
      {required ProjectCategory body}) async {
    return ProjectCategory.fromJson(await _client.send(
      'post',
      'rest/api/3/projectCategory',
      body: body.toJson(),
    ));
  }

  /// Returns a project category.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<ProjectCategory> getProjectCategoryById(int id) async {
    return ProjectCategory.fromJson(await _client.send(
      'get',
      'rest/api/3/projectCategory/{id}',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Updates a project category.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<UpdatedProjectCategory> updateProjectCategory(
      {required int id, required ProjectCategory body}) async {
    return UpdatedProjectCategory.fromJson(await _client.send(
      'put',
      'rest/api/3/projectCategory/{id}',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a project category.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> removeProjectCategory(int id) async {
    await _client.send(
      'delete',
      'rest/api/3/projectCategory/{id}',
      pathParameters: {
        'id': '$id',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class ProjectComponentsApi {
  final ApiClient _client;

  ProjectComponentsApi(this._client);

  /// Creates a component. Use components to provide containers for issues
  /// within a project.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project in which the component is created or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Component> createComponent({required Component body}) async {
    return Component.fromJson(await _client.send(
      'post',
      'rest/api/3/component',
      body: body.toJson(),
    ));
  }

  /// Returns a component.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for
  /// project containing the component.
  Future<Component> getComponent(String id) async {
    return Component.fromJson(await _client.send(
      'get',
      'rest/api/3/component/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Updates a component. Any fields included in the request are overwritten.
  /// If `leadAccountId` is an empty string ("") the component lead is removed.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the component or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Component> updateComponent(
      {required String id, required Component body}) async {
    return Component.fromJson(await _client.send(
      'put',
      'rest/api/3/component/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a component.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the component or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteComponent(
      {required String id, String? moveIssuesTo}) async {
    await _client.send(
      'delete',
      'rest/api/3/component/{id}',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        if (moveIssuesTo != null) 'moveIssuesTo': moveIssuesTo,
      },
    );
  }

  /// Returns the counts of issues assigned to the component.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<ComponentIssuesCount> getComponentRelatedIssues(String id) async {
    return ComponentIssuesCount.fromJson(await _client.send(
      'get',
      'rest/api/3/component/{id}/relatedIssueCounts',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of all components in a project.
  /// See the
  /// [Get project components](#api-rest-api-3-project-projectIdOrKey-components-get)
  /// resource if you want to get a full list of versions without pagination.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<PageBeanComponentWithIssueCount> getProjectComponentsPaginated(
      {required String projectIdOrKey,
      int? startAt,
      int? maxResults,
      String? orderBy,
      String? query}) async {
    return PageBeanComponentWithIssueCount.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/component',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (orderBy != null) 'orderBy': orderBy,
        if (query != null) 'query': query,
      },
    ));
  }

  /// Returns all components in a project. See the
  /// [Get project components paginated](#api-rest-api-3-project-projectIdOrKey-component-get)
  /// resource if you want to get a full list of components with pagination.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<List<Component>> getProjectComponents(String projectIdOrKey) async {
    return (await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/components',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ) as List<Object?>)
        .map((i) => Component.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }
}

/// Jira Cloud platform REST API documentation

class ProjectEmailApi {
  final ApiClient _client;

  ProjectEmailApi(this._client);

  /// Returns the
  /// [project's sender email address](https://confluence.atlassian.com/x/dolKLg).
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<ProjectEmailAddress> getProjectEmail(int projectId) async {
    return ProjectEmailAddress.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectId}/email',
      pathParameters: {
        'projectId': '$projectId',
      },
    ));
  }

  /// Sets the
  /// [project's sender email address](https://confluence.atlassian.com/x/dolKLg).
  ///
  /// If `emailAddress` is an empty string, the default email address is
  /// restored.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<void> updateProjectEmail(
      {required int projectId, required ProjectEmailAddress body}) async {
    await _client.send(
      'put',
      'rest/api/3/project/{projectId}/email',
      pathParameters: {
        'projectId': '$projectId',
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class ProjectKeyAndNameValidationApi {
  final ApiClient _client;

  ProjectKeyAndNameValidationApi(this._client);

  /// Validates a project key by confirming the key is a valid string and not in
  /// use.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<ErrorCollection> validateProjectKey({String? key}) async {
    return ErrorCollection.fromJson(await _client.send(
      'get',
      'rest/api/3/projectvalidate/key',
      queryParameters: {
        if (key != null) 'key': key,
      },
    ));
  }

  /// Validates a project key and, if the key is invalid or in use, generates a
  /// valid random string for the project key.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<String> getValidProjectKey({String? key}) async {
    return await _client.send(
      'get',
      'rest/api/3/projectvalidate/validProjectKey',
      queryParameters: {
        if (key != null) 'key': key,
      },
    ) as String;
  }

  /// Checks that a project name isn't in use. If the name isn't in use, the
  /// passed string is returned. If the name is in use, this operation attempts
  /// to generate a valid project name based on the one supplied, usually by
  /// adding a sequence number. If a valid project name cannot be generated, a
  /// 404 response is returned.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<String> getValidProjectName(String name) async {
    return await _client.send(
      'get',
      'rest/api/3/projectvalidate/validProjectName',
      queryParameters: {
        'name': name,
      },
    ) as String;
  }
}

/// Jira Cloud platform REST API documentation

class ProjectPermissionSchemesApi {
  final ApiClient _client;

  ProjectPermissionSchemesApi(this._client);

  /// Returns the
  /// [issue security scheme](https://confluence.atlassian.com/x/J4lKLg)
  /// associated with the project.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or the
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg).
  Future<SecurityScheme> getProjectIssueSecurityScheme(
      String projectKeyOrId) async {
    return SecurityScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectKeyOrId}/issuesecuritylevelscheme',
      pathParameters: {
        'projectKeyOrId': projectKeyOrId,
      },
    ));
  }

  /// Gets the [permission scheme](https://confluence.atlassian.com/x/yodKLg)
  /// associated with the project.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg).
  Future<PermissionScheme> getAssignedPermissionScheme(
      {required String projectKeyOrId, String? expand}) async {
    return PermissionScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectKeyOrId}/permissionscheme',
      pathParameters: {
        'projectKeyOrId': projectKeyOrId,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Assigns a permission scheme with a project. See
  /// [Managing project permissions](https://confluence.atlassian.com/x/yodKLg)
  /// for more information about permission schemes.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg)
  Future<PermissionScheme> assignPermissionScheme(
      {required String projectKeyOrId,
      String? expand,
      required IdBean body}) async {
    return PermissionScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/project/{projectKeyOrId}/permissionscheme',
      pathParameters: {
        'projectKeyOrId': projectKeyOrId,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Returns all [issue security](https://confluence.atlassian.com/x/J4lKLg)
  /// levels for the project that the user has access to.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) for the
  /// project, however, issue security levels are only returned for
  /// authenticated user with *Set Issue Security*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) for the
  /// project.
  Future<ProjectIssueSecurityLevels> getSecurityLevelsForProject(
      String projectKeyOrId) async {
    return ProjectIssueSecurityLevels.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectKeyOrId}/securitylevel',
      pathParameters: {
        'projectKeyOrId': projectKeyOrId,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ProjectPropertiesApi {
  final ApiClient _client;

  ProjectPropertiesApi(this._client);

  /// Returns all
  /// [project property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties)
  /// keys for the project.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<PropertyKeys> getProjectPropertyKeys(String projectIdOrKey) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/properties',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ));
  }

  /// Returns the value of a
  /// [project property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the property.
  Future<EntityProperty> getProjectProperty(
      {required String projectIdOrKey, required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/properties/{propertyKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Sets the value of the
  /// [project property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties).
  /// You can use project properties to store custom data against the project.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project in which the property is created.
  Future<void> setProjectProperty(
      {required String projectIdOrKey,
      required String propertyKey,
      required dynamic body}) async {
    await _client.send(
      'put',
      'rest/api/3/project/{projectIdOrKey}/properties/{propertyKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'propertyKey': propertyKey,
      },
      body: body,
    );
  }

  /// Deletes the
  /// [property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties)
  /// from a project.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the property.
  Future<void> deleteProjectProperty(
      {required String projectIdOrKey, required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/project/{projectIdOrKey}/properties/{propertyKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'propertyKey': propertyKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class ProjectRolesApi {
  final ApiClient _client;

  ProjectRolesApi(this._client);

  /// Returns a list of
  /// [project roles](https://confluence.atlassian.com/x/3odKLg) for the project
  /// returning the name and self URL for each role.
  ///
  /// Note that all project roles are shared with all projects in Jira Cloud.
  /// See [Get all project roles](#api-rest-api-3-role-get) for more
  /// information.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for any
  /// project on the site or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Map<String, dynamic>> getProjectRoles(String projectIdOrKey) async {
    return await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/role',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ) as Map<String, Object?>;
  }

  /// Returns a project role's details and actors associated with the project.
  /// The list of actors is sorted by display name.
  ///
  /// To check whether a user belongs to a role based on their group
  /// memberships, use [Get user](#api-rest-api-3-user-get) with the `groups`
  /// expand parameter selected. Then check whether the user keys and groups
  /// match with the actors returned for the project.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> getProjectRole(
      {required String projectIdOrKey, required int id}) async {
    return ProjectRole.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/role/{id}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'id': '$id',
      },
    ));
  }

  /// Returns all [project roles](https://confluence.atlassian.com/x/3odKLg) and
  /// the details for each role. Note that the list of project roles is common
  /// to all projects.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<List<ProjectRoleDetails>> getProjectRoleDetails(
      {required String projectIdOrKey,
      bool? currentMember,
      bool? excludeConnectAddons}) async {
    return (await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/roledetails',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (currentMember != null) 'currentMember': '$currentMember',
        if (excludeConnectAddons != null)
          'excludeConnectAddons': '$excludeConnectAddons',
      },
    ) as List<Object?>)
        .map((i) =>
            ProjectRoleDetails.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Gets a list of all project roles, complete with project role details and
  /// default actors.
  ///
  /// ### About project roles ###
  ///
  /// [Project roles](https://confluence.atlassian.com/x/3odKLg) are a flexible
  /// way to to associate users and groups with projects. In Jira Cloud, the
  /// list of project roles is shared globally with all projects, but each
  /// project can have a different set of actors associated with it (unlike
  /// groups, which have the same membership throughout all Jira applications).
  ///
  /// Project roles are used in
  /// [permission schemes](#api-rest-api-3-permissionscheme-get),
  /// [email notification schemes](#api-rest-api-3-notificationscheme-get),
  /// [issue security levels](#api-rest-api-3-issuesecurityschemes-get),
  /// [comment visibility](#api-rest-api-3-comment-list-post), and workflow
  /// conditions.
  ///
  /// #### Members and actors ####
  ///
  /// In the Jira REST API, a member of a project role is called an *actor*. An
  /// *actor* is a group or user associated with a project role.
  ///
  /// Actors may be set as
  /// [default members](https://confluence.atlassian.com/x/3odKLg#Managingprojectroles-Specifying'defaultmembers'foraprojectrole)
  /// of the project role or set at the project level:
  ///
  ///  *  Default actors: Users and groups that are assigned to the project role
  /// for all newly created projects. The default actors can be removed at the
  /// project level later if desired.
  ///  *  Actors: Users and groups that are associated with a project role for a
  /// project, which may differ from the default actors. This enables you to
  /// assign a user to different roles in different projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<ProjectRole>> getAllProjectRoles() async {
    return (await _client.send(
      'get',
      'rest/api/3/role',
    ) as List<Object?>)
        .map(
            (i) => ProjectRole.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a new project role with no
  /// [default actors](#api-rest-api-3-resolution-get). You can use the
  /// [Add default actors to project role](#api-rest-api-3-role-id-actors-post)
  /// operation to add default actors to the project role after creating it.
  ///
  /// *Note that although a new project role is available to all projects upon
  /// creation, any default actors that are associated with the project role are
  /// not added to projects that existed prior to the role being created.*<
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> createProjectRole(
      {required CreateUpdateRoleRequestBean body}) async {
    return ProjectRole.fromJson(await _client.send(
      'post',
      'rest/api/3/role',
      body: body.toJson(),
    ));
  }

  /// Gets the project role details and the default actors associated with the
  /// role. The list of default actors is sorted by display name.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> getProjectRoleById(int id) async {
    return ProjectRole.fromJson(await _client.send(
      'get',
      'rest/api/3/role/{id}',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Updates the project role's name and description. You must include both a
  /// name and a description in the request.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> fullyUpdateProjectRole(
      {required int id, required CreateUpdateRoleRequestBean body}) async {
    return ProjectRole.fromJson(await _client.send(
      'put',
      'rest/api/3/role/{id}',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Updates either the project role's name or its description.
  ///
  /// You cannot update both the name and description at the same time using
  /// this operation. If you send a request with a name and a description only
  /// the name is updated.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> partialUpdateProjectRole(
      {required int id, required CreateUpdateRoleRequestBean body}) async {
    return ProjectRole.fromJson(await _client.send(
      'post',
      'rest/api/3/role/{id}',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a project role. You must specify a replacement project role if you
  /// wish to delete a project role that is in use.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteProjectRole({required int id, int? swap}) async {
    await _client.send(
      'delete',
      'rest/api/3/role/{id}',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (swap != null) 'swap': '$swap',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class ProjectRoleActorsApi {
  final ApiClient _client;

  ProjectRoleActorsApi(this._client);

  /// Sets the actors for a project role for a project, replacing all existing
  /// actors.
  ///
  /// To add actors to the project without overwriting the existing list, use
  /// [Add actors to project role](#api-rest-api-3-project-projectIdOrKey-role-id-post).
  ///
  /// **[Permissions](#permissions) required:** *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> setActors(
      {required String projectIdOrKey,
      required int id,
      required ProjectRoleActorsUpdateBean body}) async {
    return ProjectRole.fromJson(await _client.send(
      'put',
      'rest/api/3/project/{projectIdOrKey}/role/{id}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Adds actors to a project role for the project.
  ///
  /// To replace all actors for the project, use
  /// [Set actors for project role](#api-rest-api-3-project-projectIdOrKey-role-id-put).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> addActorUsers(
      {required String projectIdOrKey,
      required int id,
      required ActorsMap body}) async {
    return ProjectRole.fromJson(await _client.send(
      'post',
      'rest/api/3/project/{projectIdOrKey}/role/{id}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes actors from a project role for the project.
  ///
  /// To remove default actors from the project role, use
  /// [Delete default actors from project role](#api-rest-api-3-role-id-actors-delete).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteActor(
      {required String projectIdOrKey,
      required int id,
      String? user,
      String? group}) async {
    await _client.send(
      'delete',
      'rest/api/3/project/{projectIdOrKey}/role/{id}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'id': '$id',
      },
      queryParameters: {
        if (user != null) 'user': user,
        if (group != null) 'group': group,
      },
    );
  }

  /// Returns the [default actors](#api-rest-api-3-resolution-get) for the
  /// project role.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> getProjectRoleActorsForRole(int id) async {
    return ProjectRole.fromJson(await _client.send(
      'get',
      'rest/api/3/role/{id}/actors',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Adds [default actors](#api-rest-api-3-resolution-get) to a role. You may
  /// add groups or users, but you cannot add groups and users in the same
  /// request.
  ///
  /// Changing a project role's default actors does not affect project role
  /// members for projects already created.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> addProjectRoleActorsToRole(
      {required int id, required ActorInputBean body}) async {
    return ProjectRole.fromJson(await _client.send(
      'post',
      'rest/api/3/role/{id}/actors',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the [default actors](#api-rest-api-3-resolution-get) from a
  /// project role. You may delete a group or user, but you cannot delete a
  /// group and a user in the same request.
  ///
  /// Changing a project role's default actors does not affect project role
  /// members for projects already created.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> deleteProjectRoleActorsFromRole(
      {required int id, String? user, String? group}) async {
    return ProjectRole.fromJson(await _client.send(
      'delete',
      'rest/api/3/role/{id}/actors',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (user != null) 'user': user,
        if (group != null) 'group': group,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ProjectTypesApi {
  final ApiClient _client;

  ProjectTypesApi(this._client);

  /// Returns all [project types](https://confluence.atlassian.com/x/Var1Nw),
  /// whether or not the instance has a valid license for each type.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<List<ProjectType>> getAllProjectTypes() async {
    return (await _client.send(
      'get',
      'rest/api/3/project/type',
    ) as List<Object?>)
        .map(
            (i) => ProjectType.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns all [project types](https://confluence.atlassian.com/x/Var1Nw)
  /// with a valid license.
  Future<List<ProjectType>> getAllAccessibleProjectTypes() async {
    return (await _client.send(
      'get',
      'rest/api/3/project/type/accessible',
    ) as List<Object?>)
        .map(
            (i) => ProjectType.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a [project type](https://confluence.atlassian.com/x/Var1Nw).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<ProjectType> getProjectTypeByKey(String projectTypeKey) async {
    return ProjectType.fromJson(await _client.send(
      'get',
      'rest/api/3/project/type/{projectTypeKey}',
      pathParameters: {
        'projectTypeKey': projectTypeKey,
      },
    ));
  }

  /// Returns a [project type](https://confluence.atlassian.com/x/Var1Nw) if it
  /// is accessible to the user.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<ProjectType> getAccessibleProjectTypeByKey(
      String projectTypeKey) async {
    return ProjectType.fromJson(await _client.send(
      'get',
      'rest/api/3/project/type/{projectTypeKey}/accessible',
      pathParameters: {
        'projectTypeKey': projectTypeKey,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ProjectVersionsApi {
  final ApiClient _client;

  ProjectVersionsApi(this._client);

  /// Returns a [paginated](#pagination) list of all versions in a project. See
  /// the
  /// [Get project versions](#api-rest-api-3-project-projectIdOrKey-versions-get)
  /// resource if you want to get a full list of versions without pagination.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<PageBeanVersion> getProjectVersionsPaginated(
      {required String projectIdOrKey,
      int? startAt,
      int? maxResults,
      String? orderBy,
      String? query,
      String? status,
      String? expand}) async {
    return PageBeanVersion.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/version',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (orderBy != null) 'orderBy': orderBy,
        if (query != null) 'query': query,
        if (status != null) 'status': status,
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns all versions in a project. The response is not paginated. Use
  /// [Get project versions paginated](#api-rest-api-3-project-projectIdOrKey-version-get)
  /// if you want to get the versions in a project with pagination.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<List<Version>> getProjectVersions(
      {required String projectIdOrKey, String? expand}) async {
    return (await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/versions',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ) as List<Object?>)
        .map((i) => Version.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a project version.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project the version is added to.
  Future<Version> createVersion({required Version body}) async {
    return Version.fromJson(await _client.send(
      'post',
      'rest/api/3/version',
      body: body.toJson(),
    ));
  }

  /// Returns a project version.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the version.
  Future<Version> getVersion({required String id, String? expand}) async {
    return Version.fromJson(await _client.send(
      'get',
      'rest/api/3/version/{id}',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates a project version.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that contains the version.
  Future<Version> updateVersion(
      {required String id, required Version body}) async {
    return Version.fromJson(await _client.send(
      'put',
      'rest/api/3/version/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a project version.
  ///
  /// Deprecated, use
  /// [ Delete and replace version](#api-rest-api-3-version-id-removeAndSwap-post)
  /// that supports swapping version values in custom fields, in addition to the
  /// swapping for `fixVersion` and `affectedVersion` provided in this resource.
  ///
  /// Alternative versions can be provided to update issues that use the deleted
  /// version in `fixVersion` or `affectedVersion`. If alternatives are not
  /// provided, occurrences of `fixVersion` and `affectedVersion` that contain
  /// the deleted version are cleared.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that contains the version.
  Future<void> deleteVersion(
      {required String id,
      String? moveFixIssuesTo,
      String? moveAffectedIssuesTo}) async {
    await _client.send(
      'delete',
      'rest/api/3/version/{id}',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        if (moveFixIssuesTo != null) 'moveFixIssuesTo': moveFixIssuesTo,
        if (moveAffectedIssuesTo != null)
          'moveAffectedIssuesTo': moveAffectedIssuesTo,
      },
    );
  }

  /// Merges two project versions. The merge is completed by deleting the
  /// version specified in `id` and replacing any occurrences of its ID in
  /// `fixVersion` with the version ID specified in `moveIssuesTo`.
  ///
  /// Consider using
  /// [ Delete and replace version](#api-rest-api-3-version-id-removeAndSwap-post)
  /// instead. This resource supports swapping version values in `fixVersion`,
  /// `affectedVersion`, and custom fields.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that contains the version.
  Future<void> mergeVersions(
      {required String id, required String moveIssuesTo}) async {
    await _client.send(
      'put',
      'rest/api/3/version/{id}/mergeto/{moveIssuesTo}',
      pathParameters: {
        'id': id,
        'moveIssuesTo': moveIssuesTo,
      },
    );
  }

  /// Modifies the version's sequence within the project, which affects the
  /// display order of the versions in Jira.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects* project
  /// permission for the project that contains the version.
  Future<Version> moveVersion(
      {required String id, required VersionMoveBean body}) async {
    return Version.fromJson(await _client.send(
      'post',
      'rest/api/3/version/{id}/move',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }

  /// Returns the following counts for a version:
  ///
  ///  *  Number of issues where the `fixVersion` is set to the version.
  ///  *  Number of issues where the `affectedVersion` is set to the version.
  ///  *  Number of issues where a version custom field is set to the version.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects* project
  /// permission for the project that contains the version.
  Future<VersionIssueCounts> getVersionRelatedIssues(String id) async {
    return VersionIssueCounts.fromJson(await _client.send(
      'get',
      'rest/api/3/version/{id}/relatedIssueCounts',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Deletes a project version.
  ///
  /// Alternative versions can be provided to update issues that use the deleted
  /// version in `fixVersion`, `affectedVersion`, or any version picker custom
  /// fields. If alternatives are not provided, occurrences of `fixVersion`,
  /// `affectedVersion`, and any version picker custom field, that contain the
  /// deleted version, are cleared. Any replacement version must be in the same
  /// project as the version being deleted and cannot be the version being
  /// deleted.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that contains the version.
  Future<void> deleteAndReplaceVersion(
      {required String id, required DeleteAndReplaceVersionBean body}) async {
    await _client.send(
      'post',
      'rest/api/3/version/{id}/removeAndSwap',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    );
  }

  /// Returns counts of the issues and unresolved issues for the project
  /// version.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects* project
  /// permission for the project that contains the version.
  Future<VersionUnresolvedIssuesCount> getVersionUnresolvedIssues(
      String id) async {
    return VersionUnresolvedIssuesCount.fromJson(await _client.send(
      'get',
      'rest/api/3/version/{id}/unresolvedIssueCount',
      pathParameters: {
        'id': id,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ScreensApi {
  final ApiClient _client;

  ScreensApi(this._client);

  /// Returns a [paginated](#pagination) list of the screens a field is used in.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanScreenWithTab> getScreensForField(
      {required String fieldId,
      int? startAt,
      int? maxResults,
      String? expand}) async {
    return PageBeanScreenWithTab.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/screens',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of all screens or those specified
  /// by one or more screen IDs.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanScreen> getScreens(
      {int? startAt, int? maxResults, List<int>? id}) async {
    return PageBeanScreen.fromJson(await _client.send(
      'get',
      'rest/api/3/screens',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': '$id',
      },
    ));
  }

  /// Creates a screen with a default field tab.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Screen> createScreen({required ScreenDetails body}) async {
    return Screen.fromJson(await _client.send(
      'post',
      'rest/api/3/screens',
      body: body.toJson(),
    ));
  }

  /// Adds a field to the default tab of the default screen.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> addFieldToDefaultScreen(String fieldId) async {
    await _client.send(
      'post',
      'rest/api/3/screens/addToDefault/{fieldId}',
      pathParameters: {
        'fieldId': fieldId,
      },
    );
  }

  /// Updates a screen. Only screens used in classic projects can be updated.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Screen> updateScreen(
      {required int screenId, required UpdateScreenDetails body}) async {
    return Screen.fromJson(await _client.send(
      'put',
      'rest/api/3/screens/{screenId}',
      pathParameters: {
        'screenId': '$screenId',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a screen. A screen cannot be deleted if it is used in a screen
  /// scheme, workflow, or workflow draft.
  ///
  /// Only screens used in classic projects can be deleted.
  Future<void> deleteScreen(int screenId) async {
    await _client.send(
      'delete',
      'rest/api/3/screens/{screenId}',
      pathParameters: {
        'screenId': '$screenId',
      },
    );
  }

  /// Returns the fields that can be added to a tab on a screen.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<ScreenableField>> getAvailableScreenFields(int screenId) async {
    return (await _client.send(
      'get',
      'rest/api/3/screens/{screenId}/availableFields',
      pathParameters: {
        'screenId': '$screenId',
      },
    ) as List<Object?>)
        .map((i) =>
            ScreenableField.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }
}

/// Jira Cloud platform REST API documentation

class ScreenTabsApi {
  final ApiClient _client;

  ScreenTabsApi(this._client);

  /// Returns the list of tabs for a screen.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///  *  *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) when the
  /// project key is specified, providing that the screen is associated with the
  /// project through a Screen Scheme and Issue Type Screen Scheme.
  Future<List<ScreenableTab>> getAllScreenTabs(
      {required int screenId, String? projectKey}) async {
    return (await _client.send(
      'get',
      'rest/api/3/screens/{screenId}/tabs',
      pathParameters: {
        'screenId': '$screenId',
      },
      queryParameters: {
        if (projectKey != null) 'projectKey': projectKey,
      },
    ) as List<Object?>)
        .map((i) =>
            ScreenableTab.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a tab for a screen.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ScreenableTab> addScreenTab(
      {required int screenId, required ScreenableTab body}) async {
    return ScreenableTab.fromJson(await _client.send(
      'post',
      'rest/api/3/screens/{screenId}/tabs',
      pathParameters: {
        'screenId': '$screenId',
      },
      body: body.toJson(),
    ));
  }

  /// Updates the name of a screen tab.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ScreenableTab> renameScreenTab(
      {required int screenId,
      required int tabId,
      required ScreenableTab body}) async {
    return ScreenableTab.fromJson(await _client.send(
      'put',
      'rest/api/3/screens/{screenId}/tabs/{tabId}',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a screen tab.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteScreenTab(
      {required int screenId, required int tabId}) async {
    await _client.send(
      'delete',
      'rest/api/3/screens/{screenId}/tabs/{tabId}',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
      },
    );
  }

  /// Moves a screen tab.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> moveScreenTab(
      {required int screenId, required int tabId, required int pos}) async {
    await _client.send(
      'post',
      'rest/api/3/screens/{screenId}/tabs/{tabId}/move/{pos}',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
        'pos': '$pos',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class ScreenTabFieldsApi {
  final ApiClient _client;

  ScreenTabFieldsApi(this._client);

  /// Returns all fields for a screen tab.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///  *  *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) when the
  /// project key is specified, providing that the screen is associated with the
  /// project through a Screen Scheme and Issue Type Screen Scheme.
  Future<List<ScreenableField>> getAllScreenTabFields(
      {required int screenId, required int tabId, String? projectKey}) async {
    return (await _client.send(
      'get',
      'rest/api/3/screens/{screenId}/tabs/{tabId}/fields',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
      },
      queryParameters: {
        if (projectKey != null) 'projectKey': projectKey,
      },
    ) as List<Object?>)
        .map((i) =>
            ScreenableField.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Adds a field to a screen tab.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ScreenableField> addScreenTabField(
      {required int screenId,
      required int tabId,
      required AddFieldBean body}) async {
    return ScreenableField.fromJson(await _client.send(
      'post',
      'rest/api/3/screens/{screenId}/tabs/{tabId}/fields',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
      },
      body: body.toJson(),
    ));
  }

  /// Removes a field from a screen tab.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> removeScreenTabField(
      {required int screenId, required int tabId, required String id}) async {
    await _client.send(
      'delete',
      'rest/api/3/screens/{screenId}/tabs/{tabId}/fields/{id}',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
        'id': id,
      },
    );
  }

  /// Moves a screen tab field.
  ///
  /// If `after` and `position` are provided in the request, `position` is
  /// ignored.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> moveScreenTabField(
      {required int screenId,
      required int tabId,
      required String id,
      required MoveFieldBean body}) async {
    await _client.send(
      'post',
      'rest/api/3/screens/{screenId}/tabs/{tabId}/fields/{id}/move',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
        'id': id,
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class ScreenSchemesApi {
  final ApiClient _client;

  ScreenSchemesApi(this._client);

  /// Returns a [paginated](#pagination) list of screen schemes.
  ///
  /// Only screen schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanScreenScheme> getScreenSchemes(
      {int? startAt, int? maxResults, List<int>? id}) async {
    return PageBeanScreenScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/screenscheme',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': '$id',
      },
    ));
  }

  /// Creates a screen scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ScreenSchemeId> createScreenScheme(
      {required ScreenSchemeDetails body}) async {
    return ScreenSchemeId.fromJson(await _client.send(
      'post',
      'rest/api/3/screenscheme',
      body: body.toJson(),
    ));
  }

  /// Updates a screen scheme. Only screen schemes used in classic projects can
  /// be updated.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> updateScreenScheme(
      {required String screenSchemeId,
      required UpdateScreenSchemeDetails body}) async {
    await _client.send(
      'put',
      'rest/api/3/screenscheme/{screenSchemeId}',
      pathParameters: {
        'screenSchemeId': screenSchemeId,
      },
      body: body.toJson(),
    );
  }

  /// Deletes a screen scheme. A screen scheme cannot be deleted if it is used
  /// in an issue type screen scheme.
  ///
  /// Only screens schemes used in classic projects can be deleted.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteScreenScheme(String screenSchemeId) async {
    await _client.send(
      'delete',
      'rest/api/3/screenscheme/{screenSchemeId}',
      pathParameters: {
        'screenSchemeId': screenSchemeId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class ServerInfoApi {
  final ApiClient _client;

  ServerInfoApi(this._client);

  /// Returns information about the Jira instance.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<ServerInformation> getServerInfo() async {
    return ServerInformation.fromJson(await _client.send(
      'get',
      'rest/api/3/serverInfo',
    ));
  }
}

/// Jira Cloud platform REST API documentation

class TasksApi {
  final ApiClient _client;

  TasksApi(this._client);

  /// Returns the status of a [long-running asynchronous task](#async).
  ///
  /// When a task has finished, this operation returns the JSON blob applicable
  /// to the task. See the documentation of the operation that created the task
  /// for details. Task details are not permanently retained. As of September
  /// 2019, details are retained for 14 days although this period may change
  /// without notice.
  ///
  /// **[Permissions](#permissions) required:** either of:
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///  *  Creator of the task.
  Future<TaskProgressBeanObject> getTask(String taskId) async {
    return TaskProgressBeanObject.fromJson(await _client.send(
      'get',
      'rest/api/3/task/{taskId}',
      pathParameters: {
        'taskId': taskId,
      },
    ));
  }

  /// Cancels a task.
  ///
  /// **[Permissions](#permissions) required:** either of:
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///  *  Creator of the task.
  Future<void> cancelTask(String taskId) async {
    await _client.send(
      'post',
      'rest/api/3/task/{taskId}/cancel',
      pathParameters: {
        'taskId': taskId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class TimeTrackingApi {
  final ApiClient _client;

  TimeTrackingApi(this._client);

  /// Returns the time tracking provider that is currently selected. Note that
  /// if time tracking is disabled, then a successful but empty response is
  /// returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TimeTrackingProvider> getSelectedTimeTrackingImplementation() async {
    return TimeTrackingProvider.fromJson(await _client.send(
      'get',
      'rest/api/3/configuration/timetracking',
    ));
  }

  /// Selects a time tracking provider.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> selectTimeTrackingImplementation(
      {required TimeTrackingProvider body}) async {
    await _client.send(
      'put',
      'rest/api/3/configuration/timetracking',
      body: body.toJson(),
    );
  }

  /// Returns all time tracking providers. By default, Jira only has one time
  /// tracking provider: *JIRA provided time tracking*. However, you can install
  /// other time tracking providers via apps from the Atlassian Marketplace. For
  /// more information on time tracking providers, see the documentation for the
  /// [ Time Tracking Provider](https://developer.atlassian.com/cloud/jira/platform/modules/time-tracking-provider/)
  /// module.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<TimeTrackingProvider>>
      getAvailableTimeTrackingImplementations() async {
    return (await _client.send(
      'get',
      'rest/api/3/configuration/timetracking/list',
    ) as List<Object?>)
        .map((i) => TimeTrackingProvider.fromJson(
            i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns the time tracking settings. This includes settings such as the
  /// time format, default time unit, and others. For more information, see
  /// [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TimeTrackingConfiguration> getSharedTimeTrackingConfiguration() async {
    return TimeTrackingConfiguration.fromJson(await _client.send(
      'get',
      'rest/api/3/configuration/timetracking/options',
    ));
  }

  /// Sets the time tracking settings.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TimeTrackingConfiguration> setSharedTimeTrackingConfiguration(
      {required TimeTrackingConfiguration body}) async {
    return TimeTrackingConfiguration.fromJson(await _client.send(
      'put',
      'rest/api/3/configuration/timetracking/options',
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class UsersApi {
  final ApiClient _client;

  UsersApi(this._client);

  /// Returns a user.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<User> getUser(
      {String? accountId,
      String? username,
      String? key,
      String? expand}) async {
    return User.fromJson(await _client.send(
      'get',
      'rest/api/3/user',
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (username != null) 'username': username,
        if (key != null) 'key': key,
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Creates a user. This resource is retained for legacy compatibility. As
  /// soon as a more suitable alternative is available this resource will be
  /// deprecated.
  ///
  /// The option is provided to set or generate a password for the user. When
  /// using the option to generate a password, by omitting `password` from the
  /// request, include `"notification": "true"` to ensure the user is sent an
  /// email advising them that their account is created. This email includes a
  /// link for the user to set their password. If the notification isn't sent
  /// for a generated password, the user will need to be sent a reset password
  /// request from Jira.
  ///
  /// If the user exists and has access to Jira, the operation returns a 201
  /// status. If the user exists but does not have access to Jira, the operation
  /// returns a 400 status.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<User> createUser({required UserWriteBean body}) async {
    return User.fromJson(await _client.send(
      'post',
      'rest/api/3/user',
      body: body.toJson(),
    ));
  }

  /// Deletes a user.
  ///
  /// **[Permissions](#permissions) required:** Site administration (that is,
  /// membership of the *site-admin*
  /// [group](https://confluence.atlassian.com/x/24xjL)).
  Future<void> removeUser(
      {required String accountId, String? username, String? key}) async {
    await _client.send(
      'delete',
      'rest/api/3/user',
      queryParameters: {
        'accountId': accountId,
        if (username != null) 'username': username,
        if (key != null) 'key': key,
      },
    );
  }

  /// Returns a [paginated](#pagination) list of the users specified by one or
  /// more account IDs.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PageBeanUser> bulkGetUsers(
      {int? startAt,
      int? maxResults,
      List<String>? username,
      List<String>? key,
      required List<String> accountId}) async {
    return PageBeanUser.fromJson(await _client.send(
      'get',
      'rest/api/3/user/bulk',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (username != null) 'username': '$username',
        if (key != null) 'key': '$key',
        'accountId': '$accountId',
      },
    ));
  }

  /// Returns the account IDs for the users specified in the `key` or `username`
  /// parameters. Note that multiple `key` or `username` parameters can be
  /// specified.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<List<UserMigrationBean>> bulkGetUsersMigration(
      {int? startAt,
      int? maxResults,
      List<String>? username,
      List<String>? key}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/bulk/migration',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (username != null) 'username': '$username',
        if (key != null) 'key': '$key',
      },
    ) as List<Object?>)
        .map((i) =>
            UserMigrationBean.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns the default
  /// [issue table columns](https://confluence.atlassian.com/x/XYdKLg) for the
  /// user. If `accountId` is not passed in the request, the calling user's
  /// details are returned.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLgl), to get
  /// the column details for any user.
  ///  *  Permission to access Jira, to get the calling user's column details.
  Future<List<ColumnItem>> getUserDefaultColumns(
      {String? accountId, String? username}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/columns',
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (username != null) 'username': username,
      },
    ) as List<Object?>)
        .map((i) => ColumnItem.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Sets the default
  /// [ issue table columns](https://confluence.atlassian.com/x/XYdKLg) for the
  /// user. If an account ID is not passed, the calling user's default columns
  /// are set. If no column details are sent, then all default columns are
  /// removed.
  ///
  /// The parameters for this resource are expressed as HTML form data. For
  /// example, in curl:
  ///
  /// `curl -X PUT -d columns=summary -d columns=description
  /// https://your-domain.atlassian.net/rest/api/3/user/columns?accountId=5b10ac8d82e05b22cc7d4ef5'`
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to set the
  /// columns on any user.
  ///  *  Permission to access Jira, to set the calling user's columns.
  Future<void> setUserColumns(
      {String? accountId, required List<String> body}) async {
    await _client.send(
      'put',
      'rest/api/3/user/columns',
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
      },
      body: body,
    );
  }

  /// Resets the default
  /// [ issue table columns](https://confluence.atlassian.com/x/XYdKLg) for the
  /// user to the system default. If `accountId` is not passed, the calling
  /// user's default columns are reset.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to set the
  /// columns on any user.
  ///  *  Permission to access Jira, to set the calling user's columns.
  Future<void> resetUserColumns({String? accountId, String? username}) async {
    await _client.send(
      'delete',
      'rest/api/3/user/columns',
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (username != null) 'username': username,
      },
    );
  }

  /// Returns a user's email address. This API is only available to apps
  /// approved by Atlassian, according to these
  /// [guidelines](https://community.developer.atlassian.com/t/guidelines-for-requesting-access-to-email-address/27603).
  Future<UnrestrictedUserEmail> getUserEmail(String accountId) async {
    return UnrestrictedUserEmail.fromJson(await _client.send(
      'get',
      'rest/api/3/user/email',
      queryParameters: {
        'accountId': accountId,
      },
    ));
  }

  /// Returns a user's email address. This API is only available to apps
  /// approved by Atlassian, according to these
  /// [guidelines](https://community.developer.atlassian.com/t/guidelines-for-requesting-access-to-email-address/27603).
  Future<UnrestrictedUserEmail> getUserEmailBulk(List<String> accountId) async {
    return UnrestrictedUserEmail.fromJson(await _client.send(
      'get',
      'rest/api/3/user/email/bulk',
      queryParameters: {
        'accountId': '$accountId',
      },
    ));
  }

  /// Returns the groups to which a user belongs.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<GroupName>> getUserGroups(
      {required String accountId, String? username, String? key}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/groups',
      queryParameters: {
        'accountId': accountId,
        if (username != null) 'username': username,
        if (key != null) 'key': key,
      },
    ) as List<Object?>)
        .map((i) => GroupName.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a list of all (active and inactive) users.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<User>> getAllUsersDefault({int? startAt, int? maxResults}) async {
    return (await _client.send(
      'get',
      'rest/api/3/users',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a list of all (active and inactive) users.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<User>> getAllUsers({int? startAt, int? maxResults}) async {
    return (await _client.send(
      'get',
      'rest/api/3/users/search',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }
}

/// Jira Cloud platform REST API documentation

class UserPropertiesApi {
  final ApiClient _client;

  UserPropertiesApi(this._client);

  /// Returns the keys of all properties for a user.
  ///
  /// Note: This operation does not access the
  /// [user properties](https://confluence.atlassian.com/x/8YxjL) created and
  /// maintained in Jira.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to access
  /// the property keys on any user.
  ///  *  Access to Jira, to access the calling user's property keys.
  Future<PropertyKeys> getUserPropertyKeys(
      {String? accountId, String? userKey, String? username}) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/user/properties',
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (userKey != null) 'userKey': userKey,
        if (username != null) 'username': username,
      },
    ));
  }

  /// Returns the value of a user's property. If no property key is provided
  /// [Get user property keys](#api-rest-api-3-user-properties-get) is called.
  ///
  /// Note: This operation does not access the
  /// [user properties](https://confluence.atlassian.com/x/8YxjL) created and
  /// maintained in Jira.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to get a
  /// property from any user.
  ///  *  Access to Jira, to get a property from the calling user's record.
  Future<EntityProperty> getUserProperty(
      {String? accountId,
      String? userKey,
      String? username,
      required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/user/properties/{propertyKey}',
      pathParameters: {
        'propertyKey': propertyKey,
      },
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (userKey != null) 'userKey': userKey,
        if (username != null) 'username': username,
      },
    ));
  }

  /// Sets the value of a user's property. Use this resource to store custom
  /// data against a user.
  ///
  /// Note: This operation does not access the
  /// [user properties](https://confluence.atlassian.com/x/8YxjL) created and
  /// maintained in Jira.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to set a
  /// property on any user.
  ///  *  Access to Jira, to set a property on the calling user's record.
  Future<void> setUserProperty(
      {String? accountId,
      String? userKey,
      String? username,
      required String propertyKey,
      required dynamic body}) async {
    await _client.send(
      'put',
      'rest/api/3/user/properties/{propertyKey}',
      pathParameters: {
        'propertyKey': propertyKey,
      },
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (userKey != null) 'userKey': userKey,
        if (username != null) 'username': username,
      },
      body: body,
    );
  }

  /// Deletes a property from a user.
  ///
  /// Note: This operation does not access the
  /// [user properties](https://confluence.atlassian.com/x/8YxjL) created and
  /// maintained in Jira.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to delete
  /// a property from any user.
  ///  *  Access to Jira, to delete a property from the calling user's record.
  Future<void> deleteUserProperty(
      {String? accountId,
      String? userKey,
      String? username,
      required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/user/properties/{propertyKey}',
      pathParameters: {
        'propertyKey': propertyKey,
      },
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (userKey != null) 'userKey': userKey,
        if (username != null) 'username': username,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class UserSearchApi {
  final ApiClient _client;

  UserSearchApi(this._client);

  /// Returns a list of users who can be assigned issues in one or more
  /// projects. The list may be restricted to users whose attributes match a
  /// string.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that can be assigned issues in the projects. This means
  /// the operation usually returns fewer users than specified in `maxResults`.
  /// To get all the users who can be assigned issues in the projects, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<List<User>> findBulkAssignableUsers(
      {String? query,
      String? username,
      String? accountId,
      required String projectKeys,
      int? startAt,
      int? maxResults}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/assignable/multiProjectSearch',
      queryParameters: {
        if (query != null) 'query': query,
        if (username != null) 'username': username,
        if (accountId != null) 'accountId': accountId,
        'projectKeys': projectKeys,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a list of users that can be assigned to an issue. Use this
  /// operation to find the list of users who can be assigned to:
  ///
  ///  *  a new issue, by providing the `projectKeyOrId`.
  ///  *  an updated issue, by providing the `issueKey`.
  ///  *  to an issue during a transition (workflow action), by providing the
  /// `issueKey` and the transition id in `actionDescriptorId`. You can obtain
  /// the IDs of an issue's valid transitions using the `transitions` option in
  /// the `expand` parameter of
  /// [ Get issue](#api-rest-api-3-issue-issueIdOrKey-get).
  ///
  /// In all these cases, you can pass an account ID to determine if a user can
  /// be assigned to an issue. The user is returned in the response if they can
  /// be assigned to the issue or issue transition.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that can be assigned the issue. This means the operation
  /// usually returns fewer users than specified in `maxResults`. To get all the
  /// users who can be assigned the issue, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<List<User>> findAssignableUsers(
      {String? query,
      String? sessionId,
      String? username,
      String? accountId,
      String? project,
      String? issueKey,
      int? startAt,
      int? maxResults,
      int? actionDescriptorId,
      bool? recommend}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/assignable/search',
      queryParameters: {
        if (query != null) 'query': query,
        if (sessionId != null) 'sessionId': sessionId,
        if (username != null) 'username': username,
        if (accountId != null) 'accountId': accountId,
        if (project != null) 'project': project,
        if (issueKey != null) 'issueKey': issueKey,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (actionDescriptorId != null)
          'actionDescriptorId': '$actionDescriptorId',
        if (recommend != null) 'recommend': '$recommend',
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a list of users who fulfill these criteria:
  ///
  ///  *  their user attributes match a search string.
  ///  *  they have a set of permissions for a project or issue.
  ///
  /// If no search string is provided, a list of all users with the permissions
  /// is returned.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that match the search string and have permission for the
  /// project or issue. This means the operation usually returns fewer users
  /// than specified in `maxResults`. To get all the users who match the search
  /// string and have permission for the project or issue, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to get
  /// users for any project.
  ///  *  *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for a
  /// project, to get users for that project.
  Future<List<User>> findUsersWithAllPermissions(
      {String? query,
      String? username,
      String? accountId,
      required String permissions,
      String? issueKey,
      String? projectKey,
      int? startAt,
      int? maxResults}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/permission/search',
      queryParameters: {
        if (query != null) 'query': query,
        if (username != null) 'username': username,
        if (accountId != null) 'accountId': accountId,
        'permissions': permissions,
        if (issueKey != null) 'issueKey': issueKey,
        if (projectKey != null) 'projectKey': projectKey,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a list of users whose attributes match the query term. The
  /// returned object includes the `html` field where the matched query term is
  /// highlighted with the HTML strong tag. A list of account IDs can be
  /// provided to exclude users from the results.
  ///
  /// This operation takes the users in the range defined by `maxResults`, up to
  /// the thousandth user, and then returns only the users from that range that
  /// match the query term. This means the operation usually returns fewer users
  /// than specified in `maxResults`. To get all the users who match the query
  /// term, use [Get all users](#api-rest-api-3-users-search-get) and filter the
  /// records in your code.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Anonymous
  /// calls and calls by users without the required permission return search
  /// results for an exact name match only.
  Future<FoundUsers> findUsersForPicker(
      {required String query,
      int? maxResults,
      bool? showAvatar,
      List<String>? exclude,
      List<String>? excludeAccountIds,
      String? avatarSize,
      bool? excludeConnectUsers}) async {
    return FoundUsers.fromJson(await _client.send(
      'get',
      'rest/api/3/user/picker',
      queryParameters: {
        'query': query,
        if (maxResults != null) 'maxResults': '$maxResults',
        if (showAvatar != null) 'showAvatar': '$showAvatar',
        if (exclude != null) 'exclude': '$exclude',
        if (excludeAccountIds != null)
          'excludeAccountIds': '$excludeAccountIds',
        if (avatarSize != null) 'avatarSize': avatarSize,
        if (excludeConnectUsers != null)
          'excludeConnectUsers': '$excludeConnectUsers',
      },
    ));
  }

  /// Returns a list of users that match the search string and property.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that match the search string and property. This means the
  /// operation usually returns fewer users than specified in `maxResults`. To
  /// get all the users who match the search string and property, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Anonymous
  /// calls or calls by users without the required permission return empty
  /// search results.
  Future<List<User>> findUsers(
      {String? query,
      String? username,
      String? accountId,
      int? startAt,
      int? maxResults,
      String? property}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/search',
      queryParameters: {
        if (query != null) 'query': query,
        if (username != null) 'username': username,
        if (accountId != null) 'accountId': accountId,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (property != null) 'property': property,
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Finds users with a structured query and returns a [paginated](#pagination)
  /// list of user details.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that match the structured query. This means the operation
  /// usually returns fewer users than specified in `maxResults`. To get all the
  /// users who match the structured query, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///
  /// The query statements are:
  ///
  ///  *  `is assignee of PROJ` Returns the users that are assignees of at least
  /// one issue in project *PROJ*.
  ///  *  `is assignee of (PROJ-1, PROJ-2)` Returns users that are assignees on
  /// the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is reporter of (PROJ-1, PROJ-2)` Returns users that are reporters on
  /// the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is watcher of (PROJ-1, PROJ-2)` Returns users that are watchers on
  /// the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is voter of (PROJ-1, PROJ-2)` Returns users that are voters on the
  /// issues *PROJ-1* or *PROJ-2*.
  ///  *  `is commenter of (PROJ-1, PROJ-2)` Returns users that have posted a
  /// comment on the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is transitioner of (PROJ-1, PROJ-2)` Returns users that have
  /// performed a transition on issues *PROJ-1* or *PROJ-2*.
  ///  *  `[propertyKey].entity.property.path is "property value"` Returns users
  /// with the entity property value.
  ///
  /// The list of issues can be extended as needed, as in *(PROJ-1, PROJ-2, ...
  /// PROJ-n)*. Statements can be combined using the `AND` and `OR` operators to
  /// form more complex queries. For example:
  ///
  /// `is assignee of PROJ AND [propertyKey].entity.property.path is "property
  /// value"`
  Future<PageBeanUser> findUsersByQuery(
      {required String query, int? startAt, int? maxResults}) async {
    return PageBeanUser.fromJson(await _client.send(
      'get',
      'rest/api/3/user/search/query',
      queryParameters: {
        'query': query,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Finds users with a structured query and returns a [paginated](#pagination)
  /// list of user keys.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that match the structured query. This means the operation
  /// usually returns fewer users than specified in `maxResults`. To get all the
  /// users who match the structured query, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///
  /// The query statements are:
  ///
  ///  *  `is assignee of PROJ` Returns the users that are assignees of at least
  /// one issue in project *PROJ*.
  ///  *  `is assignee of (PROJ-1, PROJ-2)` Returns users that are assignees on
  /// the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is reporter of (PROJ-1, PROJ-2)` Returns users that are reporters on
  /// the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is watcher of (PROJ-1, PROJ-2)` Returns users that are watchers on
  /// the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is voter of (PROJ-1, PROJ-2)` Returns users that are voters on the
  /// issues *PROJ-1* or *PROJ-2*.
  ///  *  `is commenter of (PROJ-1, PROJ-2)` Returns users that have posted a
  /// comment on the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is transitioner of (PROJ-1, PROJ-2)` Returns users that have
  /// performed a transition on issues *PROJ-1* or *PROJ-2*.
  ///  *  `[propertyKey].entity.property.path is "property value"` Returns users
  /// with the entity property value.
  ///
  /// The list of issues can be extended as needed, as in *(PROJ-1, PROJ-2, ...
  /// PROJ-n)*. Statements can be combined using the `AND` and `OR` operators to
  /// form more complex queries. For example:
  ///
  /// `is assignee of PROJ AND [propertyKey].entity.property.path is "property
  /// value"`
  Future<PageBeanUserKey> findUserKeysByQuery(
      {required String query, int? startAt, int? maxResults}) async {
    return PageBeanUserKey.fromJson(await _client.send(
      'get',
      'rest/api/3/user/search/query/key',
      queryParameters: {
        'query': query,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Returns a list of users who fulfill these criteria:
  ///
  ///  *  their user attributes match a search string.
  ///  *  they have permission to browse issues.
  ///
  /// Use this resource to find users who can browse:
  ///
  ///  *  an issue, by providing the `issueKey`.
  ///  *  any issue in a project, by providing the `projectKey`.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that match the search string and have permission to browse
  /// issues. This means the operation usually returns fewer users than
  /// specified in `maxResults`. To get all the users who match the search
  /// string and have permission to browse issues, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Anonymous
  /// calls and calls by users without the required permission return empty
  /// search results.
  Future<List<User>> findUsersWithBrowsePermission(
      {String? query,
      String? username,
      String? accountId,
      String? issueKey,
      String? projectKey,
      int? startAt,
      int? maxResults}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/viewissue/search',
      queryParameters: {
        if (query != null) 'query': query,
        if (username != null) 'username': username,
        if (accountId != null) 'accountId': accountId,
        if (issueKey != null) 'issueKey': issueKey,
        if (projectKey != null) 'projectKey': projectKey,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }
}

/// Jira Cloud platform REST API documentation

class WebhooksApi {
  final ApiClient _client;

  WebhooksApi(this._client);

  /// Returns a [paginated](#pagination) list of the webhooks registered by the
  /// calling app.
  ///
  /// **[Permissions](#permissions) required:** Only
  /// [Connect apps](https://developer.atlassian.com/cloud/jira/platform/integrating-with-jira-cloud/#atlassian-connect)
  /// can use this operation.
  Future<PageBeanWebhook> getDynamicWebhooksForApp(
      {int? startAt, int? maxResults}) async {
    return PageBeanWebhook.fromJson(await _client.send(
      'get',
      'rest/api/3/webhook',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Registers webhooks.
  ///
  /// **[Permissions](#permissions) required:** Only
  /// [Connect apps](https://developer.atlassian.com/cloud/jira/platform/integrating-with-jira-cloud/#atlassian-connect)
  /// can use this operation.
  Future<ContainerForRegisteredWebhooks> registerDynamicWebhooks(
      {required WebhookRegistrationDetails body}) async {
    return ContainerForRegisteredWebhooks.fromJson(await _client.send(
      'post',
      'rest/api/3/webhook',
      body: body.toJson(),
    ));
  }

  /// Removes webhooks by ID. Only webhooks registered by the calling Connect
  /// app are removed. If webhooks created by other apps are specified, they are
  /// ignored.
  ///
  /// **[Permissions](#permissions) required:** Only
  /// [Connect apps](https://developer.atlassian.com/cloud/jira/platform/integrating-with-jira-cloud/#atlassian-connect)
  /// can use this operation.
  Future<void> deleteWebhookById({required ContainerForWebhookIDs body}) async {
    await _client.send(
      'delete',
      'rest/api/3/webhook',
      body: body.toJson(),
    );
  }

  /// Returns webhooks that have recently failed to be delivered to the
  /// requesting app after the maximum number of retries.
  ///
  /// After 72 hours the failure may no longer be returned by this operation.
  ///
  /// The oldest failure is returned first.
  ///
  /// This method uses a cursor-based pagination. To request the next page use
  /// the failure time of the last webhook on the list as the `failedAfter`
  /// value or use the URL provided in `next`.
  ///
  /// **[Permissions](#permissions) required:** Only
  /// [Connect apps](https://developer.atlassian.com/cloud/jira/platform/integrating-with-jira-cloud/#atlassian-connect)
  /// can use this operation.
  Future<FailedWebhooks> getFailedWebhooks(
      {int? maxResults, int? after}) async {
    return FailedWebhooks.fromJson(await _client.send(
      'get',
      'rest/api/3/webhook/failed',
      queryParameters: {
        if (maxResults != null) 'maxResults': '$maxResults',
        if (after != null) 'after': '$after',
      },
    ));
  }

  /// Webhooks registered through the REST API expire after 30 days. Call this
  /// resource periodically to keep them alive.
  ///
  /// Unrecognized webhook IDs (nonexistent or belonging to other apps) are
  /// ignored.
  ///
  /// **[Permissions](#permissions) required:** Only
  /// [Connect apps](https://developer.atlassian.com/cloud/jira/platform/integrating-with-jira-cloud/#atlassian-connect)
  /// can use this operation.
  Future<WebhooksExpirationDate> refreshWebhooks(
      {required ContainerForWebhookIDs body}) async {
    return WebhooksExpirationDate.fromJson(await _client.send(
      'put',
      'rest/api/3/webhook/refresh',
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowsApi {
  final ApiClient _client;

  WorkflowsApi(this._client);

  /// Returns all workflows in Jira or a workflow. Deprecated, use
  /// [Get workflows paginated](#api-rest-api-3-workflow-search-get).
  ///
  /// If the `workflowName` parameter is specified, the workflow is returned as
  /// an object (not in an array). Otherwise, an array of workflow objects is
  /// returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<DeprecatedWorkflow>> getAllWorkflows(
      {String? workflowName}) async {
    return (await _client.send(
      'get',
      'rest/api/3/workflow',
      queryParameters: {
        if (workflowName != null) 'workflowName': workflowName,
      },
    ) as List<Object?>)
        .map((i) =>
            DeprecatedWorkflow.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a [paginated](#pagination) list of published classic workflows.
  /// When workflow names are specified, details of those workflows are
  /// returned. Otherwise, all published classic workflows are returned.
  ///
  /// This operation does not return next-gen workflows.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanWorkflow> getWorkflowsPaginated(
      {int? startAt,
      int? maxResults,
      List<String>? workflowName,
      String? expand}) async {
    return PageBeanWorkflow.fromJson(await _client.send(
      'get',
      'rest/api/3/workflow/search',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (workflowName != null) 'workflowName': '$workflowName',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Deletes a workflow.
  ///
  /// The workflow cannot be deleted if it is:
  ///
  ///  *  an active workflow.
  ///  *  a system workflow.
  ///  *  associated with any workflow scheme.
  ///  *  associated with any draft workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteInactiveWorkflow(String entityId) async {
    await _client.send(
      'delete',
      'rest/api/3/workflow/{entityId}',
      pathParameters: {
        'entityId': entityId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowTransitionRulesApi {
  final ApiClient _client;

  WorkflowTransitionRulesApi(this._client);

  /// Returns a [paginated](#pagination) list of workflows with transition
  /// rules. The workflows can be filtered to return only those containing
  /// workflow transition rules:
  ///
  ///  *  of one or more transition rule types, such as
  /// [workflow post functions](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-post-function/).
  ///  *  matching one or more transition rule keys.
  ///
  /// Only workflows containing transition rules created by the calling Connect
  /// app are returned. However, if a workflow is returned all transition rules
  /// that match the filters are returned for that workflow.
  ///
  /// Due to server-side optimizations, workflows with an empty list of rules
  /// may be returned; these workflows can be ignored.
  ///
  /// **[Permissions](#permissions) required:** Only Connect apps can use this
  /// operation.
  Future<PageBeanWorkflowTransitionRules>
      getWorkflowTransitionRuleConfigurations(
          {int? startAt,
          int? maxResults,
          required List<String> types,
          List<String>? keys,
          String? expand}) async {
    return PageBeanWorkflowTransitionRules.fromJson(await _client.send(
      'get',
      'rest/api/3/workflow/rule/config',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        'types': '$types',
        if (keys != null) 'keys': '$keys',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates configuration of workflow transition rules. The following rule
  /// types are supported:
  ///
  ///  *
  /// [post functions](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-post-function/)
  ///  *
  /// [conditions](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-condition/)
  ///  *
  /// [validators](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-validator/)
  ///
  /// Only rules created by the calling Connect app can be updated.
  ///
  /// **[Permissions](#permissions) required:** Only Connect apps can use this
  /// operation.
  Future<WorkflowTransitionRulesUpdateErrors>
      updateWorkflowTransitionRuleConfigurations(
          {required WorkflowTransitionRulesUpdate body}) async {
    return WorkflowTransitionRulesUpdateErrors.fromJson(await _client.send(
      'put',
      'rest/api/3/workflow/rule/config',
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowSchemesApi {
  final ApiClient _client;

  WorkflowSchemesApi(this._client);

  /// Returns a [paginated](#pagination) list of all workflow schemes, not
  /// including draft workflow schemes.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanWorkflowScheme> getAllWorkflowSchemes(
      {int? startAt, int? maxResults}) async {
    return PageBeanWorkflowScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Creates a workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> createWorkflowScheme(
      {required WorkflowScheme body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'post',
      'rest/api/3/workflowscheme',
      body: body.toJson(),
    ));
  }

  /// Returns a workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> getWorkflowScheme(
      {required int id, bool? returnDraftIfExists}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (returnDraftIfExists != null)
          'returnDraftIfExists': '$returnDraftIfExists',
      },
    ));
  }

  /// Updates a workflow scheme, including the name, default workflow, issue
  /// type to project mappings, and more. If the workflow scheme is active (that
  /// is, being used by at least one project), then a draft workflow scheme is
  /// created or updated instead, provided that `updateDraftIfNeeded` is set to
  /// `true`.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> updateWorkflowScheme(
      {required int id, required WorkflowScheme body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a workflow scheme. Note that a workflow scheme cannot be deleted
  /// if it is active (that is, being used by at least one project).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteWorkflowScheme(int id) async {
    await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}',
      pathParameters: {
        'id': '$id',
      },
    );
  }

  /// Returns the default workflow for a workflow scheme. The default workflow
  /// is the workflow that is assigned any issue types that have not been mapped
  /// to any other workflow. The default workflow has *All Unassigned Issue
  /// Types* listed in its issue types for the workflow scheme in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<DefaultWorkflow> getDefaultWorkflow(
      {required int id, bool? returnDraftIfExists}) async {
    return DefaultWorkflow.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/default',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (returnDraftIfExists != null)
          'returnDraftIfExists': '$returnDraftIfExists',
      },
    ));
  }

  /// Sets the default workflow for a workflow scheme.
  ///
  /// Note that active workflow schemes cannot be edited. If the workflow scheme
  /// is active, set `updateDraftIfNeeded` to `true` in the request object and a
  /// draft workflow scheme is created or updated with the new default workflow.
  /// The draft workflow scheme can be published in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> updateDefaultWorkflow(
      {required int id, required DefaultWorkflow body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/default',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Resets the default workflow for a workflow scheme. That is, the default
  /// workflow is set to Jira's system workflow (the *jira* workflow).
  ///
  /// Note that active workflow schemes cannot be edited. If the workflow scheme
  /// is active, set `updateDraftIfNeeded` to `true` and a draft workflow scheme
  /// is created or updated with the default workflow reset. The draft workflow
  /// scheme can be published in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> deleteDefaultWorkflow(
      {required int id, bool? updateDraftIfNeeded}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/default',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (updateDraftIfNeeded != null)
          'updateDraftIfNeeded': '$updateDraftIfNeeded',
      },
    ));
  }

  /// Returns the issue type-workflow mapping for an issue type in a workflow
  /// scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeWorkflowMapping> getWorkflowSchemeIssueType(
      {required int id,
      required String issueType,
      bool? returnDraftIfExists}) async {
    return IssueTypeWorkflowMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/issuetype/{issueType}',
      pathParameters: {
        'id': '$id',
        'issueType': issueType,
      },
      queryParameters: {
        if (returnDraftIfExists != null)
          'returnDraftIfExists': '$returnDraftIfExists',
      },
    ));
  }

  /// Sets the workflow for an issue type in a workflow scheme.
  ///
  /// Note that active workflow schemes cannot be edited. If the workflow scheme
  /// is active, set `updateDraftIfNeeded` to `true` in the request body and a
  /// draft workflow scheme is created or updated with the new issue
  /// type-workflow mapping. The draft workflow scheme can be published in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> setWorkflowSchemeIssueType(
      {required int id,
      required String issueType,
      required IssueTypeWorkflowMapping body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/issuetype/{issueType}',
      pathParameters: {
        'id': '$id',
        'issueType': issueType,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the issue type-workflow mapping for an issue type in a workflow
  /// scheme.
  ///
  /// Note that active workflow schemes cannot be edited. If the workflow scheme
  /// is active, set `updateDraftIfNeeded` to `true` and a draft workflow scheme
  /// is created or updated with the issue type-workflow mapping deleted. The
  /// draft workflow scheme can be published in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> deleteWorkflowSchemeIssueType(
      {required int id,
      required String issueType,
      bool? updateDraftIfNeeded}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/issuetype/{issueType}',
      pathParameters: {
        'id': '$id',
        'issueType': issueType,
      },
      queryParameters: {
        if (updateDraftIfNeeded != null)
          'updateDraftIfNeeded': '$updateDraftIfNeeded',
      },
    ));
  }

  /// Returns the workflow-issue type mappings for a workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypesWorkflowMapping> getWorkflow(
      {required int id,
      String? workflowName,
      bool? returnDraftIfExists}) async {
    return IssueTypesWorkflowMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/workflow',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (workflowName != null) 'workflowName': workflowName,
        if (returnDraftIfExists != null)
          'returnDraftIfExists': '$returnDraftIfExists',
      },
    ));
  }

  /// Sets the issue types for a workflow in a workflow scheme. The workflow can
  /// also be set as the default workflow for the workflow scheme. Unmapped
  /// issues types are mapped to the default workflow.
  ///
  /// Note that active workflow schemes cannot be edited. If the workflow scheme
  /// is active, set `updateDraftIfNeeded` to `true` in the request body and a
  /// draft workflow scheme is created or updated with the new workflow-issue
  /// types mappings. The draft workflow scheme can be published in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> updateWorkflowMapping(
      {required int id,
      required String workflowName,
      required IssueTypesWorkflowMapping body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/workflow',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        'workflowName': workflowName,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the workflow-issue type mapping for a workflow in a workflow
  /// scheme.
  ///
  /// Note that active workflow schemes cannot be edited. If the workflow scheme
  /// is active, set `updateDraftIfNeeded` to `true` and a draft workflow scheme
  /// is created or updated with the workflow-issue type mapping deleted. The
  /// draft workflow scheme can be published in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteWorkflowMapping(
      {required int id,
      required String workflowName,
      bool? updateDraftIfNeeded}) async {
    await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/workflow',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        'workflowName': workflowName,
        if (updateDraftIfNeeded != null)
          'updateDraftIfNeeded': '$updateDraftIfNeeded',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowSchemeProjectAssociationsApi {
  final ApiClient _client;

  WorkflowSchemeProjectAssociationsApi(this._client);

  /// Returns a list of the workflow schemes associated with a list of projects.
  /// Each returned workflow scheme includes a list of the requested projects
  /// associated with it. Any next-gen or non-existent projects in the request
  /// are ignored and no errors are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ContainerOfWorkflowSchemeAssociations>
      getWorkflowSchemeProjectAssociations(List<int> projectId) async {
    return ContainerOfWorkflowSchemeAssociations.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/project',
      queryParameters: {
        'projectId': '$projectId',
      },
    ));
  }

  /// Assigns a workflow scheme to a project. This operation is performed only
  /// when there are no issues in the project.
  ///
  /// Workflow schemes can only be assigned to classic projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> associateSchemeWithProject(
      {required WorkflowSchemeProjectAssociation body}) async {
    await _client.send(
      'put',
      'rest/api/3/workflowscheme/project',
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowSchemeDraftsApi {
  final ApiClient _client;

  WorkflowSchemeDraftsApi(this._client);

  /// Create a draft workflow scheme from an active workflow scheme, by copying
  /// the active workflow scheme. Note that an active workflow scheme can only
  /// have one draft workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> createWorkflowSchemeDraftFromParent(int id) async {
    return WorkflowScheme.fromJson(await _client.send(
      'post',
      'rest/api/3/workflowscheme/{id}/createdraft',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Returns the draft workflow scheme for an active workflow scheme. Draft
  /// workflow schemes allow changes to be made to the active workflow schemes:
  /// When an active workflow scheme is updated, a draft copy is created. The
  /// draft is modified, then the changes in the draft are copied back to the
  /// active workflow scheme. See
  /// [Configuring workflow schemes](https://confluence.atlassian.com/x/tohKLg)
  /// for more information.
  /// Note that:
  ///
  ///  *  Only active workflow schemes can have draft workflow schemes.
  ///  *  An active workflow scheme can only have one draft workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> getWorkflowSchemeDraft(int id) async {
    return WorkflowScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/draft',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Updates a draft workflow scheme. If a draft workflow scheme does not exist
  /// for the active workflow scheme, then a draft is created. Note that an
  /// active workflow scheme can only have one draft workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> updateWorkflowSchemeDraft(
      {required int id, required WorkflowScheme body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/draft',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a draft workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteWorkflowSchemeDraft(int id) async {
    await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/draft',
      pathParameters: {
        'id': '$id',
      },
    );
  }

  /// Returns the default workflow for a workflow scheme's draft. The default
  /// workflow is the workflow that is assigned any issue types that have not
  /// been mapped to any other workflow. The default workflow has *All
  /// Unassigned Issue Types* listed in its issue types for the workflow scheme
  /// in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<DefaultWorkflow> getDraftDefaultWorkflow(int id) async {
    return DefaultWorkflow.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/draft/default',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Sets the default workflow for a workflow scheme's draft.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> updateDraftDefaultWorkflow(
      {required int id, required DefaultWorkflow body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/draft/default',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Resets the default workflow for a workflow scheme's draft. That is, the
  /// default workflow is set to Jira's system workflow (the *jira* workflow).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> deleteDraftDefaultWorkflow(int id) async {
    return WorkflowScheme.fromJson(await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/draft/default',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Returns the issue type-workflow mapping for an issue type in a workflow
  /// scheme's draft.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeWorkflowMapping> getWorkflowSchemeDraftIssueType(
      {required int id, required String issueType}) async {
    return IssueTypeWorkflowMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}',
      pathParameters: {
        'id': '$id',
        'issueType': issueType,
      },
    ));
  }

  /// Sets the workflow for an issue type in a workflow scheme's draft.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> setWorkflowSchemeDraftIssueType(
      {required int id,
      required String issueType,
      required IssueTypeWorkflowMapping body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}',
      pathParameters: {
        'id': '$id',
        'issueType': issueType,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the issue type-workflow mapping for an issue type in a workflow
  /// scheme's draft.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> deleteWorkflowSchemeDraftIssueType(
      {required int id, required String issueType}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}',
      pathParameters: {
        'id': '$id',
        'issueType': issueType,
      },
    ));
  }

  /// Returns the workflow-issue type mappings for a workflow scheme's draft.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypesWorkflowMapping> getDraftWorkflow(
      {required int id, String? workflowName}) async {
    return IssueTypesWorkflowMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/draft/workflow',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (workflowName != null) 'workflowName': workflowName,
      },
    ));
  }

  /// Sets the issue types for a workflow in a workflow scheme's draft. The
  /// workflow can also be set as the default workflow for the draft workflow
  /// scheme. Unmapped issues types are mapped to the default workflow.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> updateDraftWorkflowMapping(
      {required int id,
      required String workflowName,
      required IssueTypesWorkflowMapping body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/draft/workflow',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        'workflowName': workflowName,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the workflow-issue type mapping for a workflow in a workflow
  /// scheme's draft.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteDraftWorkflowMapping(
      {required int id, required String workflowName}) async {
    await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/draft/workflow',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        'workflowName': workflowName,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowStatusesApi {
  final ApiClient _client;

  WorkflowStatusesApi(this._client);

  /// Returns a list of all statuses associated with workflows.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<List<StatusDetails>> getStatuses() async {
    return (await _client.send(
      'get',
      'rest/api/3/status',
    ) as List<Object?>)
        .map((i) =>
            StatusDetails.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a status. The status must be associated with a workflow to be
  /// returned.
  ///
  /// If a name is used on more than one status, only the status found first is
  /// returned. Therefore, identifying the status by its ID may be preferable.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// [Permissions](#permissions) required: None.
  Future<StatusDetails> getStatus(String idOrName) async {
    return StatusDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/status/{idOrName}',
      pathParameters: {
        'idOrName': idOrName,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowStatusCategoriesApi {
  final ApiClient _client;

  WorkflowStatusCategoriesApi(this._client);

  /// Returns a list of all status categories.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<List<StatusCategory>> getStatusCategories() async {
    return (await _client.send(
      'get',
      'rest/api/3/statuscategory',
    ) as List<Object?>)
        .map((i) =>
            StatusCategory.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a status category. Status categories provided a mechanism for
  /// categorizing [statuses](#api-rest-api-3-status-idOrName-get).
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<StatusCategory> getStatusCategory(String idOrKey) async {
    return StatusCategory.fromJson(await _client.send(
      'get',
      'rest/api/3/statuscategory/{idOrKey}',
      pathParameters: {
        'idOrKey': idOrKey,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowTransitionPropertiesApi {
  final ApiClient _client;

  WorkflowTransitionPropertiesApi(this._client);

  /// Returns the properties on a workflow transition. Transition properties are
  /// used to change the behavior of a transition. For more information, see
  /// [Transition properties](https://confluence.atlassian.com/x/zIhKLg#Advancedworkflowconfiguration-transitionproperties)
  /// and [Workflow properties](https://confluence.atlassian.com/x/JYlKLg).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowTransitionProperty> getWorkflowTransitionProperties(
      {required int transitionId,
      bool? includeReservedKeys,
      String? key,
      required String workflowName,
      String? workflowMode}) async {
    return WorkflowTransitionProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/workflow/transitions/{transitionId}/properties',
      pathParameters: {
        'transitionId': '$transitionId',
      },
      queryParameters: {
        if (includeReservedKeys != null)
          'includeReservedKeys': '$includeReservedKeys',
        if (key != null) 'key': key,
        'workflowName': workflowName,
        if (workflowMode != null) 'workflowMode': workflowMode,
      },
    ));
  }

  /// Updates a workflow transition by changing the property value. Trying to
  /// update a property that does not exist results in a new property being
  /// added to the transition. Transition properties are used to change the
  /// behavior of a transition. For more information, see
  /// [Transition properties](https://confluence.atlassian.com/x/zIhKLg#Advancedworkflowconfiguration-transitionproperties)
  /// and [Workflow properties](https://confluence.atlassian.com/x/JYlKLg).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowTransitionProperty> updateWorkflowTransitionProperty(
      {required int transitionId,
      required String key,
      required String workflowName,
      String? workflowMode,
      required WorkflowTransitionProperty body}) async {
    return WorkflowTransitionProperty.fromJson(await _client.send(
      'put',
      'rest/api/3/workflow/transitions/{transitionId}/properties',
      pathParameters: {
        'transitionId': '$transitionId',
      },
      queryParameters: {
        'key': key,
        'workflowName': workflowName,
        if (workflowMode != null) 'workflowMode': workflowMode,
      },
      body: body.toJson(),
    ));
  }

  /// Adds a property to a workflow transition. Transition properties are used
  /// to change the behavior of a transition. For more information, see
  /// [Transition properties](https://confluence.atlassian.com/x/zIhKLg#Advancedworkflowconfiguration-transitionproperties)
  /// and [Workflow properties](https://confluence.atlassian.com/x/JYlKLg).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowTransitionProperty> createWorkflowTransitionProperty(
      {required int transitionId,
      required String key,
      required String workflowName,
      String? workflowMode,
      required WorkflowTransitionProperty body}) async {
    return WorkflowTransitionProperty.fromJson(await _client.send(
      'post',
      'rest/api/3/workflow/transitions/{transitionId}/properties',
      pathParameters: {
        'transitionId': '$transitionId',
      },
      queryParameters: {
        'key': key,
        'workflowName': workflowName,
        if (workflowMode != null) 'workflowMode': workflowMode,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a property from a workflow transition. Transition properties are
  /// used to change the behavior of a transition. For more information, see
  /// [Transition properties](https://confluence.atlassian.com/x/zIhKLg#Advancedworkflowconfiguration-transitionproperties)
  /// and [Workflow properties](https://confluence.atlassian.com/x/JYlKLg).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteWorkflowTransitionProperty(
      {required int transitionId,
      required String key,
      required String workflowName,
      String? workflowMode}) async {
    await _client.send(
      'delete',
      'rest/api/3/workflow/transitions/{transitionId}/properties',
      pathParameters: {
        'transitionId': '$transitionId',
      },
      queryParameters: {
        'key': key,
        'workflowName': workflowName,
        if (workflowMode != null) 'workflowMode': workflowMode,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class AppPropertiesApi {
  final ApiClient _client;

  AppPropertiesApi(this._client);

  /// Gets all the properties of an app.
  ///
  /// **[Permissions](#permissions) required:** Only a Connect app whose key
  /// matches `addonKey` can make this request.
  Future<PropertyKeys> getAddonProperties(String addonKey) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/atlassian-connect/1/addons/{addonKey}/properties',
      pathParameters: {
        'addonKey': addonKey,
      },
    ));
  }

  /// Returns the key and value of an app's property.
  ///
  /// **[Permissions](#permissions) required:** Only a Connect app whose key
  /// matches `addonKey` can make this request.
  Future<EntityProperty> getAddonProperty(
      {required String addonKey, required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}',
      pathParameters: {
        'addonKey': addonKey,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Sets the value of an app's property. Use this resource to store custom
  /// data for your app.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// **[Permissions](#permissions) required:** Only a Connect app whose key
  /// matches `addonKey` can make this request.
  Future<OperationMessage> putAddonProperty(
      {required String addonKey,
      required String propertyKey,
      required dynamic body}) async {
    return OperationMessage.fromJson(await _client.send(
      'put',
      'rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}',
      pathParameters: {
        'addonKey': addonKey,
        'propertyKey': propertyKey,
      },
      body: body,
    ));
  }

  /// Deletes an app's property.
  ///
  /// **[Permissions](#permissions) required:** Only a Connect app whose key
  /// matches `addonKey` can make this request.
  Future<void> deleteAddonProperty(
      {required String addonKey, required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}',
      pathParameters: {
        'addonKey': addonKey,
        'propertyKey': propertyKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class DynamicModulesApi {
  final ApiClient _client;

  DynamicModulesApi(this._client);

  /// Returns all modules registered dynamically by the calling app.
  ///
  /// **[Permissions](#permissions) required:** Only Connect apps can make this
  /// request.
  Future<ConnectModules> getModules() async {
    return ConnectModules.fromJson(await _client.send(
      'get',
      'rest/atlassian-connect/1/app/module/dynamic',
    ));
  }

  /// Registers a list of modules.
  ///
  /// **[Permissions](#permissions) required:** Only Connect apps can make this
  /// request.
  Future<void> registerModules({required ConnectModules body}) async {
    await _client.send(
      'post',
      'rest/atlassian-connect/1/app/module/dynamic',
      body: body.toJson(),
    );
  }

  /// Remove all or a list of modules registered by the calling app.
  ///
  /// **[Permissions](#permissions) required:** Only Connect apps can make this
  /// request.
  Future<void> removeModules({List<String>? moduleKey}) async {
    await _client.send(
      'delete',
      'rest/atlassian-connect/1/app/module/dynamic',
      queryParameters: {
        if (moduleKey != null) 'moduleKey': '$moduleKey',
      },
    );
  }
}

/// Details about a task.
class TaskProgressBeanObject {
  /// The URL of the task.
  final String self;

  /// The ID of the task.
  final String id;

  /// The description of the task.
  final String? description;

  /// The status of the task.
  final TaskProgressBeanObjectStatus status;

  /// Information about the progress of the task.
  final String? message;

  /// The result of the task execution.
  final dynamic result;

  /// The ID of the user who submitted the task.
  final int submittedBy;

  /// The progress of the task, as a percentage complete.
  final int progress;

  /// The execution time of the task, in milliseconds.
  final int elapsedRuntime;

  /// A timestamp recording when the task was submitted.
  final int submitted;

  /// A timestamp recording when the task was started.
  final int? started;

  /// A timestamp recording when the task was finished.
  final int? finished;

  /// A timestamp recording when the task progress was last updated.
  final int lastUpdate;

  TaskProgressBeanObject(
      {required this.self,
      required this.id,
      this.description,
      required this.status,
      this.message,
      this.result,
      required this.submittedBy,
      required this.progress,
      required this.elapsedRuntime,
      required this.submitted,
      this.started,
      this.finished,
      required this.lastUpdate});

  factory TaskProgressBeanObject.fromJson(Map<String, Object?> json) {
    return TaskProgressBeanObject(
      self: json[r'self'] as String? ?? '',
      id: json[r'id'] as String? ?? '',
      description: json[r'description'] as String?,
      status: TaskProgressBeanObjectStatus.fromValue(
          json[r'status'] as String? ?? ''),
      message: json[r'message'] as String?,
      result: json[r'result'],
      submittedBy: (json[r'submittedBy'] as num?)?.toInt() ?? 0,
      progress: (json[r'progress'] as num?)?.toInt() ?? 0,
      elapsedRuntime: (json[r'elapsedRuntime'] as num?)?.toInt() ?? 0,
      submitted: (json[r'submitted'] as num?)?.toInt() ?? 0,
      started: (json[r'started'] as num?)?.toInt(),
      finished: (json[r'finished'] as num?)?.toInt(),
      lastUpdate: (json[r'lastUpdate'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var description = this.description;
    var status = this.status;
    var message = this.message;
    var result = this.result;
    var submittedBy = this.submittedBy;
    var progress = this.progress;
    var elapsedRuntime = this.elapsedRuntime;
    var submitted = this.submitted;
    var started = this.started;
    var finished = this.finished;
    var lastUpdate = this.lastUpdate;

    final json = <String, Object?>{};
    json[r'self'] = self;
    json[r'id'] = id;
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'status'] = status.value;
    if (message != null) {
      json[r'message'] = message;
    }
    if (result != null) {
      json[r'result'] = result;
    }
    json[r'submittedBy'] = submittedBy;
    json[r'progress'] = progress;
    json[r'elapsedRuntime'] = elapsedRuntime;
    json[r'submitted'] = submitted;
    if (started != null) {
      json[r'started'] = started;
    }
    if (finished != null) {
      json[r'finished'] = finished;
    }
    json[r'lastUpdate'] = lastUpdate;
    return json;
  }

  TaskProgressBeanObject copyWith(
      {String? self,
      String? id,
      String? description,
      TaskProgressBeanObjectStatus? status,
      String? message,
      dynamic result,
      int? submittedBy,
      int? progress,
      int? elapsedRuntime,
      int? submitted,
      int? started,
      int? finished,
      int? lastUpdate}) {
    return TaskProgressBeanObject(
      self: self ?? this.self,
      id: id ?? this.id,
      description: description ?? this.description,
      status: status ?? this.status,
      message: message ?? this.message,
      result: result ?? this.result,
      submittedBy: submittedBy ?? this.submittedBy,
      progress: progress ?? this.progress,
      elapsedRuntime: elapsedRuntime ?? this.elapsedRuntime,
      submitted: submitted ?? this.submitted,
      started: started ?? this.started,
      finished: finished ?? this.finished,
      lastUpdate: lastUpdate ?? this.lastUpdate,
    );
  }
}

class TaskProgressBeanObjectStatus {
  static const enqueued = TaskProgressBeanObjectStatus._('ENQUEUED');
  static const running = TaskProgressBeanObjectStatus._('RUNNING');
  static const complete = TaskProgressBeanObjectStatus._('COMPLETE');
  static const failed = TaskProgressBeanObjectStatus._('FAILED');
  static const cancelRequested =
      TaskProgressBeanObjectStatus._('CANCEL_REQUESTED');
  static const cancelled = TaskProgressBeanObjectStatus._('CANCELLED');
  static const dead = TaskProgressBeanObjectStatus._('DEAD');

  static const values = [
    enqueued,
    running,
    complete,
    failed,
    cancelRequested,
    cancelled,
    dead,
  ];
  final String value;

  const TaskProgressBeanObjectStatus._(this.value);

  static TaskProgressBeanObjectStatus fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => TaskProgressBeanObjectStatus._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// List of issues and JQL queries.
class IssuesAndJQLQueries {
  /// A list of JQL queries.
  final List<String> jqls;

  /// A list of issue IDs.
  final List<int> issueIds;

  IssuesAndJQLQueries({required this.jqls, required this.issueIds});

  factory IssuesAndJQLQueries.fromJson(Map<String, Object?> json) {
    return IssuesAndJQLQueries(
      jqls: (json[r'jqls'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      issueIds: (json[r'issueIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var jqls = this.jqls;
    var issueIds = this.issueIds;

    final json = <String, Object?>{};
    json[r'jqls'] = jqls;
    json[r'issueIds'] = issueIds;
    return json;
  }

  IssuesAndJQLQueries copyWith({List<String>? jqls, List<int>? issueIds}) {
    return IssuesAndJQLQueries(
      jqls: jqls ?? this.jqls,
      issueIds: issueIds ?? this.issueIds,
    );
  }
}

/// A list of matched issues or errors for each JQL query, in the order the JQL
/// queries were passed.
class IssueMatches {
  final List<IssueMatchesForJQL> matches;

  IssueMatches({required this.matches});

  factory IssueMatches.fromJson(Map<String, Object?> json) {
    return IssueMatches(
      matches: (json[r'matches'] as List<Object?>?)
              ?.map((i) => IssueMatchesForJQL.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var matches = this.matches;

    final json = <String, Object?>{};
    json[r'matches'] = matches.map((i) => i.toJson()).toList();
    return json;
  }

  IssueMatches copyWith({List<IssueMatchesForJQL>? matches}) {
    return IssueMatches(
      matches: matches ?? this.matches,
    );
  }
}

/// A list of the issues matched to a JQL query or details of errors encountered
/// during matching.
class IssueMatchesForJQL {
  /// A list of issue IDs.
  final List<int> matchedIssues;

  /// A list of errors.
  final List<String> errors;

  IssueMatchesForJQL({required this.matchedIssues, required this.errors});

  factory IssueMatchesForJQL.fromJson(Map<String, Object?> json) {
    return IssueMatchesForJQL(
      matchedIssues: (json[r'matchedIssues'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      errors: (json[r'errors'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var matchedIssues = this.matchedIssues;
    var errors = this.errors;

    final json = <String, Object?>{};
    json[r'matchedIssues'] = matchedIssues;
    json[r'errors'] = errors;
    return json;
  }

  IssueMatchesForJQL copyWith(
      {List<int>? matchedIssues, List<String>? errors}) {
    return IssueMatchesForJQL(
      matchedIssues: matchedIssues ?? this.matchedIssues,
      errors: errors ?? this.errors,
    );
  }
}

/// Details of a locale.
class Locale {
  /// The locale code. The Java the locale format is used: a two character
  /// language code (ISO 639), an underscore, and two letter country code (ISO
  /// 3166). For example, en_US represents a locale of English (United States).
  /// Required on create.
  final String? locale;

  Locale({this.locale});

  factory Locale.fromJson(Map<String, Object?> json) {
    return Locale(
      locale: json[r'locale'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var locale = this.locale;

    final json = <String, Object?>{};
    if (locale != null) {
      json[r'locale'] = locale;
    }
    return json;
  }

  Locale copyWith({String? locale}) {
    return Locale(
      locale: locale ?? this.locale,
    );
  }
}

/// Jira instance health check results. Deprecated and no longer returned.
class HealthCheckResult {
  /// The name of the Jira health check item.
  final String? name;

  /// The description of the Jira health check item.
  final String? description;

  /// Whether the Jira health check item passed or failed.
  final bool passed;

  HealthCheckResult({this.name, this.description, bool? passed})
      : passed = passed ?? false;

  factory HealthCheckResult.fromJson(Map<String, Object?> json) {
    return HealthCheckResult(
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      passed: json[r'passed'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;
    var passed = this.passed;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'passed'] = passed;
    return json;
  }

  HealthCheckResult copyWith(
      {String? name, String? description, bool? passed}) {
    return HealthCheckResult(
      name: name ?? this.name,
      description: description ?? this.description,
      passed: passed ?? this.passed,
    );
  }
}

/// Details about the Jira instance.
class ServerInformation {
  /// The base URL of the Jira instance.
  final String? baseUrl;

  /// The version of Jira.
  final String? version;

  /// The major, minor, and revision version numbers of the Jira version.
  final List<int> versionNumbers;

  /// The type of server deployment. This is always returned as *Cloud*.
  final String? deploymentType;

  /// The build number of the Jira version.
  final int? buildNumber;

  /// The timestamp when the Jira version was built.
  final DateTime? buildDate;

  /// The time in Jira when this request was responded to.
  final DateTime? serverTime;

  /// The unique identifier of the Jira version.
  final String? scmInfo;

  /// The name of the Jira instance.
  final String? serverTitle;

  /// Jira instance health check results. Deprecated and no longer returned.
  final List<HealthCheckResult> healthChecks;

  ServerInformation(
      {this.baseUrl,
      this.version,
      List<int>? versionNumbers,
      this.deploymentType,
      this.buildNumber,
      this.buildDate,
      this.serverTime,
      this.scmInfo,
      this.serverTitle,
      List<HealthCheckResult>? healthChecks})
      : versionNumbers = versionNumbers ?? [],
        healthChecks = healthChecks ?? [];

  factory ServerInformation.fromJson(Map<String, Object?> json) {
    return ServerInformation(
      baseUrl: json[r'baseUrl'] as String?,
      version: json[r'version'] as String?,
      versionNumbers: (json[r'versionNumbers'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      deploymentType: json[r'deploymentType'] as String?,
      buildNumber: (json[r'buildNumber'] as num?)?.toInt(),
      buildDate: DateTime.tryParse(json[r'buildDate'] as String? ?? ''),
      serverTime: DateTime.tryParse(json[r'serverTime'] as String? ?? ''),
      scmInfo: json[r'scmInfo'] as String?,
      serverTitle: json[r'serverTitle'] as String?,
      healthChecks: (json[r'healthChecks'] as List<Object?>?)
              ?.map((i) => HealthCheckResult.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var baseUrl = this.baseUrl;
    var version = this.version;
    var versionNumbers = this.versionNumbers;
    var deploymentType = this.deploymentType;
    var buildNumber = this.buildNumber;
    var buildDate = this.buildDate;
    var serverTime = this.serverTime;
    var scmInfo = this.scmInfo;
    var serverTitle = this.serverTitle;
    var healthChecks = this.healthChecks;

    final json = <String, Object?>{};
    if (baseUrl != null) {
      json[r'baseUrl'] = baseUrl;
    }
    if (version != null) {
      json[r'version'] = version;
    }
    json[r'versionNumbers'] = versionNumbers;
    if (deploymentType != null) {
      json[r'deploymentType'] = deploymentType;
    }
    if (buildNumber != null) {
      json[r'buildNumber'] = buildNumber;
    }
    if (buildDate != null) {
      json[r'buildDate'] = buildDate.toIso8601String();
    }
    if (serverTime != null) {
      json[r'serverTime'] = serverTime.toIso8601String();
    }
    if (scmInfo != null) {
      json[r'scmInfo'] = scmInfo;
    }
    if (serverTitle != null) {
      json[r'serverTitle'] = serverTitle;
    }
    json[r'healthChecks'] = healthChecks.map((i) => i.toJson()).toList();
    return json;
  }

  ServerInformation copyWith(
      {String? baseUrl,
      String? version,
      List<int>? versionNumbers,
      String? deploymentType,
      int? buildNumber,
      DateTime? buildDate,
      DateTime? serverTime,
      String? scmInfo,
      String? serverTitle,
      List<HealthCheckResult>? healthChecks}) {
    return ServerInformation(
      baseUrl: baseUrl ?? this.baseUrl,
      version: version ?? this.version,
      versionNumbers: versionNumbers ?? this.versionNumbers,
      deploymentType: deploymentType ?? this.deploymentType,
      buildNumber: buildNumber ?? this.buildNumber,
      buildDate: buildDate ?? this.buildDate,
      serverTime: serverTime ?? this.serverTime,
      scmInfo: scmInfo ?? this.scmInfo,
      serverTitle: serverTitle ?? this.serverTitle,
      healthChecks: healthChecks ?? this.healthChecks,
    );
  }
}

/// List of issue level security items in a project.
class ProjectIssueSecurityLevels {
  /// Issue level security items list.
  final List<SecurityLevel> levels;

  ProjectIssueSecurityLevels({required this.levels});

  factory ProjectIssueSecurityLevels.fromJson(Map<String, Object?> json) {
    return ProjectIssueSecurityLevels(
      levels: (json[r'levels'] as List<Object?>?)
              ?.map((i) => SecurityLevel.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var levels = this.levels;

    final json = <String, Object?>{};
    json[r'levels'] = levels.map((i) => i.toJson()).toList();
    return json;
  }

  ProjectIssueSecurityLevels copyWith({List<SecurityLevel>? levels}) {
    return ProjectIssueSecurityLevels(
      levels: levels ?? this.levels,
    );
  }
}

/// Details of an issue level security item.
class SecurityLevel {
  /// The URL of the issue level security item.
  final String? self;

  /// The ID of the issue level security item.
  final String? id;

  /// The description of the issue level security item.
  final String? description;

  /// The name of the issue level security item.
  final String? name;

  SecurityLevel({this.self, this.id, this.description, this.name});

  factory SecurityLevel.fromJson(Map<String, Object?> json) {
    return SecurityLevel(
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  SecurityLevel copyWith(
      {String? self, String? id, String? description, String? name}) {
    return SecurityLevel(
      self: self ?? this.self,
      id: id ?? this.id,
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// Property key details.
class PropertyKey {
  /// The URL of the property.
  final String? self;

  /// The key of the property.
  final String? key;

  PropertyKey({this.self, this.key});

  factory PropertyKey.fromJson(Map<String, Object?> json) {
    return PropertyKey(
      self: json[r'self'] as String?,
      key: json[r'key'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var key = this.key;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    return json;
  }

  PropertyKey copyWith({String? self, String? key}) {
    return PropertyKey(
      self: self ?? this.self,
      key: key ?? this.key,
    );
  }
}

/// List of property keys.
class PropertyKeys {
  /// Property key details.
  final List<PropertyKey> keys;

  PropertyKeys({List<PropertyKey>? keys}) : keys = keys ?? [];

  factory PropertyKeys.fromJson(Map<String, Object?> json) {
    return PropertyKeys(
      keys: (json[r'keys'] as List<Object?>?)
              ?.map((i) =>
                  PropertyKey.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var keys = this.keys;

    final json = <String, Object?>{};
    json[r'keys'] = keys.map((i) => i.toJson()).toList();
    return json;
  }

  PropertyKeys copyWith({List<PropertyKey>? keys}) {
    return PropertyKeys(
      keys: keys ?? this.keys,
    );
  }
}

/// An entity property, for more information see
/// [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
class EntityProperty {
  /// The key of the property. Required on create and update.
  final String? key;

  /// The value of the property. Required on create and update.
  final dynamic value;

  EntityProperty({this.key, this.value});

  factory EntityProperty.fromJson(Map<String, Object?> json) {
    return EntityProperty(
      key: json[r'key'] as String?,
      value: json[r'value'],
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var value = this.value;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  EntityProperty copyWith({String? key, dynamic value}) {
    return EntityProperty(
      key: key ?? this.key,
      value: value ?? this.value,
    );
  }
}

class AvatarUrlsBean {
  /// The URL of the item's 16x16 pixel avatar.
  final String? $16X16;

  /// The URL of the item's 24x24 pixel avatar.
  final String? $24X24;

  /// The URL of the item's 32x32 pixel avatar.
  final String? $32X32;

  /// The URL of the item's 48x48 pixel avatar.
  final String? $48X48;

  AvatarUrlsBean({this.$16X16, this.$24X24, this.$32X32, this.$48X48});

  factory AvatarUrlsBean.fromJson(Map<String, Object?> json) {
    return AvatarUrlsBean(
      $16X16: json[r'16x16'] as String?,
      $24X24: json[r'24x24'] as String?,
      $32X32: json[r'32x32'] as String?,
      $48X48: json[r'48x48'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var $16X16 = this.$16X16;
    var $24X24 = this.$24X24;
    var $32X32 = this.$32X32;
    var $48X48 = this.$48X48;

    final json = <String, Object?>{};
    if ($16X16 != null) {
      json[r'16x16'] = $16X16;
    }
    if ($24X24 != null) {
      json[r'24x24'] = $24X24;
    }
    if ($32X32 != null) {
      json[r'32x32'] = $32X32;
    }
    if ($48X48 != null) {
      json[r'48x48'] = $48X48;
    }
    return json;
  }

  AvatarUrlsBean copyWith(
      {String? $16X16, String? $24X24, String? $32X32, String? $48X48}) {
    return AvatarUrlsBean(
      $16X16: $16X16 ?? this.$16X16,
      $24X24: $24X24 ?? this.$24X24,
      $32X32: $32X32 ?? this.$32X32,
      $48X48: $48X48 ?? this.$48X48,
    );
  }
}

/// Details about a notification associated with an event.
class EventNotification {
  /// Expand options that include additional event notification details in the
  /// response.
  final String? expand;

  /// The ID of the notification.
  final int? id;

  /// Identifies the recipients of the notification.
  final EventNotificationNotificationType? notificationType;

  /// The value of the `notificationType`:
  ///
  ///  *  `User` The `parameter` is the user account ID.
  ///  *  `Group` The `parameter` is the group name.
  ///  *  `ProjectRole` The `parameter` is the project role ID.
  ///  *  `UserCustomField` The `parameter` is the ID of the custom field.
  ///  *  `GroupCustomField` The `parameter` is the ID of the custom field.
  final String? parameter;

  /// The specified group.
  final GroupName? group;

  /// The custom user or group field.
  final FieldDetails? field;

  /// The email address.
  final String? emailAddress;

  /// The specified project role.
  final ProjectRole? projectRole;

  /// The specified user.
  final UserDetails? user;

  EventNotification(
      {this.expand,
      this.id,
      this.notificationType,
      this.parameter,
      this.group,
      this.field,
      this.emailAddress,
      this.projectRole,
      this.user});

  factory EventNotification.fromJson(Map<String, Object?> json) {
    return EventNotification(
      expand: json[r'expand'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      notificationType: json[r'notificationType'] != null
          ? EventNotificationNotificationType.fromValue(
              json[r'notificationType']! as String)
          : null,
      parameter: json[r'parameter'] as String?,
      group: json[r'group'] != null
          ? GroupName.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
      field: json[r'field'] != null
          ? FieldDetails.fromJson(json[r'field']! as Map<String, Object?>)
          : null,
      emailAddress: json[r'emailAddress'] as String?,
      projectRole: json[r'projectRole'] != null
          ? ProjectRole.fromJson(json[r'projectRole']! as Map<String, Object?>)
          : null,
      user: json[r'user'] != null
          ? UserDetails.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var id = this.id;
    var notificationType = this.notificationType;
    var parameter = this.parameter;
    var group = this.group;
    var field = this.field;
    var emailAddress = this.emailAddress;
    var projectRole = this.projectRole;
    var user = this.user;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (notificationType != null) {
      json[r'notificationType'] = notificationType.value;
    }
    if (parameter != null) {
      json[r'parameter'] = parameter;
    }
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    if (field != null) {
      json[r'field'] = field.toJson();
    }
    if (emailAddress != null) {
      json[r'emailAddress'] = emailAddress;
    }
    if (projectRole != null) {
      json[r'projectRole'] = projectRole.toJson();
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  EventNotification copyWith(
      {String? expand,
      int? id,
      EventNotificationNotificationType? notificationType,
      String? parameter,
      GroupName? group,
      FieldDetails? field,
      String? emailAddress,
      ProjectRole? projectRole,
      UserDetails? user}) {
    return EventNotification(
      expand: expand ?? this.expand,
      id: id ?? this.id,
      notificationType: notificationType ?? this.notificationType,
      parameter: parameter ?? this.parameter,
      group: group ?? this.group,
      field: field ?? this.field,
      emailAddress: emailAddress ?? this.emailAddress,
      projectRole: projectRole ?? this.projectRole,
      user: user ?? this.user,
    );
  }
}

class EventNotificationNotificationType {
  static const currentAssignee =
      EventNotificationNotificationType._('CurrentAssignee');
  static const reporter = EventNotificationNotificationType._('Reporter');
  static const currentUser = EventNotificationNotificationType._('CurrentUser');
  static const projectLead = EventNotificationNotificationType._('ProjectLead');
  static const componentLead =
      EventNotificationNotificationType._('ComponentLead');
  static const user = EventNotificationNotificationType._('User');
  static const group = EventNotificationNotificationType._('Group');
  static const projectRole = EventNotificationNotificationType._('ProjectRole');
  static const emailAddress =
      EventNotificationNotificationType._('EmailAddress');
  static const allWatchers = EventNotificationNotificationType._('AllWatchers');
  static const userCustomField =
      EventNotificationNotificationType._('UserCustomField');
  static const groupCustomField =
      EventNotificationNotificationType._('GroupCustomField');

  static const values = [
    currentAssignee,
    reporter,
    currentUser,
    projectLead,
    componentLead,
    user,
    group,
    projectRole,
    emailAddress,
    allWatchers,
    userCustomField,
    groupCustomField,
  ];
  final String value;

  const EventNotificationNotificationType._(this.value);

  static EventNotificationNotificationType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => EventNotificationNotificationType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about a field.
class FieldDetails {
  /// The ID of the field.
  final String? id;

  /// The key of the field.
  final String? key;

  /// The name of the field.
  final String? name;

  /// Whether the field is a custom field.
  final bool custom;

  /// Whether the content of the field can be used to order lists.
  final bool orderable;

  /// Whether the field can be used as a column on the issue navigator.
  final bool navigable;

  /// Whether the content of the field can be searched.
  final bool searchable;

  /// The names that can be used to reference the field in an advanced search.
  /// For more information, see
  /// [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ).
  final List<String> clauseNames;

  /// The scope of the field.
  final Scope? scope;

  /// The data schema for the field.
  final JsonTypeBean? schema;

  FieldDetails(
      {this.id,
      this.key,
      this.name,
      bool? custom,
      bool? orderable,
      bool? navigable,
      bool? searchable,
      List<String>? clauseNames,
      this.scope,
      this.schema})
      : custom = custom ?? false,
        orderable = orderable ?? false,
        navigable = navigable ?? false,
        searchable = searchable ?? false,
        clauseNames = clauseNames ?? [];

  factory FieldDetails.fromJson(Map<String, Object?> json) {
    return FieldDetails(
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      custom: json[r'custom'] as bool? ?? false,
      orderable: json[r'orderable'] as bool? ?? false,
      navigable: json[r'navigable'] as bool? ?? false,
      searchable: json[r'searchable'] as bool? ?? false,
      clauseNames: (json[r'clauseNames'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      schema: json[r'schema'] != null
          ? JsonTypeBean.fromJson(json[r'schema']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;
    var name = this.name;
    var custom = this.custom;
    var orderable = this.orderable;
    var navigable = this.navigable;
    var searchable = this.searchable;
    var clauseNames = this.clauseNames;
    var scope = this.scope;
    var schema = this.schema;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'custom'] = custom;
    json[r'orderable'] = orderable;
    json[r'navigable'] = navigable;
    json[r'searchable'] = searchable;
    json[r'clauseNames'] = clauseNames;
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (schema != null) {
      json[r'schema'] = schema.toJson();
    }
    return json;
  }

  FieldDetails copyWith(
      {String? id,
      String? key,
      String? name,
      bool? custom,
      bool? orderable,
      bool? navigable,
      bool? searchable,
      List<String>? clauseNames,
      Scope? scope,
      JsonTypeBean? schema}) {
    return FieldDetails(
      id: id ?? this.id,
      key: key ?? this.key,
      name: name ?? this.name,
      custom: custom ?? this.custom,
      orderable: orderable ?? this.orderable,
      navigable: navigable ?? this.navigable,
      searchable: searchable ?? this.searchable,
      clauseNames: clauseNames ?? this.clauseNames,
      scope: scope ?? this.scope,
      schema: schema ?? this.schema,
    );
  }
}

/// Details about a group name.
class GroupName {
  /// The name of group.
  final String? name;

  /// The URL for these group details.
  final String? self;

  GroupName({this.name, this.self});

  factory GroupName.fromJson(Map<String, Object?> json) {
    return GroupName(
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var self = this.self;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  GroupName copyWith({String? name, String? self}) {
    return GroupName(
      name: name ?? this.name,
      self: self ?? this.self,
    );
  }
}

/// The schema of a field.
class JsonTypeBean {
  /// The data type of the field.
  final String type;

  /// When the data type is an array, the name of the field items within the
  /// array.
  final String? items;

  /// If the field is a system field, the name of the field.
  final String? system;

  /// If the field is a custom field, the URI of the field.
  final String? custom;

  /// If the field is a custom field, the custom ID of the field.
  final int? customId;

  /// If the field is a custom field, the configuration of the field.
  final Map<String, dynamic>? configuration;

  JsonTypeBean(
      {required this.type,
      this.items,
      this.system,
      this.custom,
      this.customId,
      this.configuration});

  factory JsonTypeBean.fromJson(Map<String, Object?> json) {
    return JsonTypeBean(
      type: json[r'type'] as String? ?? '',
      items: json[r'items'] as String?,
      system: json[r'system'] as String?,
      custom: json[r'custom'] as String?,
      customId: (json[r'customId'] as num?)?.toInt(),
      configuration: json[r'configuration'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var items = this.items;
    var system = this.system;
    var custom = this.custom;
    var customId = this.customId;
    var configuration = this.configuration;

    final json = <String, Object?>{};
    json[r'type'] = type;
    if (items != null) {
      json[r'items'] = items;
    }
    if (system != null) {
      json[r'system'] = system;
    }
    if (custom != null) {
      json[r'custom'] = custom;
    }
    if (customId != null) {
      json[r'customId'] = customId;
    }
    if (configuration != null) {
      json[r'configuration'] = configuration;
    }
    return json;
  }

  JsonTypeBean copyWith(
      {String? type,
      String? items,
      String? system,
      String? custom,
      int? customId,
      Map<String, dynamic>? configuration}) {
    return JsonTypeBean(
      type: type ?? this.type,
      items: items ?? this.items,
      system: system ?? this.system,
      custom: custom ?? this.custom,
      customId: customId ?? this.customId,
      configuration: configuration ?? this.configuration,
    );
  }
}

/// Details about a notification event.
class NotificationEvent {
  /// The ID of the event. The event can be a
  /// [Jira system event](https://confluence.atlassian.com/x/8YdKLg#Creatinganotificationscheme-eventsEvents)
  /// or a [custom event](https://confluence.atlassian.com/x/AIlKLg).
  final int? id;

  /// The name of the event.
  final String? name;

  /// The description of the event.
  final String? description;

  /// The template of the event. Only custom events configured by Jira
  /// administrators have template.
  final NotificationEvent? templateEvent;

  NotificationEvent({this.id, this.name, this.description, this.templateEvent});

  factory NotificationEvent.fromJson(Map<String, Object?> json) {
    return NotificationEvent(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      templateEvent: json[r'templateEvent'] != null
          ? NotificationEvent.fromJson(
              json[r'templateEvent']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var templateEvent = this.templateEvent;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (templateEvent != null) {
      json[r'templateEvent'] = templateEvent.toJson();
    }
    return json;
  }

  NotificationEvent copyWith(
      {int? id,
      String? name,
      String? description,
      NotificationEvent? templateEvent}) {
    return NotificationEvent(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      templateEvent: templateEvent ?? this.templateEvent,
    );
  }
}

/// Details about a notification scheme.
class NotificationScheme {
  /// Expand options that include additional notification scheme details in the
  /// response.
  final String? expand;

  /// The ID of the notification scheme.
  final int? id;
  final String? self;

  /// The name of the notification scheme.
  final String? name;

  /// The description of the notification scheme.
  final String? description;

  /// The notification events and associated recipients.
  final List<NotificationSchemeEvent> notificationSchemeEvents;

  /// The scope of the notification scheme.
  final Scope? scope;

  NotificationScheme(
      {this.expand,
      this.id,
      this.self,
      this.name,
      this.description,
      List<NotificationSchemeEvent>? notificationSchemeEvents,
      this.scope})
      : notificationSchemeEvents = notificationSchemeEvents ?? [];

  factory NotificationScheme.fromJson(Map<String, Object?> json) {
    return NotificationScheme(
      expand: json[r'expand'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      self: json[r'self'] as String?,
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      notificationSchemeEvents:
          (json[r'notificationSchemeEvents'] as List<Object?>?)
                  ?.map((i) => NotificationSchemeEvent.fromJson(
                      i as Map<String, Object?>? ?? const {}))
                  .toList() ??
              [],
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var id = this.id;
    var self = this.self;
    var name = this.name;
    var description = this.description;
    var notificationSchemeEvents = this.notificationSchemeEvents;
    var scope = this.scope;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'notificationSchemeEvents'] =
        notificationSchemeEvents.map((i) => i.toJson()).toList();
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    return json;
  }

  NotificationScheme copyWith(
      {String? expand,
      int? id,
      String? self,
      String? name,
      String? description,
      List<NotificationSchemeEvent>? notificationSchemeEvents,
      Scope? scope}) {
    return NotificationScheme(
      expand: expand ?? this.expand,
      id: id ?? this.id,
      self: self ?? this.self,
      name: name ?? this.name,
      description: description ?? this.description,
      notificationSchemeEvents:
          notificationSchemeEvents ?? this.notificationSchemeEvents,
      scope: scope ?? this.scope,
    );
  }
}

/// Details about a notification scheme event.
class NotificationSchemeEvent {
  final NotificationEvent? event;
  final List<EventNotification> notifications;

  NotificationSchemeEvent({this.event, List<EventNotification>? notifications})
      : notifications = notifications ?? [];

  factory NotificationSchemeEvent.fromJson(Map<String, Object?> json) {
    return NotificationSchemeEvent(
      event: json[r'event'] != null
          ? NotificationEvent.fromJson(json[r'event']! as Map<String, Object?>)
          : null,
      notifications: (json[r'notifications'] as List<Object?>?)
              ?.map((i) => EventNotification.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var event = this.event;
    var notifications = this.notifications;

    final json = <String, Object?>{};
    if (event != null) {
      json[r'event'] = event.toJson();
    }
    json[r'notifications'] = notifications.map((i) => i.toJson()).toList();
    return json;
  }

  NotificationSchemeEvent copyWith(
      {NotificationEvent? event, List<EventNotification>? notifications}) {
    return NotificationSchemeEvent(
      event: event ?? this.event,
      notifications: notifications ?? this.notifications,
    );
  }
}

/// Details about a next-gen project.
class ProjectForScope {
  /// The URL of the project details.
  final String? self;

  /// The ID of the project.
  final String? id;

  /// The key of the project.
  final String? key;

  /// The name of the project.
  final String? name;

  /// The
  /// [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes)
  /// of the project.
  final ProjectForScopeProjectTypeKey? projectTypeKey;

  /// Whether or not the project is simplified.
  final bool simplified;

  /// The URLs of the project's avatars.
  final AvatarUrlsBean? avatarUrls;

  /// The category the project belongs to.
  final UpdatedProjectCategory? projectCategory;

  ProjectForScope(
      {this.self,
      this.id,
      this.key,
      this.name,
      this.projectTypeKey,
      bool? simplified,
      this.avatarUrls,
      this.projectCategory})
      : simplified = simplified ?? false;

  factory ProjectForScope.fromJson(Map<String, Object?> json) {
    return ProjectForScope(
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      projectTypeKey: json[r'projectTypeKey'] != null
          ? ProjectForScopeProjectTypeKey.fromValue(
              json[r'projectTypeKey']! as String)
          : null,
      simplified: json[r'simplified'] as bool? ?? false,
      avatarUrls: json[r'avatarUrls'] != null
          ? AvatarUrlsBean.fromJson(
              json[r'avatarUrls']! as Map<String, Object?>)
          : null,
      projectCategory: json[r'projectCategory'] != null
          ? UpdatedProjectCategory.fromJson(
              json[r'projectCategory']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var key = this.key;
    var name = this.name;
    var projectTypeKey = this.projectTypeKey;
    var simplified = this.simplified;
    var avatarUrls = this.avatarUrls;
    var projectCategory = this.projectCategory;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (projectTypeKey != null) {
      json[r'projectTypeKey'] = projectTypeKey.value;
    }
    json[r'simplified'] = simplified;
    if (avatarUrls != null) {
      json[r'avatarUrls'] = avatarUrls.toJson();
    }
    if (projectCategory != null) {
      json[r'projectCategory'] = projectCategory.toJson();
    }
    return json;
  }

  ProjectForScope copyWith(
      {String? self,
      String? id,
      String? key,
      String? name,
      ProjectForScopeProjectTypeKey? projectTypeKey,
      bool? simplified,
      AvatarUrlsBean? avatarUrls,
      UpdatedProjectCategory? projectCategory}) {
    return ProjectForScope(
      self: self ?? this.self,
      id: id ?? this.id,
      key: key ?? this.key,
      name: name ?? this.name,
      projectTypeKey: projectTypeKey ?? this.projectTypeKey,
      simplified: simplified ?? this.simplified,
      avatarUrls: avatarUrls ?? this.avatarUrls,
      projectCategory: projectCategory ?? this.projectCategory,
    );
  }
}

class ProjectForScopeProjectTypeKey {
  static const software = ProjectForScopeProjectTypeKey._('software');
  static const serviceDesk = ProjectForScopeProjectTypeKey._('service_desk');
  static const business = ProjectForScopeProjectTypeKey._('business');

  static const values = [
    software,
    serviceDesk,
    business,
  ];
  final String value;

  const ProjectForScopeProjectTypeKey._(this.value);

  static ProjectForScopeProjectTypeKey fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectForScopeProjectTypeKey._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about the roles in a project.
class ProjectRole {
  /// The URL the project role details.
  final String? self;

  /// The name of the project role.
  final String? name;

  /// The ID of the project role.
  final int? id;

  /// The description of the project role.
  final String? description;

  /// The list of users who act in this role.
  final List<RoleActor> actors;

  /// The scope of the role. Indicated for roles associated with
  /// [next-gen projects](https://confluence.atlassian.com/x/loMyO).
  final Scope? scope;

  /// The translated name of the project role.
  final String? translatedName;

  /// Whether the calling user is part of this role.
  final bool currentUserRole;

  /// Whether this role is the admin role for the project.
  final bool admin;

  /// Whether the roles are configurable for this project.
  final bool roleConfigurable;

  /// Whether this role is the default role for the project
  final bool default$;

  ProjectRole(
      {this.self,
      this.name,
      this.id,
      this.description,
      List<RoleActor>? actors,
      this.scope,
      this.translatedName,
      bool? currentUserRole,
      bool? admin,
      bool? roleConfigurable,
      bool? default$})
      : actors = actors ?? [],
        currentUserRole = currentUserRole ?? false,
        admin = admin ?? false,
        roleConfigurable = roleConfigurable ?? false,
        default$ = default$ ?? false;

  factory ProjectRole.fromJson(Map<String, Object?> json) {
    return ProjectRole(
      self: json[r'self'] as String?,
      name: json[r'name'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      description: json[r'description'] as String?,
      actors: (json[r'actors'] as List<Object?>?)
              ?.map((i) =>
                  RoleActor.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      translatedName: json[r'translatedName'] as String?,
      currentUserRole: json[r'currentUserRole'] as bool? ?? false,
      admin: json[r'admin'] as bool? ?? false,
      roleConfigurable: json[r'roleConfigurable'] as bool? ?? false,
      default$: json[r'default'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var name = this.name;
    var id = this.id;
    var description = this.description;
    var actors = this.actors;
    var scope = this.scope;
    var translatedName = this.translatedName;
    var currentUserRole = this.currentUserRole;
    var admin = this.admin;
    var roleConfigurable = this.roleConfigurable;
    var default$ = this.default$;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'actors'] = actors.map((i) => i.toJson()).toList();
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (translatedName != null) {
      json[r'translatedName'] = translatedName;
    }
    json[r'currentUserRole'] = currentUserRole;
    json[r'admin'] = admin;
    json[r'roleConfigurable'] = roleConfigurable;
    json[r'default'] = default$;
    return json;
  }

  ProjectRole copyWith(
      {String? self,
      String? name,
      int? id,
      String? description,
      List<RoleActor>? actors,
      Scope? scope,
      String? translatedName,
      bool? currentUserRole,
      bool? admin,
      bool? roleConfigurable,
      bool? default$}) {
    return ProjectRole(
      self: self ?? this.self,
      name: name ?? this.name,
      id: id ?? this.id,
      description: description ?? this.description,
      actors: actors ?? this.actors,
      scope: scope ?? this.scope,
      translatedName: translatedName ?? this.translatedName,
      currentUserRole: currentUserRole ?? this.currentUserRole,
      admin: admin ?? this.admin,
      roleConfigurable: roleConfigurable ?? this.roleConfigurable,
      default$: default$ ?? this.default$,
    );
  }
}

/// Details of the group associated with the role.
class ProjectRoleGroup {
  /// The display name of the group.
  final String? displayName;

  /// The name of the group
  final String? name;

  ProjectRoleGroup({this.displayName, this.name});

  factory ProjectRoleGroup.fromJson(Map<String, Object?> json) {
    return ProjectRoleGroup(
      displayName: json[r'displayName'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var displayName = this.displayName;
    var name = this.name;

    final json = <String, Object?>{};
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  ProjectRoleGroup copyWith({String? displayName, String? name}) {
    return ProjectRoleGroup(
      displayName: displayName ?? this.displayName,
      name: name ?? this.name,
    );
  }
}

/// Details of the user associated with the role.
class ProjectRoleUser {
  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Returns
  /// *unknown* if the record is deleted and corrupted, for example, as the
  /// result of a server import.
  final String? accountId;

  ProjectRoleUser({this.accountId});

  factory ProjectRoleUser.fromJson(Map<String, Object?> json) {
    return ProjectRoleUser(
      accountId: json[r'accountId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    return json;
  }

  ProjectRoleUser copyWith({String? accountId}) {
    return ProjectRoleUser(
      accountId: accountId ?? this.accountId,
    );
  }
}

/// Details about a user assigned to a project role.
class RoleActor {
  /// The ID of the role actor.
  final int? id;

  /// The display name of the role actor. For users, depending on the users
  /// privacy setting, this may return an alternative value for the user's name.
  final String? displayName;

  /// The type of role actor.
  final RoleActorType? type;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? name;

  /// The avatar of the role actor.
  final String? avatarUrl;
  final ProjectRoleUser? actorUser;
  final ProjectRoleGroup? actorGroup;

  RoleActor(
      {this.id,
      this.displayName,
      this.type,
      this.name,
      this.avatarUrl,
      this.actorUser,
      this.actorGroup});

  factory RoleActor.fromJson(Map<String, Object?> json) {
    return RoleActor(
      id: (json[r'id'] as num?)?.toInt(),
      displayName: json[r'displayName'] as String?,
      type: json[r'type'] != null
          ? RoleActorType.fromValue(json[r'type']! as String)
          : null,
      name: json[r'name'] as String?,
      avatarUrl: json[r'avatarUrl'] as String?,
      actorUser: json[r'actorUser'] != null
          ? ProjectRoleUser.fromJson(
              json[r'actorUser']! as Map<String, Object?>)
          : null,
      actorGroup: json[r'actorGroup'] != null
          ? ProjectRoleGroup.fromJson(
              json[r'actorGroup']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var displayName = this.displayName;
    var type = this.type;
    var name = this.name;
    var avatarUrl = this.avatarUrl;
    var actorUser = this.actorUser;
    var actorGroup = this.actorGroup;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (avatarUrl != null) {
      json[r'avatarUrl'] = avatarUrl;
    }
    if (actorUser != null) {
      json[r'actorUser'] = actorUser.toJson();
    }
    if (actorGroup != null) {
      json[r'actorGroup'] = actorGroup.toJson();
    }
    return json;
  }

  RoleActor copyWith(
      {int? id,
      String? displayName,
      RoleActorType? type,
      String? name,
      String? avatarUrl,
      ProjectRoleUser? actorUser,
      ProjectRoleGroup? actorGroup}) {
    return RoleActor(
      id: id ?? this.id,
      displayName: displayName ?? this.displayName,
      type: type ?? this.type,
      name: name ?? this.name,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      actorUser: actorUser ?? this.actorUser,
      actorGroup: actorGroup ?? this.actorGroup,
    );
  }
}

class RoleActorType {
  static const atlassianGroupRoleActor =
      RoleActorType._('atlassian-group-role-actor');
  static const atlassianUserRoleActor =
      RoleActorType._('atlassian-user-role-actor');

  static const values = [
    atlassianGroupRoleActor,
    atlassianUserRoleActor,
  ];
  final String value;

  const RoleActorType._(this.value);

  static RoleActorType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => RoleActorType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The projects the item is associated with. Indicated for items associated
/// with [next-gen projects](https://confluence.atlassian.com/x/loMyO).
class Scope {
  /// The type of scope.
  final ScopeType? type;

  /// The project the item has scope in.
  final ProjectForScope? project;

  Scope({this.type, this.project});

  factory Scope.fromJson(Map<String, Object?> json) {
    return Scope(
      type: json[r'type'] != null
          ? ScopeType.fromValue(json[r'type']! as String)
          : null,
      project: json[r'project'] != null
          ? ProjectForScope.fromJson(json[r'project']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var project = this.project;

    final json = <String, Object?>{};
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (project != null) {
      json[r'project'] = project.toJson();
    }
    return json;
  }

  Scope copyWith({ScopeType? type, ProjectForScope? project}) {
    return Scope(
      type: type ?? this.type,
      project: project ?? this.project,
    );
  }
}

class ScopeType {
  static const project = ScopeType._('PROJECT');
  static const template = ScopeType._('TEMPLATE');

  static const values = [
    project,
    template,
  ];
  final String value;

  const ScopeType._(this.value);

  static ScopeType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => ScopeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A project category.
class UpdatedProjectCategory {
  /// The URL of the project category.
  final String? self;

  /// The ID of the project category.
  final String? id;

  /// The name of the project category.
  final String? description;

  /// The description of the project category.
  final String? name;

  UpdatedProjectCategory({this.self, this.id, this.description, this.name});

  factory UpdatedProjectCategory.fromJson(Map<String, Object?> json) {
    return UpdatedProjectCategory(
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  UpdatedProjectCategory copyWith(
      {String? self, String? id, String? description, String? name}) {
    return UpdatedProjectCategory(
      self: self ?? this.self,
      id: id ?? this.id,
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// User details permitted by the user's Atlassian Account privacy settings.
/// However, be aware of these exceptions:
///
///  *  User record deleted from Atlassian: This occurs as the result of a right
/// to be forgotten request. In this case, `displayName` provides an indication
/// and other parameters have default values or are blank (for example, email is
/// blank).
///  *  User record corrupted: This occurs as a results of events such as a
/// server import and can only happen to deleted users. In this case,
/// `accountId` returns *unknown* and all other parameters have fallback values.
///  *  User record unavailable: This usually occurs due to an internal service
/// outage. In this case, all parameters have fallback values.
class UserDetails {
  /// The URL of the user.
  final String? self;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? name;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? key;

  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
  final String? accountId;

  /// The email address of the user. Depending on the users privacy settings,
  /// this may be returned as null.
  final String? emailAddress;

  /// The avatars of the user.
  final AvatarUrlsBean? avatarUrls;

  /// The display name of the user. Depending on the users privacy settings,
  /// this may return an alternative value.
  final String? displayName;

  /// Whether the user is active.
  final bool active;

  /// The time zone specified in the user's profile. Depending on the users
  /// privacy settings, this may be returned as null.
  final String? timeZone;

  /// The type of account represented by this user. This will be one of
  /// 'atlassian' (normal users), 'app' (application user) or 'customer' (Jira
  /// Service Desk customer user)
  final String? accountType;

  UserDetails(
      {this.self,
      this.name,
      this.key,
      this.accountId,
      this.emailAddress,
      this.avatarUrls,
      this.displayName,
      bool? active,
      this.timeZone,
      this.accountType})
      : active = active ?? false;

  factory UserDetails.fromJson(Map<String, Object?> json) {
    return UserDetails(
      self: json[r'self'] as String?,
      name: json[r'name'] as String?,
      key: json[r'key'] as String?,
      accountId: json[r'accountId'] as String?,
      emailAddress: json[r'emailAddress'] as String?,
      avatarUrls: json[r'avatarUrls'] != null
          ? AvatarUrlsBean.fromJson(
              json[r'avatarUrls']! as Map<String, Object?>)
          : null,
      displayName: json[r'displayName'] as String?,
      active: json[r'active'] as bool? ?? false,
      timeZone: json[r'timeZone'] as String?,
      accountType: json[r'accountType'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var name = this.name;
    var key = this.key;
    var accountId = this.accountId;
    var emailAddress = this.emailAddress;
    var avatarUrls = this.avatarUrls;
    var displayName = this.displayName;
    var active = this.active;
    var timeZone = this.timeZone;
    var accountType = this.accountType;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (emailAddress != null) {
      json[r'emailAddress'] = emailAddress;
    }
    if (avatarUrls != null) {
      json[r'avatarUrls'] = avatarUrls.toJson();
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    json[r'active'] = active;
    if (timeZone != null) {
      json[r'timeZone'] = timeZone;
    }
    if (accountType != null) {
      json[r'accountType'] = accountType;
    }
    return json;
  }

  UserDetails copyWith(
      {String? self,
      String? name,
      String? key,
      String? accountId,
      String? emailAddress,
      AvatarUrlsBean? avatarUrls,
      String? displayName,
      bool? active,
      String? timeZone,
      String? accountType}) {
    return UserDetails(
      self: self ?? this.self,
      name: name ?? this.name,
      key: key ?? this.key,
      accountId: accountId ?? this.accountId,
      emailAddress: emailAddress ?? this.emailAddress,
      avatarUrls: avatarUrls ?? this.avatarUrls,
      displayName: displayName ?? this.displayName,
      active: active ?? this.active,
      timeZone: timeZone ?? this.timeZone,
      accountType: accountType ?? this.accountType,
    );
  }
}

/// A page of items.
class PageBeanNotificationScheme {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<NotificationScheme> values;

  PageBeanNotificationScheme(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<NotificationScheme>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanNotificationScheme.fromJson(Map<String, Object?> json) {
    return PageBeanNotificationScheme(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => NotificationScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanNotificationScheme copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<NotificationScheme>? values}) {
    return PageBeanNotificationScheme(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanUserKey {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<UserKey> values;

  PageBeanUserKey(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<UserKey>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanUserKey.fromJson(Map<String, Object?> json) {
    return PageBeanUserKey(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  UserKey.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanUserKey copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<UserKey>? values}) {
    return PageBeanUserKey(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// List of user account IDs.
class UserKey {
  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? key;

  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Returns
  /// *unknown* if the record is deleted and corrupted, for example, as the
  /// result of a server import.
  final String? accountId;

  UserKey({this.key, this.accountId});

  factory UserKey.fromJson(Map<String, Object?> json) {
    return UserKey(
      key: json[r'key'] as String?,
      accountId: json[r'accountId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var accountId = this.accountId;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key;
    }
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    return json;
  }

  UserKey copyWith({String? key, String? accountId}) {
    return UserKey(
      key: key ?? this.key,
      accountId: accountId ?? this.accountId,
    );
  }
}

/// Details of an application role.
class ApplicationRole {
  /// The key of the application role.
  final String? key;

  /// The groups associated with the application role.
  final List<String> groups;

  /// The display name of the application role.
  final String? name;

  /// The groups that are granted default access for this application role.
  final List<String> defaultGroups;

  /// Determines whether this application role should be selected by default on
  /// user creation.
  final bool selectedByDefault;

  /// Deprecated.
  final bool defined;

  /// The maximum count of users on your license.
  final int? numberOfSeats;

  /// The count of users remaining on your license.
  final int? remainingSeats;

  /// The number of users counting against your license.
  final int? userCount;

  /// The [type of users](https://confluence.atlassian.com/x/lRW3Ng) being
  /// counted against your license.
  final String? userCountDescription;
  final bool hasUnlimitedSeats;

  /// Indicates if the application role belongs to Jira platform (`jira-core`).
  final bool platform;

  ApplicationRole(
      {this.key,
      List<String>? groups,
      this.name,
      List<String>? defaultGroups,
      bool? selectedByDefault,
      bool? defined,
      this.numberOfSeats,
      this.remainingSeats,
      this.userCount,
      this.userCountDescription,
      bool? hasUnlimitedSeats,
      bool? platform})
      : groups = groups ?? [],
        defaultGroups = defaultGroups ?? [],
        selectedByDefault = selectedByDefault ?? false,
        defined = defined ?? false,
        hasUnlimitedSeats = hasUnlimitedSeats ?? false,
        platform = platform ?? false;

  factory ApplicationRole.fromJson(Map<String, Object?> json) {
    return ApplicationRole(
      key: json[r'key'] as String?,
      groups: (json[r'groups'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      name: json[r'name'] as String?,
      defaultGroups: (json[r'defaultGroups'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      selectedByDefault: json[r'selectedByDefault'] as bool? ?? false,
      defined: json[r'defined'] as bool? ?? false,
      numberOfSeats: (json[r'numberOfSeats'] as num?)?.toInt(),
      remainingSeats: (json[r'remainingSeats'] as num?)?.toInt(),
      userCount: (json[r'userCount'] as num?)?.toInt(),
      userCountDescription: json[r'userCountDescription'] as String?,
      hasUnlimitedSeats: json[r'hasUnlimitedSeats'] as bool? ?? false,
      platform: json[r'platform'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var groups = this.groups;
    var name = this.name;
    var defaultGroups = this.defaultGroups;
    var selectedByDefault = this.selectedByDefault;
    var defined = this.defined;
    var numberOfSeats = this.numberOfSeats;
    var remainingSeats = this.remainingSeats;
    var userCount = this.userCount;
    var userCountDescription = this.userCountDescription;
    var hasUnlimitedSeats = this.hasUnlimitedSeats;
    var platform = this.platform;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key;
    }
    json[r'groups'] = groups;
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'defaultGroups'] = defaultGroups;
    json[r'selectedByDefault'] = selectedByDefault;
    json[r'defined'] = defined;
    if (numberOfSeats != null) {
      json[r'numberOfSeats'] = numberOfSeats;
    }
    if (remainingSeats != null) {
      json[r'remainingSeats'] = remainingSeats;
    }
    if (userCount != null) {
      json[r'userCount'] = userCount;
    }
    if (userCountDescription != null) {
      json[r'userCountDescription'] = userCountDescription;
    }
    json[r'hasUnlimitedSeats'] = hasUnlimitedSeats;
    json[r'platform'] = platform;
    return json;
  }

  ApplicationRole copyWith(
      {String? key,
      List<String>? groups,
      String? name,
      List<String>? defaultGroups,
      bool? selectedByDefault,
      bool? defined,
      int? numberOfSeats,
      int? remainingSeats,
      int? userCount,
      String? userCountDescription,
      bool? hasUnlimitedSeats,
      bool? platform}) {
    return ApplicationRole(
      key: key ?? this.key,
      groups: groups ?? this.groups,
      name: name ?? this.name,
      defaultGroups: defaultGroups ?? this.defaultGroups,
      selectedByDefault: selectedByDefault ?? this.selectedByDefault,
      defined: defined ?? this.defined,
      numberOfSeats: numberOfSeats ?? this.numberOfSeats,
      remainingSeats: remainingSeats ?? this.remainingSeats,
      userCount: userCount ?? this.userCount,
      userCountDescription: userCountDescription ?? this.userCountDescription,
      hasUnlimitedSeats: hasUnlimitedSeats ?? this.hasUnlimitedSeats,
      platform: platform ?? this.platform,
    );
  }
}

class ListWrapperCallbackApplicationRole {
  ListWrapperCallbackApplicationRole();

  factory ListWrapperCallbackApplicationRole.fromJson(
      Map<String, Object?> json) {
    return ListWrapperCallbackApplicationRole();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class ListWrapperCallbackGroupName {
  ListWrapperCallbackGroupName();

  factory ListWrapperCallbackGroupName.fromJson(Map<String, Object?> json) {
    return ListWrapperCallbackGroupName();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// A page of items.
class PageBeanUser {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<User> values;

  PageBeanUser(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<User>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanUser.fromJson(Map<String, Object?> json) {
    return PageBeanUser(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map(
                  (i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanUser copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<User>? values}) {
    return PageBeanUser(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

class SimpleListWrapperApplicationRole {
  final int? size;
  final List<ApplicationRole> items;
  final ListWrapperCallbackApplicationRole? pagingCallback;
  final ListWrapperCallbackApplicationRole? callback;
  final int? maxResults;

  SimpleListWrapperApplicationRole(
      {this.size,
      List<ApplicationRole>? items,
      this.pagingCallback,
      this.callback,
      this.maxResults})
      : items = items ?? [];

  factory SimpleListWrapperApplicationRole.fromJson(Map<String, Object?> json) {
    return SimpleListWrapperApplicationRole(
      size: (json[r'size'] as num?)?.toInt(),
      items: (json[r'items'] as List<Object?>?)
              ?.map((i) => ApplicationRole.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      pagingCallback: json[r'pagingCallback'] != null
          ? ListWrapperCallbackApplicationRole.fromJson(
              json[r'pagingCallback']! as Map<String, Object?>)
          : null,
      callback: json[r'callback'] != null
          ? ListWrapperCallbackApplicationRole.fromJson(
              json[r'callback']! as Map<String, Object?>)
          : null,
      maxResults: (json[r'max-results'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var size = this.size;
    var items = this.items;
    var pagingCallback = this.pagingCallback;
    var callback = this.callback;
    var maxResults = this.maxResults;

    final json = <String, Object?>{};
    if (size != null) {
      json[r'size'] = size;
    }
    json[r'items'] = items.map((i) => i.toJson()).toList();
    if (pagingCallback != null) {
      json[r'pagingCallback'] = pagingCallback.toJson();
    }
    if (callback != null) {
      json[r'callback'] = callback.toJson();
    }
    if (maxResults != null) {
      json[r'max-results'] = maxResults;
    }
    return json;
  }

  SimpleListWrapperApplicationRole copyWith(
      {int? size,
      List<ApplicationRole>? items,
      ListWrapperCallbackApplicationRole? pagingCallback,
      ListWrapperCallbackApplicationRole? callback,
      int? maxResults}) {
    return SimpleListWrapperApplicationRole(
      size: size ?? this.size,
      items: items ?? this.items,
      pagingCallback: pagingCallback ?? this.pagingCallback,
      callback: callback ?? this.callback,
      maxResults: maxResults ?? this.maxResults,
    );
  }
}

class SimpleListWrapperGroupName {
  final int? size;
  final List<GroupName> items;
  final ListWrapperCallbackGroupName? pagingCallback;
  final ListWrapperCallbackGroupName? callback;
  final int? maxResults;

  SimpleListWrapperGroupName(
      {this.size,
      List<GroupName>? items,
      this.pagingCallback,
      this.callback,
      this.maxResults})
      : items = items ?? [];

  factory SimpleListWrapperGroupName.fromJson(Map<String, Object?> json) {
    return SimpleListWrapperGroupName(
      size: (json[r'size'] as num?)?.toInt(),
      items: (json[r'items'] as List<Object?>?)
              ?.map((i) =>
                  GroupName.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      pagingCallback: json[r'pagingCallback'] != null
          ? ListWrapperCallbackGroupName.fromJson(
              json[r'pagingCallback']! as Map<String, Object?>)
          : null,
      callback: json[r'callback'] != null
          ? ListWrapperCallbackGroupName.fromJson(
              json[r'callback']! as Map<String, Object?>)
          : null,
      maxResults: (json[r'max-results'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var size = this.size;
    var items = this.items;
    var pagingCallback = this.pagingCallback;
    var callback = this.callback;
    var maxResults = this.maxResults;

    final json = <String, Object?>{};
    if (size != null) {
      json[r'size'] = size;
    }
    json[r'items'] = items.map((i) => i.toJson()).toList();
    if (pagingCallback != null) {
      json[r'pagingCallback'] = pagingCallback.toJson();
    }
    if (callback != null) {
      json[r'callback'] = callback.toJson();
    }
    if (maxResults != null) {
      json[r'max-results'] = maxResults;
    }
    return json;
  }

  SimpleListWrapperGroupName copyWith(
      {int? size,
      List<GroupName>? items,
      ListWrapperCallbackGroupName? pagingCallback,
      ListWrapperCallbackGroupName? callback,
      int? maxResults}) {
    return SimpleListWrapperGroupName(
      size: size ?? this.size,
      items: items ?? this.items,
      pagingCallback: pagingCallback ?? this.pagingCallback,
      callback: callback ?? this.callback,
      maxResults: maxResults ?? this.maxResults,
    );
  }
}

/// A user with details as permitted by the user's Atlassian Account privacy
/// settings. However, be aware of these exceptions:
///
///  *  User record deleted from Atlassian: This occurs as the result of a right
/// to be forgotten request. In this case, `displayName` provides an indication
/// and other parameters have default values or are blank (for example, email is
/// blank).
///  *  User record corrupted: This occurs as a results of events such as a
/// server import and can only happen to deleted users. In this case,
/// `accountId` returns *unknown* and all other parameters have fallback values.
///  *  User record unavailable: This usually occurs due to an internal service
/// outage. In this case, all parameters have fallback values.
class User {
  /// The URL of the user.
  final String? self;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? key;

  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Required in
  /// requests.
  final String? accountId;

  /// The user account type. Can take the following values:
  ///
  ///  *  `atlassian` regular Atlassian user account
  ///  *  `app` system account used for Connect applications and OAuth to
  /// represent external systems
  ///  *  `customer` Jira Service Desk account representing an external service
  /// desk
  final UserAccountType? accountType;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? name;

  /// The email address of the user. Depending on the users privacy setting,
  /// this may be returned as null.
  final String? emailAddress;

  /// The avatars of the user.
  final AvatarUrlsBean? avatarUrls;

  /// The display name of the user. Depending on the users privacy setting,
  /// this may return an alternative value.
  final String? displayName;

  /// Whether the user is active.
  final bool active;

  /// The time zone specified in the user's profile. Depending on the users
  /// privacy setting, this may be returned as null.
  final String? timeZone;

  /// The locale of the user. Depending on the users privacy setting, this may
  /// be returned as null.
  final String? locale;

  /// The groups that the user belongs to.
  final SimpleListWrapperGroupName? groups;

  /// The application roles the user is assigned to.
  final SimpleListWrapperApplicationRole? applicationRoles;

  /// Expand options that include additional user details in the response.
  final String? expand;

  User(
      {this.self,
      this.key,
      this.accountId,
      this.accountType,
      this.name,
      this.emailAddress,
      this.avatarUrls,
      this.displayName,
      bool? active,
      this.timeZone,
      this.locale,
      this.groups,
      this.applicationRoles,
      this.expand})
      : active = active ?? false;

  factory User.fromJson(Map<String, Object?> json) {
    return User(
      self: json[r'self'] as String?,
      key: json[r'key'] as String?,
      accountId: json[r'accountId'] as String?,
      accountType: json[r'accountType'] != null
          ? UserAccountType.fromValue(json[r'accountType']! as String)
          : null,
      name: json[r'name'] as String?,
      emailAddress: json[r'emailAddress'] as String?,
      avatarUrls: json[r'avatarUrls'] != null
          ? AvatarUrlsBean.fromJson(
              json[r'avatarUrls']! as Map<String, Object?>)
          : null,
      displayName: json[r'displayName'] as String?,
      active: json[r'active'] as bool? ?? false,
      timeZone: json[r'timeZone'] as String?,
      locale: json[r'locale'] as String?,
      groups: json[r'groups'] != null
          ? SimpleListWrapperGroupName.fromJson(
              json[r'groups']! as Map<String, Object?>)
          : null,
      applicationRoles: json[r'applicationRoles'] != null
          ? SimpleListWrapperApplicationRole.fromJson(
              json[r'applicationRoles']! as Map<String, Object?>)
          : null,
      expand: json[r'expand'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var key = this.key;
    var accountId = this.accountId;
    var accountType = this.accountType;
    var name = this.name;
    var emailAddress = this.emailAddress;
    var avatarUrls = this.avatarUrls;
    var displayName = this.displayName;
    var active = this.active;
    var timeZone = this.timeZone;
    var locale = this.locale;
    var groups = this.groups;
    var applicationRoles = this.applicationRoles;
    var expand = this.expand;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (accountType != null) {
      json[r'accountType'] = accountType.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (emailAddress != null) {
      json[r'emailAddress'] = emailAddress;
    }
    if (avatarUrls != null) {
      json[r'avatarUrls'] = avatarUrls.toJson();
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    json[r'active'] = active;
    if (timeZone != null) {
      json[r'timeZone'] = timeZone;
    }
    if (locale != null) {
      json[r'locale'] = locale;
    }
    if (groups != null) {
      json[r'groups'] = groups.toJson();
    }
    if (applicationRoles != null) {
      json[r'applicationRoles'] = applicationRoles.toJson();
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    return json;
  }

  User copyWith(
      {String? self,
      String? key,
      String? accountId,
      UserAccountType? accountType,
      String? name,
      String? emailAddress,
      AvatarUrlsBean? avatarUrls,
      String? displayName,
      bool? active,
      String? timeZone,
      String? locale,
      SimpleListWrapperGroupName? groups,
      SimpleListWrapperApplicationRole? applicationRoles,
      String? expand}) {
    return User(
      self: self ?? this.self,
      key: key ?? this.key,
      accountId: accountId ?? this.accountId,
      accountType: accountType ?? this.accountType,
      name: name ?? this.name,
      emailAddress: emailAddress ?? this.emailAddress,
      avatarUrls: avatarUrls ?? this.avatarUrls,
      displayName: displayName ?? this.displayName,
      active: active ?? this.active,
      timeZone: timeZone ?? this.timeZone,
      locale: locale ?? this.locale,
      groups: groups ?? this.groups,
      applicationRoles: applicationRoles ?? this.applicationRoles,
      expand: expand ?? this.expand,
    );
  }
}

class UserAccountType {
  static const atlassian = UserAccountType._('atlassian');
  static const app = UserAccountType._('app');
  static const customer = UserAccountType._('customer');
  static const unknown = UserAccountType._('unknown');

  static const values = [
    atlassian,
    app,
    customer,
    unknown,
  ];
  final String value;

  const UserAccountType._(this.value);

  static UserAccountType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UserAccountType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A change item.
class ChangeDetails {
  /// The name of the field changed.
  final String? field;

  /// The type of the field changed.
  final String? fieldtype;

  /// The ID of the field changed.
  final String? fieldId;

  /// The details of the original value.
  final String? from;

  /// The details of the original value as a string.
  final String? fromString;

  /// The details of the new value.
  final String? to;

  /// The details of the new value as a string.
  final String? toString$;

  ChangeDetails(
      {this.field,
      this.fieldtype,
      this.fieldId,
      this.from,
      this.fromString,
      this.to,
      this.toString$});

  factory ChangeDetails.fromJson(Map<String, Object?> json) {
    return ChangeDetails(
      field: json[r'field'] as String?,
      fieldtype: json[r'fieldtype'] as String?,
      fieldId: json[r'fieldId'] as String?,
      from: json[r'from'] as String?,
      fromString: json[r'fromString'] as String?,
      to: json[r'to'] as String?,
      toString$: json[r'toString'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var field = this.field;
    var fieldtype = this.fieldtype;
    var fieldId = this.fieldId;
    var from = this.from;
    var fromString = this.fromString;
    var to = this.to;
    var toString$ = this.toString$;

    final json = <String, Object?>{};
    if (field != null) {
      json[r'field'] = field;
    }
    if (fieldtype != null) {
      json[r'fieldtype'] = fieldtype;
    }
    if (fieldId != null) {
      json[r'fieldId'] = fieldId;
    }
    if (from != null) {
      json[r'from'] = from;
    }
    if (fromString != null) {
      json[r'fromString'] = fromString;
    }
    if (to != null) {
      json[r'to'] = to;
    }
    if (toString$ != null) {
      json[r'toString'] = toString$;
    }
    return json;
  }

  ChangeDetails copyWith(
      {String? field,
      String? fieldtype,
      String? fieldId,
      String? from,
      String? fromString,
      String? to,
      String? toString$}) {
    return ChangeDetails(
      field: field ?? this.field,
      fieldtype: fieldtype ?? this.fieldtype,
      fieldId: fieldId ?? this.fieldId,
      from: from ?? this.from,
      fromString: fromString ?? this.fromString,
      to: to ?? this.to,
      toString$: toString$ ?? this.toString$,
    );
  }
}

/// A changelog.
class Changelog {
  /// The ID of the changelog.
  final String? id;

  /// The user who made the change.
  final UserDetails? author;

  /// The date on which the change took place.
  final DateTime? created;

  /// The list of items changed.
  final List<ChangeDetails> items;

  /// The history metadata associated with the changed.
  final HistoryMetadata? historyMetadata;

  Changelog(
      {this.id,
      this.author,
      this.created,
      List<ChangeDetails>? items,
      this.historyMetadata})
      : items = items ?? [];

  factory Changelog.fromJson(Map<String, Object?> json) {
    return Changelog(
      id: json[r'id'] as String?,
      author: json[r'author'] != null
          ? UserDetails.fromJson(json[r'author']! as Map<String, Object?>)
          : null,
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      items: (json[r'items'] as List<Object?>?)
              ?.map((i) => ChangeDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      historyMetadata: json[r'historyMetadata'] != null
          ? HistoryMetadata.fromJson(
              json[r'historyMetadata']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var author = this.author;
    var created = this.created;
    var items = this.items;
    var historyMetadata = this.historyMetadata;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (author != null) {
      json[r'author'] = author.toJson();
    }
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    json[r'items'] = items.map((i) => i.toJson()).toList();
    if (historyMetadata != null) {
      json[r'historyMetadata'] = historyMetadata.toJson();
    }
    return json;
  }

  Changelog copyWith(
      {String? id,
      UserDetails? author,
      DateTime? created,
      List<ChangeDetails>? items,
      HistoryMetadata? historyMetadata}) {
    return Changelog(
      id: id ?? this.id,
      author: author ?? this.author,
      created: created ?? this.created,
      items: items ?? this.items,
      historyMetadata: historyMetadata ?? this.historyMetadata,
    );
  }
}

/// The metadata describing an issue field.
class FieldMetadata {
  /// Whether the field is required.
  final bool required;

  /// The data type of the field.
  final JsonTypeBean schema;

  /// The name of the field.
  final String name;

  /// The key of the field.
  final String key;

  /// The URL that can be used to automatically complete the field.
  final String? autoCompleteUrl;

  /// Whether the field has a default value.
  final bool hasDefaultValue;

  /// The list of operations that can be performed on the field.
  final List<String> operations;

  /// The list of values allowed in the field.
  final List<dynamic> allowedValues;

  /// The default value of the field.
  final dynamic defaultValue;

  FieldMetadata(
      {required this.required,
      required this.schema,
      required this.name,
      required this.key,
      this.autoCompleteUrl,
      bool? hasDefaultValue,
      required this.operations,
      List<dynamic>? allowedValues,
      this.defaultValue})
      : hasDefaultValue = hasDefaultValue ?? false,
        allowedValues = allowedValues ?? [];

  factory FieldMetadata.fromJson(Map<String, Object?> json) {
    return FieldMetadata(
      required: json[r'required'] as bool? ?? false,
      schema: JsonTypeBean.fromJson(
          json[r'schema'] as Map<String, Object?>? ?? const {}),
      name: json[r'name'] as String? ?? '',
      key: json[r'key'] as String? ?? '',
      autoCompleteUrl: json[r'autoCompleteUrl'] as String?,
      hasDefaultValue: json[r'hasDefaultValue'] as bool? ?? false,
      operations: (json[r'operations'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      allowedValues:
          (json[r'allowedValues'] as List<Object?>?)?.map((i) => i).toList() ??
              [],
      defaultValue: json[r'defaultValue'],
    );
  }

  Map<String, Object?> toJson() {
    var required = this.required;
    var schema = this.schema;
    var name = this.name;
    var key = this.key;
    var autoCompleteUrl = this.autoCompleteUrl;
    var hasDefaultValue = this.hasDefaultValue;
    var operations = this.operations;
    var allowedValues = this.allowedValues;
    var defaultValue = this.defaultValue;

    final json = <String, Object?>{};
    json[r'required'] = required;
    json[r'schema'] = schema.toJson();
    json[r'name'] = name;
    json[r'key'] = key;
    if (autoCompleteUrl != null) {
      json[r'autoCompleteUrl'] = autoCompleteUrl;
    }
    json[r'hasDefaultValue'] = hasDefaultValue;
    json[r'operations'] = operations;
    json[r'allowedValues'] = allowedValues;
    if (defaultValue != null) {
      json[r'defaultValue'] = defaultValue;
    }
    return json;
  }

  FieldMetadata copyWith(
      {bool? required,
      JsonTypeBean? schema,
      String? name,
      String? key,
      String? autoCompleteUrl,
      bool? hasDefaultValue,
      List<String>? operations,
      List<dynamic>? allowedValues,
      dynamic defaultValue}) {
    return FieldMetadata(
      required: required ?? this.required,
      schema: schema ?? this.schema,
      name: name ?? this.name,
      key: key ?? this.key,
      autoCompleteUrl: autoCompleteUrl ?? this.autoCompleteUrl,
      hasDefaultValue: hasDefaultValue ?? this.hasDefaultValue,
      operations: operations ?? this.operations,
      allowedValues: allowedValues ?? this.allowedValues,
      defaultValue: defaultValue ?? this.defaultValue,
    );
  }
}

/// Details of issue history metadata.
class HistoryMetadata {
  /// The type of the history record.
  final String? type;

  /// The description of the history record.
  final String? description;

  /// The description key of the history record.
  final String? descriptionKey;

  /// The activity described in the history record.
  final String? activityDescription;

  /// The key of the activity described in the history record.
  final String? activityDescriptionKey;

  /// The description of the email address associated the history record.
  final String? emailDescription;

  /// The description key of the email address associated the history record.
  final String? emailDescriptionKey;

  /// Details of the user whose action created the history record.
  final HistoryMetadataParticipant? actor;

  /// Details of the system that generated the history record.
  final HistoryMetadataParticipant? generator;

  /// Details of the cause that triggered the creation the history record.
  final HistoryMetadataParticipant? cause;

  /// Additional arbitrary information about the history record.
  final Map<String, dynamic>? extraData;

  HistoryMetadata(
      {this.type,
      this.description,
      this.descriptionKey,
      this.activityDescription,
      this.activityDescriptionKey,
      this.emailDescription,
      this.emailDescriptionKey,
      this.actor,
      this.generator,
      this.cause,
      this.extraData});

  factory HistoryMetadata.fromJson(Map<String, Object?> json) {
    return HistoryMetadata(
      type: json[r'type'] as String?,
      description: json[r'description'] as String?,
      descriptionKey: json[r'descriptionKey'] as String?,
      activityDescription: json[r'activityDescription'] as String?,
      activityDescriptionKey: json[r'activityDescriptionKey'] as String?,
      emailDescription: json[r'emailDescription'] as String?,
      emailDescriptionKey: json[r'emailDescriptionKey'] as String?,
      actor: json[r'actor'] != null
          ? HistoryMetadataParticipant.fromJson(
              json[r'actor']! as Map<String, Object?>)
          : null,
      generator: json[r'generator'] != null
          ? HistoryMetadataParticipant.fromJson(
              json[r'generator']! as Map<String, Object?>)
          : null,
      cause: json[r'cause'] != null
          ? HistoryMetadataParticipant.fromJson(
              json[r'cause']! as Map<String, Object?>)
          : null,
      extraData: json[r'extraData'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var description = this.description;
    var descriptionKey = this.descriptionKey;
    var activityDescription = this.activityDescription;
    var activityDescriptionKey = this.activityDescriptionKey;
    var emailDescription = this.emailDescription;
    var emailDescriptionKey = this.emailDescriptionKey;
    var actor = this.actor;
    var generator = this.generator;
    var cause = this.cause;
    var extraData = this.extraData;

    final json = <String, Object?>{};
    if (type != null) {
      json[r'type'] = type;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (descriptionKey != null) {
      json[r'descriptionKey'] = descriptionKey;
    }
    if (activityDescription != null) {
      json[r'activityDescription'] = activityDescription;
    }
    if (activityDescriptionKey != null) {
      json[r'activityDescriptionKey'] = activityDescriptionKey;
    }
    if (emailDescription != null) {
      json[r'emailDescription'] = emailDescription;
    }
    if (emailDescriptionKey != null) {
      json[r'emailDescriptionKey'] = emailDescriptionKey;
    }
    if (actor != null) {
      json[r'actor'] = actor.toJson();
    }
    if (generator != null) {
      json[r'generator'] = generator.toJson();
    }
    if (cause != null) {
      json[r'cause'] = cause.toJson();
    }
    if (extraData != null) {
      json[r'extraData'] = extraData;
    }
    return json;
  }

  HistoryMetadata copyWith(
      {String? type,
      String? description,
      String? descriptionKey,
      String? activityDescription,
      String? activityDescriptionKey,
      String? emailDescription,
      String? emailDescriptionKey,
      HistoryMetadataParticipant? actor,
      HistoryMetadataParticipant? generator,
      HistoryMetadataParticipant? cause,
      Map<String, dynamic>? extraData}) {
    return HistoryMetadata(
      type: type ?? this.type,
      description: description ?? this.description,
      descriptionKey: descriptionKey ?? this.descriptionKey,
      activityDescription: activityDescription ?? this.activityDescription,
      activityDescriptionKey:
          activityDescriptionKey ?? this.activityDescriptionKey,
      emailDescription: emailDescription ?? this.emailDescription,
      emailDescriptionKey: emailDescriptionKey ?? this.emailDescriptionKey,
      actor: actor ?? this.actor,
      generator: generator ?? this.generator,
      cause: cause ?? this.cause,
      extraData: extraData ?? this.extraData,
    );
  }
}

/// Details of user or system associated with a issue history metadata item.
class HistoryMetadataParticipant {
  /// The ID of the user or system associated with a history record.
  final String? id;

  /// The display name of the user or system associated with a history record.
  final String? displayName;

  /// The key of the display name of the user or system associated with a
  /// history record.
  final String? displayNameKey;

  /// The type of the user or system associated with a history record.
  final String? type;

  /// The URL to an avatar for the user or system associated with a history
  /// record.
  final String? avatarUrl;

  /// The URL of the user or system associated with a history record.
  final String? url;

  HistoryMetadataParticipant(
      {this.id,
      this.displayName,
      this.displayNameKey,
      this.type,
      this.avatarUrl,
      this.url});

  factory HistoryMetadataParticipant.fromJson(Map<String, Object?> json) {
    return HistoryMetadataParticipant(
      id: json[r'id'] as String?,
      displayName: json[r'displayName'] as String?,
      displayNameKey: json[r'displayNameKey'] as String?,
      type: json[r'type'] as String?,
      avatarUrl: json[r'avatarUrl'] as String?,
      url: json[r'url'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var displayName = this.displayName;
    var displayNameKey = this.displayNameKey;
    var type = this.type;
    var avatarUrl = this.avatarUrl;
    var url = this.url;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (displayNameKey != null) {
      json[r'displayNameKey'] = displayNameKey;
    }
    if (type != null) {
      json[r'type'] = type;
    }
    if (avatarUrl != null) {
      json[r'avatarUrl'] = avatarUrl;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    return json;
  }

  HistoryMetadataParticipant copyWith(
      {String? id,
      String? displayName,
      String? displayNameKey,
      String? type,
      String? avatarUrl,
      String? url}) {
    return HistoryMetadataParticipant(
      id: id ?? this.id,
      displayName: displayName ?? this.displayName,
      displayNameKey: displayNameKey ?? this.displayNameKey,
      type: type ?? this.type,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      url: url ?? this.url,
    );
  }
}

class IncludedFields {
  final List<String> included;
  final List<String> excluded;
  final List<String> actuallyIncluded;

  IncludedFields(
      {List<String>? included,
      List<String>? excluded,
      List<String>? actuallyIncluded})
      : included = included ?? [],
        excluded = excluded ?? [],
        actuallyIncluded = actuallyIncluded ?? [];

  factory IncludedFields.fromJson(Map<String, Object?> json) {
    return IncludedFields(
      included: (json[r'included'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      excluded: (json[r'excluded'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      actuallyIncluded: (json[r'actuallyIncluded'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var included = this.included;
    var excluded = this.excluded;
    var actuallyIncluded = this.actuallyIncluded;

    final json = <String, Object?>{};
    json[r'included'] = included;
    json[r'excluded'] = excluded;
    json[r'actuallyIncluded'] = actuallyIncluded;
    return json;
  }

  IncludedFields copyWith(
      {List<String>? included,
      List<String>? excluded,
      List<String>? actuallyIncluded}) {
    return IncludedFields(
      included: included ?? this.included,
      excluded: excluded ?? this.excluded,
      actuallyIncluded: actuallyIncluded ?? this.actuallyIncluded,
    );
  }
}

class IssueBean {
  /// Expand options that include additional issue details in the response.
  final String? expand;

  /// The ID of the issue.
  final String? id;

  /// The URL of the issue details.
  final String? self;

  /// The key of the issue.
  final String? key;

  /// The rendered value of each field present on the issue.
  final Map<String, dynamic>? renderedFields;

  /// Details of the issue properties identified in the request.
  final Map<String, dynamic>? properties;

  /// The ID and name of each field present on the issue.
  final Map<String, dynamic>? names;

  /// The schema describing each field present on the issue.
  final Map<String, dynamic>? schema;

  /// The transitions that can be performed on the issue.
  final List<IssueTransition> transitions;

  /// The operations that can be performed on the issue.
  final Operations? operations;

  /// The metadata for the fields on the issue that can be amended.
  final IssueUpdateMetadata? editmeta;

  /// Details of changelogs associated with the issue.
  final PageOfChangelogs? changelog;

  /// The versions of each field on the issue.
  final Map<String, dynamic>? versionedRepresentations;
  final IncludedFields? fieldsToInclude;
  final Map<String, dynamic>? fields;

  IssueBean(
      {this.expand,
      this.id,
      this.self,
      this.key,
      this.renderedFields,
      this.properties,
      this.names,
      this.schema,
      List<IssueTransition>? transitions,
      this.operations,
      this.editmeta,
      this.changelog,
      this.versionedRepresentations,
      this.fieldsToInclude,
      this.fields})
      : transitions = transitions ?? [];

  factory IssueBean.fromJson(Map<String, Object?> json) {
    return IssueBean(
      expand: json[r'expand'] as String?,
      id: json[r'id'] as String?,
      self: json[r'self'] as String?,
      key: json[r'key'] as String?,
      renderedFields: json[r'renderedFields'] as Map<String, Object?>?,
      properties: json[r'properties'] as Map<String, Object?>?,
      names: json[r'names'] as Map<String, Object?>?,
      schema: json[r'schema'] as Map<String, Object?>?,
      transitions: (json[r'transitions'] as List<Object?>?)
              ?.map((i) => IssueTransition.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      operations: json[r'operations'] != null
          ? Operations.fromJson(json[r'operations']! as Map<String, Object?>)
          : null,
      editmeta: json[r'editmeta'] != null
          ? IssueUpdateMetadata.fromJson(
              json[r'editmeta']! as Map<String, Object?>)
          : null,
      changelog: json[r'changelog'] != null
          ? PageOfChangelogs.fromJson(
              json[r'changelog']! as Map<String, Object?>)
          : null,
      versionedRepresentations:
          json[r'versionedRepresentations'] as Map<String, Object?>?,
      fieldsToInclude: json[r'fieldsToInclude'] != null
          ? IncludedFields.fromJson(
              json[r'fieldsToInclude']! as Map<String, Object?>)
          : null,
      fields: json[r'fields'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var id = this.id;
    var self = this.self;
    var key = this.key;
    var renderedFields = this.renderedFields;
    var properties = this.properties;
    var names = this.names;
    var schema = this.schema;
    var transitions = this.transitions;
    var operations = this.operations;
    var editmeta = this.editmeta;
    var changelog = this.changelog;
    var versionedRepresentations = this.versionedRepresentations;
    var fieldsToInclude = this.fieldsToInclude;
    var fields = this.fields;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (renderedFields != null) {
      json[r'renderedFields'] = renderedFields;
    }
    if (properties != null) {
      json[r'properties'] = properties;
    }
    if (names != null) {
      json[r'names'] = names;
    }
    if (schema != null) {
      json[r'schema'] = schema;
    }
    json[r'transitions'] = transitions.map((i) => i.toJson()).toList();
    if (operations != null) {
      json[r'operations'] = operations.toJson();
    }
    if (editmeta != null) {
      json[r'editmeta'] = editmeta.toJson();
    }
    if (changelog != null) {
      json[r'changelog'] = changelog.toJson();
    }
    if (versionedRepresentations != null) {
      json[r'versionedRepresentations'] = versionedRepresentations;
    }
    if (fieldsToInclude != null) {
      json[r'fieldsToInclude'] = fieldsToInclude.toJson();
    }
    if (fields != null) {
      json[r'fields'] = fields;
    }
    return json;
  }

  IssueBean copyWith(
      {String? expand,
      String? id,
      String? self,
      String? key,
      Map<String, dynamic>? renderedFields,
      Map<String, dynamic>? properties,
      Map<String, dynamic>? names,
      Map<String, dynamic>? schema,
      List<IssueTransition>? transitions,
      Operations? operations,
      IssueUpdateMetadata? editmeta,
      PageOfChangelogs? changelog,
      Map<String, dynamic>? versionedRepresentations,
      IncludedFields? fieldsToInclude,
      Map<String, dynamic>? fields}) {
    return IssueBean(
      expand: expand ?? this.expand,
      id: id ?? this.id,
      self: self ?? this.self,
      key: key ?? this.key,
      renderedFields: renderedFields ?? this.renderedFields,
      properties: properties ?? this.properties,
      names: names ?? this.names,
      schema: schema ?? this.schema,
      transitions: transitions ?? this.transitions,
      operations: operations ?? this.operations,
      editmeta: editmeta ?? this.editmeta,
      changelog: changelog ?? this.changelog,
      versionedRepresentations:
          versionedRepresentations ?? this.versionedRepresentations,
      fieldsToInclude: fieldsToInclude ?? this.fieldsToInclude,
      fields: fields ?? this.fields,
    );
  }
}

/// Details of an issue transition.
class IssueTransition {
  /// The ID of the issue transition. Required when specifying a transition to
  /// undertake.
  final String? id;

  /// The name of the issue transition.
  final String? name;

  /// Details of the issue status after the transition.
  final StatusDetails? to;

  /// Whether there is a screen associated with the issue transition.
  final bool hasScreen;

  /// Whether the issue transition is global, that is, the transition is applied
  /// to issues regardless of their status.
  final bool isGlobal;

  /// Whether this is the initial issue transition for the workflow.
  final bool isInitial;

  /// Whether the transition is available to be performed.
  final bool isAvailable;

  /// Whether the issue has to meet criteria before the issue transition is
  /// applied.
  final bool isConditional;

  /// Details of the fields associated with the issue transition screen. Use
  /// this information to populate `fields` and `update` in a transition
  /// request.
  final Map<String, dynamic>? fields;

  /// Expand options that include additional transition details in the response.
  final String? expand;
  final bool looped;

  IssueTransition(
      {this.id,
      this.name,
      this.to,
      bool? hasScreen,
      bool? isGlobal,
      bool? isInitial,
      bool? isAvailable,
      bool? isConditional,
      this.fields,
      this.expand,
      bool? looped})
      : hasScreen = hasScreen ?? false,
        isGlobal = isGlobal ?? false,
        isInitial = isInitial ?? false,
        isAvailable = isAvailable ?? false,
        isConditional = isConditional ?? false,
        looped = looped ?? false;

  factory IssueTransition.fromJson(Map<String, Object?> json) {
    return IssueTransition(
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      to: json[r'to'] != null
          ? StatusDetails.fromJson(json[r'to']! as Map<String, Object?>)
          : null,
      hasScreen: json[r'hasScreen'] as bool? ?? false,
      isGlobal: json[r'isGlobal'] as bool? ?? false,
      isInitial: json[r'isInitial'] as bool? ?? false,
      isAvailable: json[r'isAvailable'] as bool? ?? false,
      isConditional: json[r'isConditional'] as bool? ?? false,
      fields: json[r'fields'] as Map<String, Object?>?,
      expand: json[r'expand'] as String?,
      looped: json[r'looped'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var to = this.to;
    var hasScreen = this.hasScreen;
    var isGlobal = this.isGlobal;
    var isInitial = this.isInitial;
    var isAvailable = this.isAvailable;
    var isConditional = this.isConditional;
    var fields = this.fields;
    var expand = this.expand;
    var looped = this.looped;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (to != null) {
      json[r'to'] = to.toJson();
    }
    json[r'hasScreen'] = hasScreen;
    json[r'isGlobal'] = isGlobal;
    json[r'isInitial'] = isInitial;
    json[r'isAvailable'] = isAvailable;
    json[r'isConditional'] = isConditional;
    if (fields != null) {
      json[r'fields'] = fields;
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    json[r'looped'] = looped;
    return json;
  }

  IssueTransition copyWith(
      {String? id,
      String? name,
      StatusDetails? to,
      bool? hasScreen,
      bool? isGlobal,
      bool? isInitial,
      bool? isAvailable,
      bool? isConditional,
      Map<String, dynamic>? fields,
      String? expand,
      bool? looped}) {
    return IssueTransition(
      id: id ?? this.id,
      name: name ?? this.name,
      to: to ?? this.to,
      hasScreen: hasScreen ?? this.hasScreen,
      isGlobal: isGlobal ?? this.isGlobal,
      isInitial: isInitial ?? this.isInitial,
      isAvailable: isAvailable ?? this.isAvailable,
      isConditional: isConditional ?? this.isConditional,
      fields: fields ?? this.fields,
      expand: expand ?? this.expand,
      looped: looped ?? this.looped,
    );
  }
}

/// A list of editable field details.
class IssueUpdateMetadata {
  /// A list of editable field details.
  final Map<String, dynamic>? fields;

  IssueUpdateMetadata({this.fields});

  factory IssueUpdateMetadata.fromJson(Map<String, Object?> json) {
    return IssueUpdateMetadata(
      fields: json[r'fields'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var fields = this.fields;

    final json = <String, Object?>{};
    if (fields != null) {
      json[r'fields'] = fields;
    }
    return json;
  }

  IssueUpdateMetadata copyWith({Map<String, dynamic>? fields}) {
    return IssueUpdateMetadata(
      fields: fields ?? this.fields,
    );
  }
}

/// Details a link group, which defines issue operations.
class LinkGroup {
  final String? id;
  final String? styleClass;
  final SimpleLink? header;
  final int? weight;
  final List<SimpleLink> links;
  final List<LinkGroup> groups;

  LinkGroup(
      {this.id,
      this.styleClass,
      this.header,
      this.weight,
      List<SimpleLink>? links,
      List<LinkGroup>? groups})
      : links = links ?? [],
        groups = groups ?? [];

  factory LinkGroup.fromJson(Map<String, Object?> json) {
    return LinkGroup(
      id: json[r'id'] as String?,
      styleClass: json[r'styleClass'] as String?,
      header: json[r'header'] != null
          ? SimpleLink.fromJson(json[r'header']! as Map<String, Object?>)
          : null,
      weight: (json[r'weight'] as num?)?.toInt(),
      links: (json[r'links'] as List<Object?>?)
              ?.map((i) =>
                  SimpleLink.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      groups: (json[r'groups'] as List<Object?>?)
              ?.map((i) =>
                  LinkGroup.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var styleClass = this.styleClass;
    var header = this.header;
    var weight = this.weight;
    var links = this.links;
    var groups = this.groups;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (styleClass != null) {
      json[r'styleClass'] = styleClass;
    }
    if (header != null) {
      json[r'header'] = header.toJson();
    }
    if (weight != null) {
      json[r'weight'] = weight;
    }
    json[r'links'] = links.map((i) => i.toJson()).toList();
    json[r'groups'] = groups.map((i) => i.toJson()).toList();
    return json;
  }

  LinkGroup copyWith(
      {String? id,
      String? styleClass,
      SimpleLink? header,
      int? weight,
      List<SimpleLink>? links,
      List<LinkGroup>? groups}) {
    return LinkGroup(
      id: id ?? this.id,
      styleClass: styleClass ?? this.styleClass,
      header: header ?? this.header,
      weight: weight ?? this.weight,
      links: links ?? this.links,
      groups: groups ?? this.groups,
    );
  }
}

/// Details of the operations that can be performed on the issue.
class Operations {
  /// Details of the link groups defining issue operations.
  final List<LinkGroup> linkGroups;

  Operations({List<LinkGroup>? linkGroups}) : linkGroups = linkGroups ?? [];

  factory Operations.fromJson(Map<String, Object?> json) {
    return Operations(
      linkGroups: (json[r'linkGroups'] as List<Object?>?)
              ?.map((i) =>
                  LinkGroup.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var linkGroups = this.linkGroups;

    final json = <String, Object?>{};
    json[r'linkGroups'] = linkGroups.map((i) => i.toJson()).toList();
    return json;
  }

  Operations copyWith({List<LinkGroup>? linkGroups}) {
    return Operations(
      linkGroups: linkGroups ?? this.linkGroups,
    );
  }
}

/// A page of changelogs.
class PageOfChangelogs {
  /// The index of the first item returned on the page.
  final int? startAt;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The number of results on the page.
  final int? total;

  /// The list of changelogs.
  final List<Changelog> histories;

  PageOfChangelogs(
      {this.startAt, this.maxResults, this.total, List<Changelog>? histories})
      : histories = histories ?? [];

  factory PageOfChangelogs.fromJson(Map<String, Object?> json) {
    return PageOfChangelogs(
      startAt: (json[r'startAt'] as num?)?.toInt(),
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      histories: (json[r'histories'] as List<Object?>?)
              ?.map((i) =>
                  Changelog.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var startAt = this.startAt;
    var maxResults = this.maxResults;
    var total = this.total;
    var histories = this.histories;

    final json = <String, Object?>{};
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'histories'] = histories.map((i) => i.toJson()).toList();
    return json;
  }

  PageOfChangelogs copyWith(
      {int? startAt, int? maxResults, int? total, List<Changelog>? histories}) {
    return PageOfChangelogs(
      startAt: startAt ?? this.startAt,
      maxResults: maxResults ?? this.maxResults,
      total: total ?? this.total,
      histories: histories ?? this.histories,
    );
  }
}

/// The result of a JQL search.
class SearchResults {
  /// Expand options that include additional search result details in the
  /// response.
  final String? expand;

  /// The index of the first item returned on the page.
  final int? startAt;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The number of results on the page.
  final int? total;

  /// The list of issues found by the search.
  final List<IssueBean> issues;

  /// Any warnings related to the JQL query.
  final List<String> warningMessages;

  /// The ID and name of each field in the search results.
  final Map<String, dynamic>? names;

  /// The schema describing the field types in the search results.
  final Map<String, dynamic>? schema;

  SearchResults(
      {this.expand,
      this.startAt,
      this.maxResults,
      this.total,
      List<IssueBean>? issues,
      List<String>? warningMessages,
      this.names,
      this.schema})
      : issues = issues ?? [],
        warningMessages = warningMessages ?? [];

  factory SearchResults.fromJson(Map<String, Object?> json) {
    return SearchResults(
      expand: json[r'expand'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      issues: (json[r'issues'] as List<Object?>?)
              ?.map((i) =>
                  IssueBean.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      warningMessages: (json[r'warningMessages'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      names: json[r'names'] as Map<String, Object?>?,
      schema: json[r'schema'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var startAt = this.startAt;
    var maxResults = this.maxResults;
    var total = this.total;
    var issues = this.issues;
    var warningMessages = this.warningMessages;
    var names = this.names;
    var schema = this.schema;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'issues'] = issues.map((i) => i.toJson()).toList();
    json[r'warningMessages'] = warningMessages;
    if (names != null) {
      json[r'names'] = names;
    }
    if (schema != null) {
      json[r'schema'] = schema;
    }
    return json;
  }

  SearchResults copyWith(
      {String? expand,
      int? startAt,
      int? maxResults,
      int? total,
      List<IssueBean>? issues,
      List<String>? warningMessages,
      Map<String, dynamic>? names,
      Map<String, dynamic>? schema}) {
    return SearchResults(
      expand: expand ?? this.expand,
      startAt: startAt ?? this.startAt,
      maxResults: maxResults ?? this.maxResults,
      total: total ?? this.total,
      issues: issues ?? this.issues,
      warningMessages: warningMessages ?? this.warningMessages,
      names: names ?? this.names,
      schema: schema ?? this.schema,
    );
  }
}

/// Details about the operations available in this version.
class SimpleLink {
  final String? id;
  final String? styleClass;
  final String? iconClass;
  final String? label;
  final String? title;
  final String? href;
  final int? weight;

  SimpleLink(
      {this.id,
      this.styleClass,
      this.iconClass,
      this.label,
      this.title,
      this.href,
      this.weight});

  factory SimpleLink.fromJson(Map<String, Object?> json) {
    return SimpleLink(
      id: json[r'id'] as String?,
      styleClass: json[r'styleClass'] as String?,
      iconClass: json[r'iconClass'] as String?,
      label: json[r'label'] as String?,
      title: json[r'title'] as String?,
      href: json[r'href'] as String?,
      weight: (json[r'weight'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var styleClass = this.styleClass;
    var iconClass = this.iconClass;
    var label = this.label;
    var title = this.title;
    var href = this.href;
    var weight = this.weight;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (styleClass != null) {
      json[r'styleClass'] = styleClass;
    }
    if (iconClass != null) {
      json[r'iconClass'] = iconClass;
    }
    if (label != null) {
      json[r'label'] = label;
    }
    if (title != null) {
      json[r'title'] = title;
    }
    if (href != null) {
      json[r'href'] = href;
    }
    if (weight != null) {
      json[r'weight'] = weight;
    }
    return json;
  }

  SimpleLink copyWith(
      {String? id,
      String? styleClass,
      String? iconClass,
      String? label,
      String? title,
      String? href,
      int? weight}) {
    return SimpleLink(
      id: id ?? this.id,
      styleClass: styleClass ?? this.styleClass,
      iconClass: iconClass ?? this.iconClass,
      label: label ?? this.label,
      title: title ?? this.title,
      href: href ?? this.href,
      weight: weight ?? this.weight,
    );
  }
}

/// A status category.
class StatusCategory {
  /// The URL of the status category.
  final String? self;

  /// The ID of the status category.
  final int? id;

  /// The key of the status category.
  final String? key;

  /// The name of the color used to represent the status category.
  final String? colorName;

  /// The name of the status category.
  final String? name;

  StatusCategory({this.self, this.id, this.key, this.colorName, this.name});

  factory StatusCategory.fromJson(Map<String, Object?> json) {
    return StatusCategory(
      self: json[r'self'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      key: json[r'key'] as String?,
      colorName: json[r'colorName'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var key = this.key;
    var colorName = this.colorName;
    var name = this.name;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (colorName != null) {
      json[r'colorName'] = colorName;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  StatusCategory copyWith(
      {String? self, int? id, String? key, String? colorName, String? name}) {
    return StatusCategory(
      self: self ?? this.self,
      id: id ?? this.id,
      key: key ?? this.key,
      colorName: colorName ?? this.colorName,
      name: name ?? this.name,
    );
  }
}

/// A status.
class StatusDetails {
  /// The URL of the status.
  final String? self;

  /// The description of the status.
  final String? description;

  /// The URL of the icon used to represent the status.
  final String? iconUrl;

  /// The name of the status.
  final String? name;

  /// The ID of the status.
  final String? id;

  /// The category assigned to the status.
  final StatusCategory? statusCategory;

  StatusDetails(
      {this.self,
      this.description,
      this.iconUrl,
      this.name,
      this.id,
      this.statusCategory});

  factory StatusDetails.fromJson(Map<String, Object?> json) {
    return StatusDetails(
      self: json[r'self'] as String?,
      description: json[r'description'] as String?,
      iconUrl: json[r'iconUrl'] as String?,
      name: json[r'name'] as String?,
      id: json[r'id'] as String?,
      statusCategory: json[r'statusCategory'] != null
          ? StatusCategory.fromJson(
              json[r'statusCategory']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var description = this.description;
    var iconUrl = this.iconUrl;
    var name = this.name;
    var id = this.id;
    var statusCategory = this.statusCategory;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (iconUrl != null) {
      json[r'iconUrl'] = iconUrl;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (statusCategory != null) {
      json[r'statusCategory'] = statusCategory.toJson();
    }
    return json;
  }

  StatusDetails copyWith(
      {String? self,
      String? description,
      String? iconUrl,
      String? name,
      String? id,
      StatusCategory? statusCategory}) {
    return StatusDetails(
      self: self ?? this.self,
      description: description ?? this.description,
      iconUrl: iconUrl ?? this.iconUrl,
      name: name ?? this.name,
      id: id ?? this.id,
      statusCategory: statusCategory ?? this.statusCategory,
    );
  }
}

class SearchRequestBean {
  /// A [JQL](https://confluence.atlassian.com/x/egORLQ) expression.
  final String? jql;

  /// The index of the first item to return in the page of results (page
  /// offset). The base index is `0`.
  final int? startAt;

  /// The maximum number of items to return per page.
  final int? maxResults;

  /// A list of fields to return for each issue, use it to retrieve a subset of
  /// fields. This parameter accepts a comma-separated list. Expand options
  /// include:
  ///
  ///  *  `*all` Returns all fields.
  ///  *  `*navigable` Returns navigable fields.
  ///  *  Any issue field, prefixed with a minus to exclude.
  ///
  /// The default is `*navigable`.
  ///
  /// Examples:
  ///
  ///  *  `summary,comment` Returns the summary and comments fields only.
  ///  *  `-description` Returns all navigable (default) fields except
  /// description.
  ///  *  `*all,-comment` Returns all fields except comments.
  ///
  /// Multiple `fields` parameters can be included in a request.
  ///
  /// Note: All navigable fields are returned by default. This differs from
  /// [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is
  /// all fields.
  final List<String> fields;

  /// Determines how to validate the JQL query and treat the validation results.
  /// Supported values:
  ///
  ///  *  `strict` Returns a 400 response code if any errors are found, along
  /// with a list of all errors (and warnings).
  ///  *  `warn` Returns all errors as warnings.
  ///  *  `none` No validation is performed.
  ///  *  `true` *Deprecated* A legacy synonym for `strict`.
  ///  *  `false` *Deprecated* A legacy synonym for `warn`.
  ///
  /// The default is `strict`.
  ///
  /// Note: If the JQL is not correctly formed a 400 response code is returned,
  /// regardless of the `validateQuery` value.
  final SearchRequestBeanValidateQuery? validateQuery;

  /// Use [expand](em>#expansion) to include additional information about issues
  /// in the response. Note that, unlike the majority of instances where
  /// `expand` is specified, `expand` is defined as a list of values. The expand
  /// options are:
  ///
  ///  *  `renderedFields` Returns field values rendered in HTML format.
  ///  *  `names` Returns the display name of each field.
  ///  *  `schema` Returns the schema describing a field type.
  ///  *  `transitions` Returns all possible transitions for the issue.
  ///  *  `operations` Returns all possible operations for the issue.
  ///  *  `editmeta` Returns information about how each field can be edited.
  ///  *  `changelog` Returns a list of recent updates to an issue, sorted by
  /// date, starting from the most recent.
  ///  *  `versionedRepresentations` Instead of `fields`, returns
  /// `versionedRepresentations` a JSON array containing each version of a
  /// field's value, with the highest numbered item representing the most recent
  /// version.
  final List<String> expand;

  /// A list of up to 5 issue properties to include in the results. This
  /// parameter accepts a comma-separated list.
  final List<String> properties;

  /// Reference fields by their key (rather than ID). The default is `false`.
  final bool fieldsByKeys;

  SearchRequestBean(
      {this.jql,
      this.startAt,
      this.maxResults,
      List<String>? fields,
      this.validateQuery,
      List<String>? expand,
      List<String>? properties,
      bool? fieldsByKeys})
      : fields = fields ?? [],
        expand = expand ?? [],
        properties = properties ?? [],
        fieldsByKeys = fieldsByKeys ?? false;

  factory SearchRequestBean.fromJson(Map<String, Object?> json) {
    return SearchRequestBean(
      jql: json[r'jql'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      fields: (json[r'fields'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      validateQuery: json[r'validateQuery'] != null
          ? SearchRequestBeanValidateQuery.fromValue(
              json[r'validateQuery']! as String)
          : null,
      expand: (json[r'expand'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      properties: (json[r'properties'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      fieldsByKeys: json[r'fieldsByKeys'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var jql = this.jql;
    var startAt = this.startAt;
    var maxResults = this.maxResults;
    var fields = this.fields;
    var validateQuery = this.validateQuery;
    var expand = this.expand;
    var properties = this.properties;
    var fieldsByKeys = this.fieldsByKeys;

    final json = <String, Object?>{};
    if (jql != null) {
      json[r'jql'] = jql;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    json[r'fields'] = fields;
    if (validateQuery != null) {
      json[r'validateQuery'] = validateQuery.value;
    }
    json[r'expand'] = expand;
    json[r'properties'] = properties;
    json[r'fieldsByKeys'] = fieldsByKeys;
    return json;
  }

  SearchRequestBean copyWith(
      {String? jql,
      int? startAt,
      int? maxResults,
      List<String>? fields,
      SearchRequestBeanValidateQuery? validateQuery,
      List<String>? expand,
      List<String>? properties,
      bool? fieldsByKeys}) {
    return SearchRequestBean(
      jql: jql ?? this.jql,
      startAt: startAt ?? this.startAt,
      maxResults: maxResults ?? this.maxResults,
      fields: fields ?? this.fields,
      validateQuery: validateQuery ?? this.validateQuery,
      expand: expand ?? this.expand,
      properties: properties ?? this.properties,
      fieldsByKeys: fieldsByKeys ?? this.fieldsByKeys,
    );
  }
}

class SearchRequestBeanValidateQuery {
  static const strict = SearchRequestBeanValidateQuery._('strict');
  static const warn = SearchRequestBeanValidateQuery._('warn');
  static const none = SearchRequestBeanValidateQuery._('none');
  static const true$ = SearchRequestBeanValidateQuery._('true');
  static const false$ = SearchRequestBeanValidateQuery._('false');

  static const values = [
    strict,
    warn,
    none,
    true$,
    false$,
  ];
  final String value;

  const SearchRequestBeanValidateQuery._(this.value);

  static SearchRequestBeanValidateQuery fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => SearchRequestBeanValidateQuery._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of a field that can be used in advanced searches.
class FieldReferenceData {
  /// The field identifier.
  final String? value;

  /// The display name of the field.
  final String? displayName;

  /// Whether the field can be used in a query's `ORDER BY` clause.
  final FieldReferenceDataOrderable? orderable;

  /// Whether the content of this field can be searched.
  final FieldReferenceDataSearchable? searchable;

  /// Whether the field provide auto-complete suggestions.
  final FieldReferenceDataAuto? auto;

  /// If the item is a custom field, the ID of the custom field.
  final String? cfid;

  /// The valid search operators for the field.
  final List<String> operators;

  /// The data types of items in the field.
  final List<String> types;

  FieldReferenceData(
      {this.value,
      this.displayName,
      this.orderable,
      this.searchable,
      this.auto,
      this.cfid,
      List<String>? operators,
      List<String>? types})
      : operators = operators ?? [],
        types = types ?? [];

  factory FieldReferenceData.fromJson(Map<String, Object?> json) {
    return FieldReferenceData(
      value: json[r'value'] as String?,
      displayName: json[r'displayName'] as String?,
      orderable: json[r'orderable'] != null
          ? FieldReferenceDataOrderable.fromValue(json[r'orderable']! as String)
          : null,
      searchable: json[r'searchable'] != null
          ? FieldReferenceDataSearchable.fromValue(
              json[r'searchable']! as String)
          : null,
      auto: json[r'auto'] != null
          ? FieldReferenceDataAuto.fromValue(json[r'auto']! as String)
          : null,
      cfid: json[r'cfid'] as String?,
      operators: (json[r'operators'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      types: (json[r'types'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;
    var displayName = this.displayName;
    var orderable = this.orderable;
    var searchable = this.searchable;
    var auto = this.auto;
    var cfid = this.cfid;
    var operators = this.operators;
    var types = this.types;

    final json = <String, Object?>{};
    if (value != null) {
      json[r'value'] = value;
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (orderable != null) {
      json[r'orderable'] = orderable.value;
    }
    if (searchable != null) {
      json[r'searchable'] = searchable.value;
    }
    if (auto != null) {
      json[r'auto'] = auto.value;
    }
    if (cfid != null) {
      json[r'cfid'] = cfid;
    }
    json[r'operators'] = operators;
    json[r'types'] = types;
    return json;
  }

  FieldReferenceData copyWith(
      {String? value,
      String? displayName,
      FieldReferenceDataOrderable? orderable,
      FieldReferenceDataSearchable? searchable,
      FieldReferenceDataAuto? auto,
      String? cfid,
      List<String>? operators,
      List<String>? types}) {
    return FieldReferenceData(
      value: value ?? this.value,
      displayName: displayName ?? this.displayName,
      orderable: orderable ?? this.orderable,
      searchable: searchable ?? this.searchable,
      auto: auto ?? this.auto,
      cfid: cfid ?? this.cfid,
      operators: operators ?? this.operators,
      types: types ?? this.types,
    );
  }
}

class FieldReferenceDataOrderable {
  static const true$ = FieldReferenceDataOrderable._('true');
  static const false$ = FieldReferenceDataOrderable._('false');

  static const values = [
    true$,
    false$,
  ];
  final String value;

  const FieldReferenceDataOrderable._(this.value);

  static FieldReferenceDataOrderable fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldReferenceDataOrderable._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class FieldReferenceDataSearchable {
  static const true$ = FieldReferenceDataSearchable._('true');
  static const false$ = FieldReferenceDataSearchable._('false');

  static const values = [
    true$,
    false$,
  ];
  final String value;

  const FieldReferenceDataSearchable._(this.value);

  static FieldReferenceDataSearchable fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldReferenceDataSearchable._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class FieldReferenceDataAuto {
  static const true$ = FieldReferenceDataAuto._('true');
  static const false$ = FieldReferenceDataAuto._('false');

  static const values = [
    true$,
    false$,
  ];
  final String value;

  const FieldReferenceDataAuto._(this.value);

  static FieldReferenceDataAuto fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldReferenceDataAuto._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of functions that can be used in advanced searches.
class FunctionReferenceData {
  /// The function identifier.
  final String? value;

  /// The display name of the function.
  final String? displayName;

  /// Whether the function can take a list of arguments.
  final FunctionReferenceDataIsList? isList;

  /// The data types returned by the function.
  final List<String> types;

  FunctionReferenceData(
      {this.value, this.displayName, this.isList, List<String>? types})
      : types = types ?? [];

  factory FunctionReferenceData.fromJson(Map<String, Object?> json) {
    return FunctionReferenceData(
      value: json[r'value'] as String?,
      displayName: json[r'displayName'] as String?,
      isList: json[r'isList'] != null
          ? FunctionReferenceDataIsList.fromValue(json[r'isList']! as String)
          : null,
      types: (json[r'types'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;
    var displayName = this.displayName;
    var isList = this.isList;
    var types = this.types;

    final json = <String, Object?>{};
    if (value != null) {
      json[r'value'] = value;
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (isList != null) {
      json[r'isList'] = isList.value;
    }
    json[r'types'] = types;
    return json;
  }

  FunctionReferenceData copyWith(
      {String? value,
      String? displayName,
      FunctionReferenceDataIsList? isList,
      List<String>? types}) {
    return FunctionReferenceData(
      value: value ?? this.value,
      displayName: displayName ?? this.displayName,
      isList: isList ?? this.isList,
      types: types ?? this.types,
    );
  }
}

class FunctionReferenceDataIsList {
  static const true$ = FunctionReferenceDataIsList._('true');
  static const false$ = FunctionReferenceDataIsList._('false');

  static const values = [
    true$,
    false$,
  ];
  final String value;

  const FunctionReferenceDataIsList._(this.value);

  static FunctionReferenceDataIsList fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FunctionReferenceDataIsList._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Lists of JQL reference data.
class JQLReferenceData {
  /// List of fields usable in JQL queries.
  final List<FieldReferenceData> visibleFieldNames;

  /// List of functions usable in JQL queries.
  final List<FunctionReferenceData> visibleFunctionNames;

  /// List of JQL query reserved words.
  final List<String> jqlReservedWords;

  JQLReferenceData(
      {List<FieldReferenceData>? visibleFieldNames,
      List<FunctionReferenceData>? visibleFunctionNames,
      List<String>? jqlReservedWords})
      : visibleFieldNames = visibleFieldNames ?? [],
        visibleFunctionNames = visibleFunctionNames ?? [],
        jqlReservedWords = jqlReservedWords ?? [];

  factory JQLReferenceData.fromJson(Map<String, Object?> json) {
    return JQLReferenceData(
      visibleFieldNames: (json[r'visibleFieldNames'] as List<Object?>?)
              ?.map((i) => FieldReferenceData.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      visibleFunctionNames: (json[r'visibleFunctionNames'] as List<Object?>?)
              ?.map((i) => FunctionReferenceData.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      jqlReservedWords: (json[r'jqlReservedWords'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var visibleFieldNames = this.visibleFieldNames;
    var visibleFunctionNames = this.visibleFunctionNames;
    var jqlReservedWords = this.jqlReservedWords;

    final json = <String, Object?>{};
    json[r'visibleFieldNames'] =
        visibleFieldNames.map((i) => i.toJson()).toList();
    json[r'visibleFunctionNames'] =
        visibleFunctionNames.map((i) => i.toJson()).toList();
    json[r'jqlReservedWords'] = jqlReservedWords;
    return json;
  }

  JQLReferenceData copyWith(
      {List<FieldReferenceData>? visibleFieldNames,
      List<FunctionReferenceData>? visibleFunctionNames,
      List<String>? jqlReservedWords}) {
    return JQLReferenceData(
      visibleFieldNames: visibleFieldNames ?? this.visibleFieldNames,
      visibleFunctionNames: visibleFunctionNames ?? this.visibleFunctionNames,
      jqlReservedWords: jqlReservedWords ?? this.jqlReservedWords,
    );
  }
}

/// A field auto-complete suggestion.
class AutoCompleteSuggestion {
  /// The value of a suggested item.
  final String? value;

  /// The display name of a suggested item. If `fieldValue` or `predicateValue`
  /// are provided, the matching text is highlighted with the HTML bold tag.
  final String? displayName;

  AutoCompleteSuggestion({this.value, this.displayName});

  factory AutoCompleteSuggestion.fromJson(Map<String, Object?> json) {
    return AutoCompleteSuggestion(
      value: json[r'value'] as String?,
      displayName: json[r'displayName'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;
    var displayName = this.displayName;

    final json = <String, Object?>{};
    if (value != null) {
      json[r'value'] = value;
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    return json;
  }

  AutoCompleteSuggestion copyWith({String? value, String? displayName}) {
    return AutoCompleteSuggestion(
      value: value ?? this.value,
      displayName: displayName ?? this.displayName,
    );
  }
}

/// The results from a JQL query.
class AutoCompleteSuggestions {
  /// The list of suggested item.
  final List<AutoCompleteSuggestion> results;

  AutoCompleteSuggestions({List<AutoCompleteSuggestion>? results})
      : results = results ?? [];

  factory AutoCompleteSuggestions.fromJson(Map<String, Object?> json) {
    return AutoCompleteSuggestions(
      results: (json[r'results'] as List<Object?>?)
              ?.map((i) => AutoCompleteSuggestion.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var results = this.results;

    final json = <String, Object?>{};
    json[r'results'] = results.map((i) => i.toJson()).toList();
    return json;
  }

  AutoCompleteSuggestions copyWith({List<AutoCompleteSuggestion>? results}) {
    return AutoCompleteSuggestions(
      results: results ?? this.results,
    );
  }
}

/// The JQL queries to be converted.
class JQLPersonalDataMigrationRequest {
  /// A list of queries with user identifiers. Maximum of 100 queries.
  final List<String> queryStrings;

  JQLPersonalDataMigrationRequest({List<String>? queryStrings})
      : queryStrings = queryStrings ?? [];

  factory JQLPersonalDataMigrationRequest.fromJson(Map<String, Object?> json) {
    return JQLPersonalDataMigrationRequest(
      queryStrings: (json[r'queryStrings'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var queryStrings = this.queryStrings;

    final json = <String, Object?>{};
    json[r'queryStrings'] = queryStrings;
    return json;
  }

  JQLPersonalDataMigrationRequest copyWith({List<String>? queryStrings}) {
    return JQLPersonalDataMigrationRequest(
      queryStrings: queryStrings ?? this.queryStrings,
    );
  }
}

/// The converted JQL queries.
class ConvertedJQLQueries {
  /// The list of converted query strings with account IDs in place of user
  /// identifiers.
  final List<String> queryStrings;

  /// List of queries containing user information that could not be mapped to an
  /// existing user
  final List<JQLQueryWithUnknownUsers> queriesWithUnknownUsers;

  ConvertedJQLQueries(
      {List<String>? queryStrings,
      List<JQLQueryWithUnknownUsers>? queriesWithUnknownUsers})
      : queryStrings = queryStrings ?? [],
        queriesWithUnknownUsers = queriesWithUnknownUsers ?? [];

  factory ConvertedJQLQueries.fromJson(Map<String, Object?> json) {
    return ConvertedJQLQueries(
      queryStrings: (json[r'queryStrings'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      queriesWithUnknownUsers:
          (json[r'queriesWithUnknownUsers'] as List<Object?>?)
                  ?.map((i) => JQLQueryWithUnknownUsers.fromJson(
                      i as Map<String, Object?>? ?? const {}))
                  .toList() ??
              [],
    );
  }

  Map<String, Object?> toJson() {
    var queryStrings = this.queryStrings;
    var queriesWithUnknownUsers = this.queriesWithUnknownUsers;

    final json = <String, Object?>{};
    json[r'queryStrings'] = queryStrings;
    json[r'queriesWithUnknownUsers'] =
        queriesWithUnknownUsers.map((i) => i.toJson()).toList();
    return json;
  }

  ConvertedJQLQueries copyWith(
      {List<String>? queryStrings,
      List<JQLQueryWithUnknownUsers>? queriesWithUnknownUsers}) {
    return ConvertedJQLQueries(
      queryStrings: queryStrings ?? this.queryStrings,
      queriesWithUnknownUsers:
          queriesWithUnknownUsers ?? this.queriesWithUnknownUsers,
    );
  }
}

/// JQL queries that contained users that could not be found
class JQLQueryWithUnknownUsers {
  /// The original query, for reference
  final String? originalQuery;

  /// The converted query, with accountIDs instead of user identifiers, or
  /// 'unknown' for users that could not be found
  final String? convertedQuery;

  JQLQueryWithUnknownUsers({this.originalQuery, this.convertedQuery});

  factory JQLQueryWithUnknownUsers.fromJson(Map<String, Object?> json) {
    return JQLQueryWithUnknownUsers(
      originalQuery: json[r'originalQuery'] as String?,
      convertedQuery: json[r'convertedQuery'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var originalQuery = this.originalQuery;
    var convertedQuery = this.convertedQuery;

    final json = <String, Object?>{};
    if (originalQuery != null) {
      json[r'originalQuery'] = originalQuery;
    }
    if (convertedQuery != null) {
      json[r'convertedQuery'] = convertedQuery;
    }
    return json;
  }

  JQLQueryWithUnknownUsers copyWith(
      {String? originalQuery, String? convertedQuery}) {
    return JQLQueryWithUnknownUsers(
      originalQuery: originalQuery ?? this.originalQuery,
      convertedQuery: convertedQuery ?? this.convertedQuery,
    );
  }
}

/// Details about a project component.
class Component {
  /// The URL of the component.
  final String? self;

  /// The unique identifier for the component.
  final String? id;

  /// The unique name for the component in the project. Required when creating a
  /// component. Optional when updating a component. The maximum length is 255
  /// characters.
  final String? name;

  /// The description for the component. Optional when creating or updating a
  /// component.
  final String? description;

  /// The user details for the component's lead user.
  final User? lead;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? leadUserName;

  /// The accountId of the component's lead user. The accountId uniquely
  /// identifies the user across all Atlassian products. For example,
  /// *5b10ac8d82e05b22cc7d4ef5*.
  final String? leadAccountId;

  /// The nominal user type used to determine the assignee for issues created
  /// with this component. See `realAssigneeType` for details on how the type of
  /// the user, and hence the user, assigned to issues is determined. Can take
  /// the following values:
  ///
  ///  *  `PROJECT_LEAD` the assignee to any issues created with this component
  /// is nominally the lead for the project the component is in.
  ///  *  `COMPONENT_LEAD` the assignee to any issues created with this
  /// component is nominally the lead for the component.
  ///  *  `UNASSIGNED` an assignee is not set for issues created with this
  /// component.
  ///  *  `PROJECT_DEFAULT` the assignee to any issues created with this
  /// component is nominally the default assignee for the project that the
  /// component is in.
  ///
  /// Default value: `PROJECT_DEFAULT`.
  /// Optional when creating or updating a component.
  final ComponentAssigneeType? assigneeType;

  /// The details of the user associated with `assigneeType`, if any. See
  /// `realAssignee` for details of the user assigned to issues created with
  /// this component.
  final User? assignee;

  /// The type of the assignee that is assigned to issues created with this
  /// component, when an assignee cannot be set from the `assigneeType`. For
  /// example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead
  /// is set. This property is set to one of the following values:
  ///
  ///  *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project
  /// lead has permission to be assigned issues in the project that the
  /// component is in.
  ///  *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the
  /// component lead has permission to be assigned issues in the project that
  /// the component is in.
  ///  *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is
  /// configured to allow unassigned issues.
  ///  *  `PROJECT_DEFAULT` when none of the preceding cases are true.
  final ComponentRealAssigneeType? realAssigneeType;

  /// The user assigned to issues created with this component, when
  /// `assigneeType` does not identify a valid assignee.
  final User? realAssignee;

  /// Whether a user is associated with `assigneeType`. For example, if the
  /// `assigneeType` is set to `COMPONENT_LEAD` but the component lead is not
  /// set, then `false` is returned.
  final bool isAssigneeTypeValid;

  /// The key of the project the component is assigned to. Required when
  /// creating a component. Can't be updated.
  final String? project;

  /// The ID of the project the component is assigned to.
  final int? projectId;

  Component(
      {this.self,
      this.id,
      this.name,
      this.description,
      this.lead,
      this.leadUserName,
      this.leadAccountId,
      this.assigneeType,
      this.assignee,
      this.realAssigneeType,
      this.realAssignee,
      bool? isAssigneeTypeValid,
      this.project,
      this.projectId})
      : isAssigneeTypeValid = isAssigneeTypeValid ?? false;

  factory Component.fromJson(Map<String, Object?> json) {
    return Component(
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      lead: json[r'lead'] != null
          ? User.fromJson(json[r'lead']! as Map<String, Object?>)
          : null,
      leadUserName: json[r'leadUserName'] as String?,
      leadAccountId: json[r'leadAccountId'] as String?,
      assigneeType: json[r'assigneeType'] != null
          ? ComponentAssigneeType.fromValue(json[r'assigneeType']! as String)
          : null,
      assignee: json[r'assignee'] != null
          ? User.fromJson(json[r'assignee']! as Map<String, Object?>)
          : null,
      realAssigneeType: json[r'realAssigneeType'] != null
          ? ComponentRealAssigneeType.fromValue(
              json[r'realAssigneeType']! as String)
          : null,
      realAssignee: json[r'realAssignee'] != null
          ? User.fromJson(json[r'realAssignee']! as Map<String, Object?>)
          : null,
      isAssigneeTypeValid: json[r'isAssigneeTypeValid'] as bool? ?? false,
      project: json[r'project'] as String?,
      projectId: (json[r'projectId'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var lead = this.lead;
    var leadUserName = this.leadUserName;
    var leadAccountId = this.leadAccountId;
    var assigneeType = this.assigneeType;
    var assignee = this.assignee;
    var realAssigneeType = this.realAssigneeType;
    var realAssignee = this.realAssignee;
    var isAssigneeTypeValid = this.isAssigneeTypeValid;
    var project = this.project;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (lead != null) {
      json[r'lead'] = lead.toJson();
    }
    if (leadUserName != null) {
      json[r'leadUserName'] = leadUserName;
    }
    if (leadAccountId != null) {
      json[r'leadAccountId'] = leadAccountId;
    }
    if (assigneeType != null) {
      json[r'assigneeType'] = assigneeType.value;
    }
    if (assignee != null) {
      json[r'assignee'] = assignee.toJson();
    }
    if (realAssigneeType != null) {
      json[r'realAssigneeType'] = realAssigneeType.value;
    }
    if (realAssignee != null) {
      json[r'realAssignee'] = realAssignee.toJson();
    }
    json[r'isAssigneeTypeValid'] = isAssigneeTypeValid;
    if (project != null) {
      json[r'project'] = project;
    }
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    return json;
  }

  Component copyWith(
      {String? self,
      String? id,
      String? name,
      String? description,
      User? lead,
      String? leadUserName,
      String? leadAccountId,
      ComponentAssigneeType? assigneeType,
      User? assignee,
      ComponentRealAssigneeType? realAssigneeType,
      User? realAssignee,
      bool? isAssigneeTypeValid,
      String? project,
      int? projectId}) {
    return Component(
      self: self ?? this.self,
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      lead: lead ?? this.lead,
      leadUserName: leadUserName ?? this.leadUserName,
      leadAccountId: leadAccountId ?? this.leadAccountId,
      assigneeType: assigneeType ?? this.assigneeType,
      assignee: assignee ?? this.assignee,
      realAssigneeType: realAssigneeType ?? this.realAssigneeType,
      realAssignee: realAssignee ?? this.realAssignee,
      isAssigneeTypeValid: isAssigneeTypeValid ?? this.isAssigneeTypeValid,
      project: project ?? this.project,
      projectId: projectId ?? this.projectId,
    );
  }
}

class ComponentAssigneeType {
  static const projectDefault = ComponentAssigneeType._('PROJECT_DEFAULT');
  static const componentLead = ComponentAssigneeType._('COMPONENT_LEAD');
  static const projectLead = ComponentAssigneeType._('PROJECT_LEAD');
  static const unassigned = ComponentAssigneeType._('UNASSIGNED');

  static const values = [
    projectDefault,
    componentLead,
    projectLead,
    unassigned,
  ];
  final String value;

  const ComponentAssigneeType._(this.value);

  static ComponentAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ComponentAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ComponentRealAssigneeType {
  static const projectDefault = ComponentRealAssigneeType._('PROJECT_DEFAULT');
  static const componentLead = ComponentRealAssigneeType._('COMPONENT_LEAD');
  static const projectLead = ComponentRealAssigneeType._('PROJECT_LEAD');
  static const unassigned = ComponentRealAssigneeType._('UNASSIGNED');

  static const values = [
    projectDefault,
    componentLead,
    projectLead,
    unassigned,
  ];
  final String value;

  const ComponentRealAssigneeType._(this.value);

  static ComponentRealAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ComponentRealAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about a filter.
class Filter {
  /// The URL of the filter.
  final String? self;

  /// The unique identifier for the filter.
  final String? id;

  /// The name of the filter. Must be unique.
  final String name;

  /// A description of the filter.
  final String? description;

  /// The user who owns the filter. This is defaulted to the creator of the
  /// filter, however Jira administrators can change the owner of a shared
  /// filter in the admin settings.
  final User? owner;

  /// The JQL query for the filter. For example, *project = SSP AND issuetype =
  /// Bug*.
  final String? jql;

  /// A URL to view the filter results in Jira, using the ID of the filter. For
  /// example, *https://your-domain.atlassian.net/issues/?filter=10100*.
  final String? viewUrl;

  /// A URL to view the filter results in Jira, using the
  /// [Search for issues using JQL](#api-rest-api-3-filter-search-get) operation
  /// with the filter's JQL string to return the filter results. For example,
  /// *https://your-domain.atlassian.net/rest/api/3/search?jql=project+%3D+SSP+AND+issuetype+%3D+Bug*.
  final String? searchUrl;

  /// Whether the filter is selected as a favorite.
  final bool favourite;

  /// The count of how many users have selected this filter as a favorite,
  /// including the filter owner.
  final int? favouritedCount;

  /// The groups and projects that the filter is shared with.
  final List<SharePermission> sharePermissions;

  /// A paginated list of the users that the filter is shared with. This
  /// includes users that are members of the groups or can browse the projects
  /// that the filter is shared with.
  final UserList? sharedUsers;

  /// A paginated list of the users that are subscribed to the filter.
  final FilterSubscriptionsList? subscriptions;

  Filter(
      {this.self,
      this.id,
      required this.name,
      this.description,
      this.owner,
      this.jql,
      this.viewUrl,
      this.searchUrl,
      bool? favourite,
      this.favouritedCount,
      List<SharePermission>? sharePermissions,
      this.sharedUsers,
      this.subscriptions})
      : favourite = favourite ?? false,
        sharePermissions = sharePermissions ?? [];

  factory Filter.fromJson(Map<String, Object?> json) {
    return Filter(
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
      owner: json[r'owner'] != null
          ? User.fromJson(json[r'owner']! as Map<String, Object?>)
          : null,
      jql: json[r'jql'] as String?,
      viewUrl: json[r'viewUrl'] as String?,
      searchUrl: json[r'searchUrl'] as String?,
      favourite: json[r'favourite'] as bool? ?? false,
      favouritedCount: (json[r'favouritedCount'] as num?)?.toInt(),
      sharePermissions: (json[r'sharePermissions'] as List<Object?>?)
              ?.map((i) => SharePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      sharedUsers: json[r'sharedUsers'] != null
          ? UserList.fromJson(json[r'sharedUsers']! as Map<String, Object?>)
          : null,
      subscriptions: json[r'subscriptions'] != null
          ? FilterSubscriptionsList.fromJson(
              json[r'subscriptions']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var owner = this.owner;
    var jql = this.jql;
    var viewUrl = this.viewUrl;
    var searchUrl = this.searchUrl;
    var favourite = this.favourite;
    var favouritedCount = this.favouritedCount;
    var sharePermissions = this.sharePermissions;
    var sharedUsers = this.sharedUsers;
    var subscriptions = this.subscriptions;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    if (owner != null) {
      json[r'owner'] = owner.toJson();
    }
    if (jql != null) {
      json[r'jql'] = jql;
    }
    if (viewUrl != null) {
      json[r'viewUrl'] = viewUrl;
    }
    if (searchUrl != null) {
      json[r'searchUrl'] = searchUrl;
    }
    json[r'favourite'] = favourite;
    if (favouritedCount != null) {
      json[r'favouritedCount'] = favouritedCount;
    }
    json[r'sharePermissions'] =
        sharePermissions.map((i) => i.toJson()).toList();
    if (sharedUsers != null) {
      json[r'sharedUsers'] = sharedUsers.toJson();
    }
    if (subscriptions != null) {
      json[r'subscriptions'] = subscriptions.toJson();
    }
    return json;
  }

  Filter copyWith(
      {String? self,
      String? id,
      String? name,
      String? description,
      User? owner,
      String? jql,
      String? viewUrl,
      String? searchUrl,
      bool? favourite,
      int? favouritedCount,
      List<SharePermission>? sharePermissions,
      UserList? sharedUsers,
      FilterSubscriptionsList? subscriptions}) {
    return Filter(
      self: self ?? this.self,
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      owner: owner ?? this.owner,
      jql: jql ?? this.jql,
      viewUrl: viewUrl ?? this.viewUrl,
      searchUrl: searchUrl ?? this.searchUrl,
      favourite: favourite ?? this.favourite,
      favouritedCount: favouritedCount ?? this.favouritedCount,
      sharePermissions: sharePermissions ?? this.sharePermissions,
      sharedUsers: sharedUsers ?? this.sharedUsers,
      subscriptions: subscriptions ?? this.subscriptions,
    );
  }
}

/// Details of a user or group subscribing to a filter.
class FilterSubscription {
  /// The ID of the filter subscription.
  final int? id;

  /// The user subscribing to filter.
  final User? user;

  /// The group subscribing to filter.
  final GroupName? group;

  FilterSubscription({this.id, this.user, this.group});

  factory FilterSubscription.fromJson(Map<String, Object?> json) {
    return FilterSubscription(
      id: (json[r'id'] as num?)?.toInt(),
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
      group: json[r'group'] != null
          ? GroupName.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var user = this.user;
    var group = this.group;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  FilterSubscription copyWith({int? id, User? user, GroupName? group}) {
    return FilterSubscription(
      id: id ?? this.id,
      user: user ?? this.user,
      group: group ?? this.group,
    );
  }
}

/// A paginated list of subscriptions to a filter.
class FilterSubscriptionsList {
  /// The number of items on the page.
  final int? size;

  /// The list of items.
  final List<FilterSubscription> items;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The index of the first item returned on the page.
  final int? startIndex;

  /// The index of the last item returned on the page.
  final int? endIndex;

  FilterSubscriptionsList(
      {this.size,
      List<FilterSubscription>? items,
      this.maxResults,
      this.startIndex,
      this.endIndex})
      : items = items ?? [];

  factory FilterSubscriptionsList.fromJson(Map<String, Object?> json) {
    return FilterSubscriptionsList(
      size: (json[r'size'] as num?)?.toInt(),
      items: (json[r'items'] as List<Object?>?)
              ?.map((i) => FilterSubscription.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'max-results'] as num?)?.toInt(),
      startIndex: (json[r'start-index'] as num?)?.toInt(),
      endIndex: (json[r'end-index'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var size = this.size;
    var items = this.items;
    var maxResults = this.maxResults;
    var startIndex = this.startIndex;
    var endIndex = this.endIndex;

    final json = <String, Object?>{};
    if (size != null) {
      json[r'size'] = size;
    }
    json[r'items'] = items.map((i) => i.toJson()).toList();
    if (maxResults != null) {
      json[r'max-results'] = maxResults;
    }
    if (startIndex != null) {
      json[r'start-index'] = startIndex;
    }
    if (endIndex != null) {
      json[r'end-index'] = endIndex;
    }
    return json;
  }

  FilterSubscriptionsList copyWith(
      {int? size,
      List<FilterSubscription>? items,
      int? maxResults,
      int? startIndex,
      int? endIndex}) {
    return FilterSubscriptionsList(
      size: size ?? this.size,
      items: items ?? this.items,
      maxResults: maxResults ?? this.maxResults,
      startIndex: startIndex ?? this.startIndex,
      endIndex: endIndex ?? this.endIndex,
    );
  }
}

/// The project issue type hierarchy.
class Hierarchy {
  /// The ID of the base level. This property is deprecated, see
  /// [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final int? baseLevelId;

  /// Details about the hierarchy level.
  final List<HierarchyLevel> levels;

  Hierarchy({this.baseLevelId, List<HierarchyLevel>? levels})
      : levels = levels ?? [];

  factory Hierarchy.fromJson(Map<String, Object?> json) {
    return Hierarchy(
      baseLevelId: (json[r'baseLevelId'] as num?)?.toInt(),
      levels: (json[r'levels'] as List<Object?>?)
              ?.map((i) => HierarchyLevel.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var baseLevelId = this.baseLevelId;
    var levels = this.levels;

    final json = <String, Object?>{};
    if (baseLevelId != null) {
      json[r'baseLevelId'] = baseLevelId;
    }
    json[r'levels'] = levels.map((i) => i.toJson()).toList();
    return json;
  }

  Hierarchy copyWith({int? baseLevelId, List<HierarchyLevel>? levels}) {
    return Hierarchy(
      baseLevelId: baseLevelId ?? this.baseLevelId,
      levels: levels ?? this.levels,
    );
  }
}

class HierarchyLevel {
  /// The ID of the hierarchy level. This property is deprecated, see
  /// [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final int? id;

  /// The name of this hierarchy level.
  final String? name;

  /// The ID of the level above this one in the hierarchy. This property is
  /// deprecated, see
  /// [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final int? aboveLevelId;

  /// The ID of the level below this one in the hierarchy. This property is
  /// deprecated, see
  /// [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final int? belowLevelId;

  /// The ID of the project configuration. This property is deprecated, see
  /// [Change oticen: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final int? projectConfigurationId;

  /// The level of this item in the hierarchy.
  final int? level;

  /// The issue types available in this hierarchy level.
  final List<int> issueTypeIds;

  /// The external UUID of the hierarchy level. This property is deprecated, see
  /// [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final String? externalUuid;
  final HierarchyLevelGlobalHierarchyLevel? globalHierarchyLevel;

  HierarchyLevel(
      {this.id,
      this.name,
      this.aboveLevelId,
      this.belowLevelId,
      this.projectConfigurationId,
      this.level,
      List<int>? issueTypeIds,
      this.externalUuid,
      this.globalHierarchyLevel})
      : issueTypeIds = issueTypeIds ?? [];

  factory HierarchyLevel.fromJson(Map<String, Object?> json) {
    return HierarchyLevel(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      aboveLevelId: (json[r'aboveLevelId'] as num?)?.toInt(),
      belowLevelId: (json[r'belowLevelId'] as num?)?.toInt(),
      projectConfigurationId:
          (json[r'projectConfigurationId'] as num?)?.toInt(),
      level: (json[r'level'] as num?)?.toInt(),
      issueTypeIds: (json[r'issueTypeIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      externalUuid: json[r'externalUuid'] as String?,
      globalHierarchyLevel: json[r'globalHierarchyLevel'] != null
          ? HierarchyLevelGlobalHierarchyLevel.fromValue(
              json[r'globalHierarchyLevel']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var aboveLevelId = this.aboveLevelId;
    var belowLevelId = this.belowLevelId;
    var projectConfigurationId = this.projectConfigurationId;
    var level = this.level;
    var issueTypeIds = this.issueTypeIds;
    var externalUuid = this.externalUuid;
    var globalHierarchyLevel = this.globalHierarchyLevel;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (aboveLevelId != null) {
      json[r'aboveLevelId'] = aboveLevelId;
    }
    if (belowLevelId != null) {
      json[r'belowLevelId'] = belowLevelId;
    }
    if (projectConfigurationId != null) {
      json[r'projectConfigurationId'] = projectConfigurationId;
    }
    if (level != null) {
      json[r'level'] = level;
    }
    json[r'issueTypeIds'] = issueTypeIds;
    if (externalUuid != null) {
      json[r'externalUuid'] = externalUuid;
    }
    if (globalHierarchyLevel != null) {
      json[r'globalHierarchyLevel'] = globalHierarchyLevel.value;
    }
    return json;
  }

  HierarchyLevel copyWith(
      {int? id,
      String? name,
      int? aboveLevelId,
      int? belowLevelId,
      int? projectConfigurationId,
      int? level,
      List<int>? issueTypeIds,
      String? externalUuid,
      HierarchyLevelGlobalHierarchyLevel? globalHierarchyLevel}) {
    return HierarchyLevel(
      id: id ?? this.id,
      name: name ?? this.name,
      aboveLevelId: aboveLevelId ?? this.aboveLevelId,
      belowLevelId: belowLevelId ?? this.belowLevelId,
      projectConfigurationId:
          projectConfigurationId ?? this.projectConfigurationId,
      level: level ?? this.level,
      issueTypeIds: issueTypeIds ?? this.issueTypeIds,
      externalUuid: externalUuid ?? this.externalUuid,
      globalHierarchyLevel: globalHierarchyLevel ?? this.globalHierarchyLevel,
    );
  }
}

class HierarchyLevelGlobalHierarchyLevel {
  static const subtask = HierarchyLevelGlobalHierarchyLevel._('SUBTASK');
  static const base = HierarchyLevelGlobalHierarchyLevel._('BASE');
  static const epic = HierarchyLevelGlobalHierarchyLevel._('EPIC');

  static const values = [
    subtask,
    base,
    epic,
  ];
  final String value;

  const HierarchyLevelGlobalHierarchyLevel._(this.value);

  static HierarchyLevelGlobalHierarchyLevel fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => HierarchyLevelGlobalHierarchyLevel._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about an issue type.
class IssueTypeDetails {
  /// The URL of these issue type details.
  final String? self;

  /// The ID of the issue type.
  final String? id;

  /// The description of the issue type.
  final String? description;

  /// The URL of the issue type's avatar.
  final String? iconUrl;

  /// The name of the issue type.
  final String? name;

  /// Whether this issue type is used to create subtasks.
  final bool subtask;

  /// The ID of the issue type's avatar.
  final int? avatarId;

  /// Unique ID for next-gen projects.
  final String? entityId;

  /// Hierarchy level of the issue type.
  final int? hierarchyLevel;

  /// Details of the next-gen projects the issue type is available in.
  final Scope? scope;

  IssueTypeDetails(
      {this.self,
      this.id,
      this.description,
      this.iconUrl,
      this.name,
      bool? subtask,
      this.avatarId,
      this.entityId,
      this.hierarchyLevel,
      this.scope})
      : subtask = subtask ?? false;

  factory IssueTypeDetails.fromJson(Map<String, Object?> json) {
    return IssueTypeDetails(
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      description: json[r'description'] as String?,
      iconUrl: json[r'iconUrl'] as String?,
      name: json[r'name'] as String?,
      subtask: json[r'subtask'] as bool? ?? false,
      avatarId: (json[r'avatarId'] as num?)?.toInt(),
      entityId: json[r'entityId'] as String?,
      hierarchyLevel: (json[r'hierarchyLevel'] as num?)?.toInt(),
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var description = this.description;
    var iconUrl = this.iconUrl;
    var name = this.name;
    var subtask = this.subtask;
    var avatarId = this.avatarId;
    var entityId = this.entityId;
    var hierarchyLevel = this.hierarchyLevel;
    var scope = this.scope;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (iconUrl != null) {
      json[r'iconUrl'] = iconUrl;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'subtask'] = subtask;
    if (avatarId != null) {
      json[r'avatarId'] = avatarId;
    }
    if (entityId != null) {
      json[r'entityId'] = entityId;
    }
    if (hierarchyLevel != null) {
      json[r'hierarchyLevel'] = hierarchyLevel;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    return json;
  }

  IssueTypeDetails copyWith(
      {String? self,
      String? id,
      String? description,
      String? iconUrl,
      String? name,
      bool? subtask,
      int? avatarId,
      String? entityId,
      int? hierarchyLevel,
      Scope? scope}) {
    return IssueTypeDetails(
      self: self ?? this.self,
      id: id ?? this.id,
      description: description ?? this.description,
      iconUrl: iconUrl ?? this.iconUrl,
      name: name ?? this.name,
      subtask: subtask ?? this.subtask,
      avatarId: avatarId ?? this.avatarId,
      entityId: entityId ?? this.entityId,
      hierarchyLevel: hierarchyLevel ?? this.hierarchyLevel,
      scope: scope ?? this.scope,
    );
  }
}

/// Details about a project.
class Project {
  /// Expand options that include additional project details in the response.
  final String? expand;

  /// The URL of the project details.
  final String? self;

  /// The ID of the project.
  final String? id;

  /// The key of the project.
  final String? key;

  /// A brief description of the project.
  final String? description;

  /// The username of the project lead.
  final User? lead;

  /// List of the components contained in the project.
  final List<Component> components;

  /// List of the issue types available in the project.
  final List<IssueTypeDetails> issueTypes;

  /// A link to information about this project, such as project documentation.
  final String? url;

  /// An email address associated with the project.
  final String? email;

  /// The default assignee when creating issues for this project.
  final ProjectAssigneeType? assigneeType;

  /// The versions defined in the project. For more information, see
  /// [Create version](#api-rest-api-3-version-post).
  final List<Version> versions;

  /// The name of the project.
  final String? name;

  /// The name and self URL for each role defined in the project. For more
  /// information, see [Create project role](#api-rest-api-3-role-post).
  final Map<String, dynamic>? roles;

  /// The URLs of the project's avatars.
  final AvatarUrlsBean? avatarUrls;

  /// The category the project belongs to.
  final ProjectCategory? projectCategory;

  /// The
  /// [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes)
  /// of the project.
  final ProjectProjectTypeKey? projectTypeKey;

  /// Whether the project is simplified.
  final bool simplified;

  /// The type of the project.
  final ProjectStyle? style;

  /// Whether the project is selected as a favorite.
  final bool favourite;

  /// Whether the project is private.
  final bool isPrivate;

  /// The issue type hierarchy for the project.
  final Hierarchy? issueTypeHierarchy;

  /// User permissions on the project
  final ProjectPermissions? permissions;

  /// Map of project properties
  final Map<String, dynamic>? properties;

  /// Unique ID for next-gen projects.
  final String? uuid;

  /// Insights about the project.
  final ProjectInsight? insight;

  /// Whether the project is marked as deleted.
  final bool deleted;

  /// The date when the project is deleted permanently.
  final DateTime? retentionTillDate;

  /// The date when the project was marked as deleted.
  final DateTime? deletedDate;

  /// The user who marked the project as deleted.
  final User? deletedBy;

  /// Whether the project is archived.
  final bool archived;

  /// The date when the project was archived.
  final DateTime? archivedDate;

  /// The user who archived the project.
  final User? archivedBy;

  Project(
      {this.expand,
      this.self,
      this.id,
      this.key,
      this.description,
      this.lead,
      List<Component>? components,
      List<IssueTypeDetails>? issueTypes,
      this.url,
      this.email,
      this.assigneeType,
      List<Version>? versions,
      this.name,
      this.roles,
      this.avatarUrls,
      this.projectCategory,
      this.projectTypeKey,
      bool? simplified,
      this.style,
      bool? favourite,
      bool? isPrivate,
      this.issueTypeHierarchy,
      this.permissions,
      this.properties,
      this.uuid,
      this.insight,
      bool? deleted,
      this.retentionTillDate,
      this.deletedDate,
      this.deletedBy,
      bool? archived,
      this.archivedDate,
      this.archivedBy})
      : components = components ?? [],
        issueTypes = issueTypes ?? [],
        versions = versions ?? [],
        simplified = simplified ?? false,
        favourite = favourite ?? false,
        isPrivate = isPrivate ?? false,
        deleted = deleted ?? false,
        archived = archived ?? false;

  factory Project.fromJson(Map<String, Object?> json) {
    return Project(
      expand: json[r'expand'] as String?,
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      description: json[r'description'] as String?,
      lead: json[r'lead'] != null
          ? User.fromJson(json[r'lead']! as Map<String, Object?>)
          : null,
      components: (json[r'components'] as List<Object?>?)
              ?.map((i) =>
                  Component.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      issueTypes: (json[r'issueTypes'] as List<Object?>?)
              ?.map((i) => IssueTypeDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      url: json[r'url'] as String?,
      email: json[r'email'] as String?,
      assigneeType: json[r'assigneeType'] != null
          ? ProjectAssigneeType.fromValue(json[r'assigneeType']! as String)
          : null,
      versions: (json[r'versions'] as List<Object?>?)
              ?.map((i) =>
                  Version.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      name: json[r'name'] as String?,
      roles: json[r'roles'] as Map<String, Object?>?,
      avatarUrls: json[r'avatarUrls'] != null
          ? AvatarUrlsBean.fromJson(
              json[r'avatarUrls']! as Map<String, Object?>)
          : null,
      projectCategory: json[r'projectCategory'] != null
          ? ProjectCategory.fromJson(
              json[r'projectCategory']! as Map<String, Object?>)
          : null,
      projectTypeKey: json[r'projectTypeKey'] != null
          ? ProjectProjectTypeKey.fromValue(json[r'projectTypeKey']! as String)
          : null,
      simplified: json[r'simplified'] as bool? ?? false,
      style: json[r'style'] != null
          ? ProjectStyle.fromValue(json[r'style']! as String)
          : null,
      favourite: json[r'favourite'] as bool? ?? false,
      isPrivate: json[r'isPrivate'] as bool? ?? false,
      issueTypeHierarchy: json[r'issueTypeHierarchy'] != null
          ? Hierarchy.fromJson(
              json[r'issueTypeHierarchy']! as Map<String, Object?>)
          : null,
      permissions: json[r'permissions'] != null
          ? ProjectPermissions.fromJson(
              json[r'permissions']! as Map<String, Object?>)
          : null,
      properties: json[r'properties'] as Map<String, Object?>?,
      uuid: json[r'uuid'] as String?,
      insight: json[r'insight'] != null
          ? ProjectInsight.fromJson(json[r'insight']! as Map<String, Object?>)
          : null,
      deleted: json[r'deleted'] as bool? ?? false,
      retentionTillDate:
          DateTime.tryParse(json[r'retentionTillDate'] as String? ?? ''),
      deletedDate: DateTime.tryParse(json[r'deletedDate'] as String? ?? ''),
      deletedBy: json[r'deletedBy'] != null
          ? User.fromJson(json[r'deletedBy']! as Map<String, Object?>)
          : null,
      archived: json[r'archived'] as bool? ?? false,
      archivedDate: DateTime.tryParse(json[r'archivedDate'] as String? ?? ''),
      archivedBy: json[r'archivedBy'] != null
          ? User.fromJson(json[r'archivedBy']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var self = this.self;
    var id = this.id;
    var key = this.key;
    var description = this.description;
    var lead = this.lead;
    var components = this.components;
    var issueTypes = this.issueTypes;
    var url = this.url;
    var email = this.email;
    var assigneeType = this.assigneeType;
    var versions = this.versions;
    var name = this.name;
    var roles = this.roles;
    var avatarUrls = this.avatarUrls;
    var projectCategory = this.projectCategory;
    var projectTypeKey = this.projectTypeKey;
    var simplified = this.simplified;
    var style = this.style;
    var favourite = this.favourite;
    var isPrivate = this.isPrivate;
    var issueTypeHierarchy = this.issueTypeHierarchy;
    var permissions = this.permissions;
    var properties = this.properties;
    var uuid = this.uuid;
    var insight = this.insight;
    var deleted = this.deleted;
    var retentionTillDate = this.retentionTillDate;
    var deletedDate = this.deletedDate;
    var deletedBy = this.deletedBy;
    var archived = this.archived;
    var archivedDate = this.archivedDate;
    var archivedBy = this.archivedBy;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (lead != null) {
      json[r'lead'] = lead.toJson();
    }
    json[r'components'] = components.map((i) => i.toJson()).toList();
    json[r'issueTypes'] = issueTypes.map((i) => i.toJson()).toList();
    if (url != null) {
      json[r'url'] = url;
    }
    if (email != null) {
      json[r'email'] = email;
    }
    if (assigneeType != null) {
      json[r'assigneeType'] = assigneeType.value;
    }
    json[r'versions'] = versions.map((i) => i.toJson()).toList();
    if (name != null) {
      json[r'name'] = name;
    }
    if (roles != null) {
      json[r'roles'] = roles;
    }
    if (avatarUrls != null) {
      json[r'avatarUrls'] = avatarUrls.toJson();
    }
    if (projectCategory != null) {
      json[r'projectCategory'] = projectCategory.toJson();
    }
    if (projectTypeKey != null) {
      json[r'projectTypeKey'] = projectTypeKey.value;
    }
    json[r'simplified'] = simplified;
    if (style != null) {
      json[r'style'] = style.value;
    }
    json[r'favourite'] = favourite;
    json[r'isPrivate'] = isPrivate;
    if (issueTypeHierarchy != null) {
      json[r'issueTypeHierarchy'] = issueTypeHierarchy.toJson();
    }
    if (permissions != null) {
      json[r'permissions'] = permissions.toJson();
    }
    if (properties != null) {
      json[r'properties'] = properties;
    }
    if (uuid != null) {
      json[r'uuid'] = uuid;
    }
    if (insight != null) {
      json[r'insight'] = insight.toJson();
    }
    json[r'deleted'] = deleted;
    if (retentionTillDate != null) {
      json[r'retentionTillDate'] = retentionTillDate.toIso8601String();
    }
    if (deletedDate != null) {
      json[r'deletedDate'] = deletedDate.toIso8601String();
    }
    if (deletedBy != null) {
      json[r'deletedBy'] = deletedBy.toJson();
    }
    json[r'archived'] = archived;
    if (archivedDate != null) {
      json[r'archivedDate'] = archivedDate.toIso8601String();
    }
    if (archivedBy != null) {
      json[r'archivedBy'] = archivedBy.toJson();
    }
    return json;
  }

  Project copyWith(
      {String? expand,
      String? self,
      String? id,
      String? key,
      String? description,
      User? lead,
      List<Component>? components,
      List<IssueTypeDetails>? issueTypes,
      String? url,
      String? email,
      ProjectAssigneeType? assigneeType,
      List<Version>? versions,
      String? name,
      Map<String, dynamic>? roles,
      AvatarUrlsBean? avatarUrls,
      ProjectCategory? projectCategory,
      ProjectProjectTypeKey? projectTypeKey,
      bool? simplified,
      ProjectStyle? style,
      bool? favourite,
      bool? isPrivate,
      Hierarchy? issueTypeHierarchy,
      ProjectPermissions? permissions,
      Map<String, dynamic>? properties,
      String? uuid,
      ProjectInsight? insight,
      bool? deleted,
      DateTime? retentionTillDate,
      DateTime? deletedDate,
      User? deletedBy,
      bool? archived,
      DateTime? archivedDate,
      User? archivedBy}) {
    return Project(
      expand: expand ?? this.expand,
      self: self ?? this.self,
      id: id ?? this.id,
      key: key ?? this.key,
      description: description ?? this.description,
      lead: lead ?? this.lead,
      components: components ?? this.components,
      issueTypes: issueTypes ?? this.issueTypes,
      url: url ?? this.url,
      email: email ?? this.email,
      assigneeType: assigneeType ?? this.assigneeType,
      versions: versions ?? this.versions,
      name: name ?? this.name,
      roles: roles ?? this.roles,
      avatarUrls: avatarUrls ?? this.avatarUrls,
      projectCategory: projectCategory ?? this.projectCategory,
      projectTypeKey: projectTypeKey ?? this.projectTypeKey,
      simplified: simplified ?? this.simplified,
      style: style ?? this.style,
      favourite: favourite ?? this.favourite,
      isPrivate: isPrivate ?? this.isPrivate,
      issueTypeHierarchy: issueTypeHierarchy ?? this.issueTypeHierarchy,
      permissions: permissions ?? this.permissions,
      properties: properties ?? this.properties,
      uuid: uuid ?? this.uuid,
      insight: insight ?? this.insight,
      deleted: deleted ?? this.deleted,
      retentionTillDate: retentionTillDate ?? this.retentionTillDate,
      deletedDate: deletedDate ?? this.deletedDate,
      deletedBy: deletedBy ?? this.deletedBy,
      archived: archived ?? this.archived,
      archivedDate: archivedDate ?? this.archivedDate,
      archivedBy: archivedBy ?? this.archivedBy,
    );
  }
}

class ProjectAssigneeType {
  static const projectLead = ProjectAssigneeType._('PROJECT_LEAD');
  static const unassigned = ProjectAssigneeType._('UNASSIGNED');

  static const values = [
    projectLead,
    unassigned,
  ];
  final String value;

  const ProjectAssigneeType._(this.value);

  static ProjectAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ProjectProjectTypeKey {
  static const software = ProjectProjectTypeKey._('software');
  static const serviceDesk = ProjectProjectTypeKey._('service_desk');
  static const business = ProjectProjectTypeKey._('business');

  static const values = [
    software,
    serviceDesk,
    business,
  ];
  final String value;

  const ProjectProjectTypeKey._(this.value);

  static ProjectProjectTypeKey fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectProjectTypeKey._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ProjectStyle {
  static const classic = ProjectStyle._('classic');
  static const nextGen = ProjectStyle._('next-gen');

  static const values = [
    classic,
    nextGen,
  ];
  final String value;

  const ProjectStyle._(this.value);

  static ProjectStyle fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => ProjectStyle._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A project category.
class ProjectCategory {
  /// The URL of the project category.
  final String? self;

  /// The ID of the project category.
  final String? id;

  /// The name of the project category. Required on create, optional on update.
  final String? name;

  /// The description of the project category. Required on create, optional on
  /// update.
  final String? description;

  ProjectCategory({this.self, this.id, this.name, this.description});

  factory ProjectCategory.fromJson(Map<String, Object?> json) {
    return ProjectCategory(
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var name = this.name;
    var description = this.description;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    return json;
  }

  ProjectCategory copyWith(
      {String? self, String? id, String? name, String? description}) {
    return ProjectCategory(
      self: self ?? this.self,
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
    );
  }
}

/// Additional details about a project.
class ProjectInsight {
  /// Total issue count.
  final int? totalIssueCount;

  /// The last issue update time.
  final DateTime? lastIssueUpdateTime;

  ProjectInsight({this.totalIssueCount, this.lastIssueUpdateTime});

  factory ProjectInsight.fromJson(Map<String, Object?> json) {
    return ProjectInsight(
      totalIssueCount: (json[r'totalIssueCount'] as num?)?.toInt(),
      lastIssueUpdateTime:
          DateTime.tryParse(json[r'lastIssueUpdateTime'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var totalIssueCount = this.totalIssueCount;
    var lastIssueUpdateTime = this.lastIssueUpdateTime;

    final json = <String, Object?>{};
    if (totalIssueCount != null) {
      json[r'totalIssueCount'] = totalIssueCount;
    }
    if (lastIssueUpdateTime != null) {
      json[r'lastIssueUpdateTime'] = lastIssueUpdateTime.toIso8601String();
    }
    return json;
  }

  ProjectInsight copyWith(
      {int? totalIssueCount, DateTime? lastIssueUpdateTime}) {
    return ProjectInsight(
      totalIssueCount: totalIssueCount ?? this.totalIssueCount,
      lastIssueUpdateTime: lastIssueUpdateTime ?? this.lastIssueUpdateTime,
    );
  }
}

/// Permissions which a user has on a project.
class ProjectPermissions {
  /// Whether the logged user can edit the project.
  final bool canEdit;

  ProjectPermissions({bool? canEdit}) : canEdit = canEdit ?? false;

  factory ProjectPermissions.fromJson(Map<String, Object?> json) {
    return ProjectPermissions(
      canEdit: json[r'canEdit'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var canEdit = this.canEdit;

    final json = <String, Object?>{};
    json[r'canEdit'] = canEdit;
    return json;
  }

  ProjectPermissions copyWith({bool? canEdit}) {
    return ProjectPermissions(
      canEdit: canEdit ?? this.canEdit,
    );
  }
}

/// Details of a share permission for the filter.
class SharePermission {
  /// The unique identifier of the share permission.
  final int? id;

  /// The type of share permission:
  ///
  ///  *  `group` Shared with a group. If set in a request, then specify
  /// `sharePermission.group` as well.
  ///  *  `project` Shared with a project. If set in a request, then specify
  /// `sharePermission.project` as well.
  ///  *  `projectRole` Share with a project role in a project. This value is
  /// not returned in responses. It is used in requests, where it needs to be
  /// specify with `projectId` and `projectRoleId`.
  ///  *  `global` Shared globally. If set in a request, no other
  /// `sharePermission` properties need to be specified.
  ///  *  `loggedin` Shared with all logged-in users. Note: This value is set in
  /// a request by specifying `authenticated` as the `type`.
  ///  *  `project-unknown` Shared with a project that the user does not have
  /// access to. Cannot be set in a request.
  final SharePermissionType type;

  /// The project that the filter is shared with. This is similar to the project
  /// object returned by
  /// [Get project](#api-rest-api-3-project-projectIdOrKey-get) but it contains
  /// a subset of the properties, which are: `self`, `id`, `key`,
  /// `assigneeType`, `name`, `roles`, `avatarUrls`, `projectType`,
  /// `simplified`.
  /// For a request, specify the `id` for the project.
  final Project? project;

  /// The project role that the filter is shared with.
  /// For a request, specify the `id` for the role. You must also specify the
  /// `project` object and `id` for the project that the role is in.
  final ProjectRole? role;

  /// The group that the filter is shared with. For a request, specify the
  /// `name` property for the group.
  final GroupName? group;

  SharePermission(
      {this.id, required this.type, this.project, this.role, this.group});

  factory SharePermission.fromJson(Map<String, Object?> json) {
    return SharePermission(
      id: (json[r'id'] as num?)?.toInt(),
      type: SharePermissionType.fromValue(json[r'type'] as String? ?? ''),
      project: json[r'project'] != null
          ? Project.fromJson(json[r'project']! as Map<String, Object?>)
          : null,
      role: json[r'role'] != null
          ? ProjectRole.fromJson(json[r'role']! as Map<String, Object?>)
          : null,
      group: json[r'group'] != null
          ? GroupName.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var type = this.type;
    var project = this.project;
    var role = this.role;
    var group = this.group;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'type'] = type.value;
    if (project != null) {
      json[r'project'] = project.toJson();
    }
    if (role != null) {
      json[r'role'] = role.toJson();
    }
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    return json;
  }

  SharePermission copyWith(
      {int? id,
      SharePermissionType? type,
      Project? project,
      ProjectRole? role,
      GroupName? group}) {
    return SharePermission(
      id: id ?? this.id,
      type: type ?? this.type,
      project: project ?? this.project,
      role: role ?? this.role,
      group: group ?? this.group,
    );
  }
}

class SharePermissionType {
  static const group = SharePermissionType._('group');
  static const project = SharePermissionType._('project');
  static const projectRole = SharePermissionType._('projectRole');
  static const global = SharePermissionType._('global');
  static const loggedin = SharePermissionType._('loggedin');
  static const authenticated = SharePermissionType._('authenticated');
  static const projectUnknown = SharePermissionType._('project-unknown');

  static const values = [
    group,
    project,
    projectRole,
    global,
    loggedin,
    authenticated,
    projectUnknown,
  ];
  final String value;

  const SharePermissionType._(this.value);

  static SharePermissionType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => SharePermissionType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A paginated list of users sharing the filter. This includes users that are
/// members of the groups or can browse the projects that the filter is shared
/// with.
class UserList {
  /// The number of items on the page.
  final int? size;

  /// The list of items.
  final List<User> items;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The index of the first item returned on the page.
  final int? startIndex;

  /// The index of the last item returned on the page.
  final int? endIndex;

  UserList(
      {this.size,
      List<User>? items,
      this.maxResults,
      this.startIndex,
      this.endIndex})
      : items = items ?? [];

  factory UserList.fromJson(Map<String, Object?> json) {
    return UserList(
      size: (json[r'size'] as num?)?.toInt(),
      items: (json[r'items'] as List<Object?>?)
              ?.map(
                  (i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'max-results'] as num?)?.toInt(),
      startIndex: (json[r'start-index'] as num?)?.toInt(),
      endIndex: (json[r'end-index'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var size = this.size;
    var items = this.items;
    var maxResults = this.maxResults;
    var startIndex = this.startIndex;
    var endIndex = this.endIndex;

    final json = <String, Object?>{};
    if (size != null) {
      json[r'size'] = size;
    }
    json[r'items'] = items.map((i) => i.toJson()).toList();
    if (maxResults != null) {
      json[r'max-results'] = maxResults;
    }
    if (startIndex != null) {
      json[r'start-index'] = startIndex;
    }
    if (endIndex != null) {
      json[r'end-index'] = endIndex;
    }
    return json;
  }

  UserList copyWith(
      {int? size,
      List<User>? items,
      int? maxResults,
      int? startIndex,
      int? endIndex}) {
    return UserList(
      size: size ?? this.size,
      items: items ?? this.items,
      maxResults: maxResults ?? this.maxResults,
      startIndex: startIndex ?? this.startIndex,
      endIndex: endIndex ?? this.endIndex,
    );
  }
}

/// Details about a project version.
class Version {
  /// Use [expand](em>#expansion) to include additional information about
  /// version in the response. This parameter accepts a comma-separated list.
  /// Expand options include:
  ///
  ///  *  `operations` Returns the list of operations available for this
  /// version.
  ///  *  `issuesstatus` Returns the count of issues in this version for each of
  /// the status categories *to do*, *in progress*, *done*, and *unmapped*. The
  /// *unmapped* property contains a count of issues with a status other than
  /// *to do*, *in progress*, and *done*.
  ///
  /// Optional for create and update.
  final String? expand;

  /// The URL of the version.
  final String? self;

  /// The ID of the version.
  final String? id;

  /// The description of the version. Optional when creating or updating a
  /// version.
  final String? description;

  /// The unique name of the version. Required when creating a version. Optional
  /// when updating a version. The maximum length is 255 characters.
  final String? name;

  /// Indicates that the version is archived. Optional when creating or updating
  /// a version.
  final bool archived;

  /// Indicates that the version is released. If the version is released a
  /// request to release again is ignored. Not applicable when creating a
  /// version. Optional when updating a version.
  final bool released;

  /// The start date of the version. Expressed in ISO 8601 format (yyyy-mm-dd).
  /// Optional when creating or updating a version.
  final String? startDate;

  /// The release date of the version. Expressed in ISO 8601 format
  /// (yyyy-mm-dd). Optional when creating or updating a version.
  final String? releaseDate;

  /// Indicates that the version is overdue.
  final bool overdue;

  /// The date on which work on this version is expected to start, expressed in
  /// the instance's *Day/Month/Year Format* date format.
  final String? userStartDate;

  /// The date on which work on this version is expected to finish, expressed in
  /// the instance's *Day/Month/Year Format* date format.
  final String? userReleaseDate;

  /// Deprecated. Use `projectId`.
  final String? project;

  /// The ID of the project to which this version is attached. Required when
  /// creating a version. Not applicable when updating a version.
  final int? projectId;

  /// The URL of the self link to the version to which all unfixed issues are
  /// moved when a version is released. Not applicable when creating a version.
  /// Optional when updating a version.
  final String? moveUnfixedIssuesTo;

  /// If the expand option `operations` is used, returns the list of operations
  /// available for this version.
  final List<SimpleLink> operations;

  /// If the expand option `issuesstatus` is used, returns the count of issues
  /// in this version for each of the status categories *to do*, *in progress*,
  /// *done*, and *unmapped*. The *unmapped* property contains a count of issues
  /// with a status other than *to do*, *in progress*, and *done*.
  final VersionIssuesStatus? issuesStatusForFixVersion;

  Version(
      {this.expand,
      this.self,
      this.id,
      this.description,
      this.name,
      bool? archived,
      bool? released,
      this.startDate,
      this.releaseDate,
      bool? overdue,
      this.userStartDate,
      this.userReleaseDate,
      this.project,
      this.projectId,
      this.moveUnfixedIssuesTo,
      List<SimpleLink>? operations,
      this.issuesStatusForFixVersion})
      : archived = archived ?? false,
        released = released ?? false,
        overdue = overdue ?? false,
        operations = operations ?? [];

  factory Version.fromJson(Map<String, Object?> json) {
    return Version(
      expand: json[r'expand'] as String?,
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
      archived: json[r'archived'] as bool? ?? false,
      released: json[r'released'] as bool? ?? false,
      startDate: json[r'startDate'] as String?,
      releaseDate: json[r'releaseDate'] as String?,
      overdue: json[r'overdue'] as bool? ?? false,
      userStartDate: json[r'userStartDate'] as String?,
      userReleaseDate: json[r'userReleaseDate'] as String?,
      project: json[r'project'] as String?,
      projectId: (json[r'projectId'] as num?)?.toInt(),
      moveUnfixedIssuesTo: json[r'moveUnfixedIssuesTo'] as String?,
      operations: (json[r'operations'] as List<Object?>?)
              ?.map((i) =>
                  SimpleLink.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      issuesStatusForFixVersion: json[r'issuesStatusForFixVersion'] != null
          ? VersionIssuesStatus.fromJson(
              json[r'issuesStatusForFixVersion']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var self = this.self;
    var id = this.id;
    var description = this.description;
    var name = this.name;
    var archived = this.archived;
    var released = this.released;
    var startDate = this.startDate;
    var releaseDate = this.releaseDate;
    var overdue = this.overdue;
    var userStartDate = this.userStartDate;
    var userReleaseDate = this.userReleaseDate;
    var project = this.project;
    var projectId = this.projectId;
    var moveUnfixedIssuesTo = this.moveUnfixedIssuesTo;
    var operations = this.operations;
    var issuesStatusForFixVersion = this.issuesStatusForFixVersion;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'archived'] = archived;
    json[r'released'] = released;
    if (startDate != null) {
      json[r'startDate'] = startDate;
    }
    if (releaseDate != null) {
      json[r'releaseDate'] = releaseDate;
    }
    json[r'overdue'] = overdue;
    if (userStartDate != null) {
      json[r'userStartDate'] = userStartDate;
    }
    if (userReleaseDate != null) {
      json[r'userReleaseDate'] = userReleaseDate;
    }
    if (project != null) {
      json[r'project'] = project;
    }
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    if (moveUnfixedIssuesTo != null) {
      json[r'moveUnfixedIssuesTo'] = moveUnfixedIssuesTo;
    }
    json[r'operations'] = operations.map((i) => i.toJson()).toList();
    if (issuesStatusForFixVersion != null) {
      json[r'issuesStatusForFixVersion'] = issuesStatusForFixVersion.toJson();
    }
    return json;
  }

  Version copyWith(
      {String? expand,
      String? self,
      String? id,
      String? description,
      String? name,
      bool? archived,
      bool? released,
      String? startDate,
      String? releaseDate,
      bool? overdue,
      String? userStartDate,
      String? userReleaseDate,
      String? project,
      int? projectId,
      String? moveUnfixedIssuesTo,
      List<SimpleLink>? operations,
      VersionIssuesStatus? issuesStatusForFixVersion}) {
    return Version(
      expand: expand ?? this.expand,
      self: self ?? this.self,
      id: id ?? this.id,
      description: description ?? this.description,
      name: name ?? this.name,
      archived: archived ?? this.archived,
      released: released ?? this.released,
      startDate: startDate ?? this.startDate,
      releaseDate: releaseDate ?? this.releaseDate,
      overdue: overdue ?? this.overdue,
      userStartDate: userStartDate ?? this.userStartDate,
      userReleaseDate: userReleaseDate ?? this.userReleaseDate,
      project: project ?? this.project,
      projectId: projectId ?? this.projectId,
      moveUnfixedIssuesTo: moveUnfixedIssuesTo ?? this.moveUnfixedIssuesTo,
      operations: operations ?? this.operations,
      issuesStatusForFixVersion:
          issuesStatusForFixVersion ?? this.issuesStatusForFixVersion,
    );
  }
}

/// Counts of the number of issues in various statuses.
class VersionIssuesStatus {
  /// Count of issues with a status other than *to do*, *in progress*, and
  /// *done*.
  final int? unmapped;

  /// Count of issues with status *to do*.
  final int? toDo;

  /// Count of issues with status *in progress*.
  final int? inProgress;

  /// Count of issues with status *done*.
  final int? done;

  VersionIssuesStatus({this.unmapped, this.toDo, this.inProgress, this.done});

  factory VersionIssuesStatus.fromJson(Map<String, Object?> json) {
    return VersionIssuesStatus(
      unmapped: (json[r'unmapped'] as num?)?.toInt(),
      toDo: (json[r'toDo'] as num?)?.toInt(),
      inProgress: (json[r'inProgress'] as num?)?.toInt(),
      done: (json[r'done'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var unmapped = this.unmapped;
    var toDo = this.toDo;
    var inProgress = this.inProgress;
    var done = this.done;

    final json = <String, Object?>{};
    if (unmapped != null) {
      json[r'unmapped'] = unmapped;
    }
    if (toDo != null) {
      json[r'toDo'] = toDo;
    }
    if (inProgress != null) {
      json[r'inProgress'] = inProgress;
    }
    if (done != null) {
      json[r'done'] = done;
    }
    return json;
  }

  VersionIssuesStatus copyWith(
      {int? unmapped, int? toDo, int? inProgress, int? done}) {
    return VersionIssuesStatus(
      unmapped: unmapped ?? this.unmapped,
      toDo: toDo ?? this.toDo,
      inProgress: inProgress ?? this.inProgress,
      done: done ?? this.done,
    );
  }
}

/// Details of a filter.
class FilterDetails {
  /// The URL of the filter.
  final String? self;

  /// The unique identifier for the filter.
  final String? id;

  /// The name of the filter. Must be unique.
  final String name;

  /// A description of the filter.
  final String? description;

  /// The user who owns the filter. This is defaulted to the creator of the
  /// filter, however Jira administrators can change the owner of a shared
  /// filter in the admin settings.
  final User? owner;

  /// The JQL query for the filter. For example, *project = SSP AND issuetype =
  /// Bug*.
  final String? jql;

  /// A URL to view the filter results in Jira, using the ID of the filter. For
  /// example, *https://your-domain.atlassian.net/issues/?filter=10100*.
  final String? viewUrl;

  /// A URL to view the filter results in Jira, using the
  /// [Search for issues using JQL](#api-rest-api-3-filter-search-get) operation
  /// with the filter's JQL string to return the filter results. For example,
  /// *https://your-domain.atlassian.net/rest/api/3/search?jql=project+%3D+SSP+AND+issuetype+%3D+Bug*.
  final String? searchUrl;

  /// Whether the filter is selected as a favorite by any users, not including
  /// the filter owner.
  final bool favourite;

  /// The count of how many users have selected this filter as a favorite,
  /// including the filter owner.
  final int? favouritedCount;

  /// The groups and projects that the filter is shared with. This can be
  /// specified when updating a filter, but not when creating a filter.
  final List<SharePermission> sharePermissions;

  /// The users that are subscribed to the filter.
  final List<FilterSubscription> subscriptions;

  FilterDetails(
      {this.self,
      this.id,
      required this.name,
      this.description,
      this.owner,
      this.jql,
      this.viewUrl,
      this.searchUrl,
      bool? favourite,
      this.favouritedCount,
      List<SharePermission>? sharePermissions,
      List<FilterSubscription>? subscriptions})
      : favourite = favourite ?? false,
        sharePermissions = sharePermissions ?? [],
        subscriptions = subscriptions ?? [];

  factory FilterDetails.fromJson(Map<String, Object?> json) {
    return FilterDetails(
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
      owner: json[r'owner'] != null
          ? User.fromJson(json[r'owner']! as Map<String, Object?>)
          : null,
      jql: json[r'jql'] as String?,
      viewUrl: json[r'viewUrl'] as String?,
      searchUrl: json[r'searchUrl'] as String?,
      favourite: json[r'favourite'] as bool? ?? false,
      favouritedCount: (json[r'favouritedCount'] as num?)?.toInt(),
      sharePermissions: (json[r'sharePermissions'] as List<Object?>?)
              ?.map((i) => SharePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      subscriptions: (json[r'subscriptions'] as List<Object?>?)
              ?.map((i) => FilterSubscription.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var owner = this.owner;
    var jql = this.jql;
    var viewUrl = this.viewUrl;
    var searchUrl = this.searchUrl;
    var favourite = this.favourite;
    var favouritedCount = this.favouritedCount;
    var sharePermissions = this.sharePermissions;
    var subscriptions = this.subscriptions;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    if (owner != null) {
      json[r'owner'] = owner.toJson();
    }
    if (jql != null) {
      json[r'jql'] = jql;
    }
    if (viewUrl != null) {
      json[r'viewUrl'] = viewUrl;
    }
    if (searchUrl != null) {
      json[r'searchUrl'] = searchUrl;
    }
    json[r'favourite'] = favourite;
    if (favouritedCount != null) {
      json[r'favouritedCount'] = favouritedCount;
    }
    json[r'sharePermissions'] =
        sharePermissions.map((i) => i.toJson()).toList();
    json[r'subscriptions'] = subscriptions.map((i) => i.toJson()).toList();
    return json;
  }

  FilterDetails copyWith(
      {String? self,
      String? id,
      String? name,
      String? description,
      User? owner,
      String? jql,
      String? viewUrl,
      String? searchUrl,
      bool? favourite,
      int? favouritedCount,
      List<SharePermission>? sharePermissions,
      List<FilterSubscription>? subscriptions}) {
    return FilterDetails(
      self: self ?? this.self,
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      owner: owner ?? this.owner,
      jql: jql ?? this.jql,
      viewUrl: viewUrl ?? this.viewUrl,
      searchUrl: searchUrl ?? this.searchUrl,
      favourite: favourite ?? this.favourite,
      favouritedCount: favouritedCount ?? this.favouritedCount,
      sharePermissions: sharePermissions ?? this.sharePermissions,
      subscriptions: subscriptions ?? this.subscriptions,
    );
  }
}

/// A page of items.
class PageBeanFilterDetails {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<FilterDetails> values;

  PageBeanFilterDetails(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<FilterDetails>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanFilterDetails.fromJson(Map<String, Object?> json) {
    return PageBeanFilterDetails(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FilterDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanFilterDetails copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<FilterDetails>? values}) {
    return PageBeanFilterDetails(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Error messages from an operation.
class ErrorCollection {
  /// The list of error messages produced by this operation. For example, "input
  /// parameter 'key' must be provided"
  final List<String> errorMessages;

  /// The list of errors by parameter returned by the operation. For
  /// example,"projectKey": "Project keys must start with an uppercase letter,
  /// followed by one or more uppercase alphanumeric characters."
  final Map<String, dynamic>? errors;
  final int? status;

  ErrorCollection({List<String>? errorMessages, this.errors, this.status})
      : errorMessages = errorMessages ?? [];

  factory ErrorCollection.fromJson(Map<String, Object?> json) {
    return ErrorCollection(
      errorMessages: (json[r'errorMessages'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      errors: json[r'errors'] as Map<String, Object?>?,
      status: (json[r'status'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var errorMessages = this.errorMessages;
    var errors = this.errors;
    var status = this.status;

    final json = <String, Object?>{};
    json[r'errorMessages'] = errorMessages;
    if (errors != null) {
      json[r'errors'] = errors;
    }
    if (status != null) {
      json[r'status'] = status;
    }
    return json;
  }

  ErrorCollection copyWith(
      {List<String>? errorMessages,
      Map<String, dynamic>? errors,
      int? status}) {
    return ErrorCollection(
      errorMessages: errorMessages ?? this.errorMessages,
      errors: errors ?? this.errors,
      status: status ?? this.status,
    );
  }
}

/// Details of the scope of the default sharing for new filters and dashboards.
class DefaultShareScope {
  /// The scope of the default sharing for new filters and dashboards:
  ///
  ///  *  `AUTHENTICATED` Shared with all logged-in users.
  ///  *  `GLOBAL` Shared with all logged-in users. This shows as
  /// `AUTHENTICATED` in the response.
  ///  *  `PRIVATE` Not shared with any users.
  final DefaultShareScopeScope scope;

  DefaultShareScope({required this.scope});

  factory DefaultShareScope.fromJson(Map<String, Object?> json) {
    return DefaultShareScope(
      scope: DefaultShareScopeScope.fromValue(json[r'scope'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var scope = this.scope;

    final json = <String, Object?>{};
    json[r'scope'] = scope.value;
    return json;
  }

  DefaultShareScope copyWith({DefaultShareScopeScope? scope}) {
    return DefaultShareScope(
      scope: scope ?? this.scope,
    );
  }
}

class DefaultShareScopeScope {
  static const global = DefaultShareScopeScope._('GLOBAL');
  static const authenticated = DefaultShareScopeScope._('AUTHENTICATED');
  static const private = DefaultShareScopeScope._('PRIVATE');

  static const values = [
    global,
    authenticated,
    private,
  ];
  final String value;

  const DefaultShareScopeScope._(this.value);

  static DefaultShareScopeScope fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => DefaultShareScopeScope._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of an issue navigator column item.
class ColumnItem {
  /// The issue navigator column label.
  final String? label;

  /// The issue navigator column value.
  final String? value;

  ColumnItem({this.label, this.value});

  factory ColumnItem.fromJson(Map<String, Object?> json) {
    return ColumnItem(
      label: json[r'label'] as String?,
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var label = this.label;
    var value = this.value;

    final json = <String, Object?>{};
    if (label != null) {
      json[r'label'] = label;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  ColumnItem copyWith({String? label, String? value}) {
    return ColumnItem(
      label: label ?? this.label,
      value: value ?? this.value,
    );
  }
}

class SharePermissionInputBean {
  /// The type of the share permission.Specify the type as follows:
  ///
  ///  *  `group` Share with a group. Specify `groupname` as well.
  ///  *  `project` Share with a project. Specify `projectId` as well.
  ///  *  `projectRole` Share with a project role in a project. Specify
  /// `projectId` and `projectRoleId` as well.
  ///  *  `global` Share globally, including anonymous users. If set, this type
  /// overrides all existing share permissions and must be deleted before any
  /// non-global share permissions is set.
  ///  *  `authenticated` Share with all logged-in users. This shows as
  /// `loggedin` in the response. If set, this type overrides all existing share
  /// permissions and must be deleted before any non-global share permissions is
  /// set.
  final SharePermissionInputBeanType type;

  /// The ID of the project to share the filter with. Set `type` to `project`.
  final String? projectId;

  /// The name of the group to share the filter with. Set `type` to `group`.
  final String? groupname;

  /// The ID of the project role to share the filter with. Set `type` to
  /// `projectRole` and the `projectId` for the project that the role is in.
  final String? projectRoleId;

  SharePermissionInputBean(
      {required this.type, this.projectId, this.groupname, this.projectRoleId});

  factory SharePermissionInputBean.fromJson(Map<String, Object?> json) {
    return SharePermissionInputBean(
      type: SharePermissionInputBeanType.fromValue(
          json[r'type'] as String? ?? ''),
      projectId: json[r'projectId'] as String?,
      groupname: json[r'groupname'] as String?,
      projectRoleId: json[r'projectRoleId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var projectId = this.projectId;
    var groupname = this.groupname;
    var projectRoleId = this.projectRoleId;

    final json = <String, Object?>{};
    json[r'type'] = type.value;
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    if (groupname != null) {
      json[r'groupname'] = groupname;
    }
    if (projectRoleId != null) {
      json[r'projectRoleId'] = projectRoleId;
    }
    return json;
  }

  SharePermissionInputBean copyWith(
      {SharePermissionInputBeanType? type,
      String? projectId,
      String? groupname,
      String? projectRoleId}) {
    return SharePermissionInputBean(
      type: type ?? this.type,
      projectId: projectId ?? this.projectId,
      groupname: groupname ?? this.groupname,
      projectRoleId: projectRoleId ?? this.projectRoleId,
    );
  }
}

class SharePermissionInputBeanType {
  static const project = SharePermissionInputBeanType._('project');
  static const group = SharePermissionInputBeanType._('group');
  static const projectRole = SharePermissionInputBeanType._('projectRole');
  static const global = SharePermissionInputBeanType._('global');
  static const authenticated = SharePermissionInputBeanType._('authenticated');

  static const values = [
    project,
    group,
    projectRole,
    global,
    authenticated,
  ];
  final String value;

  const SharePermissionInputBeanType._(this.value);

  static SharePermissionInputBeanType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => SharePermissionInputBeanType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about a failed webhook.
class FailedWebhook {
  /// The webhook ID, as sent in the `X-Atlassian-Webhook-Identifier` header
  /// with the webhook.
  final String id;

  /// The webhook body.
  final String? body;

  /// The original webhook destination.
  final String url;

  /// The time the webhook was added to the list of failed webhooks (that is,
  /// the time of the last failed retry).
  final int failureTime;

  FailedWebhook(
      {required this.id,
      this.body,
      required this.url,
      required this.failureTime});

  factory FailedWebhook.fromJson(Map<String, Object?> json) {
    return FailedWebhook(
      id: json[r'id'] as String? ?? '',
      body: json[r'body'] as String?,
      url: json[r'url'] as String? ?? '',
      failureTime: (json[r'failureTime'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var body = this.body;
    var url = this.url;
    var failureTime = this.failureTime;

    final json = <String, Object?>{};
    json[r'id'] = id;
    if (body != null) {
      json[r'body'] = body;
    }
    json[r'url'] = url;
    json[r'failureTime'] = failureTime;
    return json;
  }

  FailedWebhook copyWith(
      {String? id, String? body, String? url, int? failureTime}) {
    return FailedWebhook(
      id: id ?? this.id,
      body: body ?? this.body,
      url: url ?? this.url,
      failureTime: failureTime ?? this.failureTime,
    );
  }
}

/// A page of failed webhooks.
class FailedWebhooks {
  /// The list of webhooks.
  final List<FailedWebhook> values;

  /// The maximum number of items on the page. If the list of values is shorter
  /// than this number, then there are no more pages.
  final int maxResults;

  /// The URL to the next page of results. Present only if the request returned
  /// at least one result.The next page may be empty at the time of receiving
  /// the response, but new failed webhooks may appear in time. You can save the
  /// URL to the next page and query for new results periodically (for example,
  /// every hour).
  final String? next;

  FailedWebhooks({required this.values, required this.maxResults, this.next});

  factory FailedWebhooks.fromJson(Map<String, Object?> json) {
    return FailedWebhooks(
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FailedWebhook.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'maxResults'] as num?)?.toInt() ?? 0,
      next: json[r'next'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var values = this.values;
    var maxResults = this.maxResults;
    var next = this.next;

    final json = <String, Object?>{};
    json[r'values'] = values.map((i) => i.toJson()).toList();
    json[r'maxResults'] = maxResults;
    if (next != null) {
      json[r'next'] = next;
    }
    return json;
  }

  FailedWebhooks copyWith(
      {List<FailedWebhook>? values, int? maxResults, String? next}) {
    return FailedWebhooks(
      values: values ?? this.values,
      maxResults: maxResults ?? this.maxResults,
      next: next ?? this.next,
    );
  }
}

/// A list of webhooks.
class WebhookDetails {
  /// The JQL filter that specifies which issues the webhook is sent for. Only a
  /// subset of JQL can be used. The supported elements are:
  ///
  ///  *  Fields: `issueKey`, `project`, `issuetype`, `status`, `assignee`,
  /// `reporter`, `issue.property`, and `cf[id]` (for custom fieldsonly the
  /// epic label custom field is supported).
  ///  *  Operators: `=`, `!=`, `IN`, and `NOT IN`.
  final String jqlFilter;

  /// The Jira events that trigger the webhook.
  final List<WebhookDetailsEvents> events;

  WebhookDetails({required this.jqlFilter, required this.events});

  factory WebhookDetails.fromJson(Map<String, Object?> json) {
    return WebhookDetails(
      jqlFilter: json[r'jqlFilter'] as String? ?? '',
      events: (json[r'events'] as List<Object?>?)
              ?.map((i) => WebhookDetailsEvents.fromValue(i as String? ?? ''))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var jqlFilter = this.jqlFilter;
    var events = this.events;

    final json = <String, Object?>{};
    json[r'jqlFilter'] = jqlFilter;
    json[r'events'] = events.map((i) => i.value).toList();
    return json;
  }

  WebhookDetails copyWith(
      {String? jqlFilter, List<WebhookDetailsEvents>? events}) {
    return WebhookDetails(
      jqlFilter: jqlFilter ?? this.jqlFilter,
      events: events ?? this.events,
    );
  }
}

class WebhookDetailsEvents {
  static const jiraIssueCreated = WebhookDetailsEvents._('jira:issue_created');
  static const jiraIssueUpdated = WebhookDetailsEvents._('jira:issue_updated');
  static const jiraIssueDeleted = WebhookDetailsEvents._('jira:issue_deleted');
  static const commentCreated = WebhookDetailsEvents._('comment_created');
  static const commentUpdated = WebhookDetailsEvents._('comment_updated');
  static const commentDeleted = WebhookDetailsEvents._('comment_deleted');
  static const issuePropertySet = WebhookDetailsEvents._('issue_property_set');
  static const issuePropertyDeleted =
      WebhookDetailsEvents._('issue_property_deleted');

  static const values = [
    jiraIssueCreated,
    jiraIssueUpdated,
    jiraIssueDeleted,
    commentCreated,
    commentUpdated,
    commentDeleted,
    issuePropertySet,
    issuePropertyDeleted,
  ];
  final String value;

  const WebhookDetailsEvents._(this.value);

  static WebhookDetailsEvents fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => WebhookDetailsEvents._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of webhooks to register.
class WebhookRegistrationDetails {
  /// A list of webhooks.
  final List<WebhookDetails> webhooks;

  /// The URL that specifies where to send the webhooks. This URL must use the
  /// same base URL as the Connect app.
  final String url;

  WebhookRegistrationDetails({required this.webhooks, required this.url});

  factory WebhookRegistrationDetails.fromJson(Map<String, Object?> json) {
    return WebhookRegistrationDetails(
      webhooks: (json[r'webhooks'] as List<Object?>?)
              ?.map((i) => WebhookDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      url: json[r'url'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var webhooks = this.webhooks;
    var url = this.url;

    final json = <String, Object?>{};
    json[r'webhooks'] = webhooks.map((i) => i.toJson()).toList();
    json[r'url'] = url;
    return json;
  }

  WebhookRegistrationDetails copyWith(
      {List<WebhookDetails>? webhooks, String? url}) {
    return WebhookRegistrationDetails(
      webhooks: webhooks ?? this.webhooks,
      url: url ?? this.url,
    );
  }
}

/// Container for a list of registered webhooks. Webhook details are returned in
/// the same order as the request.
class ContainerForRegisteredWebhooks {
  /// A list of registered webhooks.
  final List<RegisteredWebhook> webhookRegistrationResult;

  ContainerForRegisteredWebhooks(
      {List<RegisteredWebhook>? webhookRegistrationResult})
      : webhookRegistrationResult = webhookRegistrationResult ?? [];

  factory ContainerForRegisteredWebhooks.fromJson(Map<String, Object?> json) {
    return ContainerForRegisteredWebhooks(
      webhookRegistrationResult:
          (json[r'webhookRegistrationResult'] as List<Object?>?)
                  ?.map((i) => RegisteredWebhook.fromJson(
                      i as Map<String, Object?>? ?? const {}))
                  .toList() ??
              [],
    );
  }

  Map<String, Object?> toJson() {
    var webhookRegistrationResult = this.webhookRegistrationResult;

    final json = <String, Object?>{};
    json[r'webhookRegistrationResult'] =
        webhookRegistrationResult.map((i) => i.toJson()).toList();
    return json;
  }

  ContainerForRegisteredWebhooks copyWith(
      {List<RegisteredWebhook>? webhookRegistrationResult}) {
    return ContainerForRegisteredWebhooks(
      webhookRegistrationResult:
          webhookRegistrationResult ?? this.webhookRegistrationResult,
    );
  }
}

/// ID of a registered webhook or error messages explaining why a webhook wasn't
/// registered.
class RegisteredWebhook {
  /// The ID of the webhook. Returned if the webhook is created.
  final int? createdWebhookId;

  /// Error messages specifying why the webhook creation failed.
  final List<String> errors;

  RegisteredWebhook({this.createdWebhookId, List<String>? errors})
      : errors = errors ?? [];

  factory RegisteredWebhook.fromJson(Map<String, Object?> json) {
    return RegisteredWebhook(
      createdWebhookId: (json[r'createdWebhookId'] as num?)?.toInt(),
      errors: (json[r'errors'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var createdWebhookId = this.createdWebhookId;
    var errors = this.errors;

    final json = <String, Object?>{};
    if (createdWebhookId != null) {
      json[r'createdWebhookId'] = createdWebhookId;
    }
    json[r'errors'] = errors;
    return json;
  }

  RegisteredWebhook copyWith({int? createdWebhookId, List<String>? errors}) {
    return RegisteredWebhook(
      createdWebhookId: createdWebhookId ?? this.createdWebhookId,
      errors: errors ?? this.errors,
    );
  }
}

/// A page of items.
class PageBeanWebhook {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<Webhook> values;

  PageBeanWebhook(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<Webhook>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanWebhook.fromJson(Map<String, Object?> json) {
    return PageBeanWebhook(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Webhook.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanWebhook copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<Webhook>? values}) {
    return PageBeanWebhook(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// A webhook.
class Webhook {
  /// The ID of the webhook.
  final int id;

  /// The JQL filter that specifies which issues the webhook is sent for.
  final String jqlFilter;

  /// The Jira events that trigger the webhook.
  final List<WebhookEvents> events;
  final int expirationDate;

  Webhook(
      {required this.id,
      required this.jqlFilter,
      required this.events,
      required this.expirationDate});

  factory Webhook.fromJson(Map<String, Object?> json) {
    return Webhook(
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      jqlFilter: json[r'jqlFilter'] as String? ?? '',
      events: (json[r'events'] as List<Object?>?)
              ?.map((i) => WebhookEvents.fromValue(i as String? ?? ''))
              .toList() ??
          [],
      expirationDate: (json[r'expirationDate'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var jqlFilter = this.jqlFilter;
    var events = this.events;
    var expirationDate = this.expirationDate;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'jqlFilter'] = jqlFilter;
    json[r'events'] = events.map((i) => i.value).toList();
    json[r'expirationDate'] = expirationDate;
    return json;
  }

  Webhook copyWith(
      {int? id,
      String? jqlFilter,
      List<WebhookEvents>? events,
      int? expirationDate}) {
    return Webhook(
      id: id ?? this.id,
      jqlFilter: jqlFilter ?? this.jqlFilter,
      events: events ?? this.events,
      expirationDate: expirationDate ?? this.expirationDate,
    );
  }
}

class WebhookEvents {
  static const jiraIssueCreated = WebhookEvents._('jira:issue_created');
  static const jiraIssueUpdated = WebhookEvents._('jira:issue_updated');
  static const jiraIssueDeleted = WebhookEvents._('jira:issue_deleted');
  static const commentCreated = WebhookEvents._('comment_created');
  static const commentUpdated = WebhookEvents._('comment_updated');
  static const commentDeleted = WebhookEvents._('comment_deleted');
  static const issuePropertySet = WebhookEvents._('issue_property_set');
  static const issuePropertyDeleted = WebhookEvents._('issue_property_deleted');

  static const values = [
    jiraIssueCreated,
    jiraIssueUpdated,
    jiraIssueDeleted,
    commentCreated,
    commentUpdated,
    commentDeleted,
    issuePropertySet,
    issuePropertyDeleted,
  ];
  final String value;

  const WebhookEvents._(this.value);

  static WebhookEvents fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => WebhookEvents._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Container for a list of webhook IDs.
class ContainerForWebhookIDs {
  /// A list of webhook IDs.
  final List<int> webhookIds;

  ContainerForWebhookIDs({required this.webhookIds});

  factory ContainerForWebhookIDs.fromJson(Map<String, Object?> json) {
    return ContainerForWebhookIDs(
      webhookIds: (json[r'webhookIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var webhookIds = this.webhookIds;

    final json = <String, Object?>{};
    json[r'webhookIds'] = webhookIds;
    return json;
  }

  ContainerForWebhookIDs copyWith({List<int>? webhookIds}) {
    return ContainerForWebhookIDs(
      webhookIds: webhookIds ?? this.webhookIds,
    );
  }
}

/// The date the newly refreshed webhooks expire.
class WebhooksExpirationDate {
  final int expirationDate;

  WebhooksExpirationDate({required this.expirationDate});

  factory WebhooksExpirationDate.fromJson(Map<String, Object?> json) {
    return WebhooksExpirationDate(
      expirationDate: (json[r'expirationDate'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var expirationDate = this.expirationDate;

    final json = <String, Object?>{};
    json[r'expirationDate'] = expirationDate;
    return json;
  }

  WebhooksExpirationDate copyWith({int? expirationDate}) {
    return WebhooksExpirationDate(
      expirationDate: expirationDate ?? this.expirationDate,
    );
  }
}

class IdOrKeyBean {
  /// The ID of the referenced item.
  final int? id;

  /// The key of the referenced item.
  final String? key;

  IdOrKeyBean({this.id, this.key});

  factory IdOrKeyBean.fromJson(Map<String, Object?> json) {
    return IdOrKeyBean(
      id: (json[r'id'] as num?)?.toInt(),
      key: json[r'key'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    return json;
  }

  IdOrKeyBean copyWith({int? id, String? key}) {
    return IdOrKeyBean(
      id: id ?? this.id,
      key: key ?? this.key,
    );
  }
}

/// The JQL specifying the issues available in the evaluated Jira expression
/// under the `issues` context variable.
class JexpIssues {
  /// The JQL query that specifies the set of issues available in the Jira
  /// expression.
  final JexpJqlIssues? jql;

  JexpIssues({this.jql});

  factory JexpIssues.fromJson(Map<String, Object?> json) {
    return JexpIssues(
      jql: json[r'jql'] != null
          ? JexpJqlIssues.fromJson(json[r'jql']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var jql = this.jql;

    final json = <String, Object?>{};
    if (jql != null) {
      json[r'jql'] = jql.toJson();
    }
    return json;
  }

  JexpIssues copyWith({JexpJqlIssues? jql}) {
    return JexpIssues(
      jql: jql ?? this.jql,
    );
  }
}

/// The JQL specifying the issues available in the evaluated Jira expression
/// under the `issues` context variable. Not all issues returned by the JQL
/// query are loaded, only those described by the `startAt` and `maxResults`
/// properties. To determine whether it is necessary to iterate to ensure all
/// the issues returned by the JQL query are evaluated, inspect
/// `meta.issues.jql.count` in the response.
class JexpJqlIssues {
  /// The JQL query.
  final String? query;

  /// The index of the first issue to return from the JQL query.
  final int? startAt;

  /// The maximum number of issues to return from the JQL query. Inspect
  /// `meta.issues.jql.maxResults` in the response to ensure the maximum value
  /// has not been exceeded.
  final int? maxResults;

  /// Determines how to validate the JQL query and treat the validation results.
  final JexpJqlIssuesValidation? validation;

  JexpJqlIssues({this.query, this.startAt, this.maxResults, this.validation});

  factory JexpJqlIssues.fromJson(Map<String, Object?> json) {
    return JexpJqlIssues(
      query: json[r'query'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      validation: json[r'validation'] != null
          ? JexpJqlIssuesValidation.fromValue(json[r'validation']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var query = this.query;
    var startAt = this.startAt;
    var maxResults = this.maxResults;
    var validation = this.validation;

    final json = <String, Object?>{};
    if (query != null) {
      json[r'query'] = query;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (validation != null) {
      json[r'validation'] = validation.value;
    }
    return json;
  }

  JexpJqlIssues copyWith(
      {String? query,
      int? startAt,
      int? maxResults,
      JexpJqlIssuesValidation? validation}) {
    return JexpJqlIssues(
      query: query ?? this.query,
      startAt: startAt ?? this.startAt,
      maxResults: maxResults ?? this.maxResults,
      validation: validation ?? this.validation,
    );
  }
}

class JexpJqlIssuesValidation {
  static const strict = JexpJqlIssuesValidation._('strict');
  static const warn = JexpJqlIssuesValidation._('warn');
  static const none = JexpJqlIssuesValidation._('none');

  static const values = [
    strict,
    warn,
    none,
  ];
  final String value;

  const JexpJqlIssuesValidation._(this.value);

  static JexpJqlIssuesValidation fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JexpJqlIssuesValidation._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class JiraExpressionEvalContextBean {
  /// The issue that is available under the `issue` variable when evaluating the
  /// expression.
  final IdOrKeyBean? issue;

  /// The collection of issues that is available under the `issues` variable
  /// when evaluating the expression.
  final JexpIssues? issues;

  /// The project that is available under the `project` variable when evaluating
  /// the expression.
  final IdOrKeyBean? project;

  /// The ID of the sprint that is available under the `sprint` variable when
  /// evaluating the expression.
  final int? sprint;

  /// The ID of the board that is available under the `board` variable when
  /// evaluating the expression.
  final int? board;

  /// The ID of the service desk that is available under the `serviceDesk`
  /// variable when evaluating the expression.
  final int? serviceDesk;

  /// The ID of the customer request that is available under the
  /// `customerRequest` variable when evaluating the expression. This is the
  /// same as the ID of the underlying Jira issue, but the customer request
  /// context variable will have a different type.
  final int? customerRequest;

  JiraExpressionEvalContextBean(
      {this.issue,
      this.issues,
      this.project,
      this.sprint,
      this.board,
      this.serviceDesk,
      this.customerRequest});

  factory JiraExpressionEvalContextBean.fromJson(Map<String, Object?> json) {
    return JiraExpressionEvalContextBean(
      issue: json[r'issue'] != null
          ? IdOrKeyBean.fromJson(json[r'issue']! as Map<String, Object?>)
          : null,
      issues: json[r'issues'] != null
          ? JexpIssues.fromJson(json[r'issues']! as Map<String, Object?>)
          : null,
      project: json[r'project'] != null
          ? IdOrKeyBean.fromJson(json[r'project']! as Map<String, Object?>)
          : null,
      sprint: (json[r'sprint'] as num?)?.toInt(),
      board: (json[r'board'] as num?)?.toInt(),
      serviceDesk: (json[r'serviceDesk'] as num?)?.toInt(),
      customerRequest: (json[r'customerRequest'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var issue = this.issue;
    var issues = this.issues;
    var project = this.project;
    var sprint = this.sprint;
    var board = this.board;
    var serviceDesk = this.serviceDesk;
    var customerRequest = this.customerRequest;

    final json = <String, Object?>{};
    if (issue != null) {
      json[r'issue'] = issue.toJson();
    }
    if (issues != null) {
      json[r'issues'] = issues.toJson();
    }
    if (project != null) {
      json[r'project'] = project.toJson();
    }
    if (sprint != null) {
      json[r'sprint'] = sprint;
    }
    if (board != null) {
      json[r'board'] = board;
    }
    if (serviceDesk != null) {
      json[r'serviceDesk'] = serviceDesk;
    }
    if (customerRequest != null) {
      json[r'customerRequest'] = customerRequest;
    }
    return json;
  }

  JiraExpressionEvalContextBean copyWith(
      {IdOrKeyBean? issue,
      JexpIssues? issues,
      IdOrKeyBean? project,
      int? sprint,
      int? board,
      int? serviceDesk,
      int? customerRequest}) {
    return JiraExpressionEvalContextBean(
      issue: issue ?? this.issue,
      issues: issues ?? this.issues,
      project: project ?? this.project,
      sprint: sprint ?? this.sprint,
      board: board ?? this.board,
      serviceDesk: serviceDesk ?? this.serviceDesk,
      customerRequest: customerRequest ?? this.customerRequest,
    );
  }
}

class JiraExpressionEvalRequestBean {
  /// The Jira expression to evaluate.
  final String expression;

  /// The context in which the Jira expression is evaluated.
  final JiraExpressionEvalContextBean? context;

  JiraExpressionEvalRequestBean({required this.expression, this.context});

  factory JiraExpressionEvalRequestBean.fromJson(Map<String, Object?> json) {
    return JiraExpressionEvalRequestBean(
      expression: json[r'expression'] as String? ?? '',
      context: json[r'context'] != null
          ? JiraExpressionEvalContextBean.fromJson(
              json[r'context']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var expression = this.expression;
    var context = this.context;

    final json = <String, Object?>{};
    json[r'expression'] = expression;
    if (context != null) {
      json[r'context'] = context.toJson();
    }
    return json;
  }

  JiraExpressionEvalRequestBean copyWith(
      {String? expression, JiraExpressionEvalContextBean? context}) {
    return JiraExpressionEvalRequestBean(
      expression: expression ?? this.expression,
      context: context ?? this.context,
    );
  }
}

/// The description of the page of issues loaded by the provided JQL query.
class IssuesJqlMetaDataBean {
  /// The index of the first issue.
  final int startAt;

  /// The maximum number of issues that could be loaded in this evaluation.
  final int maxResults;

  /// The number of issues that were loaded in this evaluation.
  final int count;

  /// The total number of issues the JQL returned.
  final int totalCount;

  /// Any warnings related to the JQL query. Present only if the validation mode
  /// was set to `warn`.
  final List<String> validationWarnings;

  IssuesJqlMetaDataBean(
      {required this.startAt,
      required this.maxResults,
      required this.count,
      required this.totalCount,
      List<String>? validationWarnings})
      : validationWarnings = validationWarnings ?? [];

  factory IssuesJqlMetaDataBean.fromJson(Map<String, Object?> json) {
    return IssuesJqlMetaDataBean(
      startAt: (json[r'startAt'] as num?)?.toInt() ?? 0,
      maxResults: (json[r'maxResults'] as num?)?.toInt() ?? 0,
      count: (json[r'count'] as num?)?.toInt() ?? 0,
      totalCount: (json[r'totalCount'] as num?)?.toInt() ?? 0,
      validationWarnings: (json[r'validationWarnings'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var startAt = this.startAt;
    var maxResults = this.maxResults;
    var count = this.count;
    var totalCount = this.totalCount;
    var validationWarnings = this.validationWarnings;

    final json = <String, Object?>{};
    json[r'startAt'] = startAt;
    json[r'maxResults'] = maxResults;
    json[r'count'] = count;
    json[r'totalCount'] = totalCount;
    json[r'validationWarnings'] = validationWarnings;
    return json;
  }

  IssuesJqlMetaDataBean copyWith(
      {int? startAt,
      int? maxResults,
      int? count,
      int? totalCount,
      List<String>? validationWarnings}) {
    return IssuesJqlMetaDataBean(
      startAt: startAt ?? this.startAt,
      maxResults: maxResults ?? this.maxResults,
      count: count ?? this.count,
      totalCount: totalCount ?? this.totalCount,
      validationWarnings: validationWarnings ?? this.validationWarnings,
    );
  }
}

/// Meta data describing the `issues` context variable.
class IssuesMetaBean {
  final IssuesJqlMetaDataBean? jql;

  IssuesMetaBean({this.jql});

  factory IssuesMetaBean.fromJson(Map<String, Object?> json) {
    return IssuesMetaBean(
      jql: json[r'jql'] != null
          ? IssuesJqlMetaDataBean.fromJson(
              json[r'jql']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var jql = this.jql;

    final json = <String, Object?>{};
    if (jql != null) {
      json[r'jql'] = jql.toJson();
    }
    return json;
  }

  IssuesMetaBean copyWith({IssuesJqlMetaDataBean? jql}) {
    return IssuesMetaBean(
      jql: jql ?? this.jql,
    );
  }
}

class JiraExpressionEvaluationMetaDataBean {
  /// Contains information about the expression complexity. For example, the
  /// number of steps it took to evaluate the expression.
  final JiraExpressionsComplexityBean? complexity;

  /// Contains information about the `issues` variable in the context. For
  /// example, is the issues were loaded with JQL, information about the page
  /// will be included here.
  final IssuesMetaBean? issues;

  JiraExpressionEvaluationMetaDataBean({this.complexity, this.issues});

  factory JiraExpressionEvaluationMetaDataBean.fromJson(
      Map<String, Object?> json) {
    return JiraExpressionEvaluationMetaDataBean(
      complexity: json[r'complexity'] != null
          ? JiraExpressionsComplexityBean.fromJson(
              json[r'complexity']! as Map<String, Object?>)
          : null,
      issues: json[r'issues'] != null
          ? IssuesMetaBean.fromJson(json[r'issues']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var complexity = this.complexity;
    var issues = this.issues;

    final json = <String, Object?>{};
    if (complexity != null) {
      json[r'complexity'] = complexity.toJson();
    }
    if (issues != null) {
      json[r'issues'] = issues.toJson();
    }
    return json;
  }

  JiraExpressionEvaluationMetaDataBean copyWith(
      {JiraExpressionsComplexityBean? complexity, IssuesMetaBean? issues}) {
    return JiraExpressionEvaluationMetaDataBean(
      complexity: complexity ?? this.complexity,
      issues: issues ?? this.issues,
    );
  }
}

/// The result of evaluating a Jira expression.
class JiraExpressionResult {
  /// The value of the evaluated expression. It may be a primitive JSON value or
  /// a Jira REST API object. (Some expressions do not produce any meaningful
  /// resultsfor example, an expression that returns a lambda functionif
  /// that's the case a simple string representation is returned. These string
  /// representations should not be relied upon and may change without notice.)
  final dynamic value;

  /// Contains various characteristics of the performed expression evaluation.
  final JiraExpressionEvaluationMetaDataBean? meta;

  JiraExpressionResult({required this.value, this.meta});

  factory JiraExpressionResult.fromJson(Map<String, Object?> json) {
    return JiraExpressionResult(
      value: json[r'value'],
      meta: json[r'meta'] != null
          ? JiraExpressionEvaluationMetaDataBean.fromJson(
              json[r'meta']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;
    var meta = this.meta;

    final json = <String, Object?>{};
    json[r'value'] = value;
    if (meta != null) {
      json[r'meta'] = meta.toJson();
    }
    return json;
  }

  JiraExpressionResult copyWith(
      {dynamic value, JiraExpressionEvaluationMetaDataBean? meta}) {
    return JiraExpressionResult(
      value: value ?? this.value,
      meta: meta ?? this.meta,
    );
  }
}

class JiraExpressionsComplexityBean {
  /// The number of steps it took to evaluate the expression, where a step is a
  /// high-level operation performed by the expression. A step is an operation
  /// such as arithmetic, accessing a property, accessing a context variable, or
  /// calling a function.
  final JiraExpressionsComplexityValueBean steps;

  /// The number of expensive operations executed while evaluating the
  /// expression. Expensive operations are those that load additional data, such
  /// as entity properties, comments, or custom fields.
  final JiraExpressionsComplexityValueBean expensiveOperations;

  /// The number of Jira REST API beans returned in the response.
  final JiraExpressionsComplexityValueBean beans;

  /// The number of primitive values returned in the response.
  final JiraExpressionsComplexityValueBean primitiveValues;

  JiraExpressionsComplexityBean(
      {required this.steps,
      required this.expensiveOperations,
      required this.beans,
      required this.primitiveValues});

  factory JiraExpressionsComplexityBean.fromJson(Map<String, Object?> json) {
    return JiraExpressionsComplexityBean(
      steps: JiraExpressionsComplexityValueBean.fromJson(
          json[r'steps'] as Map<String, Object?>? ?? const {}),
      expensiveOperations: JiraExpressionsComplexityValueBean.fromJson(
          json[r'expensiveOperations'] as Map<String, Object?>? ?? const {}),
      beans: JiraExpressionsComplexityValueBean.fromJson(
          json[r'beans'] as Map<String, Object?>? ?? const {}),
      primitiveValues: JiraExpressionsComplexityValueBean.fromJson(
          json[r'primitiveValues'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var steps = this.steps;
    var expensiveOperations = this.expensiveOperations;
    var beans = this.beans;
    var primitiveValues = this.primitiveValues;

    final json = <String, Object?>{};
    json[r'steps'] = steps.toJson();
    json[r'expensiveOperations'] = expensiveOperations.toJson();
    json[r'beans'] = beans.toJson();
    json[r'primitiveValues'] = primitiveValues.toJson();
    return json;
  }

  JiraExpressionsComplexityBean copyWith(
      {JiraExpressionsComplexityValueBean? steps,
      JiraExpressionsComplexityValueBean? expensiveOperations,
      JiraExpressionsComplexityValueBean? beans,
      JiraExpressionsComplexityValueBean? primitiveValues}) {
    return JiraExpressionsComplexityBean(
      steps: steps ?? this.steps,
      expensiveOperations: expensiveOperations ?? this.expensiveOperations,
      beans: beans ?? this.beans,
      primitiveValues: primitiveValues ?? this.primitiveValues,
    );
  }
}

class JiraExpressionsComplexityValueBean {
  /// The complexity value of the current expression.
  final int value;

  /// The maximum allowed complexity. The evaluation will fail if this value is
  /// exceeded.
  final int limit;

  JiraExpressionsComplexityValueBean(
      {required this.value, required this.limit});

  factory JiraExpressionsComplexityValueBean.fromJson(
      Map<String, Object?> json) {
    return JiraExpressionsComplexityValueBean(
      value: (json[r'value'] as num?)?.toInt() ?? 0,
      limit: (json[r'limit'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;
    var limit = this.limit;

    final json = <String, Object?>{};
    json[r'value'] = value;
    json[r'limit'] = limit;
    return json;
  }

  JiraExpressionsComplexityValueBean copyWith({int? value, int? limit}) {
    return JiraExpressionsComplexityValueBean(
      value: value ?? this.value,
      limit: limit ?? this.limit,
    );
  }
}

/// Details of Jira expressions for analysis.
class JiraExpressionForAnalysis {
  /// The list of Jira expressions to analyse.
  final List<String> expressions;

  /// Context variables and their types. The type checker assumes that
  /// [common context variables](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#context-variables),
  /// such as `issue` or `project`, are available in context and sets their
  /// type. Use this property to override the default types or provide details
  /// of new variables.
  final Map<String, dynamic>? contextVariables;

  JiraExpressionForAnalysis({required this.expressions, this.contextVariables});

  factory JiraExpressionForAnalysis.fromJson(Map<String, Object?> json) {
    return JiraExpressionForAnalysis(
      expressions: (json[r'expressions'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      contextVariables: json[r'contextVariables'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var expressions = this.expressions;
    var contextVariables = this.contextVariables;

    final json = <String, Object?>{};
    json[r'expressions'] = expressions;
    if (contextVariables != null) {
      json[r'contextVariables'] = contextVariables;
    }
    return json;
  }

  JiraExpressionForAnalysis copyWith(
      {List<String>? expressions, Map<String, dynamic>? contextVariables}) {
    return JiraExpressionForAnalysis(
      expressions: expressions ?? this.expressions,
      contextVariables: contextVariables ?? this.contextVariables,
    );
  }
}

/// Details about the analysed Jira expression.
class JiraExpressionAnalysis {
  /// The analysed expression.
  final String expression;

  /// A list of validation errors. Not included if the expression is valid.
  final List<JiraExpressionValidationError> errors;

  /// Whether the expression is valid and the interpreter will evaluate it. Note
  /// that the expression may fail at runtime (for example, if it executes too
  /// many expensive operations).
  final bool valid;

  /// EXPERIMENTAL. The inferred type of the expression.
  final String? type;
  final JiraExpressionComplexity? complexity;

  JiraExpressionAnalysis(
      {required this.expression,
      List<JiraExpressionValidationError>? errors,
      required this.valid,
      this.type,
      this.complexity})
      : errors = errors ?? [];

  factory JiraExpressionAnalysis.fromJson(Map<String, Object?> json) {
    return JiraExpressionAnalysis(
      expression: json[r'expression'] as String? ?? '',
      errors: (json[r'errors'] as List<Object?>?)
              ?.map((i) => JiraExpressionValidationError.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      valid: json[r'valid'] as bool? ?? false,
      type: json[r'type'] as String?,
      complexity: json[r'complexity'] != null
          ? JiraExpressionComplexity.fromJson(
              json[r'complexity']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var expression = this.expression;
    var errors = this.errors;
    var valid = this.valid;
    var type = this.type;
    var complexity = this.complexity;

    final json = <String, Object?>{};
    json[r'expression'] = expression;
    json[r'errors'] = errors.map((i) => i.toJson()).toList();
    json[r'valid'] = valid;
    if (type != null) {
      json[r'type'] = type;
    }
    if (complexity != null) {
      json[r'complexity'] = complexity.toJson();
    }
    return json;
  }

  JiraExpressionAnalysis copyWith(
      {String? expression,
      List<JiraExpressionValidationError>? errors,
      bool? valid,
      String? type,
      JiraExpressionComplexity? complexity}) {
    return JiraExpressionAnalysis(
      expression: expression ?? this.expression,
      errors: errors ?? this.errors,
      valid: valid ?? this.valid,
      type: type ?? this.type,
      complexity: complexity ?? this.complexity,
    );
  }
}

/// Details about the complexity of the analysed Jira expression.
class JiraExpressionComplexity {
  /// Information that can be used to determine how many
  /// [expensive operations](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#expensive-operations)
  /// the evaluation of the expression will perform. This information may be a
  /// formula or number. For example:
  ///
  ///  *  `issues.map(i => i.comments)` performs as many expensive operations as
  /// there are issues on the issues list. So this parameter returns `N`, where
  /// `N` is the size of issue list.
  ///  *  `new Issue(10010).comments` gets comments for one issue, so its
  /// complexity is `2` (`1` to retrieve issue 10010 from the database plus `1`
  /// to get its comments).
  final String expensiveOperations;

  /// Variables used in the formula, mapped to the parts of the expression they
  /// refer to.
  final Map<String, dynamic>? variables;

  JiraExpressionComplexity({required this.expensiveOperations, this.variables});

  factory JiraExpressionComplexity.fromJson(Map<String, Object?> json) {
    return JiraExpressionComplexity(
      expensiveOperations: json[r'expensiveOperations'] as String? ?? '',
      variables: json[r'variables'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var expensiveOperations = this.expensiveOperations;
    var variables = this.variables;

    final json = <String, Object?>{};
    json[r'expensiveOperations'] = expensiveOperations;
    if (variables != null) {
      json[r'variables'] = variables;
    }
    return json;
  }

  JiraExpressionComplexity copyWith(
      {String? expensiveOperations, Map<String, dynamic>? variables}) {
    return JiraExpressionComplexity(
      expensiveOperations: expensiveOperations ?? this.expensiveOperations,
      variables: variables ?? this.variables,
    );
  }
}

/// Details about syntax and type errors. The error details apply to the entire
/// expression, unless the object includes:
///
///  *  `line` and `column`
///  *  `expression`
class JiraExpressionValidationError {
  /// The text line in which the error occurred.
  final int? line;

  /// The text column in which the error occurred.
  final int? column;

  /// The part of the expression in which the error occurred.
  final String? expression;

  /// Details about the error.
  final String message;

  /// The error type.
  final JiraExpressionValidationErrorType type;

  JiraExpressionValidationError(
      {this.line,
      this.column,
      this.expression,
      required this.message,
      required this.type});

  factory JiraExpressionValidationError.fromJson(Map<String, Object?> json) {
    return JiraExpressionValidationError(
      line: (json[r'line'] as num?)?.toInt(),
      column: (json[r'column'] as num?)?.toInt(),
      expression: json[r'expression'] as String?,
      message: json[r'message'] as String? ?? '',
      type: JiraExpressionValidationErrorType.fromValue(
          json[r'type'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var line = this.line;
    var column = this.column;
    var expression = this.expression;
    var message = this.message;
    var type = this.type;

    final json = <String, Object?>{};
    if (line != null) {
      json[r'line'] = line;
    }
    if (column != null) {
      json[r'column'] = column;
    }
    if (expression != null) {
      json[r'expression'] = expression;
    }
    json[r'message'] = message;
    json[r'type'] = type.value;
    return json;
  }

  JiraExpressionValidationError copyWith(
      {int? line,
      int? column,
      String? expression,
      String? message,
      JiraExpressionValidationErrorType? type}) {
    return JiraExpressionValidationError(
      line: line ?? this.line,
      column: column ?? this.column,
      expression: expression ?? this.expression,
      message: message ?? this.message,
      type: type ?? this.type,
    );
  }
}

class JiraExpressionValidationErrorType {
  static const syntax = JiraExpressionValidationErrorType._('syntax');
  static const type = JiraExpressionValidationErrorType._('type');
  static const other = JiraExpressionValidationErrorType._('other');

  static const values = [
    syntax,
    type,
    other,
  ];
  final String value;

  const JiraExpressionValidationErrorType._(this.value);

  static JiraExpressionValidationErrorType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JiraExpressionValidationErrorType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about the analysed Jira expression.
class JiraExpressionsAnalysis {
  /// The results of Jira expressions analysis.
  final List<JiraExpressionAnalysis> results;

  JiraExpressionsAnalysis({required this.results});

  factory JiraExpressionsAnalysis.fromJson(Map<String, Object?> json) {
    return JiraExpressionsAnalysis(
      results: (json[r'results'] as List<Object?>?)
              ?.map((i) => JiraExpressionAnalysis.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var results = this.results;

    final json = <String, Object?>{};
    json[r'results'] = results.map((i) => i.toJson()).toList();
    return json;
  }

  JiraExpressionsAnalysis copyWith({List<JiraExpressionAnalysis>? results}) {
    return JiraExpressionsAnalysis(
      results: results ?? this.results,
    );
  }
}

/// Details about a group.
class GroupDetails {
  /// The name of the group.
  final String? name;

  /// The ID of the group, if available, which uniquely identifies the group
  /// across all Atlassian products. For example,
  /// *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.
  final String? groupId;

  GroupDetails({this.name, this.groupId});

  factory GroupDetails.fromJson(Map<String, Object?> json) {
    return GroupDetails(
      name: json[r'name'] as String?,
      groupId: json[r'groupId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var groupId = this.groupId;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (groupId != null) {
      json[r'groupId'] = groupId;
    }
    return json;
  }

  GroupDetails copyWith({String? name, String? groupId}) {
    return GroupDetails(
      name: name ?? this.name,
      groupId: groupId ?? this.groupId,
    );
  }
}

/// A page of items.
class PageBeanGroupDetails {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<GroupDetails> values;

  PageBeanGroupDetails(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<GroupDetails>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanGroupDetails.fromJson(Map<String, Object?> json) {
    return PageBeanGroupDetails(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  GroupDetails.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanGroupDetails copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<GroupDetails>? values}) {
    return PageBeanGroupDetails(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanString {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<String> values;

  PageBeanString(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<String>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanString.fromJson(Map<String, Object?> json) {
    return PageBeanString(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values;
    return json;
  }

  PageBeanString copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<String>? values}) {
    return PageBeanString(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

class IdBean {
  /// The ID of the permission scheme to associate with the project. Use the
  /// [Get all permission schemes](#api-rest-api-3-permissionscheme-get)
  /// resource to get a list of permission scheme IDs.
  final int id;

  IdBean({required this.id});

  factory IdBean.fromJson(Map<String, Object?> json) {
    return IdBean(
      id: (json[r'id'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  IdBean copyWith({int? id}) {
    return IdBean(
      id: id ?? this.id,
    );
  }
}

/// Details about a permission granted to a user or group.
class PermissionGrant {
  /// The ID of the permission granted details.
  final int? id;

  /// The URL of the permission granted details.
  final String? self;

  /// The user or group being granted the permission. It consists of a `type`
  /// and a type-dependent `parameter`. See
  /// [Holder object](../api-group-permission-schemes/#holder-object) in *Get
  /// all permission schemes* for more information.
  final PermissionHolder? holder;

  /// The permission to grant. This permission can be one of the built-in
  /// permissions or a custom permission added by an app. See
  /// [Built-in permissions](../api-group-permission-schemes/#built-in-permissions)
  /// in *Get all permission schemes* for more information about the built-in
  /// permissions. See the
  /// [project permission](https://developer.atlassian.com/cloud/jira/platform/modules/project-permission/)
  /// and
  /// [global permission](https://developer.atlassian.com/cloud/jira/platform/modules/global-permission/)
  /// module documentation for more information about custom permissions.
  final String? permission;

  PermissionGrant({this.id, this.self, this.holder, this.permission});

  factory PermissionGrant.fromJson(Map<String, Object?> json) {
    return PermissionGrant(
      id: (json[r'id'] as num?)?.toInt(),
      self: json[r'self'] as String?,
      holder: json[r'holder'] != null
          ? PermissionHolder.fromJson(json[r'holder']! as Map<String, Object?>)
          : null,
      permission: json[r'permission'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var self = this.self;
    var holder = this.holder;
    var permission = this.permission;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (holder != null) {
      json[r'holder'] = holder.toJson();
    }
    if (permission != null) {
      json[r'permission'] = permission;
    }
    return json;
  }

  PermissionGrant copyWith(
      {int? id, String? self, PermissionHolder? holder, String? permission}) {
    return PermissionGrant(
      id: id ?? this.id,
      self: self ?? this.self,
      holder: holder ?? this.holder,
      permission: permission ?? this.permission,
    );
  }
}

/// Details of a user, group, field, or project role that holds a permission.
/// See [Holder object](../api-group-permission-schemes/#holder-object) in *Get
/// all permission schemes* for more information.
class PermissionHolder {
  /// The type of permission holder.
  final String type;

  /// The identifier of permission holder.
  final String? parameter;

  /// Expand options that include additional permission holder details in the
  /// response.
  final String? expand;

  PermissionHolder({required this.type, this.parameter, this.expand});

  factory PermissionHolder.fromJson(Map<String, Object?> json) {
    return PermissionHolder(
      type: json[r'type'] as String? ?? '',
      parameter: json[r'parameter'] as String?,
      expand: json[r'expand'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var parameter = this.parameter;
    var expand = this.expand;

    final json = <String, Object?>{};
    json[r'type'] = type;
    if (parameter != null) {
      json[r'parameter'] = parameter;
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    return json;
  }

  PermissionHolder copyWith({String? type, String? parameter, String? expand}) {
    return PermissionHolder(
      type: type ?? this.type,
      parameter: parameter ?? this.parameter,
      expand: expand ?? this.expand,
    );
  }
}

/// Details of a permission scheme.
class PermissionScheme {
  /// The expand options available for the permission scheme.
  final String? expand;

  /// The ID of the permission scheme.
  final int? id;

  /// The URL of the permission scheme.
  final String? self;

  /// The name of the permission scheme. Must be unique.
  final String name;

  /// A description for the permission scheme.
  final String? description;

  /// The scope of the permission scheme.
  final Scope? scope;

  /// The permission scheme to create or update. See
  /// [About permission schemes and grants](../api-group-permission-schemes/#about-permission-schemes-and-grants)
  /// for more information.
  final List<PermissionGrant> permissions;

  PermissionScheme(
      {this.expand,
      this.id,
      this.self,
      required this.name,
      this.description,
      this.scope,
      List<PermissionGrant>? permissions})
      : permissions = permissions ?? [];

  factory PermissionScheme.fromJson(Map<String, Object?> json) {
    return PermissionScheme(
      expand: json[r'expand'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      self: json[r'self'] as String?,
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      permissions: (json[r'permissions'] as List<Object?>?)
              ?.map((i) => PermissionGrant.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var id = this.id;
    var self = this.self;
    var name = this.name;
    var description = this.description;
    var scope = this.scope;
    var permissions = this.permissions;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    json[r'permissions'] = permissions.map((i) => i.toJson()).toList();
    return json;
  }

  PermissionScheme copyWith(
      {String? expand,
      int? id,
      String? self,
      String? name,
      String? description,
      Scope? scope,
      List<PermissionGrant>? permissions}) {
    return PermissionScheme(
      expand: expand ?? this.expand,
      id: id ?? this.id,
      self: self ?? this.self,
      name: name ?? this.name,
      description: description ?? this.description,
      scope: scope ?? this.scope,
      permissions: permissions ?? this.permissions,
    );
  }
}

/// Details about permissions.
class Permissions {
  /// List of permissions.
  final Map<String, dynamic>? permissions;

  Permissions({this.permissions});

  factory Permissions.fromJson(Map<String, Object?> json) {
    return Permissions(
      permissions: json[r'permissions'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var permissions = this.permissions;

    final json = <String, Object?>{};
    if (permissions != null) {
      json[r'permissions'] = permissions;
    }
    return json;
  }

  Permissions copyWith({Map<String, dynamic>? permissions}) {
    return Permissions(
      permissions: permissions ?? this.permissions,
    );
  }
}

/// Details of a permission and its availability to a user.
class UserPermission {
  /// The ID of the permission. Either `id` or `key` must be specified. Use
  /// [Get all permissions](#api-rest-api-3-permissions-get) to get the list of
  /// permissions.
  final String? id;

  /// The key of the permission. Either `id` or `key` must be specified. Use
  /// [Get all permissions](#api-rest-api-3-permissions-get) to get the list of
  /// permissions.
  final String? key;

  /// The name of the permission.
  final String? name;

  /// The type of the permission.
  final UserPermissionType? type;

  /// The description of the permission.
  final String? description;

  /// Whether the permission is available to the user in the queried context.
  final bool havePermission;

  /// Indicate whether the permission key is deprecated. Note that deprecated
  /// keys cannot be used in the `permissions parameter of Get my permissions.
  /// Deprecated keys are not returned by Get all permissions.`
  final bool deprecatedKey;

  UserPermission(
      {this.id,
      this.key,
      this.name,
      this.type,
      this.description,
      bool? havePermission,
      bool? deprecatedKey})
      : havePermission = havePermission ?? false,
        deprecatedKey = deprecatedKey ?? false;

  factory UserPermission.fromJson(Map<String, Object?> json) {
    return UserPermission(
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? UserPermissionType.fromValue(json[r'type']! as String)
          : null,
      description: json[r'description'] as String?,
      havePermission: json[r'havePermission'] as bool? ?? false,
      deprecatedKey: json[r'deprecatedKey'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;
    var name = this.name;
    var type = this.type;
    var description = this.description;
    var havePermission = this.havePermission;
    var deprecatedKey = this.deprecatedKey;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'havePermission'] = havePermission;
    json[r'deprecatedKey'] = deprecatedKey;
    return json;
  }

  UserPermission copyWith(
      {String? id,
      String? key,
      String? name,
      UserPermissionType? type,
      String? description,
      bool? havePermission,
      bool? deprecatedKey}) {
    return UserPermission(
      id: id ?? this.id,
      key: key ?? this.key,
      name: name ?? this.name,
      type: type ?? this.type,
      description: description ?? this.description,
      havePermission: havePermission ?? this.havePermission,
      deprecatedKey: deprecatedKey ?? this.deprecatedKey,
    );
  }
}

class UserPermissionType {
  static const global = UserPermissionType._('GLOBAL');
  static const project = UserPermissionType._('PROJECT');

  static const values = [
    global,
    project,
  ];
  final String value;

  const UserPermissionType._(this.value);

  static UserPermissionType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UserPermissionType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of global permissions to look up and project permissions with
/// associated projects and issues to look up.
class BulkPermissionsRequestBean {
  /// Project permissions with associated projects and issues to look up.
  final List<BulkProjectPermissions> projectPermissions;

  /// Global permissions to look up.
  final List<String> globalPermissions;

  /// The account ID of a user.
  final String? accountId;

  BulkPermissionsRequestBean(
      {List<BulkProjectPermissions>? projectPermissions,
      List<String>? globalPermissions,
      this.accountId})
      : projectPermissions = projectPermissions ?? [],
        globalPermissions = globalPermissions ?? [];

  factory BulkPermissionsRequestBean.fromJson(Map<String, Object?> json) {
    return BulkPermissionsRequestBean(
      projectPermissions: (json[r'projectPermissions'] as List<Object?>?)
              ?.map((i) => BulkProjectPermissions.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      globalPermissions: (json[r'globalPermissions'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      accountId: json[r'accountId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var projectPermissions = this.projectPermissions;
    var globalPermissions = this.globalPermissions;
    var accountId = this.accountId;

    final json = <String, Object?>{};
    json[r'projectPermissions'] =
        projectPermissions.map((i) => i.toJson()).toList();
    json[r'globalPermissions'] = globalPermissions;
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    return json;
  }

  BulkPermissionsRequestBean copyWith(
      {List<BulkProjectPermissions>? projectPermissions,
      List<String>? globalPermissions,
      String? accountId}) {
    return BulkPermissionsRequestBean(
      projectPermissions: projectPermissions ?? this.projectPermissions,
      globalPermissions: globalPermissions ?? this.globalPermissions,
      accountId: accountId ?? this.accountId,
    );
  }
}

/// Details of project permissions and associated issues and projects to look
/// up.
class BulkProjectPermissions {
  /// List of issue IDs.
  final List<int> issues;

  /// List of project IDs.
  final List<int> projects;

  /// List of project permissions.
  final List<String> permissions;

  BulkProjectPermissions(
      {List<int>? issues, List<int>? projects, required this.permissions})
      : issues = issues ?? [],
        projects = projects ?? [];

  factory BulkProjectPermissions.fromJson(Map<String, Object?> json) {
    return BulkProjectPermissions(
      issues: (json[r'issues'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      projects: (json[r'projects'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      permissions: (json[r'permissions'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issues = this.issues;
    var projects = this.projects;
    var permissions = this.permissions;

    final json = <String, Object?>{};
    json[r'issues'] = issues;
    json[r'projects'] = projects;
    json[r'permissions'] = permissions;
    return json;
  }

  BulkProjectPermissions copyWith(
      {List<int>? issues, List<int>? projects, List<String>? permissions}) {
    return BulkProjectPermissions(
      issues: issues ?? this.issues,
      projects: projects ?? this.projects,
      permissions: permissions ?? this.permissions,
    );
  }
}

/// Details of global and project permissions granted to the user.
class BulkPermissionGrants {
  /// List of project permissions and the projects and issues those permissions
  /// provide access to.
  final List<BulkProjectPermissionGrants> projectPermissions;

  /// List of permissions granted to the user.
  final List<String> globalPermissions;

  BulkPermissionGrants(
      {required this.projectPermissions, required this.globalPermissions});

  factory BulkPermissionGrants.fromJson(Map<String, Object?> json) {
    return BulkPermissionGrants(
      projectPermissions: (json[r'projectPermissions'] as List<Object?>?)
              ?.map((i) => BulkProjectPermissionGrants.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      globalPermissions: (json[r'globalPermissions'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var projectPermissions = this.projectPermissions;
    var globalPermissions = this.globalPermissions;

    final json = <String, Object?>{};
    json[r'projectPermissions'] =
        projectPermissions.map((i) => i.toJson()).toList();
    json[r'globalPermissions'] = globalPermissions;
    return json;
  }

  BulkPermissionGrants copyWith(
      {List<BulkProjectPermissionGrants>? projectPermissions,
      List<String>? globalPermissions}) {
    return BulkPermissionGrants(
      projectPermissions: projectPermissions ?? this.projectPermissions,
      globalPermissions: globalPermissions ?? this.globalPermissions,
    );
  }
}

/// List of project permissions and the projects and issues those permissions
/// grant access to.
class BulkProjectPermissionGrants {
  /// A project permission,
  final String permission;

  /// IDs of the issues the user has the permission for.
  final List<int> issues;

  /// IDs of the projects the user has the permission for.
  final List<int> projects;

  BulkProjectPermissionGrants(
      {required this.permission, required this.issues, required this.projects});

  factory BulkProjectPermissionGrants.fromJson(Map<String, Object?> json) {
    return BulkProjectPermissionGrants(
      permission: json[r'permission'] as String? ?? '',
      issues: (json[r'issues'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      projects: (json[r'projects'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var permission = this.permission;
    var issues = this.issues;
    var projects = this.projects;

    final json = <String, Object?>{};
    json[r'permission'] = permission;
    json[r'issues'] = issues;
    json[r'projects'] = projects;
    return json;
  }

  BulkProjectPermissionGrants copyWith(
      {String? permission, List<int>? issues, List<int>? projects}) {
    return BulkProjectPermissionGrants(
      permission: permission ?? this.permission,
      issues: issues ?? this.issues,
      projects: projects ?? this.projects,
    );
  }
}

class PermissionsKeysBean {
  /// A list of permission keys.
  final List<String> permissions;

  PermissionsKeysBean({required this.permissions});

  factory PermissionsKeysBean.fromJson(Map<String, Object?> json) {
    return PermissionsKeysBean(
      permissions: (json[r'permissions'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var permissions = this.permissions;

    final json = <String, Object?>{};
    json[r'permissions'] = permissions;
    return json;
  }

  PermissionsKeysBean copyWith({List<String>? permissions}) {
    return PermissionsKeysBean(
      permissions: permissions ?? this.permissions,
    );
  }
}

/// A list of projects in which a user is granted permissions.
class PermittedProjects {
  /// A list of projects.
  final List<ProjectIdentifierBean> projects;

  PermittedProjects({List<ProjectIdentifierBean>? projects})
      : projects = projects ?? [];

  factory PermittedProjects.fromJson(Map<String, Object?> json) {
    return PermittedProjects(
      projects: (json[r'projects'] as List<Object?>?)
              ?.map((i) => ProjectIdentifierBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var projects = this.projects;

    final json = <String, Object?>{};
    json[r'projects'] = projects.map((i) => i.toJson()).toList();
    return json;
  }

  PermittedProjects copyWith({List<ProjectIdentifierBean>? projects}) {
    return PermittedProjects(
      projects: projects ?? this.projects,
    );
  }
}

/// The identifiers for a project.
class ProjectIdentifierBean {
  /// The ID of the project.
  final int? id;

  /// The key of the project.
  final String? key;

  ProjectIdentifierBean({this.id, this.key});

  factory ProjectIdentifierBean.fromJson(Map<String, Object?> json) {
    return ProjectIdentifierBean(
      id: (json[r'id'] as num?)?.toInt(),
      key: json[r'key'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    return json;
  }

  ProjectIdentifierBean copyWith({int? id, String? key}) {
    return ProjectIdentifierBean(
      id: id ?? this.id,
      key: key ?? this.key,
    );
  }
}

/// Bulk issue property update request details.
class BulkIssuePropertyUpdateRequest {
  /// The value of the property. The value must be a
  /// [valid](https://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  final dynamic value;

  /// EXPERIMENTAL. The Jira expression to calculate the value of the property.
  /// The value of the expression must be an object that can be converted to
  /// JSON, such as a number, boolean, string, list, or map. The context
  /// variables available to the expression are `issue` and `user`. Issues for
  /// which the expression returns a value whose JSON representation is longer
  /// than 32768 characters are ignored.
  final String? expression;

  /// The bulk operation filter.
  final IssueFilterForBulkPropertySet? filter;

  BulkIssuePropertyUpdateRequest({this.value, this.expression, this.filter});

  factory BulkIssuePropertyUpdateRequest.fromJson(Map<String, Object?> json) {
    return BulkIssuePropertyUpdateRequest(
      value: json[r'value'],
      expression: json[r'expression'] as String?,
      filter: json[r'filter'] != null
          ? IssueFilterForBulkPropertySet.fromJson(
              json[r'filter']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;
    var expression = this.expression;
    var filter = this.filter;

    final json = <String, Object?>{};
    if (value != null) {
      json[r'value'] = value;
    }
    if (expression != null) {
      json[r'expression'] = expression;
    }
    if (filter != null) {
      json[r'filter'] = filter.toJson();
    }
    return json;
  }

  BulkIssuePropertyUpdateRequest copyWith(
      {dynamic value,
      String? expression,
      IssueFilterForBulkPropertySet? filter}) {
    return BulkIssuePropertyUpdateRequest(
      value: value ?? this.value,
      expression: expression ?? this.expression,
      filter: filter ?? this.filter,
    );
  }
}

/// Bulk operation filter details.
class IssueFilterForBulkPropertySet {
  /// List of issues to perform the bulk operation on.
  final List<int> entityIds;

  /// The value of properties to perform the bulk operation on.
  final dynamic currentValue;

  /// Whether the bulk operation occurs only when the property is present on or
  /// absent from an issue.
  final bool hasProperty;

  IssueFilterForBulkPropertySet(
      {List<int>? entityIds, this.currentValue, bool? hasProperty})
      : entityIds = entityIds ?? [],
        hasProperty = hasProperty ?? false;

  factory IssueFilterForBulkPropertySet.fromJson(Map<String, Object?> json) {
    return IssueFilterForBulkPropertySet(
      entityIds: (json[r'entityIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      currentValue: json[r'currentValue'],
      hasProperty: json[r'hasProperty'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var entityIds = this.entityIds;
    var currentValue = this.currentValue;
    var hasProperty = this.hasProperty;

    final json = <String, Object?>{};
    json[r'entityIds'] = entityIds;
    if (currentValue != null) {
      json[r'currentValue'] = currentValue;
    }
    json[r'hasProperty'] = hasProperty;
    return json;
  }

  IssueFilterForBulkPropertySet copyWith(
      {List<int>? entityIds, dynamic currentValue, bool? hasProperty}) {
    return IssueFilterForBulkPropertySet(
      entityIds: entityIds ?? this.entityIds,
      currentValue: currentValue ?? this.currentValue,
      hasProperty: hasProperty ?? this.hasProperty,
    );
  }
}

/// Bulk operation filter details.
class IssueFilterForBulkPropertyDelete {
  /// List of issues to perform the bulk delete operation on.
  final List<int> entityIds;

  /// The value of properties to perform the bulk operation on.
  final dynamic currentValue;

  IssueFilterForBulkPropertyDelete({List<int>? entityIds, this.currentValue})
      : entityIds = entityIds ?? [];

  factory IssueFilterForBulkPropertyDelete.fromJson(Map<String, Object?> json) {
    return IssueFilterForBulkPropertyDelete(
      entityIds: (json[r'entityIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      currentValue: json[r'currentValue'],
    );
  }

  Map<String, Object?> toJson() {
    var entityIds = this.entityIds;
    var currentValue = this.currentValue;

    final json = <String, Object?>{};
    json[r'entityIds'] = entityIds;
    if (currentValue != null) {
      json[r'currentValue'] = currentValue;
    }
    return json;
  }

  IssueFilterForBulkPropertyDelete copyWith(
      {List<int>? entityIds, dynamic currentValue}) {
    return IssueFilterForBulkPropertyDelete(
      entityIds: entityIds ?? this.entityIds,
      currentValue: currentValue ?? this.currentValue,
    );
  }
}

/// Lists of issues and entity properties. See
/// [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/)
/// for more information.
class IssueEntityProperties {
  /// A list of entity property IDs.
  final List<int> entitiesIds;

  /// A list of entity property keys and values.
  final Map<String, dynamic>? properties;

  IssueEntityProperties({List<int>? entitiesIds, this.properties})
      : entitiesIds = entitiesIds ?? [];

  factory IssueEntityProperties.fromJson(Map<String, Object?> json) {
    return IssueEntityProperties(
      entitiesIds: (json[r'entitiesIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      properties: json[r'properties'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var entitiesIds = this.entitiesIds;
    var properties = this.properties;

    final json = <String, Object?>{};
    json[r'entitiesIds'] = entitiesIds;
    if (properties != null) {
      json[r'properties'] = properties;
    }
    return json;
  }

  IssueEntityProperties copyWith(
      {List<int>? entitiesIds, Map<String, dynamic>? properties}) {
    return IssueEntityProperties(
      entitiesIds: entitiesIds ?? this.entitiesIds,
      properties: properties ?? this.properties,
    );
  }
}

class JsonNode {
  final Map<String, dynamic>? elements;
  final bool pojo;
  final bool containerNode;
  final bool missingNode;
  final bool object;
  final bool valueNode;
  final bool number;
  final bool integralNumber;
  final bool floatingPointNumber;
  final bool int$;
  final bool long;
  final bool double$;
  final bool bigDecimal;
  final bool bigInteger;
  final bool textual;
  final bool boolean;
  final bool binary;
  final num? numberValue;
  final JsonNodeNumberType? numberType;
  final int? intValue;
  final int? longValue;
  final int? bigIntegerValue;
  final num? doubleValue;
  final num? decimalValue;
  final bool booleanValue;
  final List<String> binaryValue;
  final int? valueAsInt;
  final int? valueAsLong;
  final num? valueAsDouble;
  final bool valueAsBoolean;
  final Map<String, dynamic>? fieldNames;
  final String? textValue;
  final String? valueAsText;
  final bool array;
  final Map<String, dynamic>? fields;
  final bool null$;

  JsonNode(
      {this.elements,
      bool? pojo,
      bool? containerNode,
      bool? missingNode,
      bool? object,
      bool? valueNode,
      bool? number,
      bool? integralNumber,
      bool? floatingPointNumber,
      bool? int$,
      bool? long,
      bool? double$,
      bool? bigDecimal,
      bool? bigInteger,
      bool? textual,
      bool? boolean,
      bool? binary,
      this.numberValue,
      this.numberType,
      this.intValue,
      this.longValue,
      this.bigIntegerValue,
      this.doubleValue,
      this.decimalValue,
      bool? booleanValue,
      List<String>? binaryValue,
      this.valueAsInt,
      this.valueAsLong,
      this.valueAsDouble,
      bool? valueAsBoolean,
      this.fieldNames,
      this.textValue,
      this.valueAsText,
      bool? array,
      this.fields,
      bool? null$})
      : pojo = pojo ?? false,
        containerNode = containerNode ?? false,
        missingNode = missingNode ?? false,
        object = object ?? false,
        valueNode = valueNode ?? false,
        number = number ?? false,
        integralNumber = integralNumber ?? false,
        floatingPointNumber = floatingPointNumber ?? false,
        int$ = int$ ?? false,
        long = long ?? false,
        double$ = double$ ?? false,
        bigDecimal = bigDecimal ?? false,
        bigInteger = bigInteger ?? false,
        textual = textual ?? false,
        boolean = boolean ?? false,
        binary = binary ?? false,
        booleanValue = booleanValue ?? false,
        binaryValue = binaryValue ?? [],
        valueAsBoolean = valueAsBoolean ?? false,
        array = array ?? false,
        null$ = null$ ?? false;

  factory JsonNode.fromJson(Map<String, Object?> json) {
    return JsonNode(
      elements: json[r'elements'] as Map<String, Object?>?,
      pojo: json[r'pojo'] as bool? ?? false,
      containerNode: json[r'containerNode'] as bool? ?? false,
      missingNode: json[r'missingNode'] as bool? ?? false,
      object: json[r'object'] as bool? ?? false,
      valueNode: json[r'valueNode'] as bool? ?? false,
      number: json[r'number'] as bool? ?? false,
      integralNumber: json[r'integralNumber'] as bool? ?? false,
      floatingPointNumber: json[r'floatingPointNumber'] as bool? ?? false,
      int$: json[r'int'] as bool? ?? false,
      long: json[r'long'] as bool? ?? false,
      double$: json[r'double'] as bool? ?? false,
      bigDecimal: json[r'bigDecimal'] as bool? ?? false,
      bigInteger: json[r'bigInteger'] as bool? ?? false,
      textual: json[r'textual'] as bool? ?? false,
      boolean: json[r'boolean'] as bool? ?? false,
      binary: json[r'binary'] as bool? ?? false,
      numberValue: json[r'numberValue'] as num?,
      numberType: json[r'numberType'] != null
          ? JsonNodeNumberType.fromValue(json[r'numberType']! as String)
          : null,
      intValue: (json[r'intValue'] as num?)?.toInt(),
      longValue: (json[r'longValue'] as num?)?.toInt(),
      bigIntegerValue: (json[r'bigIntegerValue'] as num?)?.toInt(),
      doubleValue: json[r'doubleValue'] as num?,
      decimalValue: json[r'decimalValue'] as num?,
      booleanValue: json[r'booleanValue'] as bool? ?? false,
      binaryValue: (json[r'binaryValue'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      valueAsInt: (json[r'valueAsInt'] as num?)?.toInt(),
      valueAsLong: (json[r'valueAsLong'] as num?)?.toInt(),
      valueAsDouble: json[r'valueAsDouble'] as num?,
      valueAsBoolean: json[r'valueAsBoolean'] as bool? ?? false,
      fieldNames: json[r'fieldNames'] as Map<String, Object?>?,
      textValue: json[r'textValue'] as String?,
      valueAsText: json[r'valueAsText'] as String?,
      array: json[r'array'] as bool? ?? false,
      fields: json[r'fields'] as Map<String, Object?>?,
      null$: json[r'null'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var elements = this.elements;
    var pojo = this.pojo;
    var containerNode = this.containerNode;
    var missingNode = this.missingNode;
    var object = this.object;
    var valueNode = this.valueNode;
    var number = this.number;
    var integralNumber = this.integralNumber;
    var floatingPointNumber = this.floatingPointNumber;
    var int$ = this.int$;
    var long = this.long;
    var double$ = this.double$;
    var bigDecimal = this.bigDecimal;
    var bigInteger = this.bigInteger;
    var textual = this.textual;
    var boolean = this.boolean;
    var binary = this.binary;
    var numberValue = this.numberValue;
    var numberType = this.numberType;
    var intValue = this.intValue;
    var longValue = this.longValue;
    var bigIntegerValue = this.bigIntegerValue;
    var doubleValue = this.doubleValue;
    var decimalValue = this.decimalValue;
    var booleanValue = this.booleanValue;
    var binaryValue = this.binaryValue;
    var valueAsInt = this.valueAsInt;
    var valueAsLong = this.valueAsLong;
    var valueAsDouble = this.valueAsDouble;
    var valueAsBoolean = this.valueAsBoolean;
    var fieldNames = this.fieldNames;
    var textValue = this.textValue;
    var valueAsText = this.valueAsText;
    var array = this.array;
    var fields = this.fields;
    var null$ = this.null$;

    final json = <String, Object?>{};
    if (elements != null) {
      json[r'elements'] = elements;
    }
    json[r'pojo'] = pojo;
    json[r'containerNode'] = containerNode;
    json[r'missingNode'] = missingNode;
    json[r'object'] = object;
    json[r'valueNode'] = valueNode;
    json[r'number'] = number;
    json[r'integralNumber'] = integralNumber;
    json[r'floatingPointNumber'] = floatingPointNumber;
    json[r'int'] = int$;
    json[r'long'] = long;
    json[r'double'] = double$;
    json[r'bigDecimal'] = bigDecimal;
    json[r'bigInteger'] = bigInteger;
    json[r'textual'] = textual;
    json[r'boolean'] = boolean;
    json[r'binary'] = binary;
    if (numberValue != null) {
      json[r'numberValue'] = numberValue;
    }
    if (numberType != null) {
      json[r'numberType'] = numberType.value;
    }
    if (intValue != null) {
      json[r'intValue'] = intValue;
    }
    if (longValue != null) {
      json[r'longValue'] = longValue;
    }
    if (bigIntegerValue != null) {
      json[r'bigIntegerValue'] = bigIntegerValue;
    }
    if (doubleValue != null) {
      json[r'doubleValue'] = doubleValue;
    }
    if (decimalValue != null) {
      json[r'decimalValue'] = decimalValue;
    }
    json[r'booleanValue'] = booleanValue;
    json[r'binaryValue'] = binaryValue;
    if (valueAsInt != null) {
      json[r'valueAsInt'] = valueAsInt;
    }
    if (valueAsLong != null) {
      json[r'valueAsLong'] = valueAsLong;
    }
    if (valueAsDouble != null) {
      json[r'valueAsDouble'] = valueAsDouble;
    }
    json[r'valueAsBoolean'] = valueAsBoolean;
    if (fieldNames != null) {
      json[r'fieldNames'] = fieldNames;
    }
    if (textValue != null) {
      json[r'textValue'] = textValue;
    }
    if (valueAsText != null) {
      json[r'valueAsText'] = valueAsText;
    }
    json[r'array'] = array;
    if (fields != null) {
      json[r'fields'] = fields;
    }
    json[r'null'] = null$;
    return json;
  }

  JsonNode copyWith(
      {Map<String, dynamic>? elements,
      bool? pojo,
      bool? containerNode,
      bool? missingNode,
      bool? object,
      bool? valueNode,
      bool? number,
      bool? integralNumber,
      bool? floatingPointNumber,
      bool? int$,
      bool? long,
      bool? double$,
      bool? bigDecimal,
      bool? bigInteger,
      bool? textual,
      bool? boolean,
      bool? binary,
      num? numberValue,
      JsonNodeNumberType? numberType,
      int? intValue,
      int? longValue,
      int? bigIntegerValue,
      num? doubleValue,
      num? decimalValue,
      bool? booleanValue,
      List<String>? binaryValue,
      int? valueAsInt,
      int? valueAsLong,
      num? valueAsDouble,
      bool? valueAsBoolean,
      Map<String, dynamic>? fieldNames,
      String? textValue,
      String? valueAsText,
      bool? array,
      Map<String, dynamic>? fields,
      bool? null$}) {
    return JsonNode(
      elements: elements ?? this.elements,
      pojo: pojo ?? this.pojo,
      containerNode: containerNode ?? this.containerNode,
      missingNode: missingNode ?? this.missingNode,
      object: object ?? this.object,
      valueNode: valueNode ?? this.valueNode,
      number: number ?? this.number,
      integralNumber: integralNumber ?? this.integralNumber,
      floatingPointNumber: floatingPointNumber ?? this.floatingPointNumber,
      int$: int$ ?? this.int$,
      long: long ?? this.long,
      double$: double$ ?? this.double$,
      bigDecimal: bigDecimal ?? this.bigDecimal,
      bigInteger: bigInteger ?? this.bigInteger,
      textual: textual ?? this.textual,
      boolean: boolean ?? this.boolean,
      binary: binary ?? this.binary,
      numberValue: numberValue ?? this.numberValue,
      numberType: numberType ?? this.numberType,
      intValue: intValue ?? this.intValue,
      longValue: longValue ?? this.longValue,
      bigIntegerValue: bigIntegerValue ?? this.bigIntegerValue,
      doubleValue: doubleValue ?? this.doubleValue,
      decimalValue: decimalValue ?? this.decimalValue,
      booleanValue: booleanValue ?? this.booleanValue,
      binaryValue: binaryValue ?? this.binaryValue,
      valueAsInt: valueAsInt ?? this.valueAsInt,
      valueAsLong: valueAsLong ?? this.valueAsLong,
      valueAsDouble: valueAsDouble ?? this.valueAsDouble,
      valueAsBoolean: valueAsBoolean ?? this.valueAsBoolean,
      fieldNames: fieldNames ?? this.fieldNames,
      textValue: textValue ?? this.textValue,
      valueAsText: valueAsText ?? this.valueAsText,
      array: array ?? this.array,
      fields: fields ?? this.fields,
      null$: null$ ?? this.null$,
    );
  }
}

class JsonNodeNumberType {
  static const int$ = JsonNodeNumberType._('INT');
  static const long = JsonNodeNumberType._('LONG');
  static const bigInteger = JsonNodeNumberType._('BIG_INTEGER');
  static const float = JsonNodeNumberType._('FLOAT');
  static const double$ = JsonNodeNumberType._('DOUBLE');
  static const bigDecimal = JsonNodeNumberType._('BIG_DECIMAL');

  static const values = [
    int$,
    long,
    bigInteger,
    float,
    double$,
    bigDecimal,
  ];
  final String value;

  const JsonNodeNumberType._(this.value);

  static JsonNodeNumberType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JsonNodeNumberType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class UserMigrationBean {
  final String? key;
  final String? username;
  final String? accountId;

  UserMigrationBean({this.key, this.username, this.accountId});

  factory UserMigrationBean.fromJson(Map<String, Object?> json) {
    return UserMigrationBean(
      key: json[r'key'] as String?,
      username: json[r'username'] as String?,
      accountId: json[r'accountId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var username = this.username;
    var accountId = this.accountId;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key;
    }
    if (username != null) {
      json[r'username'] = username;
    }
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    return json;
  }

  UserMigrationBean copyWith(
      {String? key, String? username, String? accountId}) {
    return UserMigrationBean(
      key: key ?? this.key,
      username: username ?? this.username,
      accountId: accountId ?? this.accountId,
    );
  }
}

class UnrestrictedUserEmail {
  /// The accountId of the user
  final String? accountId;

  /// The email of the user
  final String? email;

  UnrestrictedUserEmail({this.accountId, this.email});

  factory UnrestrictedUserEmail.fromJson(Map<String, Object?> json) {
    return UnrestrictedUserEmail(
      accountId: json[r'accountId'] as String?,
      email: json[r'email'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var email = this.email;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (email != null) {
      json[r'email'] = email;
    }
    return json;
  }

  UnrestrictedUserEmail copyWith({String? accountId, String? email}) {
    return UnrestrictedUserEmail(
      accountId: accountId ?? this.accountId,
      email: email ?? this.email,
    );
  }
}

/// Details about the replacement for a deleted version.
class CustomFieldReplacement {
  /// The ID of the custom field in which to replace the version number.
  final int? customFieldId;

  /// The version number to use as a replacement for the deleted version.
  final int? moveTo;

  CustomFieldReplacement({this.customFieldId, this.moveTo});

  factory CustomFieldReplacement.fromJson(Map<String, Object?> json) {
    return CustomFieldReplacement(
      customFieldId: (json[r'customFieldId'] as num?)?.toInt(),
      moveTo: (json[r'moveTo'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var customFieldId = this.customFieldId;
    var moveTo = this.moveTo;

    final json = <String, Object?>{};
    if (customFieldId != null) {
      json[r'customFieldId'] = customFieldId;
    }
    if (moveTo != null) {
      json[r'moveTo'] = moveTo;
    }
    return json;
  }

  CustomFieldReplacement copyWith({int? customFieldId, int? moveTo}) {
    return CustomFieldReplacement(
      customFieldId: customFieldId ?? this.customFieldId,
      moveTo: moveTo ?? this.moveTo,
    );
  }
}

class DeleteAndReplaceVersionBean {
  /// The ID of the version to update `fixVersion` to when the field contains
  /// the deleted version.
  final int? moveFixIssuesTo;

  /// The ID of the version to update `affectedVersion` to when the field
  /// contains the deleted version.
  final int? moveAffectedIssuesTo;

  /// An array of custom field IDs (`customFieldId`) and version IDs (`moveTo`)
  /// to update when the fields contain the deleted version.
  final List<CustomFieldReplacement> customFieldReplacementList;

  DeleteAndReplaceVersionBean(
      {this.moveFixIssuesTo,
      this.moveAffectedIssuesTo,
      List<CustomFieldReplacement>? customFieldReplacementList})
      : customFieldReplacementList = customFieldReplacementList ?? [];

  factory DeleteAndReplaceVersionBean.fromJson(Map<String, Object?> json) {
    return DeleteAndReplaceVersionBean(
      moveFixIssuesTo: (json[r'moveFixIssuesTo'] as num?)?.toInt(),
      moveAffectedIssuesTo: (json[r'moveAffectedIssuesTo'] as num?)?.toInt(),
      customFieldReplacementList:
          (json[r'customFieldReplacementList'] as List<Object?>?)
                  ?.map((i) => CustomFieldReplacement.fromJson(
                      i as Map<String, Object?>? ?? const {}))
                  .toList() ??
              [],
    );
  }

  Map<String, Object?> toJson() {
    var moveFixIssuesTo = this.moveFixIssuesTo;
    var moveAffectedIssuesTo = this.moveAffectedIssuesTo;
    var customFieldReplacementList = this.customFieldReplacementList;

    final json = <String, Object?>{};
    if (moveFixIssuesTo != null) {
      json[r'moveFixIssuesTo'] = moveFixIssuesTo;
    }
    if (moveAffectedIssuesTo != null) {
      json[r'moveAffectedIssuesTo'] = moveAffectedIssuesTo;
    }
    json[r'customFieldReplacementList'] =
        customFieldReplacementList.map((i) => i.toJson()).toList();
    return json;
  }

  DeleteAndReplaceVersionBean copyWith(
      {int? moveFixIssuesTo,
      int? moveAffectedIssuesTo,
      List<CustomFieldReplacement>? customFieldReplacementList}) {
    return DeleteAndReplaceVersionBean(
      moveFixIssuesTo: moveFixIssuesTo ?? this.moveFixIssuesTo,
      moveAffectedIssuesTo: moveAffectedIssuesTo ?? this.moveAffectedIssuesTo,
      customFieldReplacementList:
          customFieldReplacementList ?? this.customFieldReplacementList,
    );
  }
}

/// Various counts of issues within a version.
class VersionIssueCounts {
  /// The URL of these count details.
  final String? self;

  /// Count of issues where the `fixVersion` is set to the version.
  final int? issuesFixedCount;

  /// Count of issues where the `affectedVersion` is set to the version.
  final int? issuesAffectedCount;

  /// Count of issues where a version custom field is set to the version.
  final int? issueCountWithCustomFieldsShowingVersion;

  /// List of custom fields using the version.
  final List<VersionUsageInCustomField> customFieldUsage;

  VersionIssueCounts(
      {this.self,
      this.issuesFixedCount,
      this.issuesAffectedCount,
      this.issueCountWithCustomFieldsShowingVersion,
      List<VersionUsageInCustomField>? customFieldUsage})
      : customFieldUsage = customFieldUsage ?? [];

  factory VersionIssueCounts.fromJson(Map<String, Object?> json) {
    return VersionIssueCounts(
      self: json[r'self'] as String?,
      issuesFixedCount: (json[r'issuesFixedCount'] as num?)?.toInt(),
      issuesAffectedCount: (json[r'issuesAffectedCount'] as num?)?.toInt(),
      issueCountWithCustomFieldsShowingVersion:
          (json[r'issueCountWithCustomFieldsShowingVersion'] as num?)?.toInt(),
      customFieldUsage: (json[r'customFieldUsage'] as List<Object?>?)
              ?.map((i) => VersionUsageInCustomField.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var issuesFixedCount = this.issuesFixedCount;
    var issuesAffectedCount = this.issuesAffectedCount;
    var issueCountWithCustomFieldsShowingVersion =
        this.issueCountWithCustomFieldsShowingVersion;
    var customFieldUsage = this.customFieldUsage;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (issuesFixedCount != null) {
      json[r'issuesFixedCount'] = issuesFixedCount;
    }
    if (issuesAffectedCount != null) {
      json[r'issuesAffectedCount'] = issuesAffectedCount;
    }
    if (issueCountWithCustomFieldsShowingVersion != null) {
      json[r'issueCountWithCustomFieldsShowingVersion'] =
          issueCountWithCustomFieldsShowingVersion;
    }
    json[r'customFieldUsage'] =
        customFieldUsage.map((i) => i.toJson()).toList();
    return json;
  }

  VersionIssueCounts copyWith(
      {String? self,
      int? issuesFixedCount,
      int? issuesAffectedCount,
      int? issueCountWithCustomFieldsShowingVersion,
      List<VersionUsageInCustomField>? customFieldUsage}) {
    return VersionIssueCounts(
      self: self ?? this.self,
      issuesFixedCount: issuesFixedCount ?? this.issuesFixedCount,
      issuesAffectedCount: issuesAffectedCount ?? this.issuesAffectedCount,
      issueCountWithCustomFieldsShowingVersion:
          issueCountWithCustomFieldsShowingVersion ??
              this.issueCountWithCustomFieldsShowingVersion,
      customFieldUsage: customFieldUsage ?? this.customFieldUsage,
    );
  }
}

/// List of custom fields using the version.
class VersionUsageInCustomField {
  /// The name of the custom field.
  final String? fieldName;

  /// The ID of the custom field.
  final int? customFieldId;

  /// Count of the issues where the custom field contains the version.
  final int? issueCountWithVersionInCustomField;

  VersionUsageInCustomField(
      {this.fieldName,
      this.customFieldId,
      this.issueCountWithVersionInCustomField});

  factory VersionUsageInCustomField.fromJson(Map<String, Object?> json) {
    return VersionUsageInCustomField(
      fieldName: json[r'fieldName'] as String?,
      customFieldId: (json[r'customFieldId'] as num?)?.toInt(),
      issueCountWithVersionInCustomField:
          (json[r'issueCountWithVersionInCustomField'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var fieldName = this.fieldName;
    var customFieldId = this.customFieldId;
    var issueCountWithVersionInCustomField =
        this.issueCountWithVersionInCustomField;

    final json = <String, Object?>{};
    if (fieldName != null) {
      json[r'fieldName'] = fieldName;
    }
    if (customFieldId != null) {
      json[r'customFieldId'] = customFieldId;
    }
    if (issueCountWithVersionInCustomField != null) {
      json[r'issueCountWithVersionInCustomField'] =
          issueCountWithVersionInCustomField;
    }
    return json;
  }

  VersionUsageInCustomField copyWith(
      {String? fieldName,
      int? customFieldId,
      int? issueCountWithVersionInCustomField}) {
    return VersionUsageInCustomField(
      fieldName: fieldName ?? this.fieldName,
      customFieldId: customFieldId ?? this.customFieldId,
      issueCountWithVersionInCustomField: issueCountWithVersionInCustomField ??
          this.issueCountWithVersionInCustomField,
    );
  }
}

/// Count of a version's unresolved issues.
class VersionUnresolvedIssuesCount {
  /// The URL of these count details.
  final String? self;

  /// Count of unresolved issues.
  final int? issuesUnresolvedCount;

  /// Count of issues.
  final int? issuesCount;

  VersionUnresolvedIssuesCount(
      {this.self, this.issuesUnresolvedCount, this.issuesCount});

  factory VersionUnresolvedIssuesCount.fromJson(Map<String, Object?> json) {
    return VersionUnresolvedIssuesCount(
      self: json[r'self'] as String?,
      issuesUnresolvedCount: (json[r'issuesUnresolvedCount'] as num?)?.toInt(),
      issuesCount: (json[r'issuesCount'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var issuesUnresolvedCount = this.issuesUnresolvedCount;
    var issuesCount = this.issuesCount;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (issuesUnresolvedCount != null) {
      json[r'issuesUnresolvedCount'] = issuesUnresolvedCount;
    }
    if (issuesCount != null) {
      json[r'issuesCount'] = issuesCount;
    }
    return json;
  }

  VersionUnresolvedIssuesCount copyWith(
      {String? self, int? issuesUnresolvedCount, int? issuesCount}) {
    return VersionUnresolvedIssuesCount(
      self: self ?? this.self,
      issuesUnresolvedCount:
          issuesUnresolvedCount ?? this.issuesUnresolvedCount,
      issuesCount: issuesCount ?? this.issuesCount,
    );
  }
}

class VersionMoveBean {
  /// The URL (self link) of the version after which to place the moved version.
  /// Cannot be used with `position`.
  final String? after;

  /// An absolute position in which to place the moved version. Cannot be used
  /// with `after`.
  final VersionMoveBeanPosition? position;

  VersionMoveBean({this.after, this.position});

  factory VersionMoveBean.fromJson(Map<String, Object?> json) {
    return VersionMoveBean(
      after: json[r'after'] as String?,
      position: json[r'position'] != null
          ? VersionMoveBeanPosition.fromValue(json[r'position']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var after = this.after;
    var position = this.position;

    final json = <String, Object?>{};
    if (after != null) {
      json[r'after'] = after;
    }
    if (position != null) {
      json[r'position'] = position.value;
    }
    return json;
  }

  VersionMoveBean copyWith({String? after, VersionMoveBeanPosition? position}) {
    return VersionMoveBean(
      after: after ?? this.after,
      position: position ?? this.position,
    );
  }
}

class VersionMoveBeanPosition {
  static const earlier = VersionMoveBeanPosition._('Earlier');
  static const later = VersionMoveBeanPosition._('Later');
  static const first = VersionMoveBeanPosition._('First');
  static const last = VersionMoveBeanPosition._('Last');

  static const values = [
    earlier,
    later,
    first,
    last,
  ];
  final String value;

  const VersionMoveBeanPosition._(this.value);

  static VersionMoveBeanPosition fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => VersionMoveBeanPosition._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The list of users found in a search, including header text (Showing X of Y
/// matching users) and total of matched users.
class FoundUsers {
  final List<UserPickerUser> users;

  /// The total number of users found in the search.
  final int? total;

  /// Header text indicating the number of users in the response and the total
  /// number of users found in the search.
  final String? header;

  FoundUsers({List<UserPickerUser>? users, this.total, this.header})
      : users = users ?? [];

  factory FoundUsers.fromJson(Map<String, Object?> json) {
    return FoundUsers(
      users: (json[r'users'] as List<Object?>?)
              ?.map((i) => UserPickerUser.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
      header: json[r'header'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var users = this.users;
    var total = this.total;
    var header = this.header;

    final json = <String, Object?>{};
    json[r'users'] = users.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    if (header != null) {
      json[r'header'] = header;
    }
    return json;
  }

  FoundUsers copyWith(
      {List<UserPickerUser>? users, int? total, String? header}) {
    return FoundUsers(
      users: users ?? this.users,
      total: total ?? this.total,
      header: header ?? this.header,
    );
  }
}

/// A user found in a search.
class UserPickerUser {
  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
  final String? accountId;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? name;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? key;

  /// The display name, email address, and key of the user with the matched
  /// query string highlighted with the HTML bold tag.
  final String? html;

  /// The display name of the user. Depending on the users privacy setting,
  /// this may be returned as null.
  final String? displayName;

  /// The avatar URL of the user.
  final String? avatarUrl;

  UserPickerUser(
      {this.accountId,
      this.name,
      this.key,
      this.html,
      this.displayName,
      this.avatarUrl});

  factory UserPickerUser.fromJson(Map<String, Object?> json) {
    return UserPickerUser(
      accountId: json[r'accountId'] as String?,
      name: json[r'name'] as String?,
      key: json[r'key'] as String?,
      html: json[r'html'] as String?,
      displayName: json[r'displayName'] as String?,
      avatarUrl: json[r'avatarUrl'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var name = this.name;
    var key = this.key;
    var html = this.html;
    var displayName = this.displayName;
    var avatarUrl = this.avatarUrl;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (html != null) {
      json[r'html'] = html;
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (avatarUrl != null) {
      json[r'avatarUrl'] = avatarUrl;
    }
    return json;
  }

  UserPickerUser copyWith(
      {String? accountId,
      String? name,
      String? key,
      String? html,
      String? displayName,
      String? avatarUrl}) {
    return UserPickerUser(
      accountId: accountId ?? this.accountId,
      name: name ?? this.name,
      key: key ?? this.key,
      html: html ?? this.html,
      displayName: displayName ?? this.displayName,
      avatarUrl: avatarUrl ?? this.avatarUrl,
    );
  }
}

class UserWriteBean {
  /// The URL of the user.
  final String? self;

  /// The key for the user. When provided with `name`, overrides the value in
  /// `name` to set both `name` and `key`. This property is deprecated because
  /// of privacy changes. See the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? key;

  /// The username for the user. This property is deprecated because of privacy
  /// changes. See the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? name;

  /// A password for the user. If a password is not set, a random password is
  /// generated.
  final String? password;

  /// The email address for the user.
  final String emailAddress;

  /// The display name for the user.
  final String displayName;

  /// Sends the user an email confirmation that they have been added to Jira.
  /// Default is `false`.
  final String? notification;

  /// Deprecated, do not use.
  final List<String> applicationKeys;

  UserWriteBean(
      {this.self,
      this.key,
      this.name,
      this.password,
      required this.emailAddress,
      required this.displayName,
      this.notification,
      List<String>? applicationKeys})
      : applicationKeys = applicationKeys ?? [];

  factory UserWriteBean.fromJson(Map<String, Object?> json) {
    return UserWriteBean(
      self: json[r'self'] as String?,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      password: json[r'password'] as String?,
      emailAddress: json[r'emailAddress'] as String? ?? '',
      displayName: json[r'displayName'] as String? ?? '',
      notification: json[r'notification'] as String?,
      applicationKeys: (json[r'applicationKeys'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var key = this.key;
    var name = this.name;
    var password = this.password;
    var emailAddress = this.emailAddress;
    var displayName = this.displayName;
    var notification = this.notification;
    var applicationKeys = this.applicationKeys;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (password != null) {
      json[r'password'] = password;
    }
    json[r'emailAddress'] = emailAddress;
    json[r'displayName'] = displayName;
    if (notification != null) {
      json[r'notification'] = notification;
    }
    json[r'applicationKeys'] = applicationKeys;
    return json;
  }

  UserWriteBean copyWith(
      {String? self,
      String? key,
      String? name,
      String? password,
      String? emailAddress,
      String? displayName,
      String? notification,
      List<String>? applicationKeys}) {
    return UserWriteBean(
      self: self ?? this.self,
      key: key ?? this.key,
      name: name ?? this.name,
      password: password ?? this.password,
      emailAddress: emailAddress ?? this.emailAddress,
      displayName: displayName ?? this.displayName,
      notification: notification ?? this.notification,
      applicationKeys: applicationKeys ?? this.applicationKeys,
    );
  }
}

/// Details of an avatar.
class Avatar {
  /// The ID of the avatar.
  final String id;

  /// The owner of the avatar. For a system avatar the owner is null (and
  /// nothing is returned). For non-system avatars this is the appropriate
  /// identifier, such as the ID for a project or the account ID for a user.
  final String? owner;

  /// Whether the avatar is a system avatar.
  final bool isSystemAvatar;

  /// Whether the avatar is used in Jira. For example, shown as a project's
  /// avatar.
  final bool isSelected;

  /// Whether the avatar can be deleted.
  final bool isDeletable;

  /// The file name of the avatar icon. Returned for system avatars.
  final String? fileName;

  /// The list of avatar icon URLs.
  final Map<String, dynamic>? urls;

  Avatar(
      {required this.id,
      this.owner,
      bool? isSystemAvatar,
      bool? isSelected,
      bool? isDeletable,
      this.fileName,
      this.urls})
      : isSystemAvatar = isSystemAvatar ?? false,
        isSelected = isSelected ?? false,
        isDeletable = isDeletable ?? false;

  factory Avatar.fromJson(Map<String, Object?> json) {
    return Avatar(
      id: json[r'id'] as String? ?? '',
      owner: json[r'owner'] as String?,
      isSystemAvatar: json[r'isSystemAvatar'] as bool? ?? false,
      isSelected: json[r'isSelected'] as bool? ?? false,
      isDeletable: json[r'isDeletable'] as bool? ?? false,
      fileName: json[r'fileName'] as String?,
      urls: json[r'urls'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var owner = this.owner;
    var isSystemAvatar = this.isSystemAvatar;
    var isSelected = this.isSelected;
    var isDeletable = this.isDeletable;
    var fileName = this.fileName;
    var urls = this.urls;

    final json = <String, Object?>{};
    json[r'id'] = id;
    if (owner != null) {
      json[r'owner'] = owner;
    }
    json[r'isSystemAvatar'] = isSystemAvatar;
    json[r'isSelected'] = isSelected;
    json[r'isDeletable'] = isDeletable;
    if (fileName != null) {
      json[r'fileName'] = fileName;
    }
    if (urls != null) {
      json[r'urls'] = urls;
    }
    return json;
  }

  Avatar copyWith(
      {String? id,
      String? owner,
      bool? isSystemAvatar,
      bool? isSelected,
      bool? isDeletable,
      String? fileName,
      Map<String, dynamic>? urls}) {
    return Avatar(
      id: id ?? this.id,
      owner: owner ?? this.owner,
      isSystemAvatar: isSystemAvatar ?? this.isSystemAvatar,
      isSelected: isSelected ?? this.isSelected,
      isDeletable: isDeletable ?? this.isDeletable,
      fileName: fileName ?? this.fileName,
      urls: urls ?? this.urls,
    );
  }
}

/// Details about system and custom avatars.
class Avatars {
  /// System avatars list.
  final List<Avatar> system;

  /// Custom avatars list.
  final List<Avatar> custom;

  Avatars({List<Avatar>? system, List<Avatar>? custom})
      : system = system ?? [],
        custom = custom ?? [];

  factory Avatars.fromJson(Map<String, Object?> json) {
    return Avatars(
      system: (json[r'system'] as List<Object?>?)
              ?.map((i) =>
                  Avatar.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      custom: (json[r'custom'] as List<Object?>?)
              ?.map((i) =>
                  Avatar.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var system = this.system;
    var custom = this.custom;

    final json = <String, Object?>{};
    json[r'system'] = system.map((i) => i.toJson()).toList();
    json[r'custom'] = custom.map((i) => i.toJson()).toList();
    return json;
  }

  Avatars copyWith({List<Avatar>? system, List<Avatar>? custom}) {
    return Avatars(
      system: system ?? this.system,
      custom: custom ?? this.custom,
    );
  }
}

/// A screen tab.
class ScreenableTab {
  /// The ID of the screen tab.
  final int? id;

  /// The name of the screen tab. The maximum length is 255 characters.
  final String name;

  ScreenableTab({this.id, required this.name});

  factory ScreenableTab.fromJson(Map<String, Object?> json) {
    return ScreenableTab(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'name'] = name;
    return json;
  }

  ScreenableTab copyWith({int? id, String? name}) {
    return ScreenableTab(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// A page of items.
class PageBeanScreen {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<Screen> values;

  PageBeanScreen(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<Screen>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanScreen.fromJson(Map<String, Object?> json) {
    return PageBeanScreen(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Screen.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanScreen copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<Screen>? values}) {
    return PageBeanScreen(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// A screen.
class Screen {
  /// The ID of the screen.
  final int? id;

  /// The name of the screen.
  final String? name;

  /// The description of the screen.
  final String? description;

  /// The scope of the screen.
  final Scope? scope;

  Screen({this.id, this.name, this.description, this.scope});

  factory Screen.fromJson(Map<String, Object?> json) {
    return Screen(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var scope = this.scope;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    return json;
  }

  Screen copyWith({int? id, String? name, String? description, Scope? scope}) {
    return Screen(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      scope: scope ?? this.scope,
    );
  }
}

/// A screen tab field.
class ScreenableField {
  /// The ID of the screen tab field.
  final String? id;

  /// The name of the screen tab field. Required on create and update. The
  /// maximum length is 255 characters.
  final String? name;

  ScreenableField({this.id, this.name});

  factory ScreenableField.fromJson(Map<String, Object?> json) {
    return ScreenableField(
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  ScreenableField copyWith({String? id, String? name}) {
    return ScreenableField(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

class MoveFieldBean {
  /// The ID of the screen tab field after which to place the moved screen tab
  /// field. Required if `position` isn't provided.
  final String? after;

  /// The named position to which the screen tab field should be moved. Required
  /// if `after` isn't provided.
  final MoveFieldBeanPosition? position;

  MoveFieldBean({this.after, this.position});

  factory MoveFieldBean.fromJson(Map<String, Object?> json) {
    return MoveFieldBean(
      after: json[r'after'] as String?,
      position: json[r'position'] != null
          ? MoveFieldBeanPosition.fromValue(json[r'position']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var after = this.after;
    var position = this.position;

    final json = <String, Object?>{};
    if (after != null) {
      json[r'after'] = after;
    }
    if (position != null) {
      json[r'position'] = position.value;
    }
    return json;
  }

  MoveFieldBean copyWith({String? after, MoveFieldBeanPosition? position}) {
    return MoveFieldBean(
      after: after ?? this.after,
      position: position ?? this.position,
    );
  }
}

class MoveFieldBeanPosition {
  static const earlier = MoveFieldBeanPosition._('Earlier');
  static const later = MoveFieldBeanPosition._('Later');
  static const first = MoveFieldBeanPosition._('First');
  static const last = MoveFieldBeanPosition._('Last');

  static const values = [
    earlier,
    later,
    first,
    last,
  ];
  final String value;

  const MoveFieldBeanPosition._(this.value);

  static MoveFieldBeanPosition fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => MoveFieldBeanPosition._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class AddFieldBean {
  /// The ID of the field to add.
  final String fieldId;

  AddFieldBean({required this.fieldId});

  factory AddFieldBean.fromJson(Map<String, Object?> json) {
    return AddFieldBean(
      fieldId: json[r'fieldId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var fieldId = this.fieldId;

    final json = <String, Object?>{};
    json[r'fieldId'] = fieldId;
    return json;
  }

  AddFieldBean copyWith({String? fieldId}) {
    return AddFieldBean(
      fieldId: fieldId ?? this.fieldId,
    );
  }
}

/// Details of a screen.
class ScreenDetails {
  /// The name of the screen. The name must be unique. The maximum length is 255
  /// characters.
  final String name;

  /// The description of the screen. The maximum length is 255 characters.
  final String? description;

  ScreenDetails({required this.name, this.description});

  factory ScreenDetails.fromJson(Map<String, Object?> json) {
    return ScreenDetails(
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;

    final json = <String, Object?>{};
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    return json;
  }

  ScreenDetails copyWith({String? name, String? description}) {
    return ScreenDetails(
      name: name ?? this.name,
      description: description ?? this.description,
    );
  }
}

/// Details of a screen.
class UpdateScreenDetails {
  /// The name of the screen. The name must be unique. The maximum length is 255
  /// characters.
  final String? name;

  /// The description of the screen. The maximum length is 255 characters.
  final String? description;

  UpdateScreenDetails({this.name, this.description});

  factory UpdateScreenDetails.fromJson(Map<String, Object?> json) {
    return UpdateScreenDetails(
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    return json;
  }

  UpdateScreenDetails copyWith({String? name, String? description}) {
    return UpdateScreenDetails(
      name: name ?? this.name,
      description: description ?? this.description,
    );
  }
}

/// Details of an issue resolution.
class Resolution {
  /// The URL of the issue resolution.
  final String? self;

  /// The ID of the issue resolution.
  final String? id;

  /// The description of the issue resolution.
  final String? description;

  /// The name of the issue resolution.
  final String? name;

  Resolution({this.self, this.id, this.description, this.name});

  factory Resolution.fromJson(Map<String, Object?> json) {
    return Resolution(
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  Resolution copyWith(
      {String? self, String? id, String? description, String? name}) {
    return Resolution(
      self: self ?? this.self,
      id: id ?? this.id,
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

class ProjectInputBean {
  /// Project keys must be unique and start with an uppercase letter followed by
  /// one or more uppercase alphanumeric characters. The maximum length is 10
  /// characters. Required when creating a project. Optional when updating a
  /// project.
  final String? key;

  /// The name of the project. Required when creating a project. Optional when
  /// updating a project.
  final String? name;

  /// The
  /// [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes),
  /// which dictates the application-specific feature set. Required when
  /// creating a project. Not applicable for the Update project resource.
  final ProjectInputBeanProjectTypeKey? projectTypeKey;

  /// A prebuilt configuration for a project. The type of the
  /// `projectTemplateKey` must match with the type of the `projectTypeKey`.
  /// Required when creating a project. Not applicable for the Update project
  /// resource.
  final ProjectInputBeanProjectTemplateKey? projectTemplateKey;

  /// A brief description of the project.
  final String? description;

  /// This parameter is deprecated because of privacy changes. Use
  /// `leadAccountId` instead. See the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details. The user name of the project lead. Either `lead` or
  /// `leadAccountId` must be set when creating a project. Optional when
  /// updating a project. Cannot be provided with `leadAccountId`.
  final String? lead;

  /// The account ID of the project lead. Either `lead` or `leadAccountId` must
  /// be set when creating a project. Optional when updating a project. Cannot
  /// be provided with `lead`.
  final String? leadAccountId;

  /// A link to information about this project, such as project documentation
  final String? url;

  /// The default assignee when creating issues for this project.
  final ProjectInputBeanAssigneeType? assigneeType;

  /// An integer value for the project's avatar.
  final int? avatarId;

  /// The ID of the issue security scheme for the project, which enables you to
  /// control who can and cannot view issues. Use the
  /// [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get)
  /// resource to get all issue security scheme IDs.
  final int? issueSecurityScheme;

  /// The ID of the permission scheme for the project. Use the
  /// [Get all permission schemes](#api-rest-api-3-permissionscheme-get)
  /// resource to see a list of all permission scheme IDs.
  final int? permissionScheme;

  /// The ID of the notification scheme for the project. Use the
  /// [Get notification schemes](#api-rest-api-3-notificationscheme-get)
  /// resource to get a list of notification scheme IDs.
  final int? notificationScheme;

  /// The ID of the project's category. A complete list of category IDs is found
  /// using the
  /// [Get all project categories](#api-rest-api-3-projectCategory-get)
  /// operation.
  final int? categoryId;

  ProjectInputBean(
      {this.key,
      this.name,
      this.projectTypeKey,
      this.projectTemplateKey,
      this.description,
      this.lead,
      this.leadAccountId,
      this.url,
      this.assigneeType,
      this.avatarId,
      this.issueSecurityScheme,
      this.permissionScheme,
      this.notificationScheme,
      this.categoryId});

  factory ProjectInputBean.fromJson(Map<String, Object?> json) {
    return ProjectInputBean(
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      projectTypeKey: json[r'projectTypeKey'] != null
          ? ProjectInputBeanProjectTypeKey.fromValue(
              json[r'projectTypeKey']! as String)
          : null,
      projectTemplateKey: json[r'projectTemplateKey'] != null
          ? ProjectInputBeanProjectTemplateKey.fromValue(
              json[r'projectTemplateKey']! as String)
          : null,
      description: json[r'description'] as String?,
      lead: json[r'lead'] as String?,
      leadAccountId: json[r'leadAccountId'] as String?,
      url: json[r'url'] as String?,
      assigneeType: json[r'assigneeType'] != null
          ? ProjectInputBeanAssigneeType.fromValue(
              json[r'assigneeType']! as String)
          : null,
      avatarId: (json[r'avatarId'] as num?)?.toInt(),
      issueSecurityScheme: (json[r'issueSecurityScheme'] as num?)?.toInt(),
      permissionScheme: (json[r'permissionScheme'] as num?)?.toInt(),
      notificationScheme: (json[r'notificationScheme'] as num?)?.toInt(),
      categoryId: (json[r'categoryId'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var name = this.name;
    var projectTypeKey = this.projectTypeKey;
    var projectTemplateKey = this.projectTemplateKey;
    var description = this.description;
    var lead = this.lead;
    var leadAccountId = this.leadAccountId;
    var url = this.url;
    var assigneeType = this.assigneeType;
    var avatarId = this.avatarId;
    var issueSecurityScheme = this.issueSecurityScheme;
    var permissionScheme = this.permissionScheme;
    var notificationScheme = this.notificationScheme;
    var categoryId = this.categoryId;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (projectTypeKey != null) {
      json[r'projectTypeKey'] = projectTypeKey.value;
    }
    if (projectTemplateKey != null) {
      json[r'projectTemplateKey'] = projectTemplateKey.value;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (lead != null) {
      json[r'lead'] = lead;
    }
    if (leadAccountId != null) {
      json[r'leadAccountId'] = leadAccountId;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    if (assigneeType != null) {
      json[r'assigneeType'] = assigneeType.value;
    }
    if (avatarId != null) {
      json[r'avatarId'] = avatarId;
    }
    if (issueSecurityScheme != null) {
      json[r'issueSecurityScheme'] = issueSecurityScheme;
    }
    if (permissionScheme != null) {
      json[r'permissionScheme'] = permissionScheme;
    }
    if (notificationScheme != null) {
      json[r'notificationScheme'] = notificationScheme;
    }
    if (categoryId != null) {
      json[r'categoryId'] = categoryId;
    }
    return json;
  }

  ProjectInputBean copyWith(
      {String? key,
      String? name,
      ProjectInputBeanProjectTypeKey? projectTypeKey,
      ProjectInputBeanProjectTemplateKey? projectTemplateKey,
      String? description,
      String? lead,
      String? leadAccountId,
      String? url,
      ProjectInputBeanAssigneeType? assigneeType,
      int? avatarId,
      int? issueSecurityScheme,
      int? permissionScheme,
      int? notificationScheme,
      int? categoryId}) {
    return ProjectInputBean(
      key: key ?? this.key,
      name: name ?? this.name,
      projectTypeKey: projectTypeKey ?? this.projectTypeKey,
      projectTemplateKey: projectTemplateKey ?? this.projectTemplateKey,
      description: description ?? this.description,
      lead: lead ?? this.lead,
      leadAccountId: leadAccountId ?? this.leadAccountId,
      url: url ?? this.url,
      assigneeType: assigneeType ?? this.assigneeType,
      avatarId: avatarId ?? this.avatarId,
      issueSecurityScheme: issueSecurityScheme ?? this.issueSecurityScheme,
      permissionScheme: permissionScheme ?? this.permissionScheme,
      notificationScheme: notificationScheme ?? this.notificationScheme,
      categoryId: categoryId ?? this.categoryId,
    );
  }
}

class ProjectInputBeanProjectTypeKey {
  static const software = ProjectInputBeanProjectTypeKey._('software');
  static const serviceDesk = ProjectInputBeanProjectTypeKey._('service_desk');
  static const business = ProjectInputBeanProjectTypeKey._('business');

  static const values = [
    software,
    serviceDesk,
    business,
  ];
  final String value;

  const ProjectInputBeanProjectTypeKey._(this.value);

  static ProjectInputBeanProjectTypeKey fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectInputBeanProjectTypeKey._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ProjectInputBeanProjectTemplateKey {
  static const comPyxisGreenhopperJiraGhSimplifiedAgilityKanban =
      ProjectInputBeanProjectTemplateKey._(
          'com.pyxis.greenhopper.jira:gh-simplified-agility-kanban');
  static const comPyxisGreenhopperJiraGhSimplifiedAgilityScrum =
      ProjectInputBeanProjectTemplateKey._(
          'com.pyxis.greenhopper.jira:gh-simplified-agility-scrum');
  static const comPyxisGreenhopperJiraGhSimplifiedBasic =
      ProjectInputBeanProjectTemplateKey._(
          'com.pyxis.greenhopper.jira:gh-simplified-basic');
  static const comPyxisGreenhopperJiraGhSimplifiedKanbanClassic =
      ProjectInputBeanProjectTemplateKey._(
          'com.pyxis.greenhopper.jira:gh-simplified-kanban-classic');
  static const comPyxisGreenhopperJiraGhSimplifiedScrumClassic =
      ProjectInputBeanProjectTemplateKey._(
          'com.pyxis.greenhopper.jira:gh-simplified-scrum-classic');
  static const comAtlassianServicedeskSimplifiedItServiceDesk =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-it-service-desk');
  static const comAtlassianServicedeskSimplifiedInternalServiceDesk =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-internal-service-desk');
  static const comAtlassianServicedeskSimplifiedExternalServiceDesk =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-external-service-desk');
  static const comAtlassianServicedeskSimplifiedHrServiceDesk =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-hr-service-desk');
  static const comAtlassianServicedeskSimplifiedFacilitiesServiceDesk =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-facilities-service-desk');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedContentManagement =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-content-management');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedDocumentApproval =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-document-approval');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedLeadTracking =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-lead-tracking');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProcessControl =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-process-control');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProcurement =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-procurement');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProjectManagement =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-project-management');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedRecruitment =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-recruitment');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedTask =
      ProjectInputBeanProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-task-');

  static const values = [
    comPyxisGreenhopperJiraGhSimplifiedAgilityKanban,
    comPyxisGreenhopperJiraGhSimplifiedAgilityScrum,
    comPyxisGreenhopperJiraGhSimplifiedBasic,
    comPyxisGreenhopperJiraGhSimplifiedKanbanClassic,
    comPyxisGreenhopperJiraGhSimplifiedScrumClassic,
    comAtlassianServicedeskSimplifiedItServiceDesk,
    comAtlassianServicedeskSimplifiedInternalServiceDesk,
    comAtlassianServicedeskSimplifiedExternalServiceDesk,
    comAtlassianServicedeskSimplifiedHrServiceDesk,
    comAtlassianServicedeskSimplifiedFacilitiesServiceDesk,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedContentManagement,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedDocumentApproval,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedLeadTracking,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProcessControl,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProcurement,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProjectManagement,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedRecruitment,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedTask,
  ];
  final String value;

  const ProjectInputBeanProjectTemplateKey._(this.value);

  static ProjectInputBeanProjectTemplateKey fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectInputBeanProjectTemplateKey._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ProjectInputBeanAssigneeType {
  static const projectLead = ProjectInputBeanAssigneeType._('PROJECT_LEAD');
  static const unassigned = ProjectInputBeanAssigneeType._('UNASSIGNED');

  static const values = [
    projectLead,
    unassigned,
  ];
  final String value;

  const ProjectInputBeanAssigneeType._(this.value);

  static ProjectInputBeanAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectInputBeanAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Identifiers for a project.
class ProjectIdentifiers {
  /// The URL of the created project.
  final String self;

  /// The ID of the created project.
  final int id;

  /// The key of the created project.
  final String key;

  ProjectIdentifiers({required this.self, required this.id, required this.key});

  factory ProjectIdentifiers.fromJson(Map<String, Object?> json) {
    return ProjectIdentifiers(
      self: json[r'self'] as String? ?? '',
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      key: json[r'key'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var key = this.key;

    final json = <String, Object?>{};
    json[r'self'] = self;
    json[r'id'] = id;
    json[r'key'] = key;
    return json;
  }

  ProjectIdentifiers copyWith({String? self, int? id, String? key}) {
    return ProjectIdentifiers(
      self: self ?? this.self,
      id: id ?? this.id,
      key: key ?? this.key,
    );
  }
}

/// A page of items.
class PageBeanVersion {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<Version> values;

  PageBeanVersion(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<Version>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanVersion.fromJson(Map<String, Object?> json) {
    return PageBeanVersion(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Version.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanVersion copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<Version>? values}) {
    return PageBeanVersion(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Details about a component with a count of the issues it contains.
class ComponentWithIssueCount {
  /// Count of issues for the component.
  final int? issueCount;

  /// The user assigned to issues created with this component, when
  /// `assigneeType` does not identify a valid assignee.
  final User? realAssignee;

  /// Whether a user is associated with `assigneeType`. For example, if the
  /// `assigneeType` is set to `COMPONENT_LEAD` but the component lead is not
  /// set, then `false` is returned.
  final bool isAssigneeTypeValid;

  /// The type of the assignee that is assigned to issues created with this
  /// component, when an assignee cannot be set from the `assigneeType`. For
  /// example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead
  /// is set. This property is set to one of the following values:
  ///
  ///  *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project
  /// lead has permission to be assigned issues in the project that the
  /// component is in.
  ///  *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the
  /// component lead has permission to be assigned issues in the project that
  /// the component is in.
  ///  *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is
  /// configured to allow unassigned issues.
  ///  *  `PROJECT_DEFAULT` when none of the preceding cases are true.
  final ComponentWithIssueCountRealAssigneeType? realAssigneeType;

  /// The description for the component.
  final String? description;

  /// The URL for this count of the issues contained in the component.
  final String? self;

  /// The key of the project to which the component is assigned.
  final String? project;

  /// The nominal user type used to determine the assignee for issues created
  /// with this component. See `realAssigneeType` for details on how the type of
  /// the user, and hence the user, assigned to issues is determined. Takes the
  /// following values:
  ///
  ///  *  `PROJECT_LEAD` the assignee to any issues created with this component
  /// is nominally the lead for the project the component is in.
  ///  *  `COMPONENT_LEAD` the assignee to any issues created with this
  /// component is nominally the lead for the component.
  ///  *  `UNASSIGNED` an assignee is not set for issues created with this
  /// component.
  ///  *  `PROJECT_DEFAULT` the assignee to any issues created with this
  /// component is nominally the default assignee for the project that the
  /// component is in.
  final ComponentWithIssueCountAssigneeType? assigneeType;

  /// The user details for the component's lead user.
  final User? lead;

  /// The details of the user associated with `assigneeType`, if any. See
  /// `realAssignee` for details of the user assigned to issues created with
  /// this component.
  final User? assignee;

  /// Not used.
  final int? projectId;

  /// The name for the component.
  final String? name;

  /// The unique identifier for the component.
  final String? id;

  ComponentWithIssueCount(
      {this.issueCount,
      this.realAssignee,
      bool? isAssigneeTypeValid,
      this.realAssigneeType,
      this.description,
      this.self,
      this.project,
      this.assigneeType,
      this.lead,
      this.assignee,
      this.projectId,
      this.name,
      this.id})
      : isAssigneeTypeValid = isAssigneeTypeValid ?? false;

  factory ComponentWithIssueCount.fromJson(Map<String, Object?> json) {
    return ComponentWithIssueCount(
      issueCount: (json[r'issueCount'] as num?)?.toInt(),
      realAssignee: json[r'realAssignee'] != null
          ? User.fromJson(json[r'realAssignee']! as Map<String, Object?>)
          : null,
      isAssigneeTypeValid: json[r'isAssigneeTypeValid'] as bool? ?? false,
      realAssigneeType: json[r'realAssigneeType'] != null
          ? ComponentWithIssueCountRealAssigneeType.fromValue(
              json[r'realAssigneeType']! as String)
          : null,
      description: json[r'description'] as String?,
      self: json[r'self'] as String?,
      project: json[r'project'] as String?,
      assigneeType: json[r'assigneeType'] != null
          ? ComponentWithIssueCountAssigneeType.fromValue(
              json[r'assigneeType']! as String)
          : null,
      lead: json[r'lead'] != null
          ? User.fromJson(json[r'lead']! as Map<String, Object?>)
          : null,
      assignee: json[r'assignee'] != null
          ? User.fromJson(json[r'assignee']! as Map<String, Object?>)
          : null,
      projectId: (json[r'projectId'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      id: json[r'id'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var issueCount = this.issueCount;
    var realAssignee = this.realAssignee;
    var isAssigneeTypeValid = this.isAssigneeTypeValid;
    var realAssigneeType = this.realAssigneeType;
    var description = this.description;
    var self = this.self;
    var project = this.project;
    var assigneeType = this.assigneeType;
    var lead = this.lead;
    var assignee = this.assignee;
    var projectId = this.projectId;
    var name = this.name;
    var id = this.id;

    final json = <String, Object?>{};
    if (issueCount != null) {
      json[r'issueCount'] = issueCount;
    }
    if (realAssignee != null) {
      json[r'realAssignee'] = realAssignee.toJson();
    }
    json[r'isAssigneeTypeValid'] = isAssigneeTypeValid;
    if (realAssigneeType != null) {
      json[r'realAssigneeType'] = realAssigneeType.value;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (project != null) {
      json[r'project'] = project;
    }
    if (assigneeType != null) {
      json[r'assigneeType'] = assigneeType.value;
    }
    if (lead != null) {
      json[r'lead'] = lead.toJson();
    }
    if (assignee != null) {
      json[r'assignee'] = assignee.toJson();
    }
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    return json;
  }

  ComponentWithIssueCount copyWith(
      {int? issueCount,
      User? realAssignee,
      bool? isAssigneeTypeValid,
      ComponentWithIssueCountRealAssigneeType? realAssigneeType,
      String? description,
      String? self,
      String? project,
      ComponentWithIssueCountAssigneeType? assigneeType,
      User? lead,
      User? assignee,
      int? projectId,
      String? name,
      String? id}) {
    return ComponentWithIssueCount(
      issueCount: issueCount ?? this.issueCount,
      realAssignee: realAssignee ?? this.realAssignee,
      isAssigneeTypeValid: isAssigneeTypeValid ?? this.isAssigneeTypeValid,
      realAssigneeType: realAssigneeType ?? this.realAssigneeType,
      description: description ?? this.description,
      self: self ?? this.self,
      project: project ?? this.project,
      assigneeType: assigneeType ?? this.assigneeType,
      lead: lead ?? this.lead,
      assignee: assignee ?? this.assignee,
      projectId: projectId ?? this.projectId,
      name: name ?? this.name,
      id: id ?? this.id,
    );
  }
}

class ComponentWithIssueCountRealAssigneeType {
  static const projectDefault =
      ComponentWithIssueCountRealAssigneeType._('PROJECT_DEFAULT');
  static const componentLead =
      ComponentWithIssueCountRealAssigneeType._('COMPONENT_LEAD');
  static const projectLead =
      ComponentWithIssueCountRealAssigneeType._('PROJECT_LEAD');
  static const unassigned =
      ComponentWithIssueCountRealAssigneeType._('UNASSIGNED');

  static const values = [
    projectDefault,
    componentLead,
    projectLead,
    unassigned,
  ];
  final String value;

  const ComponentWithIssueCountRealAssigneeType._(this.value);

  static ComponentWithIssueCountRealAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ComponentWithIssueCountRealAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ComponentWithIssueCountAssigneeType {
  static const projectDefault =
      ComponentWithIssueCountAssigneeType._('PROJECT_DEFAULT');
  static const componentLead =
      ComponentWithIssueCountAssigneeType._('COMPONENT_LEAD');
  static const projectLead =
      ComponentWithIssueCountAssigneeType._('PROJECT_LEAD');
  static const unassigned = ComponentWithIssueCountAssigneeType._('UNASSIGNED');

  static const values = [
    projectDefault,
    componentLead,
    projectLead,
    unassigned,
  ];
  final String value;

  const ComponentWithIssueCountAssigneeType._(this.value);

  static ComponentWithIssueCountAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ComponentWithIssueCountAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A page of items.
class PageBeanComponentWithIssueCount {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<ComponentWithIssueCount> values;

  PageBeanComponentWithIssueCount(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<ComponentWithIssueCount>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanComponentWithIssueCount.fromJson(Map<String, Object?> json) {
    return PageBeanComponentWithIssueCount(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => ComponentWithIssueCount.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanComponentWithIssueCount copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<ComponentWithIssueCount>? values}) {
    return PageBeanComponentWithIssueCount(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

class StringList {
  StringList();

  factory StringList.fromJson(Map<String, Object?> json) {
    return StringList();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// A page of items.
class PageBeanProject {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<Project> values;

  PageBeanProject(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<Project>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanProject.fromJson(Map<String, Object?> json) {
    return PageBeanProject(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Project.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanProject copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<Project>? values}) {
    return PageBeanProject(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// List of project avatars.
class ProjectAvatars {
  /// List of avatars included with Jira. These avatars cannot be deleted.
  final List<Avatar> system;

  /// List of avatars added to Jira. These avatars may be deleted.
  final List<Avatar> custom;

  ProjectAvatars({List<Avatar>? system, List<Avatar>? custom})
      : system = system ?? [],
        custom = custom ?? [];

  factory ProjectAvatars.fromJson(Map<String, Object?> json) {
    return ProjectAvatars(
      system: (json[r'system'] as List<Object?>?)
              ?.map((i) =>
                  Avatar.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      custom: (json[r'custom'] as List<Object?>?)
              ?.map((i) =>
                  Avatar.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var system = this.system;
    var custom = this.custom;

    final json = <String, Object?>{};
    json[r'system'] = system.map((i) => i.toJson()).toList();
    json[r'custom'] = custom.map((i) => i.toJson()).toList();
    return json;
  }

  ProjectAvatars copyWith({List<Avatar>? system, List<Avatar>? custom}) {
    return ProjectAvatars(
      system: system ?? this.system,
      custom: custom ?? this.custom,
    );
  }
}

/// Status details for an issue type.
class IssueTypeWithStatus {
  /// The URL of the issue type's status details.
  final String self;

  /// The ID of the issue type.
  final String id;

  /// The name of the issue type.
  final String name;

  /// Whether this issue type represents subtasks.
  final bool subtask;

  /// List of status details for the issue type.
  final List<StatusDetails> statuses;

  IssueTypeWithStatus(
      {required this.self,
      required this.id,
      required this.name,
      required this.subtask,
      required this.statuses});

  factory IssueTypeWithStatus.fromJson(Map<String, Object?> json) {
    return IssueTypeWithStatus(
      self: json[r'self'] as String? ?? '',
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      subtask: json[r'subtask'] as bool? ?? false,
      statuses: (json[r'statuses'] as List<Object?>?)
              ?.map((i) => StatusDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var name = this.name;
    var subtask = this.subtask;
    var statuses = this.statuses;

    final json = <String, Object?>{};
    json[r'self'] = self;
    json[r'id'] = id;
    json[r'name'] = name;
    json[r'subtask'] = subtask;
    json[r'statuses'] = statuses.map((i) => i.toJson()).toList();
    return json;
  }

  IssueTypeWithStatus copyWith(
      {String? self,
      String? id,
      String? name,
      bool? subtask,
      List<StatusDetails>? statuses}) {
    return IssueTypeWithStatus(
      self: self ?? this.self,
      id: id ?? this.id,
      name: name ?? this.name,
      subtask: subtask ?? this.subtask,
      statuses: statuses ?? this.statuses,
    );
  }
}

/// Details about a security scheme.
class SecurityScheme {
  /// The URL of the issue security scheme.
  final String? self;

  /// The ID of the issue security scheme.
  final int? id;

  /// The name of the issue security scheme.
  final String? name;

  /// The description of the issue security scheme.
  final String? description;

  /// The ID of the default security level.
  final int? defaultSecurityLevelId;
  final List<SecurityLevel> levels;

  SecurityScheme(
      {this.self,
      this.id,
      this.name,
      this.description,
      this.defaultSecurityLevelId,
      List<SecurityLevel>? levels})
      : levels = levels ?? [];

  factory SecurityScheme.fromJson(Map<String, Object?> json) {
    return SecurityScheme(
      self: json[r'self'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      defaultSecurityLevelId:
          (json[r'defaultSecurityLevelId'] as num?)?.toInt(),
      levels: (json[r'levels'] as List<Object?>?)
              ?.map((i) => SecurityLevel.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var defaultSecurityLevelId = this.defaultSecurityLevelId;
    var levels = this.levels;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (defaultSecurityLevelId != null) {
      json[r'defaultSecurityLevelId'] = defaultSecurityLevelId;
    }
    json[r'levels'] = levels.map((i) => i.toJson()).toList();
    return json;
  }

  SecurityScheme copyWith(
      {String? self,
      int? id,
      String? name,
      String? description,
      int? defaultSecurityLevelId,
      List<SecurityLevel>? levels}) {
    return SecurityScheme(
      self: self ?? this.self,
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      defaultSecurityLevelId:
          defaultSecurityLevelId ?? this.defaultSecurityLevelId,
      levels: levels ?? this.levels,
    );
  }
}

/// An issue priority.
class Priority {
  /// The URL of the issue priority.
  final String? self;

  /// The color used to indicate the issue priority.
  final String? statusColor;

  /// The description of the issue priority.
  final String? description;

  /// The URL of the icon for the issue priority.
  final String? iconUrl;

  /// The name of the issue priority.
  final String? name;

  /// The ID of the issue priority.
  final String? id;

  Priority(
      {this.self,
      this.statusColor,
      this.description,
      this.iconUrl,
      this.name,
      this.id});

  factory Priority.fromJson(Map<String, Object?> json) {
    return Priority(
      self: json[r'self'] as String?,
      statusColor: json[r'statusColor'] as String?,
      description: json[r'description'] as String?,
      iconUrl: json[r'iconUrl'] as String?,
      name: json[r'name'] as String?,
      id: json[r'id'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var statusColor = this.statusColor;
    var description = this.description;
    var iconUrl = this.iconUrl;
    var name = this.name;
    var id = this.id;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (statusColor != null) {
      json[r'statusColor'] = statusColor;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (iconUrl != null) {
      json[r'iconUrl'] = iconUrl;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    return json;
  }

  Priority copyWith(
      {String? self,
      String? statusColor,
      String? description,
      String? iconUrl,
      String? name,
      String? id}) {
    return Priority(
      self: self ?? this.self,
      statusColor: statusColor ?? this.statusColor,
      description: description ?? this.description,
      iconUrl: iconUrl ?? this.iconUrl,
      name: name ?? this.name,
      id: id ?? this.id,
    );
  }
}

/// A comment.
class Comment {
  /// The URL of the comment.
  final String? self;

  /// The ID of the comment.
  final String? id;

  /// The ID of the user who created the comment.
  final UserDetails? author;

  /// The comment text in
  /// [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/).
  final dynamic body;

  /// The rendered version of the comment.
  final String? renderedBody;

  /// The ID of the user who updated the comment last.
  final UserDetails? updateAuthor;

  /// The date and time at which the comment was created.
  final DateTime? created;

  /// The date and time at which the comment was updated last.
  final DateTime? updated;

  /// The group or role to which this comment is visible. Optional on create and
  /// update.
  final Visibility? visibility;

  /// Whether the comment is visible in Jira Service Desk. Defaults to true when
  /// comments are created in the Jira Cloud Platform. This includes when the
  /// site doesn't use Jira Service Desk or the project isn't a Jira Service
  /// Desk project and, therefore, there is no Jira Service Desk for the issue
  /// to be visible on. To create a comment with its visibility in Jira Service
  /// Desk set to false, use the Jira Service Desk REST API
  /// [Create request comment](https://developer.atlassian.com/cloud/jira/service-desk/rest/#api-rest-servicedeskapi-request-issueIdOrKey-comment-post)
  /// operation.
  final bool jsdPublic;

  /// A list of comment properties. Optional on create and update.
  final List<EntityProperty> properties;

  Comment(
      {this.self,
      this.id,
      this.author,
      this.body,
      this.renderedBody,
      this.updateAuthor,
      this.created,
      this.updated,
      this.visibility,
      bool? jsdPublic,
      List<EntityProperty>? properties})
      : jsdPublic = jsdPublic ?? false,
        properties = properties ?? [];

  factory Comment.fromJson(Map<String, Object?> json) {
    return Comment(
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      author: json[r'author'] != null
          ? UserDetails.fromJson(json[r'author']! as Map<String, Object?>)
          : null,
      body: json[r'body'],
      renderedBody: json[r'renderedBody'] as String?,
      updateAuthor: json[r'updateAuthor'] != null
          ? UserDetails.fromJson(json[r'updateAuthor']! as Map<String, Object?>)
          : null,
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      updated: DateTime.tryParse(json[r'updated'] as String? ?? ''),
      visibility: json[r'visibility'] != null
          ? Visibility.fromJson(json[r'visibility']! as Map<String, Object?>)
          : null,
      jsdPublic: json[r'jsdPublic'] as bool? ?? false,
      properties: (json[r'properties'] as List<Object?>?)
              ?.map((i) => EntityProperty.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var author = this.author;
    var body = this.body;
    var renderedBody = this.renderedBody;
    var updateAuthor = this.updateAuthor;
    var created = this.created;
    var updated = this.updated;
    var visibility = this.visibility;
    var jsdPublic = this.jsdPublic;
    var properties = this.properties;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (author != null) {
      json[r'author'] = author.toJson();
    }
    if (body != null) {
      json[r'body'] = body;
    }
    if (renderedBody != null) {
      json[r'renderedBody'] = renderedBody;
    }
    if (updateAuthor != null) {
      json[r'updateAuthor'] = updateAuthor.toJson();
    }
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    if (updated != null) {
      json[r'updated'] = updated.toIso8601String();
    }
    if (visibility != null) {
      json[r'visibility'] = visibility.toJson();
    }
    json[r'jsdPublic'] = jsdPublic;
    json[r'properties'] = properties.map((i) => i.toJson()).toList();
    return json;
  }

  Comment copyWith(
      {String? self,
      String? id,
      UserDetails? author,
      dynamic body,
      String? renderedBody,
      UserDetails? updateAuthor,
      DateTime? created,
      DateTime? updated,
      Visibility? visibility,
      bool? jsdPublic,
      List<EntityProperty>? properties}) {
    return Comment(
      self: self ?? this.self,
      id: id ?? this.id,
      author: author ?? this.author,
      body: body ?? this.body,
      renderedBody: renderedBody ?? this.renderedBody,
      updateAuthor: updateAuthor ?? this.updateAuthor,
      created: created ?? this.created,
      updated: updated ?? this.updated,
      visibility: visibility ?? this.visibility,
      jsdPublic: jsdPublic ?? this.jsdPublic,
      properties: properties ?? this.properties,
    );
  }
}

/// Key fields from the linked issue.
class Fields {
  /// The summary description of the linked issue.
  final String? summary;

  /// The status of the linked issue.
  final StatusDetails? status;

  /// The priority of the linked issue.
  final Priority? priority;

  /// The assignee of the linked issue.
  final UserDetails? assignee;

  /// The time tracking of the linked issue.
  final TimeTrackingDetails? timetracking;

  /// The type of the linked issue.
  final IssueTypeDetails? issuetype;

  /// The type of the linked issue.
  final IssueTypeDetails? issueType;

  Fields(
      {this.summary,
      this.status,
      this.priority,
      this.assignee,
      this.timetracking,
      this.issuetype,
      this.issueType});

  factory Fields.fromJson(Map<String, Object?> json) {
    return Fields(
      summary: json[r'summary'] as String?,
      status: json[r'status'] != null
          ? StatusDetails.fromJson(json[r'status']! as Map<String, Object?>)
          : null,
      priority: json[r'priority'] != null
          ? Priority.fromJson(json[r'priority']! as Map<String, Object?>)
          : null,
      assignee: json[r'assignee'] != null
          ? UserDetails.fromJson(json[r'assignee']! as Map<String, Object?>)
          : null,
      timetracking: json[r'timetracking'] != null
          ? TimeTrackingDetails.fromJson(
              json[r'timetracking']! as Map<String, Object?>)
          : null,
      issuetype: json[r'issuetype'] != null
          ? IssueTypeDetails.fromJson(
              json[r'issuetype']! as Map<String, Object?>)
          : null,
      issueType: json[r'issueType'] != null
          ? IssueTypeDetails.fromJson(
              json[r'issueType']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var summary = this.summary;
    var status = this.status;
    var priority = this.priority;
    var assignee = this.assignee;
    var timetracking = this.timetracking;
    var issuetype = this.issuetype;
    var issueType = this.issueType;

    final json = <String, Object?>{};
    if (summary != null) {
      json[r'summary'] = summary;
    }
    if (status != null) {
      json[r'status'] = status.toJson();
    }
    if (priority != null) {
      json[r'priority'] = priority.toJson();
    }
    if (assignee != null) {
      json[r'assignee'] = assignee.toJson();
    }
    if (timetracking != null) {
      json[r'timetracking'] = timetracking.toJson();
    }
    if (issuetype != null) {
      json[r'issuetype'] = issuetype.toJson();
    }
    if (issueType != null) {
      json[r'issueType'] = issueType.toJson();
    }
    return json;
  }

  Fields copyWith(
      {String? summary,
      StatusDetails? status,
      Priority? priority,
      UserDetails? assignee,
      TimeTrackingDetails? timetracking,
      IssueTypeDetails? issuetype,
      IssueTypeDetails? issueType}) {
    return Fields(
      summary: summary ?? this.summary,
      status: status ?? this.status,
      priority: priority ?? this.priority,
      assignee: assignee ?? this.assignee,
      timetracking: timetracking ?? this.timetracking,
      issuetype: issuetype ?? this.issuetype,
      issueType: issueType ?? this.issueType,
    );
  }
}

/// This object is used as follows:
///
///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it defines
/// and reports on the type of link between the issues. Find a list of issue
/// link types with [Get issue link types](#api-rest-api-3-issueLinkType-get).
///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it
/// defines and reports on issue link types.
class IssueLinkType {
  /// The ID of the issue link type and is used as follows:
  ///
  ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is the
  /// type of issue link. Required on create when `name` isn't provided.
  /// Otherwise, read only.
  ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource
  /// it is read only.
  final String? id;

  /// The name of the issue link type and is used as follows:
  ///
  ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is the
  /// type of issue link. Required on create when `id` isn't provided.
  /// Otherwise, read only.
  ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource
  /// it is required on create and optional on update. Otherwise, read only.
  final String? name;

  /// The description of the issue link type inward link and is used as follows:
  ///
  ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is
  /// read only.
  ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource
  /// it is required on create and optional on update. Otherwise, read only.
  final String? inward;

  /// The description of the issue link type outward link and is used as
  /// follows:
  ///
  ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is
  /// read only.
  ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource
  /// it is required on create and optional on update. Otherwise, read only.
  final String? outward;

  /// The URL of the issue link type. Read only.
  final String? self;

  IssueLinkType({this.id, this.name, this.inward, this.outward, this.self});

  factory IssueLinkType.fromJson(Map<String, Object?> json) {
    return IssueLinkType(
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      inward: json[r'inward'] as String?,
      outward: json[r'outward'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var inward = this.inward;
    var outward = this.outward;
    var self = this.self;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (inward != null) {
      json[r'inward'] = inward;
    }
    if (outward != null) {
      json[r'outward'] = outward;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  IssueLinkType copyWith(
      {String? id,
      String? name,
      String? inward,
      String? outward,
      String? self}) {
    return IssueLinkType(
      id: id ?? this.id,
      name: name ?? this.name,
      inward: inward ?? this.inward,
      outward: outward ?? this.outward,
      self: self ?? this.self,
    );
  }
}

class LinkIssueRequestJsonBean {
  final IssueLinkType type;
  final LinkedIssue inwardIssue;
  final LinkedIssue outwardIssue;
  final Comment? comment;

  LinkIssueRequestJsonBean(
      {required this.type,
      required this.inwardIssue,
      required this.outwardIssue,
      this.comment});

  factory LinkIssueRequestJsonBean.fromJson(Map<String, Object?> json) {
    return LinkIssueRequestJsonBean(
      type: IssueLinkType.fromJson(
          json[r'type'] as Map<String, Object?>? ?? const {}),
      inwardIssue: LinkedIssue.fromJson(
          json[r'inwardIssue'] as Map<String, Object?>? ?? const {}),
      outwardIssue: LinkedIssue.fromJson(
          json[r'outwardIssue'] as Map<String, Object?>? ?? const {}),
      comment: json[r'comment'] != null
          ? Comment.fromJson(json[r'comment']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var inwardIssue = this.inwardIssue;
    var outwardIssue = this.outwardIssue;
    var comment = this.comment;

    final json = <String, Object?>{};
    json[r'type'] = type.toJson();
    json[r'inwardIssue'] = inwardIssue.toJson();
    json[r'outwardIssue'] = outwardIssue.toJson();
    if (comment != null) {
      json[r'comment'] = comment.toJson();
    }
    return json;
  }

  LinkIssueRequestJsonBean copyWith(
      {IssueLinkType? type,
      LinkedIssue? inwardIssue,
      LinkedIssue? outwardIssue,
      Comment? comment}) {
    return LinkIssueRequestJsonBean(
      type: type ?? this.type,
      inwardIssue: inwardIssue ?? this.inwardIssue,
      outwardIssue: outwardIssue ?? this.outwardIssue,
      comment: comment ?? this.comment,
    );
  }
}

/// The ID or key of a linked issue.
class LinkedIssue {
  /// The ID of an issue. Required if `key` isn't provided.
  final String? id;

  /// The key of an issue. Required if `id` isn't provided.
  final String? key;

  /// The URL of the issue.
  final String? self;

  /// The fields associated with the issue.
  final Fields? fields;

  LinkedIssue({this.id, this.key, this.self, this.fields});

  factory LinkedIssue.fromJson(Map<String, Object?> json) {
    return LinkedIssue(
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      self: json[r'self'] as String?,
      fields: json[r'fields'] != null
          ? Fields.fromJson(json[r'fields']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;
    var self = this.self;
    var fields = this.fields;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (fields != null) {
      json[r'fields'] = fields.toJson();
    }
    return json;
  }

  LinkedIssue copyWith(
      {String? id, String? key, String? self, Fields? fields}) {
    return LinkedIssue(
      id: id ?? this.id,
      key: key ?? this.key,
      self: self ?? this.self,
      fields: fields ?? this.fields,
    );
  }
}

class RichText {
  final bool valueSet;
  final bool finalised;
  final bool emptyAdf;

  RichText({bool? valueSet, bool? finalised, bool? emptyAdf})
      : valueSet = valueSet ?? false,
        finalised = finalised ?? false,
        emptyAdf = emptyAdf ?? false;

  factory RichText.fromJson(Map<String, Object?> json) {
    return RichText(
      valueSet: json[r'valueSet'] as bool? ?? false,
      finalised: json[r'finalised'] as bool? ?? false,
      emptyAdf: json[r'emptyAdf'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var valueSet = this.valueSet;
    var finalised = this.finalised;
    var emptyAdf = this.emptyAdf;

    final json = <String, Object?>{};
    json[r'valueSet'] = valueSet;
    json[r'finalised'] = finalised;
    json[r'emptyAdf'] = emptyAdf;
    return json;
  }

  RichText copyWith({bool? valueSet, bool? finalised, bool? emptyAdf}) {
    return RichText(
      valueSet: valueSet ?? this.valueSet,
      finalised: finalised ?? this.finalised,
      emptyAdf: emptyAdf ?? this.emptyAdf,
    );
  }
}

/// Time tracking details.
class TimeTrackingDetails {
  /// The original estimate of time needed for this issue in readable format.
  final String? originalEstimate;

  /// The remaining estimate of time needed for this issue in readable format.
  final String? remainingEstimate;

  /// Time worked on this issue in readable format.
  final String? timeSpent;

  /// The original estimate of time needed for this issue in seconds.
  final int? originalEstimateSeconds;

  /// The remaining estimate of time needed for this issue in seconds.
  final int? remainingEstimateSeconds;

  /// Time worked on this issue in seconds.
  final int? timeSpentSeconds;

  TimeTrackingDetails(
      {this.originalEstimate,
      this.remainingEstimate,
      this.timeSpent,
      this.originalEstimateSeconds,
      this.remainingEstimateSeconds,
      this.timeSpentSeconds});

  factory TimeTrackingDetails.fromJson(Map<String, Object?> json) {
    return TimeTrackingDetails(
      originalEstimate: json[r'originalEstimate'] as String?,
      remainingEstimate: json[r'remainingEstimate'] as String?,
      timeSpent: json[r'timeSpent'] as String?,
      originalEstimateSeconds:
          (json[r'originalEstimateSeconds'] as num?)?.toInt(),
      remainingEstimateSeconds:
          (json[r'remainingEstimateSeconds'] as num?)?.toInt(),
      timeSpentSeconds: (json[r'timeSpentSeconds'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var originalEstimate = this.originalEstimate;
    var remainingEstimate = this.remainingEstimate;
    var timeSpent = this.timeSpent;
    var originalEstimateSeconds = this.originalEstimateSeconds;
    var remainingEstimateSeconds = this.remainingEstimateSeconds;
    var timeSpentSeconds = this.timeSpentSeconds;

    final json = <String, Object?>{};
    if (originalEstimate != null) {
      json[r'originalEstimate'] = originalEstimate;
    }
    if (remainingEstimate != null) {
      json[r'remainingEstimate'] = remainingEstimate;
    }
    if (timeSpent != null) {
      json[r'timeSpent'] = timeSpent;
    }
    if (originalEstimateSeconds != null) {
      json[r'originalEstimateSeconds'] = originalEstimateSeconds;
    }
    if (remainingEstimateSeconds != null) {
      json[r'remainingEstimateSeconds'] = remainingEstimateSeconds;
    }
    if (timeSpentSeconds != null) {
      json[r'timeSpentSeconds'] = timeSpentSeconds;
    }
    return json;
  }

  TimeTrackingDetails copyWith(
      {String? originalEstimate,
      String? remainingEstimate,
      String? timeSpent,
      int? originalEstimateSeconds,
      int? remainingEstimateSeconds,
      int? timeSpentSeconds}) {
    return TimeTrackingDetails(
      originalEstimate: originalEstimate ?? this.originalEstimate,
      remainingEstimate: remainingEstimate ?? this.remainingEstimate,
      timeSpent: timeSpent ?? this.timeSpent,
      originalEstimateSeconds:
          originalEstimateSeconds ?? this.originalEstimateSeconds,
      remainingEstimateSeconds:
          remainingEstimateSeconds ?? this.remainingEstimateSeconds,
      timeSpentSeconds: timeSpentSeconds ?? this.timeSpentSeconds,
    );
  }
}

/// The group or role to which this item is visible.
class Visibility {
  /// Whether visibility of this item is restricted to a group or role.
  final VisibilityType? type;

  /// The name of the group or role to which visibility of this item is
  /// restricted.
  final String? value;

  Visibility({this.type, this.value});

  factory Visibility.fromJson(Map<String, Object?> json) {
    return Visibility(
      type: json[r'type'] != null
          ? VisibilityType.fromValue(json[r'type']! as String)
          : null,
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var value = this.value;

    final json = <String, Object?>{};
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  Visibility copyWith({VisibilityType? type, String? value}) {
    return Visibility(
      type: type ?? this.type,
      value: value ?? this.value,
    );
  }
}

class VisibilityType {
  static const group = VisibilityType._('group');
  static const role = VisibilityType._('role');

  static const values = [
    group,
    role,
  ];
  final String value;

  const VisibilityType._(this.value);

  static VisibilityType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => VisibilityType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of a link between issues.
class IssueLink {
  /// The ID of the issue link.
  final String? id;

  /// The URL of the issue link.
  final String? self;

  /// The type of link between the issues.
  final IssueLinkType type;

  /// The issue the link joins to.
  final LinkedIssue inwardIssue;

  /// The issue the link originates from.
  final LinkedIssue outwardIssue;

  IssueLink(
      {this.id,
      this.self,
      required this.type,
      required this.inwardIssue,
      required this.outwardIssue});

  factory IssueLink.fromJson(Map<String, Object?> json) {
    return IssueLink(
      id: json[r'id'] as String?,
      self: json[r'self'] as String?,
      type: IssueLinkType.fromJson(
          json[r'type'] as Map<String, Object?>? ?? const {}),
      inwardIssue: LinkedIssue.fromJson(
          json[r'inwardIssue'] as Map<String, Object?>? ?? const {}),
      outwardIssue: LinkedIssue.fromJson(
          json[r'outwardIssue'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var self = this.self;
    var type = this.type;
    var inwardIssue = this.inwardIssue;
    var outwardIssue = this.outwardIssue;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'type'] = type.toJson();
    json[r'inwardIssue'] = inwardIssue.toJson();
    json[r'outwardIssue'] = outwardIssue.toJson();
    return json;
  }

  IssueLink copyWith(
      {String? id,
      String? self,
      IssueLinkType? type,
      LinkedIssue? inwardIssue,
      LinkedIssue? outwardIssue}) {
    return IssueLink(
      id: id ?? this.id,
      self: self ?? this.self,
      type: type ?? this.type,
      inwardIssue: inwardIssue ?? this.inwardIssue,
      outwardIssue: outwardIssue ?? this.outwardIssue,
    );
  }
}

/// Paginated list of worklog details
class PageOfWorklogs {
  /// The index of the first item returned on the page.
  final int? startAt;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The number of results on the page.
  final int? total;

  /// List of worklogs.
  final List<Worklog> worklogs;

  PageOfWorklogs(
      {this.startAt, this.maxResults, this.total, List<Worklog>? worklogs})
      : worklogs = worklogs ?? [];

  factory PageOfWorklogs.fromJson(Map<String, Object?> json) {
    return PageOfWorklogs(
      startAt: (json[r'startAt'] as num?)?.toInt(),
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      worklogs: (json[r'worklogs'] as List<Object?>?)
              ?.map((i) =>
                  Worklog.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var startAt = this.startAt;
    var maxResults = this.maxResults;
    var total = this.total;
    var worklogs = this.worklogs;

    final json = <String, Object?>{};
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'worklogs'] = worklogs.map((i) => i.toJson()).toList();
    return json;
  }

  PageOfWorklogs copyWith(
      {int? startAt, int? maxResults, int? total, List<Worklog>? worklogs}) {
    return PageOfWorklogs(
      startAt: startAt ?? this.startAt,
      maxResults: maxResults ?? this.maxResults,
      total: total ?? this.total,
      worklogs: worklogs ?? this.worklogs,
    );
  }
}

/// Details of a worklog.
class Worklog {
  /// The URL of the worklog item.
  final String? self;

  /// Details of the user who created the worklog.
  final UserDetails? author;

  /// Details of the user who last updated the worklog.
  final UserDetails? updateAuthor;

  /// A comment about the worklog in
  /// [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/).
  /// Optional when creating or updating a worklog.
  final dynamic comment;

  /// The datetime on which the worklog was created.
  final DateTime? created;

  /// The datetime on which the worklog was last updated.
  final DateTime? updated;

  /// Details about any restrictions in the visibility of the worklog. Optional
  /// when creating or updating a worklog.
  final Visibility? visibility;

  /// The datetime on which the worklog effort was started. Required when
  /// creating a worklog. Optional when updating a worklog.
  final DateTime? started;

  /// The time spent working on the issue as days (#d), hours (#h), or minutes
  /// (#m or #). Required when creating a worklog if `timeSpentSeconds` isn't
  /// provided. Optional when updating a worklog. Cannot be provided if
  /// `timeSpentSecond` is provided.
  final String? timeSpent;

  /// The time in seconds spent working on the issue. Required when creating a
  /// worklog if `timeSpent` isn't provided. Optional when updating a worklog.
  /// Cannot be provided if `timeSpent` is provided.
  final int? timeSpentSeconds;

  /// The ID of the worklog record.
  final String? id;

  /// The ID of the issue this worklog is for.
  final String? issueId;

  /// Details of properties for the worklog. Optional when creating or updating
  /// a worklog.
  final List<EntityProperty> properties;

  Worklog(
      {this.self,
      this.author,
      this.updateAuthor,
      this.comment,
      this.created,
      this.updated,
      this.visibility,
      this.started,
      this.timeSpent,
      this.timeSpentSeconds,
      this.id,
      this.issueId,
      List<EntityProperty>? properties})
      : properties = properties ?? [];

  factory Worklog.fromJson(Map<String, Object?> json) {
    return Worklog(
      self: json[r'self'] as String?,
      author: json[r'author'] != null
          ? UserDetails.fromJson(json[r'author']! as Map<String, Object?>)
          : null,
      updateAuthor: json[r'updateAuthor'] != null
          ? UserDetails.fromJson(json[r'updateAuthor']! as Map<String, Object?>)
          : null,
      comment: json[r'comment'],
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      updated: DateTime.tryParse(json[r'updated'] as String? ?? ''),
      visibility: json[r'visibility'] != null
          ? Visibility.fromJson(json[r'visibility']! as Map<String, Object?>)
          : null,
      started: DateTime.tryParse(json[r'started'] as String? ?? ''),
      timeSpent: json[r'timeSpent'] as String?,
      timeSpentSeconds: (json[r'timeSpentSeconds'] as num?)?.toInt(),
      id: json[r'id'] as String?,
      issueId: json[r'issueId'] as String?,
      properties: (json[r'properties'] as List<Object?>?)
              ?.map((i) => EntityProperty.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var author = this.author;
    var updateAuthor = this.updateAuthor;
    var comment = this.comment;
    var created = this.created;
    var updated = this.updated;
    var visibility = this.visibility;
    var started = this.started;
    var timeSpent = this.timeSpent;
    var timeSpentSeconds = this.timeSpentSeconds;
    var id = this.id;
    var issueId = this.issueId;
    var properties = this.properties;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (author != null) {
      json[r'author'] = author.toJson();
    }
    if (updateAuthor != null) {
      json[r'updateAuthor'] = updateAuthor.toJson();
    }
    if (comment != null) {
      json[r'comment'] = comment;
    }
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    if (updated != null) {
      json[r'updated'] = updated.toIso8601String();
    }
    if (visibility != null) {
      json[r'visibility'] = visibility.toJson();
    }
    if (started != null) {
      json[r'started'] = started.toIso8601String();
    }
    if (timeSpent != null) {
      json[r'timeSpent'] = timeSpent;
    }
    if (timeSpentSeconds != null) {
      json[r'timeSpentSeconds'] = timeSpentSeconds;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (issueId != null) {
      json[r'issueId'] = issueId;
    }
    json[r'properties'] = properties.map((i) => i.toJson()).toList();
    return json;
  }

  Worklog copyWith(
      {String? self,
      UserDetails? author,
      UserDetails? updateAuthor,
      dynamic comment,
      DateTime? created,
      DateTime? updated,
      Visibility? visibility,
      DateTime? started,
      String? timeSpent,
      int? timeSpentSeconds,
      String? id,
      String? issueId,
      List<EntityProperty>? properties}) {
    return Worklog(
      self: self ?? this.self,
      author: author ?? this.author,
      updateAuthor: updateAuthor ?? this.updateAuthor,
      comment: comment ?? this.comment,
      created: created ?? this.created,
      updated: updated ?? this.updated,
      visibility: visibility ?? this.visibility,
      started: started ?? this.started,
      timeSpent: timeSpent ?? this.timeSpent,
      timeSpentSeconds: timeSpentSeconds ?? this.timeSpentSeconds,
      id: id ?? this.id,
      issueId: issueId ?? this.issueId,
      properties: properties ?? this.properties,
    );
  }
}

class IssueTypeCreateBean {
  /// The unique name for the issue type. The maximum length is 60 characters.
  final String name;

  /// The description of the issue type.
  final String? description;

  /// Whether the issue type is `subtype` or `standard`. Defaults to `standard`.
  final IssueTypeCreateBeanType? type;

  IssueTypeCreateBean({required this.name, this.description, this.type});

  factory IssueTypeCreateBean.fromJson(Map<String, Object?> json) {
    return IssueTypeCreateBean(
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
      type: json[r'type'] != null
          ? IssueTypeCreateBeanType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  IssueTypeCreateBean copyWith(
      {String? name, String? description, IssueTypeCreateBeanType? type}) {
    return IssueTypeCreateBean(
      name: name ?? this.name,
      description: description ?? this.description,
      type: type ?? this.type,
    );
  }
}

class IssueTypeCreateBeanType {
  static const subtask = IssueTypeCreateBeanType._('subtask');
  static const standard = IssueTypeCreateBeanType._('standard');

  static const values = [
    subtask,
    standard,
  ];
  final String value;

  const IssueTypeCreateBeanType._(this.value);

  static IssueTypeCreateBeanType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => IssueTypeCreateBeanType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class IssueTypeUpdateBean {
  /// The unique name for the issue type. The maximum length is 60 characters.
  final String? name;

  /// The description of the issue type.
  final String? description;

  /// The ID of an issue type avatar.
  final int? avatarId;

  IssueTypeUpdateBean({this.name, this.description, this.avatarId});

  factory IssueTypeUpdateBean.fromJson(Map<String, Object?> json) {
    return IssueTypeUpdateBean(
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      avatarId: (json[r'avatarId'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;
    var avatarId = this.avatarId;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (avatarId != null) {
      json[r'avatarId'] = avatarId;
    }
    return json;
  }

  IssueTypeUpdateBean copyWith(
      {String? name, String? description, int? avatarId}) {
    return IssueTypeUpdateBean(
      name: name ?? this.name,
      description: description ?? this.description,
      avatarId: avatarId ?? this.avatarId,
    );
  }
}

/// List of security schemes.
class SecuritySchemes {
  /// List of security schemes.
  final List<SecurityScheme> issueSecuritySchemes;

  SecuritySchemes({List<SecurityScheme>? issueSecuritySchemes})
      : issueSecuritySchemes = issueSecuritySchemes ?? [];

  factory SecuritySchemes.fromJson(Map<String, Object?> json) {
    return SecuritySchemes(
      issueSecuritySchemes: (json[r'issueSecuritySchemes'] as List<Object?>?)
              ?.map((i) => SecurityScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueSecuritySchemes = this.issueSecuritySchemes;

    final json = <String, Object?>{};
    json[r'issueSecuritySchemes'] =
        issueSecuritySchemes.map((i) => i.toJson()).toList();
    return json;
  }

  SecuritySchemes copyWith({List<SecurityScheme>? issueSecuritySchemes}) {
    return SecuritySchemes(
      issueSecuritySchemes: issueSecuritySchemes ?? this.issueSecuritySchemes,
    );
  }
}

/// Issue security level member.
class IssueSecurityLevelMember {
  /// The ID of the issue security level member.
  final int id;

  /// The ID of the issue security level.
  final int issueSecurityLevelId;

  /// The user or group being granted the permission. It consists of a `type`
  /// and a type-dependent `parameter`. See
  /// [Holder object](../api-group-permission-schemes/#holder-object) in *Get
  /// all permission schemes* for more information.
  final PermissionHolder holder;

  IssueSecurityLevelMember(
      {required this.id,
      required this.issueSecurityLevelId,
      required this.holder});

  factory IssueSecurityLevelMember.fromJson(Map<String, Object?> json) {
    return IssueSecurityLevelMember(
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      issueSecurityLevelId:
          (json[r'issueSecurityLevelId'] as num?)?.toInt() ?? 0,
      holder: PermissionHolder.fromJson(
          json[r'holder'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var issueSecurityLevelId = this.issueSecurityLevelId;
    var holder = this.holder;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'issueSecurityLevelId'] = issueSecurityLevelId;
    json[r'holder'] = holder.toJson();
    return json;
  }

  IssueSecurityLevelMember copyWith(
      {int? id, int? issueSecurityLevelId, PermissionHolder? holder}) {
    return IssueSecurityLevelMember(
      id: id ?? this.id,
      issueSecurityLevelId: issueSecurityLevelId ?? this.issueSecurityLevelId,
      holder: holder ?? this.holder,
    );
  }
}

/// A page of items.
class PageBeanIssueSecurityLevelMember {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<IssueSecurityLevelMember> values;

  PageBeanIssueSecurityLevelMember(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<IssueSecurityLevelMember>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueSecurityLevelMember.fromJson(Map<String, Object?> json) {
    return PageBeanIssueSecurityLevelMember(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueSecurityLevelMember.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueSecurityLevelMember copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<IssueSecurityLevelMember>? values}) {
    return PageBeanIssueSecurityLevelMember(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// List of issue transitions.
class Transitions {
  /// Expand options that include additional transitions details in the
  /// response.
  final String? expand;

  /// List of issue transitions.
  final List<IssueTransition> transitions;

  Transitions({this.expand, List<IssueTransition>? transitions})
      : transitions = transitions ?? [];

  factory Transitions.fromJson(Map<String, Object?> json) {
    return Transitions(
      expand: json[r'expand'] as String?,
      transitions: (json[r'transitions'] as List<Object?>?)
              ?.map((i) => IssueTransition.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var transitions = this.transitions;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    json[r'transitions'] = transitions.map((i) => i.toJson()).toList();
    return json;
  }

  Transitions copyWith({String? expand, List<IssueTransition>? transitions}) {
    return Transitions(
      expand: expand ?? this.expand,
      transitions: transitions ?? this.transitions,
    );
  }
}

/// A list of issues suggested for use in auto-completion.
class IssuePickerSuggestions {
  /// A list of issues for an issue type suggested for use in auto-completion.
  final List<IssuePickerSuggestionsIssueType> sections;

  IssuePickerSuggestions({List<IssuePickerSuggestionsIssueType>? sections})
      : sections = sections ?? [];

  factory IssuePickerSuggestions.fromJson(Map<String, Object?> json) {
    return IssuePickerSuggestions(
      sections: (json[r'sections'] as List<Object?>?)
              ?.map((i) => IssuePickerSuggestionsIssueType.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var sections = this.sections;

    final json = <String, Object?>{};
    json[r'sections'] = sections.map((i) => i.toJson()).toList();
    return json;
  }

  IssuePickerSuggestions copyWith(
      {List<IssuePickerSuggestionsIssueType>? sections}) {
    return IssuePickerSuggestions(
      sections: sections ?? this.sections,
    );
  }
}

/// A type of issue suggested for use in auto-completion.
class IssuePickerSuggestionsIssueType {
  /// The label of the type of issues suggested for use in auto-completion.
  final String? label;

  /// If issue suggestions are found, returns a message indicating the number of
  /// issues suggestions found and returned.
  final String? sub;

  /// The ID of the type of issues suggested for use in auto-completion.
  final String? id;

  /// If no issue suggestions are found, returns a message indicating no
  /// suggestions were found,
  final String? msg;

  /// A list of issues suggested for use in auto-completion.
  final List<SuggestedIssue> issues;

  IssuePickerSuggestionsIssueType(
      {this.label, this.sub, this.id, this.msg, List<SuggestedIssue>? issues})
      : issues = issues ?? [];

  factory IssuePickerSuggestionsIssueType.fromJson(Map<String, Object?> json) {
    return IssuePickerSuggestionsIssueType(
      label: json[r'label'] as String?,
      sub: json[r'sub'] as String?,
      id: json[r'id'] as String?,
      msg: json[r'msg'] as String?,
      issues: (json[r'issues'] as List<Object?>?)
              ?.map((i) => SuggestedIssue.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var label = this.label;
    var sub = this.sub;
    var id = this.id;
    var msg = this.msg;
    var issues = this.issues;

    final json = <String, Object?>{};
    if (label != null) {
      json[r'label'] = label;
    }
    if (sub != null) {
      json[r'sub'] = sub;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (msg != null) {
      json[r'msg'] = msg;
    }
    json[r'issues'] = issues.map((i) => i.toJson()).toList();
    return json;
  }

  IssuePickerSuggestionsIssueType copyWith(
      {String? label,
      String? sub,
      String? id,
      String? msg,
      List<SuggestedIssue>? issues}) {
    return IssuePickerSuggestionsIssueType(
      label: label ?? this.label,
      sub: sub ?? this.sub,
      id: id ?? this.id,
      msg: msg ?? this.msg,
      issues: issues ?? this.issues,
    );
  }
}

/// An issue suggested for use in the issue picker auto-completion.
class SuggestedIssue {
  /// The ID of the issue.
  final int? id;

  /// The key of the issue.
  final String? key;

  /// The key of the issue in HTML format.
  final String? keyHtml;

  /// The URL of the issue type's avatar.
  final String? img;

  /// The phrase containing the query string in HTML format, with the string
  /// highlighted with HTML bold tags.
  final String? summary;

  /// The phrase containing the query string, as plain text.
  final String? summaryText;

  SuggestedIssue(
      {this.id,
      this.key,
      this.keyHtml,
      this.img,
      this.summary,
      this.summaryText});

  factory SuggestedIssue.fromJson(Map<String, Object?> json) {
    return SuggestedIssue(
      id: (json[r'id'] as num?)?.toInt(),
      key: json[r'key'] as String?,
      keyHtml: json[r'keyHtml'] as String?,
      img: json[r'img'] as String?,
      summary: json[r'summary'] as String?,
      summaryText: json[r'summaryText'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;
    var keyHtml = this.keyHtml;
    var img = this.img;
    var summary = this.summary;
    var summaryText = this.summaryText;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (keyHtml != null) {
      json[r'keyHtml'] = keyHtml;
    }
    if (img != null) {
      json[r'img'] = img;
    }
    if (summary != null) {
      json[r'summary'] = summary;
    }
    if (summaryText != null) {
      json[r'summaryText'] = summaryText;
    }
    return json;
  }

  SuggestedIssue copyWith(
      {int? id,
      String? key,
      String? keyHtml,
      String? img,
      String? summary,
      String? summaryText}) {
    return SuggestedIssue(
      id: id ?? this.id,
      key: key ?? this.key,
      keyHtml: keyHtml ?? this.keyHtml,
      img: img ?? this.img,
      summary: summary ?? this.summary,
      summaryText: summaryText ?? this.summaryText,
    );
  }
}

/// Details of an operation to perform on a field.
class FieldUpdateOperation {
  /// A map containing the name of a field and the value to add to it.
  final dynamic add;

  /// A map containing the name of a field and the value to set in it.
  final dynamic set;

  /// A map containing the name of a field and the value to removed from it.
  final dynamic remove;

  /// A map containing the name of a field and the value to edit in it.
  final dynamic edit;

  FieldUpdateOperation({this.add, this.set, this.remove, this.edit});

  factory FieldUpdateOperation.fromJson(Map<String, Object?> json) {
    return FieldUpdateOperation(
      add: json[r'add'],
      set: json[r'set'],
      remove: json[r'remove'],
      edit: json[r'edit'],
    );
  }

  Map<String, Object?> toJson() {
    var add = this.add;
    var set = this.set;
    var remove = this.remove;
    var edit = this.edit;

    final json = <String, Object?>{};
    if (add != null) {
      json[r'add'] = add;
    }
    if (set != null) {
      json[r'set'] = set;
    }
    if (remove != null) {
      json[r'remove'] = remove;
    }
    if (edit != null) {
      json[r'edit'] = edit;
    }
    return json;
  }

  FieldUpdateOperation copyWith(
      {dynamic add, dynamic set, dynamic remove, dynamic edit}) {
    return FieldUpdateOperation(
      add: add ?? this.add,
      set: set ?? this.set,
      remove: remove ?? this.remove,
      edit: edit ?? this.edit,
    );
  }
}

/// Details of an issue update request.
class IssueUpdateDetails {
  /// Details of a transition. Required when performing a transition, optional
  /// when creating or editing an issue.
  final IssueTransition? transition;

  /// List of issue screen fields to update, specifying the sub-field to update
  /// and its value for each field. This field provides a straightforward option
  /// when setting a sub-field. When multiple sub-fields or other operations are
  /// required, use `update`. Fields included in here cannot be included in
  /// `update`.
  final Map<String, dynamic>? fields;

  /// List of operations to perform on issue screen fields. Note that fields
  /// included in here cannot be included in `fields`.
  final Map<String, dynamic>? update;

  /// Additional issue history details.
  final HistoryMetadata? historyMetadata;

  /// Details of issue properties to be add or update.
  final List<EntityProperty> properties;

  IssueUpdateDetails(
      {this.transition,
      this.fields,
      this.update,
      this.historyMetadata,
      List<EntityProperty>? properties})
      : properties = properties ?? [];

  factory IssueUpdateDetails.fromJson(Map<String, Object?> json) {
    return IssueUpdateDetails(
      transition: json[r'transition'] != null
          ? IssueTransition.fromJson(
              json[r'transition']! as Map<String, Object?>)
          : null,
      fields: json[r'fields'] as Map<String, Object?>?,
      update: json[r'update'] as Map<String, Object?>?,
      historyMetadata: json[r'historyMetadata'] != null
          ? HistoryMetadata.fromJson(
              json[r'historyMetadata']! as Map<String, Object?>)
          : null,
      properties: (json[r'properties'] as List<Object?>?)
              ?.map((i) => EntityProperty.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var transition = this.transition;
    var fields = this.fields;
    var update = this.update;
    var historyMetadata = this.historyMetadata;
    var properties = this.properties;

    final json = <String, Object?>{};
    if (transition != null) {
      json[r'transition'] = transition.toJson();
    }
    if (fields != null) {
      json[r'fields'] = fields;
    }
    if (update != null) {
      json[r'update'] = update;
    }
    if (historyMetadata != null) {
      json[r'historyMetadata'] = historyMetadata.toJson();
    }
    json[r'properties'] = properties.map((i) => i.toJson()).toList();
    return json;
  }

  IssueUpdateDetails copyWith(
      {IssueTransition? transition,
      Map<String, dynamic>? fields,
      Map<String, dynamic>? update,
      HistoryMetadata? historyMetadata,
      List<EntityProperty>? properties}) {
    return IssueUpdateDetails(
      transition: transition ?? this.transition,
      fields: fields ?? this.fields,
      update: update ?? this.update,
      historyMetadata: historyMetadata ?? this.historyMetadata,
      properties: properties ?? this.properties,
    );
  }
}

/// The details of votes on an issue.
class Votes {
  /// The URL of these issue vote details.
  final String? self;

  /// The number of votes on the issue.
  final int? votes;

  /// Whether the user making this request has voted on the issue.
  final bool hasVoted;

  /// List of the users who have voted on this issue. An empty list is returned
  /// when the calling user doesn't have the *View voters and watchers* project
  /// permission.
  final List<User> voters;

  Votes({this.self, this.votes, bool? hasVoted, List<User>? voters})
      : hasVoted = hasVoted ?? false,
        voters = voters ?? [];

  factory Votes.fromJson(Map<String, Object?> json) {
    return Votes(
      self: json[r'self'] as String?,
      votes: (json[r'votes'] as num?)?.toInt(),
      hasVoted: json[r'hasVoted'] as bool? ?? false,
      voters: (json[r'voters'] as List<Object?>?)
              ?.map(
                  (i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var votes = this.votes;
    var hasVoted = this.hasVoted;
    var voters = this.voters;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (votes != null) {
      json[r'votes'] = votes;
    }
    json[r'hasVoted'] = hasVoted;
    json[r'voters'] = voters.map((i) => i.toJson()).toList();
    return json;
  }

  Votes copyWith(
      {String? self, int? votes, bool? hasVoted, List<User>? voters}) {
    return Votes(
      self: self ?? this.self,
      votes: votes ?? this.votes,
      hasVoted: hasVoted ?? this.hasVoted,
      voters: voters ?? this.voters,
    );
  }
}

/// The details of watchers on an issue.
class Watchers {
  /// The URL of these issue watcher details.
  final String? self;

  /// Whether the calling user is watching this issue.
  final bool isWatching;

  /// The number of users watching this issue.
  final int? watchCount;

  /// Details of the users watching this issue.
  final List<UserDetails> watchers;

  Watchers(
      {this.self,
      bool? isWatching,
      this.watchCount,
      List<UserDetails>? watchers})
      : isWatching = isWatching ?? false,
        watchers = watchers ?? [];

  factory Watchers.fromJson(Map<String, Object?> json) {
    return Watchers(
      self: json[r'self'] as String?,
      isWatching: json[r'isWatching'] as bool? ?? false,
      watchCount: (json[r'watchCount'] as num?)?.toInt(),
      watchers: (json[r'watchers'] as List<Object?>?)
              ?.map((i) =>
                  UserDetails.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var isWatching = this.isWatching;
    var watchCount = this.watchCount;
    var watchers = this.watchers;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'isWatching'] = isWatching;
    if (watchCount != null) {
      json[r'watchCount'] = watchCount;
    }
    json[r'watchers'] = watchers.map((i) => i.toJson()).toList();
    return json;
  }

  Watchers copyWith(
      {String? self,
      bool? isWatching,
      int? watchCount,
      List<UserDetails>? watchers}) {
    return Watchers(
      self: self ?? this.self,
      isWatching: isWatching ?? this.isWatching,
      watchCount: watchCount ?? this.watchCount,
      watchers: watchers ?? this.watchers,
    );
  }
}

/// Details about a created issue or subtask.
class CreatedIssue {
  /// The ID of the created issue or subtask.
  final String? id;

  /// The key of the created issue or subtask.
  final String? key;

  /// The URL of the created issue or subtask.
  final String? self;

  /// The response code and messages related to any requested transition.
  final NestedResponse? transition;

  CreatedIssue({this.id, this.key, this.self, this.transition});

  factory CreatedIssue.fromJson(Map<String, Object?> json) {
    return CreatedIssue(
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      self: json[r'self'] as String?,
      transition: json[r'transition'] != null
          ? NestedResponse.fromJson(
              json[r'transition']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;
    var self = this.self;
    var transition = this.transition;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (transition != null) {
      json[r'transition'] = transition.toJson();
    }
    return json;
  }

  CreatedIssue copyWith(
      {String? id, String? key, String? self, NestedResponse? transition}) {
    return CreatedIssue(
      id: id ?? this.id,
      key: key ?? this.key,
      self: self ?? this.self,
      transition: transition ?? this.transition,
    );
  }
}

class NestedResponse {
  final int? status;
  final ErrorCollection? errorCollection;

  NestedResponse({this.status, this.errorCollection});

  factory NestedResponse.fromJson(Map<String, Object?> json) {
    return NestedResponse(
      status: (json[r'status'] as num?)?.toInt(),
      errorCollection: json[r'errorCollection'] != null
          ? ErrorCollection.fromJson(
              json[r'errorCollection']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var status = this.status;
    var errorCollection = this.errorCollection;

    final json = <String, Object?>{};
    if (status != null) {
      json[r'status'] = status;
    }
    if (errorCollection != null) {
      json[r'errorCollection'] = errorCollection.toJson();
    }
    return json;
  }

  NestedResponse copyWith({int? status, ErrorCollection? errorCollection}) {
    return NestedResponse(
      status: status ?? this.status,
      errorCollection: errorCollection ?? this.errorCollection,
    );
  }
}

class IssuesUpdateBean {
  final List<IssueUpdateDetails> issueUpdates;

  IssuesUpdateBean({List<IssueUpdateDetails>? issueUpdates})
      : issueUpdates = issueUpdates ?? [];

  factory IssuesUpdateBean.fromJson(Map<String, Object?> json) {
    return IssuesUpdateBean(
      issueUpdates: (json[r'issueUpdates'] as List<Object?>?)
              ?.map((i) => IssueUpdateDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueUpdates = this.issueUpdates;

    final json = <String, Object?>{};
    json[r'issueUpdates'] = issueUpdates.map((i) => i.toJson()).toList();
    return json;
  }

  IssuesUpdateBean copyWith({List<IssueUpdateDetails>? issueUpdates}) {
    return IssuesUpdateBean(
      issueUpdates: issueUpdates ?? this.issueUpdates,
    );
  }
}

class BulkOperationErrorResult {
  final int? status;
  final ErrorCollection? elementErrors;
  final int? failedElementNumber;

  BulkOperationErrorResult(
      {this.status, this.elementErrors, this.failedElementNumber});

  factory BulkOperationErrorResult.fromJson(Map<String, Object?> json) {
    return BulkOperationErrorResult(
      status: (json[r'status'] as num?)?.toInt(),
      elementErrors: json[r'elementErrors'] != null
          ? ErrorCollection.fromJson(
              json[r'elementErrors']! as Map<String, Object?>)
          : null,
      failedElementNumber: (json[r'failedElementNumber'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var status = this.status;
    var elementErrors = this.elementErrors;
    var failedElementNumber = this.failedElementNumber;

    final json = <String, Object?>{};
    if (status != null) {
      json[r'status'] = status;
    }
    if (elementErrors != null) {
      json[r'elementErrors'] = elementErrors.toJson();
    }
    if (failedElementNumber != null) {
      json[r'failedElementNumber'] = failedElementNumber;
    }
    return json;
  }

  BulkOperationErrorResult copyWith(
      {int? status, ErrorCollection? elementErrors, int? failedElementNumber}) {
    return BulkOperationErrorResult(
      status: status ?? this.status,
      elementErrors: elementErrors ?? this.elementErrors,
      failedElementNumber: failedElementNumber ?? this.failedElementNumber,
    );
  }
}

/// Details about the issues created and the errors for requests that failed.
class CreatedIssues {
  /// Details of the issues created.
  final List<CreatedIssue> issues;

  /// Error details for failed issue creation requests.
  final List<BulkOperationErrorResult> errors;

  CreatedIssues(
      {List<CreatedIssue>? issues, List<BulkOperationErrorResult>? errors})
      : issues = issues ?? [],
        errors = errors ?? [];

  factory CreatedIssues.fromJson(Map<String, Object?> json) {
    return CreatedIssues(
      issues: (json[r'issues'] as List<Object?>?)
              ?.map((i) =>
                  CreatedIssue.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      errors: (json[r'errors'] as List<Object?>?)
              ?.map((i) => BulkOperationErrorResult.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issues = this.issues;
    var errors = this.errors;

    final json = <String, Object?>{};
    json[r'issues'] = issues.map((i) => i.toJson()).toList();
    json[r'errors'] = errors.map((i) => i.toJson()).toList();
    return json;
  }

  CreatedIssues copyWith(
      {List<CreatedIssue>? issues, List<BulkOperationErrorResult>? errors}) {
    return CreatedIssues(
      issues: issues ?? this.issues,
      errors: errors ?? this.errors,
    );
  }
}

/// The wrapper for the issue creation metadata for a list of projects.
class IssueCreateMetadata {
  /// Expand options that include additional project details in the response.
  final String? expand;

  /// List of projects and their issue creation metadata.
  final List<ProjectIssueCreateMetadata> projects;

  IssueCreateMetadata({this.expand, List<ProjectIssueCreateMetadata>? projects})
      : projects = projects ?? [];

  factory IssueCreateMetadata.fromJson(Map<String, Object?> json) {
    return IssueCreateMetadata(
      expand: json[r'expand'] as String?,
      projects: (json[r'projects'] as List<Object?>?)
              ?.map((i) => ProjectIssueCreateMetadata.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var projects = this.projects;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    json[r'projects'] = projects.map((i) => i.toJson()).toList();
    return json;
  }

  IssueCreateMetadata copyWith(
      {String? expand, List<ProjectIssueCreateMetadata>? projects}) {
    return IssueCreateMetadata(
      expand: expand ?? this.expand,
      projects: projects ?? this.projects,
    );
  }
}

/// Details of the issue creation metadata for an issue type.
class IssueTypeIssueCreateMetadata {
  /// The URL of these issue type details.
  final String? self;

  /// The ID of the issue type.
  final String? id;

  /// The description of the issue type.
  final String? description;

  /// The URL of the issue type's avatar.
  final String? iconUrl;

  /// The name of the issue type.
  final String? name;

  /// Whether this issue type is used to create subtasks.
  final bool subtask;

  /// The ID of the issue type's avatar.
  final int? avatarId;

  /// Unique ID for next-gen projects.
  final String? entityId;

  /// Hierarchy level of the issue type.
  final int? hierarchyLevel;

  /// Details of the next-gen projects the issue type is available in.
  final Scope? scope;

  /// Expand options that include additional issue type metadata details in the
  /// response.
  final String? expand;

  /// List of the fields available when creating an issue for the issue type.
  final Map<String, dynamic>? fields;

  IssueTypeIssueCreateMetadata(
      {this.self,
      this.id,
      this.description,
      this.iconUrl,
      this.name,
      bool? subtask,
      this.avatarId,
      this.entityId,
      this.hierarchyLevel,
      this.scope,
      this.expand,
      this.fields})
      : subtask = subtask ?? false;

  factory IssueTypeIssueCreateMetadata.fromJson(Map<String, Object?> json) {
    return IssueTypeIssueCreateMetadata(
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      description: json[r'description'] as String?,
      iconUrl: json[r'iconUrl'] as String?,
      name: json[r'name'] as String?,
      subtask: json[r'subtask'] as bool? ?? false,
      avatarId: (json[r'avatarId'] as num?)?.toInt(),
      entityId: json[r'entityId'] as String?,
      hierarchyLevel: (json[r'hierarchyLevel'] as num?)?.toInt(),
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      expand: json[r'expand'] as String?,
      fields: json[r'fields'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var description = this.description;
    var iconUrl = this.iconUrl;
    var name = this.name;
    var subtask = this.subtask;
    var avatarId = this.avatarId;
    var entityId = this.entityId;
    var hierarchyLevel = this.hierarchyLevel;
    var scope = this.scope;
    var expand = this.expand;
    var fields = this.fields;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (iconUrl != null) {
      json[r'iconUrl'] = iconUrl;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'subtask'] = subtask;
    if (avatarId != null) {
      json[r'avatarId'] = avatarId;
    }
    if (entityId != null) {
      json[r'entityId'] = entityId;
    }
    if (hierarchyLevel != null) {
      json[r'hierarchyLevel'] = hierarchyLevel;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (fields != null) {
      json[r'fields'] = fields;
    }
    return json;
  }

  IssueTypeIssueCreateMetadata copyWith(
      {String? self,
      String? id,
      String? description,
      String? iconUrl,
      String? name,
      bool? subtask,
      int? avatarId,
      String? entityId,
      int? hierarchyLevel,
      Scope? scope,
      String? expand,
      Map<String, dynamic>? fields}) {
    return IssueTypeIssueCreateMetadata(
      self: self ?? this.self,
      id: id ?? this.id,
      description: description ?? this.description,
      iconUrl: iconUrl ?? this.iconUrl,
      name: name ?? this.name,
      subtask: subtask ?? this.subtask,
      avatarId: avatarId ?? this.avatarId,
      entityId: entityId ?? this.entityId,
      hierarchyLevel: hierarchyLevel ?? this.hierarchyLevel,
      scope: scope ?? this.scope,
      expand: expand ?? this.expand,
      fields: fields ?? this.fields,
    );
  }
}

/// Details of the issue creation metadata for a project.
class ProjectIssueCreateMetadata {
  /// Expand options that include additional project issue create metadata
  /// details in the response.
  final String? expand;

  /// The URL of the project.
  final String? self;

  /// The ID of the project.
  final String? id;

  /// The key of the project.
  final String? key;

  /// The name of the project.
  final String? name;

  /// List of the project's avatars, returning the avatar size and associated
  /// URL.
  final AvatarUrlsBean? avatarUrls;

  /// List of the issue types supported by the project.
  final List<IssueTypeIssueCreateMetadata> issuetypes;

  ProjectIssueCreateMetadata(
      {this.expand,
      this.self,
      this.id,
      this.key,
      this.name,
      this.avatarUrls,
      List<IssueTypeIssueCreateMetadata>? issuetypes})
      : issuetypes = issuetypes ?? [];

  factory ProjectIssueCreateMetadata.fromJson(Map<String, Object?> json) {
    return ProjectIssueCreateMetadata(
      expand: json[r'expand'] as String?,
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      avatarUrls: json[r'avatarUrls'] != null
          ? AvatarUrlsBean.fromJson(
              json[r'avatarUrls']! as Map<String, Object?>)
          : null,
      issuetypes: (json[r'issuetypes'] as List<Object?>?)
              ?.map((i) => IssueTypeIssueCreateMetadata.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var self = this.self;
    var id = this.id;
    var key = this.key;
    var name = this.name;
    var avatarUrls = this.avatarUrls;
    var issuetypes = this.issuetypes;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (avatarUrls != null) {
      json[r'avatarUrls'] = avatarUrls.toJson();
    }
    json[r'issuetypes'] = issuetypes.map((i) => i.toJson()).toList();
    return json;
  }

  ProjectIssueCreateMetadata copyWith(
      {String? expand,
      String? self,
      String? id,
      String? key,
      String? name,
      AvatarUrlsBean? avatarUrls,
      List<IssueTypeIssueCreateMetadata>? issuetypes}) {
    return ProjectIssueCreateMetadata(
      expand: expand ?? this.expand,
      self: self ?? this.self,
      id: id ?? this.id,
      key: key ?? this.key,
      name: name ?? this.name,
      avatarUrls: avatarUrls ?? this.avatarUrls,
      issuetypes: issuetypes ?? this.issuetypes,
    );
  }
}

/// The application the linked item is in.
class Application {
  /// The name-spaced type of the application, used by registered rendering
  /// apps.
  final String? type;

  /// The name of the application. Used in conjunction with the (remote) object
  /// icon title to display a tooltip for the link's icon. The tooltip takes the
  /// format "[application name] icon title". Blank items are excluded from the
  /// tooltip title. If both items are blank, the icon tooltop displays as "Web
  /// Link". Grouping and sorting of links may place links without an
  /// application name last.
  final String? name;

  Application({this.type, this.name});

  factory Application.fromJson(Map<String, Object?> json) {
    return Application(
      type: json[r'type'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var name = this.name;

    final json = <String, Object?>{};
    if (type != null) {
      json[r'type'] = type;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  Application copyWith({String? type, String? name}) {
    return Application(
      type: type ?? this.type,
      name: name ?? this.name,
    );
  }
}

/// An icon.
class IconBean {
  /// The URL of a 16x16 pixel icon.
  final String? url16X16;

  /// The title of the icon, for use as a tooltip on the icon.
  final String? title;

  /// The URL of the tooltip, used only for a status icon.
  final String? link;

  IconBean({this.url16X16, this.title, this.link});

  factory IconBean.fromJson(Map<String, Object?> json) {
    return IconBean(
      url16X16: json[r'url16x16'] as String?,
      title: json[r'title'] as String?,
      link: json[r'link'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var url16X16 = this.url16X16;
    var title = this.title;
    var link = this.link;

    final json = <String, Object?>{};
    if (url16X16 != null) {
      json[r'url16x16'] = url16X16;
    }
    if (title != null) {
      json[r'title'] = title;
    }
    if (link != null) {
      json[r'link'] = link;
    }
    return json;
  }

  IconBean copyWith({String? url16X16, String? title, String? link}) {
    return IconBean(
      url16X16: url16X16 ?? this.url16X16,
      title: title ?? this.title,
      link: link ?? this.link,
    );
  }
}

/// Details of an issue remote link.
class RemoteIssueLink {
  /// The ID of the link.
  final int? id;

  /// The URL of the link.
  final String? self;

  /// The global ID of the link, such as the ID of the item on the remote
  /// system.
  final String? globalId;

  /// Details of the remote application the linked item is in.
  final Application? application;

  /// Description of the relationship between the issue and the linked item.
  final String? relationship;

  /// Details of the item linked to.
  final RemoteObject? object;

  RemoteIssueLink(
      {this.id,
      this.self,
      this.globalId,
      this.application,
      this.relationship,
      this.object});

  factory RemoteIssueLink.fromJson(Map<String, Object?> json) {
    return RemoteIssueLink(
      id: (json[r'id'] as num?)?.toInt(),
      self: json[r'self'] as String?,
      globalId: json[r'globalId'] as String?,
      application: json[r'application'] != null
          ? Application.fromJson(json[r'application']! as Map<String, Object?>)
          : null,
      relationship: json[r'relationship'] as String?,
      object: json[r'object'] != null
          ? RemoteObject.fromJson(json[r'object']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var self = this.self;
    var globalId = this.globalId;
    var application = this.application;
    var relationship = this.relationship;
    var object = this.object;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (globalId != null) {
      json[r'globalId'] = globalId;
    }
    if (application != null) {
      json[r'application'] = application.toJson();
    }
    if (relationship != null) {
      json[r'relationship'] = relationship;
    }
    if (object != null) {
      json[r'object'] = object.toJson();
    }
    return json;
  }

  RemoteIssueLink copyWith(
      {int? id,
      String? self,
      String? globalId,
      Application? application,
      String? relationship,
      RemoteObject? object}) {
    return RemoteIssueLink(
      id: id ?? this.id,
      self: self ?? this.self,
      globalId: globalId ?? this.globalId,
      application: application ?? this.application,
      relationship: relationship ?? this.relationship,
      object: object ?? this.object,
    );
  }
}

/// The linked item.
class RemoteObject {
  /// The URL of the item.
  final String url;

  /// The title of the item.
  final String title;

  /// The summary details of the item.
  final String? summary;

  /// Details of the icon for the item. If no icon is defined, the default link
  /// icon is used in Jira.
  final Icon? icon;

  /// The status of the item.
  final Status? status;

  RemoteObject(
      {required this.url,
      required this.title,
      this.summary,
      this.icon,
      this.status});

  factory RemoteObject.fromJson(Map<String, Object?> json) {
    return RemoteObject(
      url: json[r'url'] as String? ?? '',
      title: json[r'title'] as String? ?? '',
      summary: json[r'summary'] as String?,
      icon: json[r'icon'] != null
          ? Icon.fromJson(json[r'icon']! as Map<String, Object?>)
          : null,
      status: json[r'status'] != null
          ? Status.fromJson(json[r'status']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var url = this.url;
    var title = this.title;
    var summary = this.summary;
    var icon = this.icon;
    var status = this.status;

    final json = <String, Object?>{};
    json[r'url'] = url;
    json[r'title'] = title;
    if (summary != null) {
      json[r'summary'] = summary;
    }
    if (icon != null) {
      json[r'icon'] = icon.toJson();
    }
    if (status != null) {
      json[r'status'] = status.toJson();
    }
    return json;
  }

  RemoteObject copyWith(
      {String? url,
      String? title,
      String? summary,
      Icon? icon,
      Status? status}) {
    return RemoteObject(
      url: url ?? this.url,
      title: title ?? this.title,
      summary: summary ?? this.summary,
      icon: icon ?? this.icon,
      status: status ?? this.status,
    );
  }
}

/// The status of the item.
class Status {
  /// Whether the item is resolved. If set to "true", the link to the issue is
  /// displayed in a strikethrough font, otherwise the link displays in normal
  /// font.
  final bool resolved;

  /// Details of the icon representing the status. If not provided, no status
  /// icon displays in Jira.
  final Icon? icon;

  Status({bool? resolved, this.icon}) : resolved = resolved ?? false;

  factory Status.fromJson(Map<String, Object?> json) {
    return Status(
      resolved: json[r'resolved'] as bool? ?? false,
      icon: json[r'icon'] != null
          ? Icon.fromJson(json[r'icon']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var resolved = this.resolved;
    var icon = this.icon;

    final json = <String, Object?>{};
    json[r'resolved'] = resolved;
    if (icon != null) {
      json[r'icon'] = icon.toJson();
    }
    return json;
  }

  Status copyWith({bool? resolved, Icon? icon}) {
    return Status(
      resolved: resolved ?? this.resolved,
      icon: icon ?? this.icon,
    );
  }
}

/// An icon. If no icon is defined:
///
///  *  for a status icon, no status icon displays in Jira.
///  *  for the remote object icon, the default link icon displays in Jira.
class Icon {
  /// The URL of an icon that displays at 16x16 pixel in Jira.
  final String? url16X16;

  /// The title of the icon. This is used as follows:
  ///
  ///  *  For a status icon it is used as a tooltip on the icon. If not set, the
  /// status icon doesn't display a tooltip in Jira.
  ///  *  For the remote object icon it is used in conjunction with the
  /// application name to display a tooltip for the link's icon. The tooltip
  /// takes the format "[application name] icon title". Blank itemsare excluded
  /// from the tooltip title. If both items are blank, the icon tooltop displays
  /// as "Web Link".
  final String? title;

  /// The URL of the tooltip, used only for a status icon. If not set, the
  /// status icon in Jira is not clickable.
  final String? link;

  Icon({this.url16X16, this.title, this.link});

  factory Icon.fromJson(Map<String, Object?> json) {
    return Icon(
      url16X16: json[r'url16x16'] as String?,
      title: json[r'title'] as String?,
      link: json[r'link'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var url16X16 = this.url16X16;
    var title = this.title;
    var link = this.link;

    final json = <String, Object?>{};
    if (url16X16 != null) {
      json[r'url16x16'] = url16X16;
    }
    if (title != null) {
      json[r'title'] = title;
    }
    if (link != null) {
      json[r'link'] = link;
    }
    return json;
  }

  Icon copyWith({String? url16X16, String? title, String? link}) {
    return Icon(
      url16X16: url16X16 ?? this.url16X16,
      title: title ?? this.title,
      link: link ?? this.link,
    );
  }
}

/// Details of a remote issue link.
class RemoteIssueLinkRequest {
  /// An identifier for the remote item in the remote system. For example, the
  /// global ID for a remote item in Confluence would consist of the app ID and
  /// page ID, like this: `appId=456&pageId=123`.
  ///
  /// Setting this field enables the remote issue link details to be updated or
  /// deleted using remote system and item details as the record identifier,
  /// rather than using the record's Jira ID.
  ///
  /// The maximum length is 255 characters.
  final String? globalId;

  /// Details of the remote application the linked item is in. For example,
  /// trello.
  final Application? application;

  /// Description of the relationship between the issue and the linked item. If
  /// not set, the relationship description "links to" is used in Jira.
  final String? relationship;

  /// Details of the item linked to.
  final RemoteObject object;

  RemoteIssueLinkRequest(
      {this.globalId,
      this.application,
      this.relationship,
      required this.object});

  factory RemoteIssueLinkRequest.fromJson(Map<String, Object?> json) {
    return RemoteIssueLinkRequest(
      globalId: json[r'globalId'] as String?,
      application: json[r'application'] != null
          ? Application.fromJson(json[r'application']! as Map<String, Object?>)
          : null,
      relationship: json[r'relationship'] as String?,
      object: RemoteObject.fromJson(
          json[r'object'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var globalId = this.globalId;
    var application = this.application;
    var relationship = this.relationship;
    var object = this.object;

    final json = <String, Object?>{};
    if (globalId != null) {
      json[r'globalId'] = globalId;
    }
    if (application != null) {
      json[r'application'] = application.toJson();
    }
    if (relationship != null) {
      json[r'relationship'] = relationship;
    }
    json[r'object'] = object.toJson();
    return json;
  }

  RemoteIssueLinkRequest copyWith(
      {String? globalId,
      Application? application,
      String? relationship,
      RemoteObject? object}) {
    return RemoteIssueLinkRequest(
      globalId: globalId ?? this.globalId,
      application: application ?? this.application,
      relationship: relationship ?? this.relationship,
      object: object ?? this.object,
    );
  }
}

/// Details of the identifiers for a created or updated remote issue link.
class RemoteIssueLinkIdentifies {
  /// The ID of the remote issue link, such as the ID of the item on the remote
  /// system.
  final int? id;

  /// The URL of the remote issue link.
  final String? self;

  RemoteIssueLinkIdentifies({this.id, this.self});

  factory RemoteIssueLinkIdentifies.fromJson(Map<String, Object?> json) {
    return RemoteIssueLinkIdentifies(
      id: (json[r'id'] as num?)?.toInt(),
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var self = this.self;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  RemoteIssueLinkIdentifies copyWith({int? id, String? self}) {
    return RemoteIssueLinkIdentifies(
      id: id ?? this.id,
      self: self ?? this.self,
    );
  }
}

/// Details about a notification.
class Notification {
  /// The subject of the email notification for the issue. If this is not
  /// specified, then the subject is set to the issue key and summary.
  final String? subject;

  /// The plain text body of the email notification for the issue.
  final String? textBody;

  /// The HTML body of the email notification for the issue.
  final String? htmlBody;

  /// The recipients of the email notification for the issue.
  final NotificationRecipients? to;

  /// Restricts the notifications to users with the specified permissions.
  final NotificationRecipientsRestrictions? restrict;

  Notification(
      {this.subject, this.textBody, this.htmlBody, this.to, this.restrict});

  factory Notification.fromJson(Map<String, Object?> json) {
    return Notification(
      subject: json[r'subject'] as String?,
      textBody: json[r'textBody'] as String?,
      htmlBody: json[r'htmlBody'] as String?,
      to: json[r'to'] != null
          ? NotificationRecipients.fromJson(
              json[r'to']! as Map<String, Object?>)
          : null,
      restrict: json[r'restrict'] != null
          ? NotificationRecipientsRestrictions.fromJson(
              json[r'restrict']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var subject = this.subject;
    var textBody = this.textBody;
    var htmlBody = this.htmlBody;
    var to = this.to;
    var restrict = this.restrict;

    final json = <String, Object?>{};
    if (subject != null) {
      json[r'subject'] = subject;
    }
    if (textBody != null) {
      json[r'textBody'] = textBody;
    }
    if (htmlBody != null) {
      json[r'htmlBody'] = htmlBody;
    }
    if (to != null) {
      json[r'to'] = to.toJson();
    }
    if (restrict != null) {
      json[r'restrict'] = restrict.toJson();
    }
    return json;
  }

  Notification copyWith(
      {String? subject,
      String? textBody,
      String? htmlBody,
      NotificationRecipients? to,
      NotificationRecipientsRestrictions? restrict}) {
    return Notification(
      subject: subject ?? this.subject,
      textBody: textBody ?? this.textBody,
      htmlBody: htmlBody ?? this.htmlBody,
      to: to ?? this.to,
      restrict: restrict ?? this.restrict,
    );
  }
}

/// Details of the users and groups to receive the notification.
class NotificationRecipients {
  /// Whether the notification should be sent to the issue's reporter.
  final bool reporter;

  /// Whether the notification should be sent to the issue's assignees.
  final bool assignee;

  /// Whether the notification should be sent to the issue's watchers.
  final bool watchers;

  /// Whether the notification should be sent to the issue's voters.
  final bool voters;

  /// List of users to receive the notification.
  final List<UserDetails> users;

  /// List of groups to receive the notification.
  final List<GroupName> groups;

  NotificationRecipients(
      {bool? reporter,
      bool? assignee,
      bool? watchers,
      bool? voters,
      List<UserDetails>? users,
      List<GroupName>? groups})
      : reporter = reporter ?? false,
        assignee = assignee ?? false,
        watchers = watchers ?? false,
        voters = voters ?? false,
        users = users ?? [],
        groups = groups ?? [];

  factory NotificationRecipients.fromJson(Map<String, Object?> json) {
    return NotificationRecipients(
      reporter: json[r'reporter'] as bool? ?? false,
      assignee: json[r'assignee'] as bool? ?? false,
      watchers: json[r'watchers'] as bool? ?? false,
      voters: json[r'voters'] as bool? ?? false,
      users: (json[r'users'] as List<Object?>?)
              ?.map((i) =>
                  UserDetails.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      groups: (json[r'groups'] as List<Object?>?)
              ?.map((i) =>
                  GroupName.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var reporter = this.reporter;
    var assignee = this.assignee;
    var watchers = this.watchers;
    var voters = this.voters;
    var users = this.users;
    var groups = this.groups;

    final json = <String, Object?>{};
    json[r'reporter'] = reporter;
    json[r'assignee'] = assignee;
    json[r'watchers'] = watchers;
    json[r'voters'] = voters;
    json[r'users'] = users.map((i) => i.toJson()).toList();
    json[r'groups'] = groups.map((i) => i.toJson()).toList();
    return json;
  }

  NotificationRecipients copyWith(
      {bool? reporter,
      bool? assignee,
      bool? watchers,
      bool? voters,
      List<UserDetails>? users,
      List<GroupName>? groups}) {
    return NotificationRecipients(
      reporter: reporter ?? this.reporter,
      assignee: assignee ?? this.assignee,
      watchers: watchers ?? this.watchers,
      voters: voters ?? this.voters,
      users: users ?? this.users,
      groups: groups ?? this.groups,
    );
  }
}

/// Details of the group membership or permissions needed to receive the
/// notification.
class NotificationRecipientsRestrictions {
  /// List of group memberships required to receive the notification.
  final List<GroupName> groups;

  /// List of permissions required to receive the notification.
  final List<RestrictedPermission> permissions;

  NotificationRecipientsRestrictions(
      {List<GroupName>? groups, List<RestrictedPermission>? permissions})
      : groups = groups ?? [],
        permissions = permissions ?? [];

  factory NotificationRecipientsRestrictions.fromJson(
      Map<String, Object?> json) {
    return NotificationRecipientsRestrictions(
      groups: (json[r'groups'] as List<Object?>?)
              ?.map((i) =>
                  GroupName.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      permissions: (json[r'permissions'] as List<Object?>?)
              ?.map((i) => RestrictedPermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var groups = this.groups;
    var permissions = this.permissions;

    final json = <String, Object?>{};
    json[r'groups'] = groups.map((i) => i.toJson()).toList();
    json[r'permissions'] = permissions.map((i) => i.toJson()).toList();
    return json;
  }

  NotificationRecipientsRestrictions copyWith(
      {List<GroupName>? groups, List<RestrictedPermission>? permissions}) {
    return NotificationRecipientsRestrictions(
      groups: groups ?? this.groups,
      permissions: permissions ?? this.permissions,
    );
  }
}

/// Details of the permission.
class RestrictedPermission {
  /// The ID of the permission. Either `id` or `key` must be specified. Use
  /// [Get all permissions](#api-rest-api-3-permissions-get) to get the list of
  /// permissions.
  final String? id;

  /// The key of the permission. Either `id` or `key` must be specified. Use
  /// [Get all permissions](#api-rest-api-3-permissions-get) to get the list of
  /// permissions.
  final String? key;

  RestrictedPermission({this.id, this.key});

  factory RestrictedPermission.fromJson(Map<String, Object?> json) {
    return RestrictedPermission(
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    return json;
  }

  RestrictedPermission copyWith({String? id, String? key}) {
    return RestrictedPermission(
      id: id ?? this.id,
      key: key ?? this.key,
    );
  }
}

/// A list of issue link type beans.
class IssueLinkTypes {
  /// The issue link type bean.
  final List<IssueLinkType> issueLinkTypes;

  IssueLinkTypes({List<IssueLinkType>? issueLinkTypes})
      : issueLinkTypes = issueLinkTypes ?? [];

  factory IssueLinkTypes.fromJson(Map<String, Object?> json) {
    return IssueLinkTypes(
      issueLinkTypes: (json[r'issueLinkTypes'] as List<Object?>?)
              ?.map((i) => IssueLinkType.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueLinkTypes = this.issueLinkTypes;

    final json = <String, Object?>{};
    json[r'issueLinkTypes'] = issueLinkTypes.map((i) => i.toJson()).toList();
    return json;
  }

  IssueLinkTypes copyWith({List<IssueLinkType>? issueLinkTypes}) {
    return IssueLinkTypes(
      issueLinkTypes: issueLinkTypes ?? this.issueLinkTypes,
    );
  }
}

/// A page of comments.
class PageOfComments {
  /// The index of the first item returned.
  final int? startAt;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The number of items returned.
  final int? total;

  /// The list of comments.
  final List<Comment> comments;

  PageOfComments(
      {this.startAt, this.maxResults, this.total, List<Comment>? comments})
      : comments = comments ?? [];

  factory PageOfComments.fromJson(Map<String, Object?> json) {
    return PageOfComments(
      startAt: (json[r'startAt'] as num?)?.toInt(),
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      comments: (json[r'comments'] as List<Object?>?)
              ?.map((i) =>
                  Comment.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var startAt = this.startAt;
    var maxResults = this.maxResults;
    var total = this.total;
    var comments = this.comments;

    final json = <String, Object?>{};
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'comments'] = comments.map((i) => i.toJson()).toList();
    return json;
  }

  PageOfComments copyWith(
      {int? startAt, int? maxResults, int? total, List<Comment>? comments}) {
    return PageOfComments(
      startAt: startAt ?? this.startAt,
      maxResults: maxResults ?? this.maxResults,
      total: total ?? this.total,
      comments: comments ?? this.comments,
    );
  }
}

class PaginatedResponseComment {
  final int? total;
  final int? maxResults;
  final int? startAt;
  final List<Comment> results;

  PaginatedResponseComment(
      {this.total, this.maxResults, this.startAt, List<Comment>? results})
      : results = results ?? [];

  factory PaginatedResponseComment.fromJson(Map<String, Object?> json) {
    return PaginatedResponseComment(
      total: (json[r'total'] as num?)?.toInt(),
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      results: (json[r'results'] as List<Object?>?)
              ?.map((i) =>
                  Comment.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var total = this.total;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var results = this.results;

    final json = <String, Object?>{};
    if (total != null) {
      json[r'total'] = total;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    json[r'results'] = results.map((i) => i.toJson()).toList();
    return json;
  }

  PaginatedResponseComment copyWith(
      {int? total, int? maxResults, int? startAt, List<Comment>? results}) {
    return PaginatedResponseComment(
      total: total ?? this.total,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      results: results ?? this.results,
    );
  }
}

class IssueCommentListRequestBean {
  /// The list of comment IDs. A maximum of 1000 IDs can be specified.
  final List<int> ids;

  IssueCommentListRequestBean({required this.ids});

  factory IssueCommentListRequestBean.fromJson(Map<String, Object?> json) {
    return IssueCommentListRequestBean(
      ids: (json[r'ids'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var ids = this.ids;

    final json = <String, Object?>{};
    json[r'ids'] = ids;
    return json;
  }

  IssueCommentListRequestBean copyWith({List<int>? ids}) {
    return IssueCommentListRequestBean(
      ids: ids ?? this.ids,
    );
  }
}

/// A page of items.
class PageBeanComment {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<Comment> values;

  PageBeanComment(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<Comment>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanComment.fromJson(Map<String, Object?> json) {
    return PageBeanComment(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Comment.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanComment copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<Comment>? values}) {
    return PageBeanComment(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanChangelog {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<Changelog> values;

  PageBeanChangelog(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<Changelog>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanChangelog.fromJson(Map<String, Object?> json) {
    return PageBeanChangelog(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Changelog.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanChangelog copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<Changelog>? values}) {
    return PageBeanChangelog(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Details about an attachment.
class Attachment {
  /// The URL of the attachment details response.
  final String? self;

  /// The ID of the attachment.
  final String? id;

  /// The file name of the attachment.
  final String? filename;

  /// Details of the user who added the attachment.
  final UserDetails? author;

  /// The datetime the attachment was created.
  final DateTime? created;

  /// The size of the attachment.
  final int? size;

  /// The MIME type of the attachment.
  final String? mimeType;

  /// The content of the attachment.
  final String? content;

  /// The URL of a thumbnail representing the attachment.
  final String? thumbnail;

  Attachment(
      {this.self,
      this.id,
      this.filename,
      this.author,
      this.created,
      this.size,
      this.mimeType,
      this.content,
      this.thumbnail});

  factory Attachment.fromJson(Map<String, Object?> json) {
    return Attachment(
      self: json[r'self'] as String?,
      id: json[r'id'] as String?,
      filename: json[r'filename'] as String?,
      author: json[r'author'] != null
          ? UserDetails.fromJson(json[r'author']! as Map<String, Object?>)
          : null,
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      size: (json[r'size'] as num?)?.toInt(),
      mimeType: json[r'mimeType'] as String?,
      content: json[r'content'] as String?,
      thumbnail: json[r'thumbnail'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var filename = this.filename;
    var author = this.author;
    var created = this.created;
    var size = this.size;
    var mimeType = this.mimeType;
    var content = this.content;
    var thumbnail = this.thumbnail;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (filename != null) {
      json[r'filename'] = filename;
    }
    if (author != null) {
      json[r'author'] = author.toJson();
    }
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    if (size != null) {
      json[r'size'] = size;
    }
    if (mimeType != null) {
      json[r'mimeType'] = mimeType;
    }
    if (content != null) {
      json[r'content'] = content;
    }
    if (thumbnail != null) {
      json[r'thumbnail'] = thumbnail;
    }
    return json;
  }

  Attachment copyWith(
      {String? self,
      String? id,
      String? filename,
      UserDetails? author,
      DateTime? created,
      int? size,
      String? mimeType,
      String? content,
      String? thumbnail}) {
    return Attachment(
      self: self ?? this.self,
      id: id ?? this.id,
      filename: filename ?? this.filename,
      author: author ?? this.author,
      created: created ?? this.created,
      size: size ?? this.size,
      mimeType: mimeType ?? this.mimeType,
      content: content ?? this.content,
      thumbnail: thumbnail ?? this.thumbnail,
    );
  }
}

class Group {
  /// The name of group.
  final String? name;

  /// The URL for these group details.
  final String? self;

  /// A paginated list of the users that are members of the group. A maximum of
  /// 50 users is returned in the list, to access additional users append
  /// `[start-index:end-index]` to the expand request. For example, to access
  /// the next 50 users, use`?expand=users[51:100]`.
  final PagedListUserDetailsApplicationUser? users;

  /// Expand options that include additional group details in the response.
  final String? expand;

  Group({this.name, this.self, this.users, this.expand});

  factory Group.fromJson(Map<String, Object?> json) {
    return Group(
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
      users: json[r'users'] != null
          ? PagedListUserDetailsApplicationUser.fromJson(
              json[r'users']! as Map<String, Object?>)
          : null,
      expand: json[r'expand'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var self = this.self;
    var users = this.users;
    var expand = this.expand;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (users != null) {
      json[r'users'] = users.toJson();
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    return json;
  }

  Group copyWith(
      {String? name,
      String? self,
      PagedListUserDetailsApplicationUser? users,
      String? expand}) {
    return Group(
      name: name ?? this.name,
      self: self ?? this.self,
      users: users ?? this.users,
      expand: expand ?? this.expand,
    );
  }
}

/// A paged list. To access additional details append `[start-index:end-index]`
/// to the expand request. For example, `?expand=sharedUsers[10:40]` returns a
/// list starting at item 10 and finishing at item 40.
class PagedListUserDetailsApplicationUser {
  /// The number of items on the page.
  final int? size;

  /// The list of items.
  final List<UserDetails> items;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The index of the first item returned on the page.
  final int? startIndex;

  /// The index of the last item returned on the page.
  final int? endIndex;

  PagedListUserDetailsApplicationUser(
      {this.size,
      List<UserDetails>? items,
      this.maxResults,
      this.startIndex,
      this.endIndex})
      : items = items ?? [];

  factory PagedListUserDetailsApplicationUser.fromJson(
      Map<String, Object?> json) {
    return PagedListUserDetailsApplicationUser(
      size: (json[r'size'] as num?)?.toInt(),
      items: (json[r'items'] as List<Object?>?)
              ?.map((i) =>
                  UserDetails.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'max-results'] as num?)?.toInt(),
      startIndex: (json[r'start-index'] as num?)?.toInt(),
      endIndex: (json[r'end-index'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var size = this.size;
    var items = this.items;
    var maxResults = this.maxResults;
    var startIndex = this.startIndex;
    var endIndex = this.endIndex;

    final json = <String, Object?>{};
    if (size != null) {
      json[r'size'] = size;
    }
    json[r'items'] = items.map((i) => i.toJson()).toList();
    if (maxResults != null) {
      json[r'max-results'] = maxResults;
    }
    if (startIndex != null) {
      json[r'start-index'] = startIndex;
    }
    if (endIndex != null) {
      json[r'end-index'] = endIndex;
    }
    return json;
  }

  PagedListUserDetailsApplicationUser copyWith(
      {int? size,
      List<UserDetails>? items,
      int? maxResults,
      int? startIndex,
      int? endIndex}) {
    return PagedListUserDetailsApplicationUser(
      size: size ?? this.size,
      items: items ?? this.items,
      maxResults: maxResults ?? this.maxResults,
      startIndex: startIndex ?? this.startIndex,
      endIndex: endIndex ?? this.endIndex,
    );
  }
}

/// A page of items.
class PageBeanUserDetails {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<UserDetails> values;

  PageBeanUserDetails(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<UserDetails>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanUserDetails.fromJson(Map<String, Object?> json) {
    return PageBeanUserDetails(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  UserDetails.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanUserDetails copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<UserDetails>? values}) {
    return PageBeanUserDetails(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

class AddGroupBean {
  /// The name of the group.
  final String name;

  AddGroupBean({required this.name});

  factory AddGroupBean.fromJson(Map<String, Object?> json) {
    return AddGroupBean(
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;

    final json = <String, Object?>{};
    json[r'name'] = name;
    return json;
  }

  AddGroupBean copyWith({String? name}) {
    return AddGroupBean(
      name: name ?? this.name,
    );
  }
}

class UpdateUserToGroupBean {
  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? name;

  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
  final String? accountId;

  UpdateUserToGroupBean({this.name, this.accountId});

  factory UpdateUserToGroupBean.fromJson(Map<String, Object?> json) {
    return UpdateUserToGroupBean(
      name: json[r'name'] as String?,
      accountId: json[r'accountId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var accountId = this.accountId;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    return json;
  }

  UpdateUserToGroupBean copyWith({String? name, String? accountId}) {
    return UpdateUserToGroupBean(
      name: name ?? this.name,
      accountId: accountId ?? this.accountId,
    );
  }
}

/// A group found in a search.
class FoundGroup {
  /// The name of the group.
  final String? name;

  /// The group name with the matched query string highlighted with the HTML
  /// bold tag.
  final String? html;
  final List<GroupLabel> labels;

  /// The ID of the group, if available, which uniquely identifies the group
  /// across all Atlassian products. For example,
  /// *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.
  final String? groupId;

  FoundGroup({this.name, this.html, List<GroupLabel>? labels, this.groupId})
      : labels = labels ?? [];

  factory FoundGroup.fromJson(Map<String, Object?> json) {
    return FoundGroup(
      name: json[r'name'] as String?,
      html: json[r'html'] as String?,
      labels: (json[r'labels'] as List<Object?>?)
              ?.map((i) =>
                  GroupLabel.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      groupId: json[r'groupId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var html = this.html;
    var labels = this.labels;
    var groupId = this.groupId;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (html != null) {
      json[r'html'] = html;
    }
    json[r'labels'] = labels.map((i) => i.toJson()).toList();
    if (groupId != null) {
      json[r'groupId'] = groupId;
    }
    return json;
  }

  FoundGroup copyWith(
      {String? name, String? html, List<GroupLabel>? labels, String? groupId}) {
    return FoundGroup(
      name: name ?? this.name,
      html: html ?? this.html,
      labels: labels ?? this.labels,
      groupId: groupId ?? this.groupId,
    );
  }
}

/// The list of groups found in a search, including header text (Showing X of Y
/// matching groups) and total of matched groups.
class FoundGroups {
  /// Header text indicating the number of groups in the response and the total
  /// number of groups found in the search.
  final String? header;

  /// The total number of groups found in the search.
  final int? total;
  final List<FoundGroup> groups;

  FoundGroups({this.header, this.total, List<FoundGroup>? groups})
      : groups = groups ?? [];

  factory FoundGroups.fromJson(Map<String, Object?> json) {
    return FoundGroups(
      header: json[r'header'] as String?,
      total: (json[r'total'] as num?)?.toInt(),
      groups: (json[r'groups'] as List<Object?>?)
              ?.map((i) =>
                  FoundGroup.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var header = this.header;
    var total = this.total;
    var groups = this.groups;

    final json = <String, Object?>{};
    if (header != null) {
      json[r'header'] = header;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'groups'] = groups.map((i) => i.toJson()).toList();
    return json;
  }

  FoundGroups copyWith({String? header, int? total, List<FoundGroup>? groups}) {
    return FoundGroups(
      header: header ?? this.header,
      total: total ?? this.total,
      groups: groups ?? this.groups,
    );
  }
}

/// A group label.
class GroupLabel {
  /// The group label name.
  final String? text;

  /// The title of the group label.
  final String? title;

  /// The type of the group label.
  final GroupLabelType? type;

  GroupLabel({this.text, this.title, this.type});

  factory GroupLabel.fromJson(Map<String, Object?> json) {
    return GroupLabel(
      text: json[r'text'] as String?,
      title: json[r'title'] as String?,
      type: json[r'type'] != null
          ? GroupLabelType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var text = this.text;
    var title = this.title;
    var type = this.type;

    final json = <String, Object?>{};
    if (text != null) {
      json[r'text'] = text;
    }
    if (title != null) {
      json[r'title'] = title;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  GroupLabel copyWith({String? text, String? title, GroupLabelType? type}) {
    return GroupLabel(
      text: text ?? this.text,
      title: title ?? this.title,
      type: type ?? this.type,
    );
  }
}

class GroupLabelType {
  static const admin = GroupLabelType._('ADMIN');
  static const single = GroupLabelType._('SINGLE');
  static const multiple = GroupLabelType._('MULTIPLE');

  static const values = [
    admin,
    single,
    multiple,
  ];
  final String value;

  const GroupLabelType._(this.value);

  static GroupLabelType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => GroupLabelType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// List of users and groups found in a search.
class FoundUsersAndGroups {
  final FoundUsers? users;
  final FoundGroups? groups;

  FoundUsersAndGroups({this.users, this.groups});

  factory FoundUsersAndGroups.fromJson(Map<String, Object?> json) {
    return FoundUsersAndGroups(
      users: json[r'users'] != null
          ? FoundUsers.fromJson(json[r'users']! as Map<String, Object?>)
          : null,
      groups: json[r'groups'] != null
          ? FoundGroups.fromJson(json[r'groups']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var users = this.users;
    var groups = this.groups;

    final json = <String, Object?>{};
    if (users != null) {
      json[r'users'] = users.toJson();
    }
    if (groups != null) {
      json[r'groups'] = groups.toJson();
    }
    return json;
  }

  FoundUsersAndGroups copyWith({FoundUsers? users, FoundGroups? groups}) {
    return FoundUsersAndGroups(
      users: users ?? this.users,
      groups: groups ?? this.groups,
    );
  }
}

class CustomFieldDefinitionJsonBean {
  /// The name of the custom field, which is displayed in Jira. This is not the
  /// unique identifier.
  final String name;

  /// The description of the custom field, which is displayed in Jira.
  final String? description;

  /// The type of the custom field. For example,
  /// *com.atlassian.jira.plugin.system.customfieldtypes:grouppicker*.
  ///
  ///  *  `cascadingselect`: Allows multiple values to be selected using two
  /// select lists
  ///  *  `datepicker`: Stores a date using a picker control
  ///  *  `datetime`: Stores a date with a time component
  ///  *  `float`: Stores and validates a numeric (floating point) input
  ///  *  `grouppicker`: Stores a user group using a picker control
  ///  *  `importid`: A read-only field that stores the previous ID of the issue
  /// from the system that it was imported from
  ///  *  `labels`: Stores labels
  ///  *  `multicheckboxes`: Stores multiple values using checkboxes
  ///  *  `multigrouppicker`: Stores multiple user groups using a picker control
  ///  *  `multiselect`: Stores multiple values using a select list
  ///  *  `multiuserpicker`: Stores multiple users using a picker control
  ///  *  `multiversion`: Stores multiple versions from the versions available
  /// in a project using a picker control
  ///  *  `project`: Stores a project from a list of projects that the user is
  /// permitted to view
  ///  *  `radiobuttons`: Stores a value using radio buttons
  ///  *  `readonlyfield`: Stores a read-only text value, which can only be
  /// populated via the API
  ///  *  `select`: Stores a value from a configurable list of options
  ///  *  `textarea`: Stores a long text string using a multiline text area
  ///  *  `textfield`: Stores a text string using a single-line text box
  ///  *  `url`: Stores a URL
  ///  *  `userpicker`: Stores a user using a picker control
  ///  *  `version`: Stores a version using a picker control
  final CustomFieldDefinitionJsonBeanType type;

  /// The searcher defines the way the field is searched in Jira. For example,
  /// *com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher*.
  /// The search UI (basic search and JQL search) will display different
  /// operations and values for the field, based on the field searcher. You must
  /// specify a searcher that is valid for the field type, as listed below
  /// (abbreviated values shown):
  ///
  ///  *  `cascadingselect`: `cascadingselectsearcher`
  ///  *  `datepicker`: `daterange`
  ///  *  `datetime`: `datetimerange`
  ///  *  `float`: `exactnumber` or `numberrange`
  ///  *  `grouppicker`: `grouppickersearcher`
  ///  *  `importid`: `exactnumber` or `numberrange`
  ///  *  `labels`: `labelsearcher`
  ///  *  `multicheckboxes`: `multiselectsearcher`
  ///  *  `multigrouppicker`: `multiselectsearcher`
  ///  *  `multiselect`: `multiselectsearcher`
  ///  *  `multiuserpicker`: `userpickergroupsearcher`
  ///  *  `multiversion`: `versionsearcher`
  ///  *  `project`: `projectsearcher`
  ///  *  `radiobuttons`: `multiselectsearcher`
  ///  *  `readonlyfield`: `textsearcher`
  ///  *  `select`: `multiselectsearcher`
  ///  *  `textarea`: `textsearcher`
  ///  *  `textfield`: `textsearcher`
  ///  *  `url`: `exacttextsearcher`
  ///  *  `userpicker`: `userpickergroupsearcher`
  ///  *  `version`: `versionsearcher`
  final CustomFieldDefinitionJsonBeanSearcherKey? searcherKey;

  CustomFieldDefinitionJsonBean(
      {required this.name,
      this.description,
      required this.type,
      this.searcherKey});

  factory CustomFieldDefinitionJsonBean.fromJson(Map<String, Object?> json) {
    return CustomFieldDefinitionJsonBean(
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
      type: CustomFieldDefinitionJsonBeanType.fromValue(
          json[r'type'] as String? ?? ''),
      searcherKey: json[r'searcherKey'] != null
          ? CustomFieldDefinitionJsonBeanSearcherKey.fromValue(
              json[r'searcherKey']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;
    var type = this.type;
    var searcherKey = this.searcherKey;

    final json = <String, Object?>{};
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'type'] = type.value;
    if (searcherKey != null) {
      json[r'searcherKey'] = searcherKey.value;
    }
    return json;
  }

  CustomFieldDefinitionJsonBean copyWith(
      {String? name,
      String? description,
      CustomFieldDefinitionJsonBeanType? type,
      CustomFieldDefinitionJsonBeanSearcherKey? searcherKey}) {
    return CustomFieldDefinitionJsonBean(
      name: name ?? this.name,
      description: description ?? this.description,
      type: type ?? this.type,
      searcherKey: searcherKey ?? this.searcherKey,
    );
  }
}

class CustomFieldDefinitionJsonBeanType {
  static const comAtlassianJiraPluginSystemCustomfieldtypesCascadingselect =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:cascadingselect');
  static const comAtlassianJiraPluginSystemCustomfieldtypesDatepicker =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:datepicker');
  static const comAtlassianJiraPluginSystemCustomfieldtypesDatetime =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:datetime');
  static const comAtlassianJiraPluginSystemCustomfieldtypesFloat =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:float');
  static const comAtlassianJiraPluginSystemCustomfieldtypesGrouppicker =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:grouppicker');
  static const comAtlassianJiraPluginSystemCustomfieldtypesImportid =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:importid');
  static const comAtlassianJiraPluginSystemCustomfieldtypesLabels =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:labels');
  static const comAtlassianJiraPluginSystemCustomfieldtypesMulticheckboxes =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes');
  static const comAtlassianJiraPluginSystemCustomfieldtypesMultigrouppicker =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:multigrouppicker');
  static const comAtlassianJiraPluginSystemCustomfieldtypesMultiselect =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:multiselect');
  static const comAtlassianJiraPluginSystemCustomfieldtypesMultiuserpicker =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:multiuserpicker');
  static const comAtlassianJiraPluginSystemCustomfieldtypesMultiversion =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:multiversion');
  static const comAtlassianJiraPluginSystemCustomfieldtypesProject =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:project');
  static const comAtlassianJiraPluginSystemCustomfieldtypesRadiobuttons =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons');
  static const comAtlassianJiraPluginSystemCustomfieldtypesReadonlyfield =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:readonlyfield');
  static const comAtlassianJiraPluginSystemCustomfieldtypesSelect =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:select');
  static const comAtlassianJiraPluginSystemCustomfieldtypesTextarea =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:textarea');
  static const comAtlassianJiraPluginSystemCustomfieldtypesTextfield =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:textfield');
  static const comAtlassianJiraPluginSystemCustomfieldtypesUrl =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:url');
  static const comAtlassianJiraPluginSystemCustomfieldtypesUserpicker =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:userpicker');
  static const comAtlassianJiraPluginSystemCustomfieldtypesVersion =
      CustomFieldDefinitionJsonBeanType._(
          'com.atlassian.jira.plugin.system.customfieldtypes:version');

  static const values = [
    comAtlassianJiraPluginSystemCustomfieldtypesCascadingselect,
    comAtlassianJiraPluginSystemCustomfieldtypesDatepicker,
    comAtlassianJiraPluginSystemCustomfieldtypesDatetime,
    comAtlassianJiraPluginSystemCustomfieldtypesFloat,
    comAtlassianJiraPluginSystemCustomfieldtypesGrouppicker,
    comAtlassianJiraPluginSystemCustomfieldtypesImportid,
    comAtlassianJiraPluginSystemCustomfieldtypesLabels,
    comAtlassianJiraPluginSystemCustomfieldtypesMulticheckboxes,
    comAtlassianJiraPluginSystemCustomfieldtypesMultigrouppicker,
    comAtlassianJiraPluginSystemCustomfieldtypesMultiselect,
    comAtlassianJiraPluginSystemCustomfieldtypesMultiuserpicker,
    comAtlassianJiraPluginSystemCustomfieldtypesMultiversion,
    comAtlassianJiraPluginSystemCustomfieldtypesProject,
    comAtlassianJiraPluginSystemCustomfieldtypesRadiobuttons,
    comAtlassianJiraPluginSystemCustomfieldtypesReadonlyfield,
    comAtlassianJiraPluginSystemCustomfieldtypesSelect,
    comAtlassianJiraPluginSystemCustomfieldtypesTextarea,
    comAtlassianJiraPluginSystemCustomfieldtypesTextfield,
    comAtlassianJiraPluginSystemCustomfieldtypesUrl,
    comAtlassianJiraPluginSystemCustomfieldtypesUserpicker,
    comAtlassianJiraPluginSystemCustomfieldtypesVersion,
  ];
  final String value;

  const CustomFieldDefinitionJsonBeanType._(this.value);

  static CustomFieldDefinitionJsonBeanType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CustomFieldDefinitionJsonBeanType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class CustomFieldDefinitionJsonBeanSearcherKey {
  static const comAtlassianJiraPluginSystemCustomfieldtypesCascadingselectsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:cascadingselectsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesDaterange =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:daterange');
  static const comAtlassianJiraPluginSystemCustomfieldtypesDatetimerange =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:datetimerange');
  static const comAtlassianJiraPluginSystemCustomfieldtypesExactnumber =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:exactnumber');
  static const comAtlassianJiraPluginSystemCustomfieldtypesExacttextsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:exacttextsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesGrouppickersearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesLabelsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:labelsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesMultiselectsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesNumberrange =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:numberrange');
  static const comAtlassianJiraPluginSystemCustomfieldtypesProjectsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:projectsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesTextsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:textsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesUserpickergroupsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:userpickergroupsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesVersionsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:versionsearcher');

  static const values = [
    comAtlassianJiraPluginSystemCustomfieldtypesCascadingselectsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesDaterange,
    comAtlassianJiraPluginSystemCustomfieldtypesDatetimerange,
    comAtlassianJiraPluginSystemCustomfieldtypesExactnumber,
    comAtlassianJiraPluginSystemCustomfieldtypesExacttextsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesGrouppickersearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesLabelsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesMultiselectsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesNumberrange,
    comAtlassianJiraPluginSystemCustomfieldtypesProjectsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesTextsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesUserpickergroupsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesVersionsearcher,
  ];
  final String value;

  const CustomFieldDefinitionJsonBeanSearcherKey._(this.value);

  static CustomFieldDefinitionJsonBeanSearcherKey fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CustomFieldDefinitionJsonBeanSearcherKey._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of a custom field.
class UpdateCustomFieldDetails {
  /// The name of the custom field. It doesn't have to be unique. The maximum
  /// length is 255 characters.
  final String? name;

  /// The description of the custom field. The maximum length is 40000
  /// characters.
  final String? description;

  /// The searcher that defines the way the field is searched in Jira. It can be
  /// set to `null`, otherwise you must specify the valid searcher for the field
  /// type, as listed below (abbreviated values shown):
  ///
  ///  *  `cascadingselect`: `cascadingselectsearcher`
  ///  *  `datepicker`: `daterange`
  ///  *  `datetime`: `datetimerange`
  ///  *  `float`: `exactnumber` or `numberrange`
  ///  *  `grouppicker`: `grouppickersearcher`
  ///  *  `importid`: `exactnumber` or `numberrange`
  ///  *  `labels`: `labelsearcher`
  ///  *  `multicheckboxes`: `multiselectsearcher`
  ///  *  `multigrouppicker`: `multiselectsearcher`
  ///  *  `multiselect`: `multiselectsearcher`
  ///  *  `multiuserpicker`: `userpickergroupsearcher`
  ///  *  `multiversion`: `versionsearcher`
  ///  *  `project`: `projectsearcher`
  ///  *  `radiobuttons`: `multiselectsearcher`
  ///  *  `readonlyfield`: `textsearcher`
  ///  *  `select`: `multiselectsearcher`
  ///  *  `textarea`: `textsearcher`
  ///  *  `textfield`: `textsearcher`
  ///  *  `url`: `exacttextsearcher`
  ///  *  `userpicker`: `userpickergroupsearcher`
  ///  *  `version`: `versionsearcher`
  final UpdateCustomFieldDetailsSearcherKey? searcherKey;

  UpdateCustomFieldDetails({this.name, this.description, this.searcherKey});

  factory UpdateCustomFieldDetails.fromJson(Map<String, Object?> json) {
    return UpdateCustomFieldDetails(
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      searcherKey: json[r'searcherKey'] != null
          ? UpdateCustomFieldDetailsSearcherKey.fromValue(
              json[r'searcherKey']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;
    var searcherKey = this.searcherKey;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (searcherKey != null) {
      json[r'searcherKey'] = searcherKey.value;
    }
    return json;
  }

  UpdateCustomFieldDetails copyWith(
      {String? name,
      String? description,
      UpdateCustomFieldDetailsSearcherKey? searcherKey}) {
    return UpdateCustomFieldDetails(
      name: name ?? this.name,
      description: description ?? this.description,
      searcherKey: searcherKey ?? this.searcherKey,
    );
  }
}

class UpdateCustomFieldDetailsSearcherKey {
  static const comAtlassianJiraPluginSystemCustomfieldtypesCascadingselectsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:cascadingselectsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesDaterange =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:daterange');
  static const comAtlassianJiraPluginSystemCustomfieldtypesDatetimerange =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:datetimerange');
  static const comAtlassianJiraPluginSystemCustomfieldtypesExactnumber =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:exactnumber');
  static const comAtlassianJiraPluginSystemCustomfieldtypesExacttextsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:exacttextsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesGrouppickersearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesLabelsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:labelsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesMultiselectsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesNumberrange =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:numberrange');
  static const comAtlassianJiraPluginSystemCustomfieldtypesProjectsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:projectsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesTextsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:textsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesUserpickergroupsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:userpickergroupsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesVersionsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:versionsearcher');

  static const values = [
    comAtlassianJiraPluginSystemCustomfieldtypesCascadingselectsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesDaterange,
    comAtlassianJiraPluginSystemCustomfieldtypesDatetimerange,
    comAtlassianJiraPluginSystemCustomfieldtypesExactnumber,
    comAtlassianJiraPluginSystemCustomfieldtypesExacttextsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesGrouppickersearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesLabelsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesMultiselectsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesNumberrange,
    comAtlassianJiraPluginSystemCustomfieldtypesProjectsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesTextsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesUserpickergroupsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesVersionsearcher,
  ];
  final String value;

  const UpdateCustomFieldDetailsSearcherKey._(this.value);

  static UpdateCustomFieldDetailsSearcherKey fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UpdateCustomFieldDetailsSearcherKey._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A page of items.
class PageBeanScreenWithTab {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<ScreenWithTab> values;

  PageBeanScreenWithTab(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<ScreenWithTab>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanScreenWithTab.fromJson(Map<String, Object?> json) {
    return PageBeanScreenWithTab(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => ScreenWithTab.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanScreenWithTab copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<ScreenWithTab>? values}) {
    return PageBeanScreenWithTab(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// A screen with tab details.
class ScreenWithTab {
  /// The ID of the screen.
  final int? id;

  /// The name of the screen.
  final String? name;

  /// The description of the screen.
  final String? description;

  /// The scope of the screen.
  final Scope? scope;

  /// The tab for the screen
  final ScreenableTab? tab;

  ScreenWithTab({this.id, this.name, this.description, this.scope, this.tab});

  factory ScreenWithTab.fromJson(Map<String, Object?> json) {
    return ScreenWithTab(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      tab: json[r'tab'] != null
          ? ScreenableTab.fromJson(json[r'tab']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var scope = this.scope;
    var tab = this.tab;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (tab != null) {
      json[r'tab'] = tab.toJson();
    }
    return json;
  }

  ScreenWithTab copyWith(
      {int? id,
      String? name,
      String? description,
      Scope? scope,
      ScreenableTab? tab}) {
    return ScreenWithTab(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      scope: scope ?? this.scope,
      tab: tab ?? this.tab,
    );
  }
}

/// A context.
class Context {
  /// The ID of the context.
  final int? id;

  /// The name of the context.
  final String? name;

  /// The scope of the context.
  final Scope? scope;

  Context({this.id, this.name, this.scope});

  factory Context.fromJson(Map<String, Object?> json) {
    return Context(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var scope = this.scope;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    return json;
  }

  Context copyWith({int? id, String? name, Scope? scope}) {
    return Context(
      id: id ?? this.id,
      name: name ?? this.name,
      scope: scope ?? this.scope,
    );
  }
}

/// A page of items.
class PageBeanContext {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<Context> values;

  PageBeanContext(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<Context>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanContext.fromJson(Map<String, Object?> json) {
    return PageBeanContext(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Context.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanContext copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<Context>? values}) {
    return PageBeanContext(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Details of the custom field options for a context.
class CustomFieldContextOption {
  /// The ID of the custom field option.
  final String id;

  /// The value of the custom field option.
  final String value;

  /// For cascading options, the ID of the custom field option containing the
  /// cascading option.
  final String? optionId;

  /// Whether the option is disabled.
  final bool disabled;

  CustomFieldContextOption(
      {required this.id,
      required this.value,
      this.optionId,
      required this.disabled});

  factory CustomFieldContextOption.fromJson(Map<String, Object?> json) {
    return CustomFieldContextOption(
      id: json[r'id'] as String? ?? '',
      value: json[r'value'] as String? ?? '',
      optionId: json[r'optionId'] as String?,
      disabled: json[r'disabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var value = this.value;
    var optionId = this.optionId;
    var disabled = this.disabled;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'value'] = value;
    if (optionId != null) {
      json[r'optionId'] = optionId;
    }
    json[r'disabled'] = disabled;
    return json;
  }

  CustomFieldContextOption copyWith(
      {String? id, String? value, String? optionId, bool? disabled}) {
    return CustomFieldContextOption(
      id: id ?? this.id,
      value: value ?? this.value,
      optionId: optionId ?? this.optionId,
      disabled: disabled ?? this.disabled,
    );
  }
}

/// A page of items.
class PageBeanCustomFieldContextOption {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<CustomFieldContextOption> values;

  PageBeanCustomFieldContextOption(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<CustomFieldContextOption>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanCustomFieldContextOption.fromJson(Map<String, Object?> json) {
    return PageBeanCustomFieldContextOption(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => CustomFieldContextOption.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanCustomFieldContextOption copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<CustomFieldContextOption>? values}) {
    return PageBeanCustomFieldContextOption(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Details of the options to create for a custom field.
class BulkCustomFieldOptionCreateRequest {
  /// Details of options to create.
  final List<CustomFieldOptionCreate> options;

  BulkCustomFieldOptionCreateRequest({List<CustomFieldOptionCreate>? options})
      : options = options ?? [];

  factory BulkCustomFieldOptionCreateRequest.fromJson(
      Map<String, Object?> json) {
    return BulkCustomFieldOptionCreateRequest(
      options: (json[r'options'] as List<Object?>?)
              ?.map((i) => CustomFieldOptionCreate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var options = this.options;

    final json = <String, Object?>{};
    json[r'options'] = options.map((i) => i.toJson()).toList();
    return json;
  }

  BulkCustomFieldOptionCreateRequest copyWith(
      {List<CustomFieldOptionCreate>? options}) {
    return BulkCustomFieldOptionCreateRequest(
      options: options ?? this.options,
    );
  }
}

/// Details of a custom field option to create.
class CustomFieldOptionCreate {
  /// The value of the custom field option.
  final String value;

  /// For cascading options, the ID of the custom field object containing the
  /// cascading option.
  final String? optionId;

  /// Whether the option is disabled.
  final bool disabled;

  CustomFieldOptionCreate({required this.value, this.optionId, bool? disabled})
      : disabled = disabled ?? false;

  factory CustomFieldOptionCreate.fromJson(Map<String, Object?> json) {
    return CustomFieldOptionCreate(
      value: json[r'value'] as String? ?? '',
      optionId: json[r'optionId'] as String?,
      disabled: json[r'disabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;
    var optionId = this.optionId;
    var disabled = this.disabled;

    final json = <String, Object?>{};
    json[r'value'] = value;
    if (optionId != null) {
      json[r'optionId'] = optionId;
    }
    json[r'disabled'] = disabled;
    return json;
  }

  CustomFieldOptionCreate copyWith(
      {String? value, String? optionId, bool? disabled}) {
    return CustomFieldOptionCreate(
      value: value ?? this.value,
      optionId: optionId ?? this.optionId,
      disabled: disabled ?? this.disabled,
    );
  }
}

/// A list of custom field options for a context.
class CustomFieldCreatedContextOptionsList {
  /// The created custom field options.
  final List<CustomFieldContextOption> options;

  CustomFieldCreatedContextOptionsList(
      {List<CustomFieldContextOption>? options})
      : options = options ?? [];

  factory CustomFieldCreatedContextOptionsList.fromJson(
      Map<String, Object?> json) {
    return CustomFieldCreatedContextOptionsList(
      options: (json[r'options'] as List<Object?>?)
              ?.map((i) => CustomFieldContextOption.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var options = this.options;

    final json = <String, Object?>{};
    json[r'options'] = options.map((i) => i.toJson()).toList();
    return json;
  }

  CustomFieldCreatedContextOptionsList copyWith(
      {List<CustomFieldContextOption>? options}) {
    return CustomFieldCreatedContextOptionsList(
      options: options ?? this.options,
    );
  }
}

/// An ordered list of custom field option IDs and information on where to move
/// them.
class OrderOfCustomFieldOptions {
  /// A list of IDs of custom field options to move. The order of the custom
  /// field option IDs in the list is the order they are given after the move.
  /// The list must contain custom field options or cascading options, but not
  /// both.
  final List<String> customFieldOptionIds;

  /// The ID of the custom field option or cascading option to place the moved
  /// options after. Required if `position` isn't provided.
  final String? after;

  /// The position the custom field options should be moved to. Required if
  /// `after` isn't provided.
  final OrderOfCustomFieldOptionsPosition? position;

  OrderOfCustomFieldOptions(
      {required this.customFieldOptionIds, this.after, this.position});

  factory OrderOfCustomFieldOptions.fromJson(Map<String, Object?> json) {
    return OrderOfCustomFieldOptions(
      customFieldOptionIds: (json[r'customFieldOptionIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      after: json[r'after'] as String?,
      position: json[r'position'] != null
          ? OrderOfCustomFieldOptionsPosition.fromValue(
              json[r'position']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var customFieldOptionIds = this.customFieldOptionIds;
    var after = this.after;
    var position = this.position;

    final json = <String, Object?>{};
    json[r'customFieldOptionIds'] = customFieldOptionIds;
    if (after != null) {
      json[r'after'] = after;
    }
    if (position != null) {
      json[r'position'] = position.value;
    }
    return json;
  }

  OrderOfCustomFieldOptions copyWith(
      {List<String>? customFieldOptionIds,
      String? after,
      OrderOfCustomFieldOptionsPosition? position}) {
    return OrderOfCustomFieldOptions(
      customFieldOptionIds: customFieldOptionIds ?? this.customFieldOptionIds,
      after: after ?? this.after,
      position: position ?? this.position,
    );
  }
}

class OrderOfCustomFieldOptionsPosition {
  static const first = OrderOfCustomFieldOptionsPosition._('First');
  static const last = OrderOfCustomFieldOptionsPosition._('Last');

  static const values = [
    first,
    last,
  ];
  final String value;

  const OrderOfCustomFieldOptionsPosition._(this.value);

  static OrderOfCustomFieldOptionsPosition fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => OrderOfCustomFieldOptionsPosition._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of the options to update for a custom field.
class BulkCustomFieldOptionUpdateRequest {
  /// Details of the options to update.
  final List<CustomFieldOptionUpdate> options;

  BulkCustomFieldOptionUpdateRequest({List<CustomFieldOptionUpdate>? options})
      : options = options ?? [];

  factory BulkCustomFieldOptionUpdateRequest.fromJson(
      Map<String, Object?> json) {
    return BulkCustomFieldOptionUpdateRequest(
      options: (json[r'options'] as List<Object?>?)
              ?.map((i) => CustomFieldOptionUpdate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var options = this.options;

    final json = <String, Object?>{};
    json[r'options'] = options.map((i) => i.toJson()).toList();
    return json;
  }

  BulkCustomFieldOptionUpdateRequest copyWith(
      {List<CustomFieldOptionUpdate>? options}) {
    return BulkCustomFieldOptionUpdateRequest(
      options: options ?? this.options,
    );
  }
}

/// Details of a custom field option for a context.
class CustomFieldOptionUpdate {
  /// The ID of the custom field option.
  final String id;

  /// The value of the custom field option.
  final String? value;

  /// Whether the option is disabled.
  final bool disabled;

  CustomFieldOptionUpdate({required this.id, this.value, bool? disabled})
      : disabled = disabled ?? false;

  factory CustomFieldOptionUpdate.fromJson(Map<String, Object?> json) {
    return CustomFieldOptionUpdate(
      id: json[r'id'] as String? ?? '',
      value: json[r'value'] as String?,
      disabled: json[r'disabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var value = this.value;
    var disabled = this.disabled;

    final json = <String, Object?>{};
    json[r'id'] = id;
    if (value != null) {
      json[r'value'] = value;
    }
    json[r'disabled'] = disabled;
    return json;
  }

  CustomFieldOptionUpdate copyWith(
      {String? id, String? value, bool? disabled}) {
    return CustomFieldOptionUpdate(
      id: id ?? this.id,
      value: value ?? this.value,
      disabled: disabled ?? this.disabled,
    );
  }
}

/// A list of custom field options for a context.
class CustomFieldUpdatedContextOptionsList {
  /// The updated custom field options.
  final List<CustomFieldOptionUpdate> options;

  CustomFieldUpdatedContextOptionsList({List<CustomFieldOptionUpdate>? options})
      : options = options ?? [];

  factory CustomFieldUpdatedContextOptionsList.fromJson(
      Map<String, Object?> json) {
    return CustomFieldUpdatedContextOptionsList(
      options: (json[r'options'] as List<Object?>?)
              ?.map((i) => CustomFieldOptionUpdate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var options = this.options;

    final json = <String, Object?>{};
    json[r'options'] = options.map((i) => i.toJson()).toList();
    return json;
  }

  CustomFieldUpdatedContextOptionsList copyWith(
      {List<CustomFieldOptionUpdate>? options}) {
    return CustomFieldUpdatedContextOptionsList(
      options: options ?? this.options,
    );
  }
}

/// Count of issues assigned to a component.
class ComponentIssuesCount {
  /// The URL for this count of issues for a component.
  final String? self;

  /// The count of issues assigned to a component.
  final int? issueCount;

  ComponentIssuesCount({this.self, this.issueCount});

  factory ComponentIssuesCount.fromJson(Map<String, Object?> json) {
    return ComponentIssuesCount(
      self: json[r'self'] as String?,
      issueCount: (json[r'issueCount'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var issueCount = this.issueCount;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (issueCount != null) {
      json[r'issueCount'] = issueCount;
    }
    return json;
  }

  ComponentIssuesCount copyWith({String? self, int? issueCount}) {
    return ComponentIssuesCount(
      self: self ?? this.self,
      issueCount: issueCount ?? this.issueCount,
    );
  }
}

/// Details of options to create for a custom field.
class BulkCreateCustomFieldOptionRequest {
  /// Details of options to create.
  final List<CustomFieldOptionValue> options;

  BulkCreateCustomFieldOptionRequest({List<CustomFieldOptionValue>? options})
      : options = options ?? [];

  factory BulkCreateCustomFieldOptionRequest.fromJson(
      Map<String, Object?> json) {
    return BulkCreateCustomFieldOptionRequest(
      options: (json[r'options'] as List<Object?>?)
              ?.map((i) => CustomFieldOptionValue.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var options = this.options;

    final json = <String, Object?>{};
    json[r'options'] = options.map((i) => i.toJson()).toList();
    return json;
  }

  BulkCreateCustomFieldOptionRequest copyWith(
      {List<CustomFieldOptionValue>? options}) {
    return BulkCreateCustomFieldOptionRequest(
      options: options ?? this.options,
    );
  }
}

/// Value of a custom field option and the values of its cascading options.
class CustomFieldOptionValue {
  /// The value of the custom field option.
  final String value;

  /// The cascading options.
  final List<String> cascadingOptions;

  CustomFieldOptionValue({required this.value, List<String>? cascadingOptions})
      : cascadingOptions = cascadingOptions ?? [];

  factory CustomFieldOptionValue.fromJson(Map<String, Object?> json) {
    return CustomFieldOptionValue(
      value: json[r'value'] as String? ?? '',
      cascadingOptions: (json[r'cascadingOptions'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;
    var cascadingOptions = this.cascadingOptions;

    final json = <String, Object?>{};
    json[r'value'] = value;
    json[r'cascadingOptions'] = cascadingOptions;
    return json;
  }

  CustomFieldOptionValue copyWith(
      {String? value, List<String>? cascadingOptions}) {
    return CustomFieldOptionValue(
      value: value ?? this.value,
      cascadingOptions: cascadingOptions ?? this.cascadingOptions,
    );
  }
}

/// Details of a custom field cascading option to rename.
class RenamedCascadingOption {
  /// The value of the cascading option.
  final String value;

  /// The new value of the cascading option.
  final String newValue;

  RenamedCascadingOption({required this.value, required this.newValue});

  factory RenamedCascadingOption.fromJson(Map<String, Object?> json) {
    return RenamedCascadingOption(
      value: json[r'value'] as String? ?? '',
      newValue: json[r'newValue'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;
    var newValue = this.newValue;

    final json = <String, Object?>{};
    json[r'value'] = value;
    json[r'newValue'] = newValue;
    return json;
  }

  RenamedCascadingOption copyWith({String? value, String? newValue}) {
    return RenamedCascadingOption(
      value: value ?? this.value,
      newValue: newValue ?? this.newValue,
    );
  }
}

/// Details of a custom field option to rename.
class RenamedOption {
  /// The current option value.
  final String value;

  /// The new value of the option.
  final String newValue;

  /// The new values for the cascading options of this option. Only used for
  /// Select List (cascading) fields.
  final List<RenamedCascadingOption> cascadingOptions;

  RenamedOption(
      {required this.value,
      required this.newValue,
      List<RenamedCascadingOption>? cascadingOptions})
      : cascadingOptions = cascadingOptions ?? [];

  factory RenamedOption.fromJson(Map<String, Object?> json) {
    return RenamedOption(
      value: json[r'value'] as String? ?? '',
      newValue: json[r'newValue'] as String? ?? '',
      cascadingOptions: (json[r'cascadingOptions'] as List<Object?>?)
              ?.map((i) => RenamedCascadingOption.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;
    var newValue = this.newValue;
    var cascadingOptions = this.cascadingOptions;

    final json = <String, Object?>{};
    json[r'value'] = value;
    json[r'newValue'] = newValue;
    json[r'cascadingOptions'] =
        cascadingOptions.map((i) => i.toJson()).toList();
    return json;
  }

  RenamedOption copyWith(
      {String? value,
      String? newValue,
      List<RenamedCascadingOption>? cascadingOptions}) {
    return RenamedOption(
      value: value ?? this.value,
      newValue: newValue ?? this.newValue,
      cascadingOptions: cascadingOptions ?? this.cascadingOptions,
    );
  }
}

/// Details of the options to update for a custom field.
class UpdateCustomFieldOption {
  /// Details of the options to update.
  final List<RenamedOption> options;

  UpdateCustomFieldOption({List<RenamedOption>? options})
      : options = options ?? [];

  factory UpdateCustomFieldOption.fromJson(Map<String, Object?> json) {
    return UpdateCustomFieldOption(
      options: (json[r'options'] as List<Object?>?)
              ?.map((i) => RenamedOption.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var options = this.options;

    final json = <String, Object?>{};
    json[r'options'] = options.map((i) => i.toJson()).toList();
    return json;
  }

  UpdateCustomFieldOption copyWith({List<RenamedOption>? options}) {
    return UpdateCustomFieldOption(
      options: options ?? this.options,
    );
  }
}

/// Details of a custom field option and its cascading options.
class CustomFieldOptionDetails {
  /// The ID of the custom field option.
  final int? id;

  /// The value of the custom field option.
  final String? value;

  /// The cascading options.
  final List<String> cascadingOptions;

  CustomFieldOptionDetails(
      {this.id, this.value, List<String>? cascadingOptions})
      : cascadingOptions = cascadingOptions ?? [];

  factory CustomFieldOptionDetails.fromJson(Map<String, Object?> json) {
    return CustomFieldOptionDetails(
      id: (json[r'id'] as num?)?.toInt(),
      value: json[r'value'] as String?,
      cascadingOptions: (json[r'cascadingOptions'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var value = this.value;
    var cascadingOptions = this.cascadingOptions;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    json[r'cascadingOptions'] = cascadingOptions;
    return json;
  }

  CustomFieldOptionDetails copyWith(
      {int? id, String? value, List<String>? cascadingOptions}) {
    return CustomFieldOptionDetails(
      id: id ?? this.id,
      value: value ?? this.value,
      cascadingOptions: cascadingOptions ?? this.cascadingOptions,
    );
  }
}

/// A page of items.
class PageBeanCustomFieldOptionDetails {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<CustomFieldOptionDetails> values;

  PageBeanCustomFieldOptionDetails(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<CustomFieldOptionDetails>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanCustomFieldOptionDetails.fromJson(Map<String, Object?> json) {
    return PageBeanCustomFieldOptionDetails(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => CustomFieldOptionDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanCustomFieldOptionDetails copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<CustomFieldOptionDetails>? values}) {
    return PageBeanCustomFieldOptionDetails(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// List of system avatars.
class SystemAvatars {
  /// A list of avatar details.
  final List<Avatar> system;

  SystemAvatars({List<Avatar>? system}) : system = system ?? [];

  factory SystemAvatars.fromJson(Map<String, Object?> json) {
    return SystemAvatars(
      system: (json[r'system'] as List<Object?>?)
              ?.map((i) =>
                  Avatar.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var system = this.system;

    final json = <String, Object?>{};
    json[r'system'] = system.map((i) => i.toJson()).toList();
    return json;
  }

  SystemAvatars copyWith({List<Avatar>? system}) {
    return SystemAvatars(
      system: system ?? this.system,
    );
  }
}

/// Details of an issue type scheme.
class IssueTypeScheme {
  /// The ID of the issue type scheme.
  final String id;

  /// The name of the issue type scheme.
  final String name;

  /// The description of the issue type scheme.
  final String? description;

  /// The ID of the default issue type of the issue type scheme.
  final String? defaultIssueTypeId;

  /// Whether the issue type scheme is the default.
  final bool isDefault;

  IssueTypeScheme(
      {required this.id,
      required this.name,
      this.description,
      this.defaultIssueTypeId,
      bool? isDefault})
      : isDefault = isDefault ?? false;

  factory IssueTypeScheme.fromJson(Map<String, Object?> json) {
    return IssueTypeScheme(
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
      defaultIssueTypeId: json[r'defaultIssueTypeId'] as String?,
      isDefault: json[r'isDefault'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var defaultIssueTypeId = this.defaultIssueTypeId;
    var isDefault = this.isDefault;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    if (defaultIssueTypeId != null) {
      json[r'defaultIssueTypeId'] = defaultIssueTypeId;
    }
    json[r'isDefault'] = isDefault;
    return json;
  }

  IssueTypeScheme copyWith(
      {String? id,
      String? name,
      String? description,
      String? defaultIssueTypeId,
      bool? isDefault}) {
    return IssueTypeScheme(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      defaultIssueTypeId: defaultIssueTypeId ?? this.defaultIssueTypeId,
      isDefault: isDefault ?? this.isDefault,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeScheme {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<IssueTypeScheme> values;

  PageBeanIssueTypeScheme(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<IssueTypeScheme>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeScheme.fromJson(Map<String, Object?> json) {
    return PageBeanIssueTypeScheme(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeScheme copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<IssueTypeScheme>? values}) {
    return PageBeanIssueTypeScheme(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Issue type scheme with a list of the projects that use it.
class IssueTypeSchemeProjects {
  /// Details of an issue type scheme.
  final IssueTypeScheme issueTypeScheme;

  /// The IDs of the projects using the issue type scheme.
  final List<String> projectIds;

  IssueTypeSchemeProjects(
      {required this.issueTypeScheme, required this.projectIds});

  factory IssueTypeSchemeProjects.fromJson(Map<String, Object?> json) {
    return IssueTypeSchemeProjects(
      issueTypeScheme: IssueTypeScheme.fromJson(
          json[r'issueTypeScheme'] as Map<String, Object?>? ?? const {}),
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeScheme = this.issueTypeScheme;
    var projectIds = this.projectIds;

    final json = <String, Object?>{};
    json[r'issueTypeScheme'] = issueTypeScheme.toJson();
    json[r'projectIds'] = projectIds;
    return json;
  }

  IssueTypeSchemeProjects copyWith(
      {IssueTypeScheme? issueTypeScheme, List<String>? projectIds}) {
    return IssueTypeSchemeProjects(
      issueTypeScheme: issueTypeScheme ?? this.issueTypeScheme,
      projectIds: projectIds ?? this.projectIds,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeSchemeProjects {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<IssueTypeSchemeProjects> values;

  PageBeanIssueTypeSchemeProjects(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<IssueTypeSchemeProjects>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeSchemeProjects.fromJson(Map<String, Object?> json) {
    return PageBeanIssueTypeSchemeProjects(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeSchemeProjects.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeSchemeProjects copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<IssueTypeSchemeProjects>? values}) {
    return PageBeanIssueTypeSchemeProjects(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Issue type scheme item.
class IssueTypeSchemeMapping {
  /// The ID of the issue type scheme.
  final String issueTypeSchemeId;

  /// The ID of the issue type.
  final String issueTypeId;

  IssueTypeSchemeMapping(
      {required this.issueTypeSchemeId, required this.issueTypeId});

  factory IssueTypeSchemeMapping.fromJson(Map<String, Object?> json) {
    return IssueTypeSchemeMapping(
      issueTypeSchemeId: json[r'issueTypeSchemeId'] as String? ?? '',
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeSchemeId = this.issueTypeSchemeId;
    var issueTypeId = this.issueTypeId;

    final json = <String, Object?>{};
    json[r'issueTypeSchemeId'] = issueTypeSchemeId;
    json[r'issueTypeId'] = issueTypeId;
    return json;
  }

  IssueTypeSchemeMapping copyWith(
      {String? issueTypeSchemeId, String? issueTypeId}) {
    return IssueTypeSchemeMapping(
      issueTypeSchemeId: issueTypeSchemeId ?? this.issueTypeSchemeId,
      issueTypeId: issueTypeId ?? this.issueTypeId,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeSchemeMapping {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<IssueTypeSchemeMapping> values;

  PageBeanIssueTypeSchemeMapping(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<IssueTypeSchemeMapping>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeSchemeMapping.fromJson(Map<String, Object?> json) {
    return PageBeanIssueTypeSchemeMapping(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeSchemeMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeSchemeMapping copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<IssueTypeSchemeMapping>? values}) {
    return PageBeanIssueTypeSchemeMapping(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Details of the association between an issue type scheme and project.
class IssueTypeSchemeProjectAssociation {
  /// The ID of the issue type scheme.
  final String issueTypeSchemeId;

  /// The ID of the project.
  final String projectId;

  IssueTypeSchemeProjectAssociation(
      {required this.issueTypeSchemeId, required this.projectId});

  factory IssueTypeSchemeProjectAssociation.fromJson(
      Map<String, Object?> json) {
    return IssueTypeSchemeProjectAssociation(
      issueTypeSchemeId: json[r'issueTypeSchemeId'] as String? ?? '',
      projectId: json[r'projectId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeSchemeId = this.issueTypeSchemeId;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    json[r'issueTypeSchemeId'] = issueTypeSchemeId;
    json[r'projectId'] = projectId;
    return json;
  }

  IssueTypeSchemeProjectAssociation copyWith(
      {String? issueTypeSchemeId, String? projectId}) {
    return IssueTypeSchemeProjectAssociation(
      issueTypeSchemeId: issueTypeSchemeId ?? this.issueTypeSchemeId,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// Details of an issue type scheme and its associated issue types.
class IssueTypeSchemeDetails {
  /// The name of the issue type scheme. The name must be unique. The maximum
  /// length is 255 characters.
  final String name;

  /// The description of the issue type scheme. The maximum length is 4000
  /// characters.
  final String? description;

  /// The ID of the default issue type of the issue type scheme. This ID must be
  /// included in `issueTypeIds`.
  final String? defaultIssueTypeId;

  /// The list of issue types IDs of the issue type scheme. At least one
  /// standard issue type ID is required.
  final List<String> issueTypeIds;

  IssueTypeSchemeDetails(
      {required this.name,
      this.description,
      this.defaultIssueTypeId,
      required this.issueTypeIds});

  factory IssueTypeSchemeDetails.fromJson(Map<String, Object?> json) {
    return IssueTypeSchemeDetails(
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
      defaultIssueTypeId: json[r'defaultIssueTypeId'] as String?,
      issueTypeIds: (json[r'issueTypeIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;
    var defaultIssueTypeId = this.defaultIssueTypeId;
    var issueTypeIds = this.issueTypeIds;

    final json = <String, Object?>{};
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    if (defaultIssueTypeId != null) {
      json[r'defaultIssueTypeId'] = defaultIssueTypeId;
    }
    json[r'issueTypeIds'] = issueTypeIds;
    return json;
  }

  IssueTypeSchemeDetails copyWith(
      {String? name,
      String? description,
      String? defaultIssueTypeId,
      List<String>? issueTypeIds}) {
    return IssueTypeSchemeDetails(
      name: name ?? this.name,
      description: description ?? this.description,
      defaultIssueTypeId: defaultIssueTypeId ?? this.defaultIssueTypeId,
      issueTypeIds: issueTypeIds ?? this.issueTypeIds,
    );
  }
}

/// The ID of an issue type scheme.
class IssueTypeSchemeID {
  /// The ID of the issue type scheme.
  final String issueTypeSchemeId;

  IssueTypeSchemeID({required this.issueTypeSchemeId});

  factory IssueTypeSchemeID.fromJson(Map<String, Object?> json) {
    return IssueTypeSchemeID(
      issueTypeSchemeId: json[r'issueTypeSchemeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeSchemeId = this.issueTypeSchemeId;

    final json = <String, Object?>{};
    json[r'issueTypeSchemeId'] = issueTypeSchemeId;
    return json;
  }

  IssueTypeSchemeID copyWith({String? issueTypeSchemeId}) {
    return IssueTypeSchemeID(
      issueTypeSchemeId: issueTypeSchemeId ?? this.issueTypeSchemeId,
    );
  }
}

/// The list of issue type IDs.
class IssueTypeIds {
  /// The list of issue type IDs.
  final List<String> issueTypeIds;

  IssueTypeIds({required this.issueTypeIds});

  factory IssueTypeIds.fromJson(Map<String, Object?> json) {
    return IssueTypeIds(
      issueTypeIds: (json[r'issueTypeIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeIds = this.issueTypeIds;

    final json = <String, Object?>{};
    json[r'issueTypeIds'] = issueTypeIds;
    return json;
  }

  IssueTypeIds copyWith({List<String>? issueTypeIds}) {
    return IssueTypeIds(
      issueTypeIds: issueTypeIds ?? this.issueTypeIds,
    );
  }
}

/// Details of the name, description, and default issue type for an issue type
/// scheme.
class IssueTypeSchemeUpdateDetails {
  /// The name of the issue type scheme. The name must be unique. The maximum
  /// length is 255 characters.
  final String? name;

  /// The description of the issue type scheme. The maximum length is 4000
  /// characters.
  final String? description;

  /// The ID of the default issue type of the issue type scheme.
  final String? defaultIssueTypeId;

  IssueTypeSchemeUpdateDetails(
      {this.name, this.description, this.defaultIssueTypeId});

  factory IssueTypeSchemeUpdateDetails.fromJson(Map<String, Object?> json) {
    return IssueTypeSchemeUpdateDetails(
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      defaultIssueTypeId: json[r'defaultIssueTypeId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;
    var defaultIssueTypeId = this.defaultIssueTypeId;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (defaultIssueTypeId != null) {
      json[r'defaultIssueTypeId'] = defaultIssueTypeId;
    }
    return json;
  }

  IssueTypeSchemeUpdateDetails copyWith(
      {String? name, String? description, String? defaultIssueTypeId}) {
    return IssueTypeSchemeUpdateDetails(
      name: name ?? this.name,
      description: description ?? this.description,
      defaultIssueTypeId: defaultIssueTypeId ?? this.defaultIssueTypeId,
    );
  }
}

/// An ordered list of issue type IDs and information about where to move them.
class OrderOfIssueTypes {
  /// A list of the issue type IDs to move. The order of the issue type IDs in
  /// the list is the order they are given after the move.
  final List<String> issueTypeIds;

  /// The ID of the issue type to place the moved issue types after. Required if
  /// `position` isn't provided.
  final String? after;

  /// The position the issue types should be moved to. Required if `after` isn't
  /// provided.
  final OrderOfIssueTypesPosition? position;

  OrderOfIssueTypes({required this.issueTypeIds, this.after, this.position});

  factory OrderOfIssueTypes.fromJson(Map<String, Object?> json) {
    return OrderOfIssueTypes(
      issueTypeIds: (json[r'issueTypeIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      after: json[r'after'] as String?,
      position: json[r'position'] != null
          ? OrderOfIssueTypesPosition.fromValue(json[r'position']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeIds = this.issueTypeIds;
    var after = this.after;
    var position = this.position;

    final json = <String, Object?>{};
    json[r'issueTypeIds'] = issueTypeIds;
    if (after != null) {
      json[r'after'] = after;
    }
    if (position != null) {
      json[r'position'] = position.value;
    }
    return json;
  }

  OrderOfIssueTypes copyWith(
      {List<String>? issueTypeIds,
      String? after,
      OrderOfIssueTypesPosition? position}) {
    return OrderOfIssueTypes(
      issueTypeIds: issueTypeIds ?? this.issueTypeIds,
      after: after ?? this.after,
      position: position ?? this.position,
    );
  }
}

class OrderOfIssueTypesPosition {
  static const first = OrderOfIssueTypesPosition._('First');
  static const last = OrderOfIssueTypesPosition._('Last');

  static const values = [
    first,
    last,
  ];
  final String value;

  const OrderOfIssueTypesPosition._(this.value);

  static OrderOfIssueTypesPosition fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => OrderOfIssueTypesPosition._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of a changed worklog.
class ChangedWorklog {
  /// The ID of the worklog.
  final int? worklogId;

  /// The datetime of the change.
  final int? updatedTime;

  /// Details of properties associated with the change.
  final List<EntityProperty> properties;

  ChangedWorklog(
      {this.worklogId, this.updatedTime, List<EntityProperty>? properties})
      : properties = properties ?? [];

  factory ChangedWorklog.fromJson(Map<String, Object?> json) {
    return ChangedWorklog(
      worklogId: (json[r'worklogId'] as num?)?.toInt(),
      updatedTime: (json[r'updatedTime'] as num?)?.toInt(),
      properties: (json[r'properties'] as List<Object?>?)
              ?.map((i) => EntityProperty.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var worklogId = this.worklogId;
    var updatedTime = this.updatedTime;
    var properties = this.properties;

    final json = <String, Object?>{};
    if (worklogId != null) {
      json[r'worklogId'] = worklogId;
    }
    if (updatedTime != null) {
      json[r'updatedTime'] = updatedTime;
    }
    json[r'properties'] = properties.map((i) => i.toJson()).toList();
    return json;
  }

  ChangedWorklog copyWith(
      {int? worklogId, int? updatedTime, List<EntityProperty>? properties}) {
    return ChangedWorklog(
      worklogId: worklogId ?? this.worklogId,
      updatedTime: updatedTime ?? this.updatedTime,
      properties: properties ?? this.properties,
    );
  }
}

/// List of changed worklogs.
class ChangedWorklogs {
  /// Changed worklog list.
  final List<ChangedWorklog> values;

  /// The datetime of the first worklog item in the list.
  final int? since;

  /// The datetime of the last worklog item in the list.
  final int? until;

  /// The URL of this changed worklogs list.
  final String? self;

  /// The URL of the next list of changed worklogs.
  final String? nextPage;
  final bool lastPage;

  ChangedWorklogs(
      {List<ChangedWorklog>? values,
      this.since,
      this.until,
      this.self,
      this.nextPage,
      bool? lastPage})
      : values = values ?? [],
        lastPage = lastPage ?? false;

  factory ChangedWorklogs.fromJson(Map<String, Object?> json) {
    return ChangedWorklogs(
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => ChangedWorklog.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      since: (json[r'since'] as num?)?.toInt(),
      until: (json[r'until'] as num?)?.toInt(),
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      lastPage: json[r'lastPage'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var values = this.values;
    var since = this.since;
    var until = this.until;
    var self = this.self;
    var nextPage = this.nextPage;
    var lastPage = this.lastPage;

    final json = <String, Object?>{};
    json[r'values'] = values.map((i) => i.toJson()).toList();
    if (since != null) {
      json[r'since'] = since;
    }
    if (until != null) {
      json[r'until'] = until;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    json[r'lastPage'] = lastPage;
    return json;
  }

  ChangedWorklogs copyWith(
      {List<ChangedWorklog>? values,
      int? since,
      int? until,
      String? self,
      String? nextPage,
      bool? lastPage}) {
    return ChangedWorklogs(
      values: values ?? this.values,
      since: since ?? this.since,
      until: until ?? this.until,
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      lastPage: lastPage ?? this.lastPage,
    );
  }
}

class WorklogIdsRequestBean {
  /// A list of worklog IDs.
  final List<int> ids;

  WorklogIdsRequestBean({required this.ids});

  factory WorklogIdsRequestBean.fromJson(Map<String, Object?> json) {
    return WorklogIdsRequestBean(
      ids: (json[r'ids'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var ids = this.ids;

    final json = <String, Object?>{};
    json[r'ids'] = ids;
    return json;
  }

  WorklogIdsRequestBean copyWith({List<int>? ids}) {
    return WorklogIdsRequestBean(
      ids: ids ?? this.ids,
    );
  }
}

/// Metadata for an issue attachment.
class AttachmentMetadata {
  /// The ID of the attachment.
  final int? id;

  /// The URL of the attachment metadata details.
  final String? self;

  /// The name of the attachment file.
  final String? filename;

  /// Details of the user who attached the file.
  final User? author;

  /// The datetime the attachment was created.
  final DateTime? created;

  /// The size of the attachment.
  final int? size;

  /// The MIME type of the attachment.
  final String? mimeType;

  /// Additional properties of the attachment.
  final Map<String, dynamic>? properties;

  /// The URL of the attachment.
  final String? content;

  /// The URL of a thumbnail representing the attachment.
  final String? thumbnail;

  AttachmentMetadata(
      {this.id,
      this.self,
      this.filename,
      this.author,
      this.created,
      this.size,
      this.mimeType,
      this.properties,
      this.content,
      this.thumbnail});

  factory AttachmentMetadata.fromJson(Map<String, Object?> json) {
    return AttachmentMetadata(
      id: (json[r'id'] as num?)?.toInt(),
      self: json[r'self'] as String?,
      filename: json[r'filename'] as String?,
      author: json[r'author'] != null
          ? User.fromJson(json[r'author']! as Map<String, Object?>)
          : null,
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      size: (json[r'size'] as num?)?.toInt(),
      mimeType: json[r'mimeType'] as String?,
      properties: json[r'properties'] as Map<String, Object?>?,
      content: json[r'content'] as String?,
      thumbnail: json[r'thumbnail'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var self = this.self;
    var filename = this.filename;
    var author = this.author;
    var created = this.created;
    var size = this.size;
    var mimeType = this.mimeType;
    var properties = this.properties;
    var content = this.content;
    var thumbnail = this.thumbnail;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (filename != null) {
      json[r'filename'] = filename;
    }
    if (author != null) {
      json[r'author'] = author.toJson();
    }
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    if (size != null) {
      json[r'size'] = size;
    }
    if (mimeType != null) {
      json[r'mimeType'] = mimeType;
    }
    if (properties != null) {
      json[r'properties'] = properties;
    }
    if (content != null) {
      json[r'content'] = content;
    }
    if (thumbnail != null) {
      json[r'thumbnail'] = thumbnail;
    }
    return json;
  }

  AttachmentMetadata copyWith(
      {int? id,
      String? self,
      String? filename,
      User? author,
      DateTime? created,
      int? size,
      String? mimeType,
      Map<String, dynamic>? properties,
      String? content,
      String? thumbnail}) {
    return AttachmentMetadata(
      id: id ?? this.id,
      self: self ?? this.self,
      filename: filename ?? this.filename,
      author: author ?? this.author,
      created: created ?? this.created,
      size: size ?? this.size,
      mimeType: mimeType ?? this.mimeType,
      properties: properties ?? this.properties,
      content: content ?? this.content,
      thumbnail: thumbnail ?? this.thumbnail,
    );
  }
}

/// Details of the instance's attachment settings.
class AttachmentSettings {
  /// Whether the ability to add attachments is enabled.
  final bool enabled;

  /// The maximum size of attachments permitted, in bytes.
  final int? uploadLimit;

  AttachmentSettings({bool? enabled, this.uploadLimit})
      : enabled = enabled ?? false;

  factory AttachmentSettings.fromJson(Map<String, Object?> json) {
    return AttachmentSettings(
      enabled: json[r'enabled'] as bool? ?? false,
      uploadLimit: (json[r'uploadLimit'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var enabled = this.enabled;
    var uploadLimit = this.uploadLimit;

    final json = <String, Object?>{};
    json[r'enabled'] = enabled;
    if (uploadLimit != null) {
      json[r'uploadLimit'] = uploadLimit;
    }
    return json;
  }

  AttachmentSettings copyWith({bool? enabled, int? uploadLimit}) {
    return AttachmentSettings(
      enabled: enabled ?? this.enabled,
      uploadLimit: uploadLimit ?? this.uploadLimit,
    );
  }
}

class AttachmentArchiveEntry {
  final String? abbreviatedName;
  final int? entryIndex;
  final String? mediaType;
  final String? name;
  final int? size;

  AttachmentArchiveEntry(
      {this.abbreviatedName,
      this.entryIndex,
      this.mediaType,
      this.name,
      this.size});

  factory AttachmentArchiveEntry.fromJson(Map<String, Object?> json) {
    return AttachmentArchiveEntry(
      abbreviatedName: json[r'abbreviatedName'] as String?,
      entryIndex: (json[r'entryIndex'] as num?)?.toInt(),
      mediaType: json[r'mediaType'] as String?,
      name: json[r'name'] as String?,
      size: (json[r'size'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var abbreviatedName = this.abbreviatedName;
    var entryIndex = this.entryIndex;
    var mediaType = this.mediaType;
    var name = this.name;
    var size = this.size;

    final json = <String, Object?>{};
    if (abbreviatedName != null) {
      json[r'abbreviatedName'] = abbreviatedName;
    }
    if (entryIndex != null) {
      json[r'entryIndex'] = entryIndex;
    }
    if (mediaType != null) {
      json[r'mediaType'] = mediaType;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (size != null) {
      json[r'size'] = size;
    }
    return json;
  }

  AttachmentArchiveEntry copyWith(
      {String? abbreviatedName,
      int? entryIndex,
      String? mediaType,
      String? name,
      int? size}) {
    return AttachmentArchiveEntry(
      abbreviatedName: abbreviatedName ?? this.abbreviatedName,
      entryIndex: entryIndex ?? this.entryIndex,
      mediaType: mediaType ?? this.mediaType,
      name: name ?? this.name,
      size: size ?? this.size,
    );
  }
}

class AttachmentArchiveImpl {
  /// The list of the items included in the archive.
  final List<AttachmentArchiveEntry> entries;

  /// The number of items in the archive.
  final int? totalEntryCount;

  AttachmentArchiveImpl(
      {List<AttachmentArchiveEntry>? entries, this.totalEntryCount})
      : entries = entries ?? [];

  factory AttachmentArchiveImpl.fromJson(Map<String, Object?> json) {
    return AttachmentArchiveImpl(
      entries: (json[r'entries'] as List<Object?>?)
              ?.map((i) => AttachmentArchiveEntry.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      totalEntryCount: (json[r'totalEntryCount'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var entries = this.entries;
    var totalEntryCount = this.totalEntryCount;

    final json = <String, Object?>{};
    json[r'entries'] = entries.map((i) => i.toJson()).toList();
    if (totalEntryCount != null) {
      json[r'totalEntryCount'] = totalEntryCount;
    }
    return json;
  }

  AttachmentArchiveImpl copyWith(
      {List<AttachmentArchiveEntry>? entries, int? totalEntryCount}) {
    return AttachmentArchiveImpl(
      entries: entries ?? this.entries,
      totalEntryCount: totalEntryCount ?? this.totalEntryCount,
    );
  }
}

class AttachmentArchive {
  final bool moreAvailable;
  final int? totalNumberOfEntriesAvailable;
  final int? totalEntryCount;
  final List<AttachmentArchiveEntry> entries;

  AttachmentArchive(
      {bool? moreAvailable,
      this.totalNumberOfEntriesAvailable,
      this.totalEntryCount,
      List<AttachmentArchiveEntry>? entries})
      : moreAvailable = moreAvailable ?? false,
        entries = entries ?? [];

  factory AttachmentArchive.fromJson(Map<String, Object?> json) {
    return AttachmentArchive(
      moreAvailable: json[r'moreAvailable'] as bool? ?? false,
      totalNumberOfEntriesAvailable:
          (json[r'totalNumberOfEntriesAvailable'] as num?)?.toInt(),
      totalEntryCount: (json[r'totalEntryCount'] as num?)?.toInt(),
      entries: (json[r'entries'] as List<Object?>?)
              ?.map((i) => AttachmentArchiveEntry.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var moreAvailable = this.moreAvailable;
    var totalNumberOfEntriesAvailable = this.totalNumberOfEntriesAvailable;
    var totalEntryCount = this.totalEntryCount;
    var entries = this.entries;

    final json = <String, Object?>{};
    json[r'moreAvailable'] = moreAvailable;
    if (totalNumberOfEntriesAvailable != null) {
      json[r'totalNumberOfEntriesAvailable'] = totalNumberOfEntriesAvailable;
    }
    if (totalEntryCount != null) {
      json[r'totalEntryCount'] = totalEntryCount;
    }
    json[r'entries'] = entries.map((i) => i.toJson()).toList();
    return json;
  }

  AttachmentArchive copyWith(
      {bool? moreAvailable,
      int? totalNumberOfEntriesAvailable,
      int? totalEntryCount,
      List<AttachmentArchiveEntry>? entries}) {
    return AttachmentArchive(
      moreAvailable: moreAvailable ?? this.moreAvailable,
      totalNumberOfEntriesAvailable:
          totalNumberOfEntriesAvailable ?? this.totalNumberOfEntriesAvailable,
      totalEntryCount: totalEntryCount ?? this.totalEntryCount,
      entries: entries ?? this.entries,
    );
  }
}

/// Metadata for an item in an attachment archive.
class AttachmentArchiveItemReadable {
  /// The path of the archive item.
  final String? path;

  /// The position of the item within the archive.
  final int? index;

  /// The size of the archive item.
  final String? size;

  /// The MIME type of the archive item.
  final String? mediaType;

  /// The label for the archive item.
  final String? label;

  AttachmentArchiveItemReadable(
      {this.path, this.index, this.size, this.mediaType, this.label});

  factory AttachmentArchiveItemReadable.fromJson(Map<String, Object?> json) {
    return AttachmentArchiveItemReadable(
      path: json[r'path'] as String?,
      index: (json[r'index'] as num?)?.toInt(),
      size: json[r'size'] as String?,
      mediaType: json[r'mediaType'] as String?,
      label: json[r'label'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var path = this.path;
    var index = this.index;
    var size = this.size;
    var mediaType = this.mediaType;
    var label = this.label;

    final json = <String, Object?>{};
    if (path != null) {
      json[r'path'] = path;
    }
    if (index != null) {
      json[r'index'] = index;
    }
    if (size != null) {
      json[r'size'] = size;
    }
    if (mediaType != null) {
      json[r'mediaType'] = mediaType;
    }
    if (label != null) {
      json[r'label'] = label;
    }
    return json;
  }

  AttachmentArchiveItemReadable copyWith(
      {String? path,
      int? index,
      String? size,
      String? mediaType,
      String? label}) {
    return AttachmentArchiveItemReadable(
      path: path ?? this.path,
      index: index ?? this.index,
      size: size ?? this.size,
      mediaType: mediaType ?? this.mediaType,
      label: label ?? this.label,
    );
  }
}

/// Metadata for an archive (for example a zip) and its contents.
class AttachmentArchiveMetadataReadable {
  /// The ID of the attachment.
  final int? id;

  /// The name of the archive file.
  final String? name;

  /// The list of the items included in the archive.
  final List<AttachmentArchiveItemReadable> entries;

  /// The number of items included in the archive.
  final int? totalEntryCount;

  /// The MIME type of the attachment.
  final String? mediaType;

  AttachmentArchiveMetadataReadable(
      {this.id,
      this.name,
      List<AttachmentArchiveItemReadable>? entries,
      this.totalEntryCount,
      this.mediaType})
      : entries = entries ?? [];

  factory AttachmentArchiveMetadataReadable.fromJson(
      Map<String, Object?> json) {
    return AttachmentArchiveMetadataReadable(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      entries: (json[r'entries'] as List<Object?>?)
              ?.map((i) => AttachmentArchiveItemReadable.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      totalEntryCount: (json[r'totalEntryCount'] as num?)?.toInt(),
      mediaType: json[r'mediaType'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var entries = this.entries;
    var totalEntryCount = this.totalEntryCount;
    var mediaType = this.mediaType;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'entries'] = entries.map((i) => i.toJson()).toList();
    if (totalEntryCount != null) {
      json[r'totalEntryCount'] = totalEntryCount;
    }
    if (mediaType != null) {
      json[r'mediaType'] = mediaType;
    }
    return json;
  }

  AttachmentArchiveMetadataReadable copyWith(
      {int? id,
      String? name,
      List<AttachmentArchiveItemReadable>? entries,
      int? totalEntryCount,
      String? mediaType}) {
    return AttachmentArchiveMetadataReadable(
      id: id ?? this.id,
      name: name ?? this.name,
      entries: entries ?? this.entries,
      totalEntryCount: totalEntryCount ?? this.totalEntryCount,
      mediaType: mediaType ?? this.mediaType,
    );
  }
}

/// The screen scheme for an issue type.
class IssueTypeScreenSchemeItem {
  /// The ID of the issue type screen scheme.
  final String issueTypeScreenSchemeId;

  /// The ID of the issue type or *default*. Only issue types used in classic
  /// projects are accepted. When creating an issue screen scheme, an entry for
  /// *default* must be provided and defines the mapping for all issue types
  /// without a screen scheme. Otherwise, a *default* entry can't be provided.
  final String issueTypeId;

  /// The ID of the screen scheme.
  final String screenSchemeId;

  IssueTypeScreenSchemeItem(
      {required this.issueTypeScreenSchemeId,
      required this.issueTypeId,
      required this.screenSchemeId});

  factory IssueTypeScreenSchemeItem.fromJson(Map<String, Object?> json) {
    return IssueTypeScreenSchemeItem(
      issueTypeScreenSchemeId:
          json[r'issueTypeScreenSchemeId'] as String? ?? '',
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
      screenSchemeId: json[r'screenSchemeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeScreenSchemeId = this.issueTypeScreenSchemeId;
    var issueTypeId = this.issueTypeId;
    var screenSchemeId = this.screenSchemeId;

    final json = <String, Object?>{};
    json[r'issueTypeScreenSchemeId'] = issueTypeScreenSchemeId;
    json[r'issueTypeId'] = issueTypeId;
    json[r'screenSchemeId'] = screenSchemeId;
    return json;
  }

  IssueTypeScreenSchemeItem copyWith(
      {String? issueTypeScreenSchemeId,
      String? issueTypeId,
      String? screenSchemeId}) {
    return IssueTypeScreenSchemeItem(
      issueTypeScreenSchemeId:
          issueTypeScreenSchemeId ?? this.issueTypeScreenSchemeId,
      issueTypeId: issueTypeId ?? this.issueTypeId,
      screenSchemeId: screenSchemeId ?? this.screenSchemeId,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeScreenSchemeItem {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<IssueTypeScreenSchemeItem> values;

  PageBeanIssueTypeScreenSchemeItem(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<IssueTypeScreenSchemeItem>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeScreenSchemeItem.fromJson(
      Map<String, Object?> json) {
    return PageBeanIssueTypeScreenSchemeItem(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeScreenSchemeItem.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeScreenSchemeItem copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<IssueTypeScreenSchemeItem>? values}) {
    return PageBeanIssueTypeScreenSchemeItem(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Details of an issue type screen scheme.
class IssueTypeScreenScheme {
  /// The ID of the issue type screen scheme.
  final String id;

  /// The name of the issue type screen scheme.
  final String name;

  /// The description of the issue type screen scheme.
  final String? description;

  IssueTypeScreenScheme(
      {required this.id, required this.name, this.description});

  factory IssueTypeScreenScheme.fromJson(Map<String, Object?> json) {
    return IssueTypeScreenScheme(
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var description = this.description;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    return json;
  }

  IssueTypeScreenScheme copyWith(
      {String? id, String? name, String? description}) {
    return IssueTypeScreenScheme(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
    );
  }
}

/// Issue type screen scheme with a list of the projects that use it.
class IssueTypeScreenSchemesProjects {
  /// Details of an issue type screen scheme.
  final IssueTypeScreenScheme issueTypeScreenScheme;

  /// The IDs of the projects using the issue type screen scheme.
  final List<String> projectIds;

  IssueTypeScreenSchemesProjects(
      {required this.issueTypeScreenScheme, required this.projectIds});

  factory IssueTypeScreenSchemesProjects.fromJson(Map<String, Object?> json) {
    return IssueTypeScreenSchemesProjects(
      issueTypeScreenScheme: IssueTypeScreenScheme.fromJson(
          json[r'issueTypeScreenScheme'] as Map<String, Object?>? ?? const {}),
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeScreenScheme = this.issueTypeScreenScheme;
    var projectIds = this.projectIds;

    final json = <String, Object?>{};
    json[r'issueTypeScreenScheme'] = issueTypeScreenScheme.toJson();
    json[r'projectIds'] = projectIds;
    return json;
  }

  IssueTypeScreenSchemesProjects copyWith(
      {IssueTypeScreenScheme? issueTypeScreenScheme,
      List<String>? projectIds}) {
    return IssueTypeScreenSchemesProjects(
      issueTypeScreenScheme:
          issueTypeScreenScheme ?? this.issueTypeScreenScheme,
      projectIds: projectIds ?? this.projectIds,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeScreenSchemesProjects {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<IssueTypeScreenSchemesProjects> values;

  PageBeanIssueTypeScreenSchemesProjects(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<IssueTypeScreenSchemesProjects>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeScreenSchemesProjects.fromJson(
      Map<String, Object?> json) {
    return PageBeanIssueTypeScreenSchemesProjects(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeScreenSchemesProjects.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeScreenSchemesProjects copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<IssueTypeScreenSchemesProjects>? values}) {
    return PageBeanIssueTypeScreenSchemesProjects(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeScreenScheme {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<IssueTypeScreenScheme> values;

  PageBeanIssueTypeScreenScheme(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<IssueTypeScreenScheme>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeScreenScheme.fromJson(Map<String, Object?> json) {
    return PageBeanIssueTypeScreenScheme(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeScreenScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeScreenScheme copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<IssueTypeScreenScheme>? values}) {
    return PageBeanIssueTypeScreenScheme(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Associated issue type screen scheme and project.
class IssueTypeScreenSchemeProjectAssociation {
  /// The ID of the issue type screen scheme.
  final String? issueTypeScreenSchemeId;

  /// The ID of the project.
  final String? projectId;

  IssueTypeScreenSchemeProjectAssociation(
      {this.issueTypeScreenSchemeId, this.projectId});

  factory IssueTypeScreenSchemeProjectAssociation.fromJson(
      Map<String, Object?> json) {
    return IssueTypeScreenSchemeProjectAssociation(
      issueTypeScreenSchemeId: json[r'issueTypeScreenSchemeId'] as String?,
      projectId: json[r'projectId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeScreenSchemeId = this.issueTypeScreenSchemeId;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    if (issueTypeScreenSchemeId != null) {
      json[r'issueTypeScreenSchemeId'] = issueTypeScreenSchemeId;
    }
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    return json;
  }

  IssueTypeScreenSchemeProjectAssociation copyWith(
      {String? issueTypeScreenSchemeId, String? projectId}) {
    return IssueTypeScreenSchemeProjectAssociation(
      issueTypeScreenSchemeId:
          issueTypeScreenSchemeId ?? this.issueTypeScreenSchemeId,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// The details of an issue type screen scheme.
class IssueTypeScreenSchemeDetails {
  /// The name of the issue type screen scheme. The name must be unique. The
  /// maximum length is 255 characters.
  final String name;

  /// The description of the issue type screen scheme. The maximum length is 255
  /// characters.
  final String? description;

  /// The IDs of the screen schemes for the issue type IDs and *default*. A
  /// *default* entry is required to create an issue type screen scheme, it
  /// defines the mapping for all issue types without a screen scheme.
  final List<IssueTypeScreenSchemeMapping> issueTypeMappings;

  IssueTypeScreenSchemeDetails(
      {required this.name, this.description, required this.issueTypeMappings});

  factory IssueTypeScreenSchemeDetails.fromJson(Map<String, Object?> json) {
    return IssueTypeScreenSchemeDetails(
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
      issueTypeMappings: (json[r'issueTypeMappings'] as List<Object?>?)
              ?.map((i) => IssueTypeScreenSchemeMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;
    var issueTypeMappings = this.issueTypeMappings;

    final json = <String, Object?>{};
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'issueTypeMappings'] =
        issueTypeMappings.map((i) => i.toJson()).toList();
    return json;
  }

  IssueTypeScreenSchemeDetails copyWith(
      {String? name,
      String? description,
      List<IssueTypeScreenSchemeMapping>? issueTypeMappings}) {
    return IssueTypeScreenSchemeDetails(
      name: name ?? this.name,
      description: description ?? this.description,
      issueTypeMappings: issueTypeMappings ?? this.issueTypeMappings,
    );
  }
}

/// The IDs of the screen schemes for the issue type IDs.
class IssueTypeScreenSchemeMapping {
  /// The ID of the issue type or *default*. Only issue types used in classic
  /// projects are accepted. An entry for *default* must be provided and defines
  /// the mapping for all issue types without a screen scheme.
  final String issueTypeId;

  /// The ID of the screen scheme. Only screen schemes used in classic projects
  /// are accepted.
  final String screenSchemeId;

  IssueTypeScreenSchemeMapping(
      {required this.issueTypeId, required this.screenSchemeId});

  factory IssueTypeScreenSchemeMapping.fromJson(Map<String, Object?> json) {
    return IssueTypeScreenSchemeMapping(
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
      screenSchemeId: json[r'screenSchemeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeId = this.issueTypeId;
    var screenSchemeId = this.screenSchemeId;

    final json = <String, Object?>{};
    json[r'issueTypeId'] = issueTypeId;
    json[r'screenSchemeId'] = screenSchemeId;
    return json;
  }

  IssueTypeScreenSchemeMapping copyWith(
      {String? issueTypeId, String? screenSchemeId}) {
    return IssueTypeScreenSchemeMapping(
      issueTypeId: issueTypeId ?? this.issueTypeId,
      screenSchemeId: screenSchemeId ?? this.screenSchemeId,
    );
  }
}

/// The ID of an issue type screen scheme.
class IssueTypeScreenSchemeId {
  /// The ID of the issue type screen scheme.
  final String id;

  IssueTypeScreenSchemeId({required this.id});

  factory IssueTypeScreenSchemeId.fromJson(Map<String, Object?> json) {
    return IssueTypeScreenSchemeId(
      id: json[r'id'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  IssueTypeScreenSchemeId copyWith({String? id}) {
    return IssueTypeScreenSchemeId(
      id: id ?? this.id,
    );
  }
}

/// Details of an issue type screen scheme.
class IssueTypeScreenSchemeUpdateDetails {
  /// The name of the issue type screen scheme. The name must be unique. The
  /// maximum length is 255 characters.
  final String? name;

  /// The description of the issue type screen scheme. The maximum length is 255
  /// characters.
  final String? description;

  IssueTypeScreenSchemeUpdateDetails({this.name, this.description});

  factory IssueTypeScreenSchemeUpdateDetails.fromJson(
      Map<String, Object?> json) {
    return IssueTypeScreenSchemeUpdateDetails(
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    return json;
  }

  IssueTypeScreenSchemeUpdateDetails copyWith(
      {String? name, String? description}) {
    return IssueTypeScreenSchemeUpdateDetails(
      name: name ?? this.name,
      description: description ?? this.description,
    );
  }
}

/// A list of issue type screen scheme mappings.
class IssueTypeScreenSchemeMappingDetails {
  /// The list of issue type to screen scheme mappings. A *default* entry cannot
  /// be specified because a default entry is added when an issue type screen
  /// scheme is created.
  final List<IssueTypeScreenSchemeMapping> issueTypeMappings;

  IssueTypeScreenSchemeMappingDetails({required this.issueTypeMappings});

  factory IssueTypeScreenSchemeMappingDetails.fromJson(
      Map<String, Object?> json) {
    return IssueTypeScreenSchemeMappingDetails(
      issueTypeMappings: (json[r'issueTypeMappings'] as List<Object?>?)
              ?.map((i) => IssueTypeScreenSchemeMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeMappings = this.issueTypeMappings;

    final json = <String, Object?>{};
    json[r'issueTypeMappings'] =
        issueTypeMappings.map((i) => i.toJson()).toList();
    return json;
  }

  IssueTypeScreenSchemeMappingDetails copyWith(
      {List<IssueTypeScreenSchemeMapping>? issueTypeMappings}) {
    return IssueTypeScreenSchemeMappingDetails(
      issueTypeMappings: issueTypeMappings ?? this.issueTypeMappings,
    );
  }
}

/// The ID of a screen scheme.
class UpdateDefaultScreenScheme {
  /// The ID of the screen scheme.
  final String screenSchemeId;

  UpdateDefaultScreenScheme({required this.screenSchemeId});

  factory UpdateDefaultScreenScheme.fromJson(Map<String, Object?> json) {
    return UpdateDefaultScreenScheme(
      screenSchemeId: json[r'screenSchemeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var screenSchemeId = this.screenSchemeId;

    final json = <String, Object?>{};
    json[r'screenSchemeId'] = screenSchemeId;
    return json;
  }

  UpdateDefaultScreenScheme copyWith({String? screenSchemeId}) {
    return UpdateDefaultScreenScheme(
      screenSchemeId: screenSchemeId ?? this.screenSchemeId,
    );
  }
}

/// Details of a custom option for a field.
class CustomFieldOption {
  /// The URL of these custom field option details.
  final String? self;

  /// The value of the custom field option.
  final String? value;

  CustomFieldOption({this.self, this.value});

  factory CustomFieldOption.fromJson(Map<String, Object?> json) {
    return CustomFieldOption(
      self: json[r'self'] as String?,
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var value = this.value;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  CustomFieldOption copyWith({String? self, String? value}) {
    return CustomFieldOption(
      self: self ?? this.self,
      value: value ?? this.value,
    );
  }
}

/// Details of context to project associations.
class CustomFieldContextProjectMapping {
  /// The ID of the context.
  final String contextId;

  /// The ID of the project.
  final String? projectId;

  /// Whether context is global.
  final bool isGlobalContext;

  CustomFieldContextProjectMapping(
      {required this.contextId, this.projectId, bool? isGlobalContext})
      : isGlobalContext = isGlobalContext ?? false;

  factory CustomFieldContextProjectMapping.fromJson(Map<String, Object?> json) {
    return CustomFieldContextProjectMapping(
      contextId: json[r'contextId'] as String? ?? '',
      projectId: json[r'projectId'] as String?,
      isGlobalContext: json[r'isGlobalContext'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var projectId = this.projectId;
    var isGlobalContext = this.isGlobalContext;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    json[r'isGlobalContext'] = isGlobalContext;
    return json;
  }

  CustomFieldContextProjectMapping copyWith(
      {String? contextId, String? projectId, bool? isGlobalContext}) {
    return CustomFieldContextProjectMapping(
      contextId: contextId ?? this.contextId,
      projectId: projectId ?? this.projectId,
      isGlobalContext: isGlobalContext ?? this.isGlobalContext,
    );
  }
}

/// A page of items.
class PageBeanCustomFieldContextProjectMapping {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<CustomFieldContextProjectMapping> values;

  PageBeanCustomFieldContextProjectMapping(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<CustomFieldContextProjectMapping>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanCustomFieldContextProjectMapping.fromJson(
      Map<String, Object?> json) {
    return PageBeanCustomFieldContextProjectMapping(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => CustomFieldContextProjectMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanCustomFieldContextProjectMapping copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<CustomFieldContextProjectMapping>? values}) {
    return PageBeanCustomFieldContextProjectMapping(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// The details of a custom field context.
class CustomFieldContext {
  /// The ID of the context.
  final String id;

  /// The name of the context.
  final String name;

  /// The description of the context.
  final String description;

  /// Whether the context is global.
  final bool isGlobalContext;

  /// Whether the context apply to all issue types.
  final bool isAnyIssueType;

  CustomFieldContext(
      {required this.id,
      required this.name,
      required this.description,
      required this.isGlobalContext,
      required this.isAnyIssueType});

  factory CustomFieldContext.fromJson(Map<String, Object?> json) {
    return CustomFieldContext(
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String? ?? '',
      isGlobalContext: json[r'isGlobalContext'] as bool? ?? false,
      isAnyIssueType: json[r'isAnyIssueType'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var isGlobalContext = this.isGlobalContext;
    var isAnyIssueType = this.isAnyIssueType;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    json[r'description'] = description;
    json[r'isGlobalContext'] = isGlobalContext;
    json[r'isAnyIssueType'] = isAnyIssueType;
    return json;
  }

  CustomFieldContext copyWith(
      {String? id,
      String? name,
      String? description,
      bool? isGlobalContext,
      bool? isAnyIssueType}) {
    return CustomFieldContext(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      isGlobalContext: isGlobalContext ?? this.isGlobalContext,
      isAnyIssueType: isAnyIssueType ?? this.isAnyIssueType,
    );
  }
}

/// A page of items.
class PageBeanCustomFieldContext {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<CustomFieldContext> values;

  PageBeanCustomFieldContext(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<CustomFieldContext>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanCustomFieldContext.fromJson(Map<String, Object?> json) {
    return PageBeanCustomFieldContext(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => CustomFieldContext.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanCustomFieldContext copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<CustomFieldContext>? values}) {
    return PageBeanCustomFieldContext(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

class CustomFieldContextDefaultValue {
  CustomFieldContextDefaultValue();

  factory CustomFieldContextDefaultValue.fromJson(Map<String, Object?> json) {
    return CustomFieldContextDefaultValue();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// Default value for a cascading select custom field.
class CustomFieldContextDefaultValueCascadingOption {
  /// The ID of the context.
  final String contextId;

  /// The ID of the default option.
  final String optionId;

  /// The ID of the default cascading option.
  final String? cascadingOptionId;
  final String type;

  CustomFieldContextDefaultValueCascadingOption(
      {required this.contextId,
      required this.optionId,
      this.cascadingOptionId,
      required this.type});

  factory CustomFieldContextDefaultValueCascadingOption.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueCascadingOption(
      contextId: json[r'contextId'] as String? ?? '',
      optionId: json[r'optionId'] as String? ?? '',
      cascadingOptionId: json[r'cascadingOptionId'] as String?,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var optionId = this.optionId;
    var cascadingOptionId = this.cascadingOptionId;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'optionId'] = optionId;
    if (cascadingOptionId != null) {
      json[r'cascadingOptionId'] = cascadingOptionId;
    }
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueCascadingOption copyWith(
      {String? contextId,
      String? optionId,
      String? cascadingOptionId,
      String? type}) {
    return CustomFieldContextDefaultValueCascadingOption(
      contextId: contextId ?? this.contextId,
      optionId: optionId ?? this.optionId,
      cascadingOptionId: cascadingOptionId ?? this.cascadingOptionId,
      type: type ?? this.type,
    );
  }
}

/// Default value for a multi-select custom field.
class CustomFieldContextDefaultValueMultipleOption {
  /// The ID of the context.
  final String contextId;

  /// The list of IDs of the default options.
  final List<String> optionIds;
  final String type;

  CustomFieldContextDefaultValueMultipleOption(
      {required this.contextId, required this.optionIds, required this.type});

  factory CustomFieldContextDefaultValueMultipleOption.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueMultipleOption(
      contextId: json[r'contextId'] as String? ?? '',
      optionIds: (json[r'optionIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var optionIds = this.optionIds;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'optionIds'] = optionIds;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueMultipleOption copyWith(
      {String? contextId, List<String>? optionIds, String? type}) {
    return CustomFieldContextDefaultValueMultipleOption(
      contextId: contextId ?? this.contextId,
      optionIds: optionIds ?? this.optionIds,
      type: type ?? this.type,
    );
  }
}

/// Default value for a single select custom field.
class CustomFieldContextDefaultValueSingleOption {
  /// The ID of the context.
  final String contextId;

  /// The ID of the default option.
  final String optionId;
  final String type;

  CustomFieldContextDefaultValueSingleOption(
      {required this.contextId, required this.optionId, required this.type});

  factory CustomFieldContextDefaultValueSingleOption.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueSingleOption(
      contextId: json[r'contextId'] as String? ?? '',
      optionId: json[r'optionId'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var optionId = this.optionId;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'optionId'] = optionId;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueSingleOption copyWith(
      {String? contextId, String? optionId, String? type}) {
    return CustomFieldContextDefaultValueSingleOption(
      contextId: contextId ?? this.contextId,
      optionId: optionId ?? this.optionId,
      type: type ?? this.type,
    );
  }
}

/// A page of items.
class PageBeanCustomFieldContextDefaultValue {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<CustomFieldContextDefaultValue> values;

  PageBeanCustomFieldContextDefaultValue(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<CustomFieldContextDefaultValue>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanCustomFieldContextDefaultValue.fromJson(
      Map<String, Object?> json) {
    return PageBeanCustomFieldContextDefaultValue(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => CustomFieldContextDefaultValue.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanCustomFieldContextDefaultValue copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<CustomFieldContextDefaultValue>? values}) {
    return PageBeanCustomFieldContextDefaultValue(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// The details of a created custom field context.
class CreateCustomFieldContext {
  /// The ID of the context.
  final String? id;

  /// The name of the context.
  final String name;

  /// The description of the context.
  final String? description;

  /// The list of project IDs associated with the context. If the list is empty,
  /// the context is global.
  final List<String> projectIds;

  /// The list of issue types IDs for the context. If the list is empty, the
  /// context refers to all issue types.
  final List<String> issueTypeIds;

  CreateCustomFieldContext(
      {this.id,
      required this.name,
      this.description,
      List<String>? projectIds,
      List<String>? issueTypeIds})
      : projectIds = projectIds ?? [],
        issueTypeIds = issueTypeIds ?? [];

  factory CreateCustomFieldContext.fromJson(Map<String, Object?> json) {
    return CreateCustomFieldContext(
      id: json[r'id'] as String?,
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      issueTypeIds: (json[r'issueTypeIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var projectIds = this.projectIds;
    var issueTypeIds = this.issueTypeIds;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'projectIds'] = projectIds;
    json[r'issueTypeIds'] = issueTypeIds;
    return json;
  }

  CreateCustomFieldContext copyWith(
      {String? id,
      String? name,
      String? description,
      List<String>? projectIds,
      List<String>? issueTypeIds}) {
    return CreateCustomFieldContext(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      projectIds: projectIds ?? this.projectIds,
      issueTypeIds: issueTypeIds ?? this.issueTypeIds,
    );
  }
}

/// A list of project IDs.
class ProjectIds {
  /// The IDs of projects.
  final List<String> projectIds;

  ProjectIds({required this.projectIds});

  factory ProjectIds.fromJson(Map<String, Object?> json) {
    return ProjectIds(
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var projectIds = this.projectIds;

    final json = <String, Object?>{};
    json[r'projectIds'] = projectIds;
    return json;
  }

  ProjectIds copyWith({List<String>? projectIds}) {
    return ProjectIds(
      projectIds: projectIds ?? this.projectIds,
    );
  }
}

/// Details of a custom field context.
class CustomFieldContextUpdateDetails {
  /// The name of the custom field context. The name must be unique. The maximum
  /// length is 255 characters.
  final String? name;

  /// The description of the custom field context. The maximum length is 255
  /// characters.
  final String? description;

  CustomFieldContextUpdateDetails({this.name, this.description});

  factory CustomFieldContextUpdateDetails.fromJson(Map<String, Object?> json) {
    return CustomFieldContextUpdateDetails(
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    return json;
  }

  CustomFieldContextUpdateDetails copyWith(
      {String? name, String? description}) {
    return CustomFieldContextUpdateDetails(
      name: name ?? this.name,
      description: description ?? this.description,
    );
  }
}

/// The project and issue type mapping.
class ProjectIssueTypeMapping {
  /// The ID of the project.
  final String projectId;

  /// The ID of the issue type.
  final String issueTypeId;

  ProjectIssueTypeMapping({required this.projectId, required this.issueTypeId});

  factory ProjectIssueTypeMapping.fromJson(Map<String, Object?> json) {
    return ProjectIssueTypeMapping(
      projectId: json[r'projectId'] as String? ?? '',
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var projectId = this.projectId;
    var issueTypeId = this.issueTypeId;

    final json = <String, Object?>{};
    json[r'projectId'] = projectId;
    json[r'issueTypeId'] = issueTypeId;
    return json;
  }

  ProjectIssueTypeMapping copyWith({String? projectId, String? issueTypeId}) {
    return ProjectIssueTypeMapping(
      projectId: projectId ?? this.projectId,
      issueTypeId: issueTypeId ?? this.issueTypeId,
    );
  }
}

/// The project and issue type mappings.
class ProjectIssueTypeMappings {
  /// The project and issue type mappings.
  final List<ProjectIssueTypeMapping> mappings;

  ProjectIssueTypeMappings({required this.mappings});

  factory ProjectIssueTypeMappings.fromJson(Map<String, Object?> json) {
    return ProjectIssueTypeMappings(
      mappings: (json[r'mappings'] as List<Object?>?)
              ?.map((i) => ProjectIssueTypeMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var mappings = this.mappings;

    final json = <String, Object?>{};
    json[r'mappings'] = mappings.map((i) => i.toJson()).toList();
    return json;
  }

  ProjectIssueTypeMappings copyWith({List<ProjectIssueTypeMapping>? mappings}) {
    return ProjectIssueTypeMappings(
      mappings: mappings ?? this.mappings,
    );
  }
}

/// The project and issue type mapping with a matching custom field context.
class ContextForProjectAndIssueType {
  /// The ID of the project.
  final String projectId;

  /// The ID of the issue type.
  final String issueTypeId;

  /// The ID of the custom field context.
  final String contextId;

  ContextForProjectAndIssueType(
      {required this.projectId,
      required this.issueTypeId,
      required this.contextId});

  factory ContextForProjectAndIssueType.fromJson(Map<String, Object?> json) {
    return ContextForProjectAndIssueType(
      projectId: json[r'projectId'] as String? ?? '',
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
      contextId: json[r'contextId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var projectId = this.projectId;
    var issueTypeId = this.issueTypeId;
    var contextId = this.contextId;

    final json = <String, Object?>{};
    json[r'projectId'] = projectId;
    json[r'issueTypeId'] = issueTypeId;
    json[r'contextId'] = contextId;
    return json;
  }

  ContextForProjectAndIssueType copyWith(
      {String? projectId, String? issueTypeId, String? contextId}) {
    return ContextForProjectAndIssueType(
      projectId: projectId ?? this.projectId,
      issueTypeId: issueTypeId ?? this.issueTypeId,
      contextId: contextId ?? this.contextId,
    );
  }
}

/// A page of items.
class PageBeanContextForProjectAndIssueType {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<ContextForProjectAndIssueType> values;

  PageBeanContextForProjectAndIssueType(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<ContextForProjectAndIssueType>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanContextForProjectAndIssueType.fromJson(
      Map<String, Object?> json) {
    return PageBeanContextForProjectAndIssueType(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => ContextForProjectAndIssueType.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanContextForProjectAndIssueType copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<ContextForProjectAndIssueType>? values}) {
    return PageBeanContextForProjectAndIssueType(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Default values to update.
class CustomFieldContextDefaultValueUpdate {
  final List<CustomFieldContextDefaultValue> defaultValues;

  CustomFieldContextDefaultValueUpdate(
      {List<CustomFieldContextDefaultValue>? defaultValues})
      : defaultValues = defaultValues ?? [];

  factory CustomFieldContextDefaultValueUpdate.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueUpdate(
      defaultValues: (json[r'defaultValues'] as List<Object?>?)
              ?.map((i) => CustomFieldContextDefaultValue.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var defaultValues = this.defaultValues;

    final json = <String, Object?>{};
    json[r'defaultValues'] = defaultValues.map((i) => i.toJson()).toList();
    return json;
  }

  CustomFieldContextDefaultValueUpdate copyWith(
      {List<CustomFieldContextDefaultValue>? defaultValues}) {
    return CustomFieldContextDefaultValueUpdate(
      defaultValues: defaultValues ?? this.defaultValues,
    );
  }
}

/// Mapping of an issue type to a context.
class IssueTypeToContextMapping {
  /// The ID of the context.
  final String contextId;

  /// The ID of the issue type.
  final String? issueTypeId;

  /// Whether the context is mapped to any issue type.
  final bool isAnyIssueType;

  IssueTypeToContextMapping(
      {required this.contextId, this.issueTypeId, bool? isAnyIssueType})
      : isAnyIssueType = isAnyIssueType ?? false;

  factory IssueTypeToContextMapping.fromJson(Map<String, Object?> json) {
    return IssueTypeToContextMapping(
      contextId: json[r'contextId'] as String? ?? '',
      issueTypeId: json[r'issueTypeId'] as String?,
      isAnyIssueType: json[r'isAnyIssueType'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var issueTypeId = this.issueTypeId;
    var isAnyIssueType = this.isAnyIssueType;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    if (issueTypeId != null) {
      json[r'issueTypeId'] = issueTypeId;
    }
    json[r'isAnyIssueType'] = isAnyIssueType;
    return json;
  }

  IssueTypeToContextMapping copyWith(
      {String? contextId, String? issueTypeId, bool? isAnyIssueType}) {
    return IssueTypeToContextMapping(
      contextId: contextId ?? this.contextId,
      issueTypeId: issueTypeId ?? this.issueTypeId,
      isAnyIssueType: isAnyIssueType ?? this.isAnyIssueType,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeToContextMapping {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<IssueTypeToContextMapping> values;

  PageBeanIssueTypeToContextMapping(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<IssueTypeToContextMapping>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeToContextMapping.fromJson(
      Map<String, Object?> json) {
    return PageBeanIssueTypeToContextMapping(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeToContextMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeToContextMapping copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<IssueTypeToContextMapping>? values}) {
    return PageBeanIssueTypeToContextMapping(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

class CreateUpdateRoleRequestBean {
  /// The name of the project role. Must be unique. Cannot begin or end with
  /// whitespace. The maximum length is 255 characters. Required when creating a
  /// project role. Optional when partially updating a project role.
  final String? name;

  /// A description of the project role. Required when fully updating a project
  /// role. Optional when creating or partially updating a project role.
  final String? description;

  CreateUpdateRoleRequestBean({this.name, this.description});

  factory CreateUpdateRoleRequestBean.fromJson(Map<String, Object?> json) {
    return CreateUpdateRoleRequestBean(
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    return json;
  }

  CreateUpdateRoleRequestBean copyWith({String? name, String? description}) {
    return CreateUpdateRoleRequestBean(
      name: name ?? this.name,
      description: description ?? this.description,
    );
  }
}

class ActorInputBean {
  /// The account IDs of the users to add as default actors. This parameter
  /// accepts a comma-separated list. For example,
  /// `"user":["5b10a2844c20165700ede21g", "5b109f2e9729b51b54dc274d"]`.
  final List<String> user;

  /// The name of the group to add as a default actor. This parameter accepts a
  /// comma-separated list. For example,
  /// `"group":["project-admin", "jira-developers"]`.
  final List<String> group;

  ActorInputBean({List<String>? user, List<String>? group})
      : user = user ?? [],
        group = group ?? [];

  factory ActorInputBean.fromJson(Map<String, Object?> json) {
    return ActorInputBean(
      user: (json[r'user'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      group: (json[r'group'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;
    var group = this.group;

    final json = <String, Object?>{};
    json[r'user'] = user;
    json[r'group'] = group;
    return json;
  }

  ActorInputBean copyWith({List<String>? user, List<String>? group}) {
    return ActorInputBean(
      user: user ?? this.user,
      group: group ?? this.group,
    );
  }
}

class ProjectRoleActorsUpdateBean {
  /// The ID of the project role. Use
  /// [Get all project roles](#api-rest-api-3-role-get) to get a list of project
  /// role IDs.
  final int? id;

  /// The actors to add to the project role. Add groups using
  /// `atlassian-group-role-actor` and a list of group names. For example,
  /// `"atlassian-group-role-actor":["another","administrators"]}`. Add users
  /// using `atlassian-user-role-actor` and a list of account IDs. For example,
  /// `"atlassian-user-role-actor":["12345678-9abc-def1-2345-6789abcdef12", "abcdef12-3456-789a-bcde-f123456789ab"]`.
  final Map<String, dynamic>? categorisedActors;

  ProjectRoleActorsUpdateBean({this.id, this.categorisedActors});

  factory ProjectRoleActorsUpdateBean.fromJson(Map<String, Object?> json) {
    return ProjectRoleActorsUpdateBean(
      id: (json[r'id'] as num?)?.toInt(),
      categorisedActors: json[r'categorisedActors'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var categorisedActors = this.categorisedActors;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (categorisedActors != null) {
      json[r'categorisedActors'] = categorisedActors;
    }
    return json;
  }

  ProjectRoleActorsUpdateBean copyWith(
      {int? id, Map<String, dynamic>? categorisedActors}) {
    return ProjectRoleActorsUpdateBean(
      id: id ?? this.id,
      categorisedActors: categorisedActors ?? this.categorisedActors,
    );
  }
}

class ActorsMap {
  /// The user account ID of the user to add.
  final List<String> user;

  /// The name of the group to add.
  final List<String> group;

  ActorsMap({List<String>? user, List<String>? group})
      : user = user ?? [],
        group = group ?? [];

  factory ActorsMap.fromJson(Map<String, Object?> json) {
    return ActorsMap(
      user: (json[r'user'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      group: (json[r'group'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var user = this.user;
    var group = this.group;

    final json = <String, Object?>{};
    json[r'user'] = user;
    json[r'group'] = group;
    return json;
  }

  ActorsMap copyWith({List<String>? user, List<String>? group}) {
    return ActorsMap(
      user: user ?? this.user,
      group: group ?? this.group,
    );
  }
}

/// Details about a project role.
class ProjectRoleDetails {
  /// The URL the project role details.
  final String? self;

  /// The name of the project role.
  final String? name;

  /// The ID of the project role.
  final int? id;

  /// The description of the project role.
  final String? description;

  /// Whether this role is the admin role for the project.
  final bool admin;

  /// The scope of the role. Indicated for roles associated with
  /// [next-gen projects](https://confluence.atlassian.com/x/loMyO).
  final Scope? scope;

  /// Whether the roles are configurable for this project.
  final bool roleConfigurable;

  /// The translated name of the project role.
  final String? translatedName;

  /// Whether this role is the default role for the project.
  final bool default$;

  ProjectRoleDetails(
      {this.self,
      this.name,
      this.id,
      this.description,
      bool? admin,
      this.scope,
      bool? roleConfigurable,
      this.translatedName,
      bool? default$})
      : admin = admin ?? false,
        roleConfigurable = roleConfigurable ?? false,
        default$ = default$ ?? false;

  factory ProjectRoleDetails.fromJson(Map<String, Object?> json) {
    return ProjectRoleDetails(
      self: json[r'self'] as String?,
      name: json[r'name'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      description: json[r'description'] as String?,
      admin: json[r'admin'] as bool? ?? false,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      roleConfigurable: json[r'roleConfigurable'] as bool? ?? false,
      translatedName: json[r'translatedName'] as String?,
      default$: json[r'default'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var name = this.name;
    var id = this.id;
    var description = this.description;
    var admin = this.admin;
    var scope = this.scope;
    var roleConfigurable = this.roleConfigurable;
    var translatedName = this.translatedName;
    var default$ = this.default$;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'admin'] = admin;
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    json[r'roleConfigurable'] = roleConfigurable;
    if (translatedName != null) {
      json[r'translatedName'] = translatedName;
    }
    json[r'default'] = default$;
    return json;
  }

  ProjectRoleDetails copyWith(
      {String? self,
      String? name,
      int? id,
      String? description,
      bool? admin,
      Scope? scope,
      bool? roleConfigurable,
      String? translatedName,
      bool? default$}) {
    return ProjectRoleDetails(
      self: self ?? this.self,
      name: name ?? this.name,
      id: id ?? this.id,
      description: description ?? this.description,
      admin: admin ?? this.admin,
      scope: scope ?? this.scope,
      roleConfigurable: roleConfigurable ?? this.roleConfigurable,
      translatedName: translatedName ?? this.translatedName,
      default$: default$ ?? this.default$,
    );
  }
}

class GlobalScopeBean {
  /// Defines the behavior of the option in the global context.If notSelectable
  /// is set, the option cannot be set as the field's value. This is useful for
  /// archiving an option that has previously been selected but shouldn't be
  /// used anymore.If defaultValue is set, the option is selected by default.
  final List<GlobalScopeBeanAttributes> attributes;

  GlobalScopeBean({List<GlobalScopeBeanAttributes>? attributes})
      : attributes = attributes ?? [];

  factory GlobalScopeBean.fromJson(Map<String, Object?> json) {
    return GlobalScopeBean(
      attributes: (json[r'attributes'] as List<Object?>?)
              ?.map((i) =>
                  GlobalScopeBeanAttributes.fromValue(i as String? ?? ''))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var attributes = this.attributes;

    final json = <String, Object?>{};
    json[r'attributes'] = attributes.map((i) => i.value).toList();
    return json;
  }

  GlobalScopeBean copyWith({List<GlobalScopeBeanAttributes>? attributes}) {
    return GlobalScopeBean(
      attributes: attributes ?? this.attributes,
    );
  }
}

class GlobalScopeBeanAttributes {
  static const notSelectable = GlobalScopeBeanAttributes._('notSelectable');
  static const defaultValue = GlobalScopeBeanAttributes._('defaultValue');

  static const values = [
    notSelectable,
    defaultValue,
  ];
  final String value;

  const GlobalScopeBeanAttributes._(this.value);

  static GlobalScopeBeanAttributes fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => GlobalScopeBeanAttributes._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of the options for a select list issue field.
class IssueFieldOption {
  /// The unique identifier for the option. This is only unique within the
  /// select field's set of options.
  final int id;

  /// The option's name, which is displayed in Jira.
  final String value;

  /// The properties of the object, as arbitrary key-value pairs. These
  /// properties can be searched using JQL, if the extractions (see
  /// [Issue Field Option Property Index](https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/))
  /// are defined in the descriptor for the issue field module.
  final Map<String, dynamic>? properties;
  final IssueFieldOptionConfiguration? config;

  IssueFieldOption(
      {required this.id, required this.value, this.properties, this.config});

  factory IssueFieldOption.fromJson(Map<String, Object?> json) {
    return IssueFieldOption(
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      value: json[r'value'] as String? ?? '',
      properties: json[r'properties'] as Map<String, Object?>?,
      config: json[r'config'] != null
          ? IssueFieldOptionConfiguration.fromJson(
              json[r'config']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var value = this.value;
    var properties = this.properties;
    var config = this.config;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'value'] = value;
    if (properties != null) {
      json[r'properties'] = properties;
    }
    if (config != null) {
      json[r'config'] = config.toJson();
    }
    return json;
  }

  IssueFieldOption copyWith(
      {int? id,
      String? value,
      Map<String, dynamic>? properties,
      IssueFieldOptionConfiguration? config}) {
    return IssueFieldOption(
      id: id ?? this.id,
      value: value ?? this.value,
      properties: properties ?? this.properties,
      config: config ?? this.config,
    );
  }
}

/// Details of the projects the option is available in.
class IssueFieldOptionConfiguration {
  /// Defines the projects that the option is available in. If the scope is not
  /// defined, then the option is available in all projects.
  final IssueFieldOptionScopeBean? scope;

  /// DEPRECATED
  final List<IssueFieldOptionConfigurationAttributes> attributes;

  IssueFieldOptionConfiguration(
      {this.scope, List<IssueFieldOptionConfigurationAttributes>? attributes})
      : attributes = attributes ?? [];

  factory IssueFieldOptionConfiguration.fromJson(Map<String, Object?> json) {
    return IssueFieldOptionConfiguration(
      scope: json[r'scope'] != null
          ? IssueFieldOptionScopeBean.fromJson(
              json[r'scope']! as Map<String, Object?>)
          : null,
      attributes: (json[r'attributes'] as List<Object?>?)
              ?.map((i) => IssueFieldOptionConfigurationAttributes.fromValue(
                  i as String? ?? ''))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var scope = this.scope;
    var attributes = this.attributes;

    final json = <String, Object?>{};
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    json[r'attributes'] = attributes.map((i) => i.value).toList();
    return json;
  }

  IssueFieldOptionConfiguration copyWith(
      {IssueFieldOptionScopeBean? scope,
      List<IssueFieldOptionConfigurationAttributes>? attributes}) {
    return IssueFieldOptionConfiguration(
      scope: scope ?? this.scope,
      attributes: attributes ?? this.attributes,
    );
  }
}

class IssueFieldOptionConfigurationAttributes {
  static const notSelectable =
      IssueFieldOptionConfigurationAttributes._('notSelectable');
  static const defaultValue =
      IssueFieldOptionConfigurationAttributes._('defaultValue');

  static const values = [
    notSelectable,
    defaultValue,
  ];
  final String value;

  const IssueFieldOptionConfigurationAttributes._(this.value);

  static IssueFieldOptionConfigurationAttributes fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => IssueFieldOptionConfigurationAttributes._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class IssueFieldOptionScopeBean {
  /// DEPRECATED
  final List<int> projects;

  /// Defines the projects in which the option is available and the behavior of
  /// the option within each project. Specify one object per project. The
  /// behavior of the option in a project context overrides the behavior in the
  /// global context.
  final List<ProjectScopeBean> projects2;

  /// Defines the behavior of the option within the global context. If this
  /// property is set, even if set to an empty object, then the option is
  /// available in all projects.
  final GlobalScopeBean? global;

  IssueFieldOptionScopeBean(
      {List<int>? projects, List<ProjectScopeBean>? projects2, this.global})
      : projects = projects ?? [],
        projects2 = projects2 ?? [];

  factory IssueFieldOptionScopeBean.fromJson(Map<String, Object?> json) {
    return IssueFieldOptionScopeBean(
      projects: (json[r'projects'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      projects2: (json[r'projects2'] as List<Object?>?)
              ?.map((i) => ProjectScopeBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      global: json[r'global'] != null
          ? GlobalScopeBean.fromJson(json[r'global']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var projects = this.projects;
    var projects2 = this.projects2;
    var global = this.global;

    final json = <String, Object?>{};
    json[r'projects'] = projects;
    json[r'projects2'] = projects2.map((i) => i.toJson()).toList();
    if (global != null) {
      json[r'global'] = global.toJson();
    }
    return json;
  }

  IssueFieldOptionScopeBean copyWith(
      {List<int>? projects,
      List<ProjectScopeBean>? projects2,
      GlobalScopeBean? global}) {
    return IssueFieldOptionScopeBean(
      projects: projects ?? this.projects,
      projects2: projects2 ?? this.projects2,
      global: global ?? this.global,
    );
  }
}

/// A page of items.
class PageBeanIssueFieldOption {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<IssueFieldOption> values;

  PageBeanIssueFieldOption(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<IssueFieldOption>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueFieldOption.fromJson(Map<String, Object?> json) {
    return PageBeanIssueFieldOption(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueFieldOption.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueFieldOption copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<IssueFieldOption>? values}) {
    return PageBeanIssueFieldOption(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

class ProjectScopeBean {
  /// The ID of the project that the option's behavior applies to.
  final int? id;

  /// Defines the behavior of the option in the project.If notSelectable is set,
  /// the option cannot be set as the field's value. This is useful for
  /// archiving an option that has previously been selected but shouldn't be
  /// used anymore.If defaultValue is set, the option is selected by default.
  final List<ProjectScopeBeanAttributes> attributes;

  ProjectScopeBean({this.id, List<ProjectScopeBeanAttributes>? attributes})
      : attributes = attributes ?? [];

  factory ProjectScopeBean.fromJson(Map<String, Object?> json) {
    return ProjectScopeBean(
      id: (json[r'id'] as num?)?.toInt(),
      attributes: (json[r'attributes'] as List<Object?>?)
              ?.map((i) =>
                  ProjectScopeBeanAttributes.fromValue(i as String? ?? ''))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var attributes = this.attributes;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'attributes'] = attributes.map((i) => i.value).toList();
    return json;
  }

  ProjectScopeBean copyWith(
      {int? id, List<ProjectScopeBeanAttributes>? attributes}) {
    return ProjectScopeBean(
      id: id ?? this.id,
      attributes: attributes ?? this.attributes,
    );
  }
}

class ProjectScopeBeanAttributes {
  static const notSelectable = ProjectScopeBeanAttributes._('notSelectable');
  static const defaultValue = ProjectScopeBeanAttributes._('defaultValue');

  static const values = [
    notSelectable,
    defaultValue,
  ];
  final String value;

  const ProjectScopeBeanAttributes._(this.value);

  static ProjectScopeBeanAttributes fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectScopeBeanAttributes._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class IssueFieldOptionCreateBean {
  /// The option's name, which is displayed in Jira.
  final String value;

  /// The properties of the option as arbitrary key-value pairs. These
  /// properties can be searched using JQL, if the extractions (see
  /// https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/)
  /// are defined in the descriptor for the issue field module.
  final Map<String, dynamic>? properties;
  final IssueFieldOptionConfiguration? config;

  IssueFieldOptionCreateBean(
      {required this.value, this.properties, this.config});

  factory IssueFieldOptionCreateBean.fromJson(Map<String, Object?> json) {
    return IssueFieldOptionCreateBean(
      value: json[r'value'] as String? ?? '',
      properties: json[r'properties'] as Map<String, Object?>?,
      config: json[r'config'] != null
          ? IssueFieldOptionConfiguration.fromJson(
              json[r'config']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;
    var properties = this.properties;
    var config = this.config;

    final json = <String, Object?>{};
    json[r'value'] = value;
    if (properties != null) {
      json[r'properties'] = properties;
    }
    if (config != null) {
      json[r'config'] = config.toJson();
    }
    return json;
  }

  IssueFieldOptionCreateBean copyWith(
      {String? value,
      Map<String, dynamic>? properties,
      IssueFieldOptionConfiguration? config}) {
    return IssueFieldOptionCreateBean(
      value: value ?? this.value,
      properties: properties ?? this.properties,
      config: config ?? this.config,
    );
  }
}

class RemoveOptionFromIssuesResult {
  /// The IDs of the modified issues.
  final List<int> modifiedIssues;

  /// The IDs of the unchanged issues, those issues where errors prevent
  /// modification.
  final List<int> unmodifiedIssues;

  /// A collection of errors related to unchanged issues. The collection size is
  /// limited, which means not all errors may be returned.
  final SimpleErrorCollection? errors;

  RemoveOptionFromIssuesResult(
      {List<int>? modifiedIssues, List<int>? unmodifiedIssues, this.errors})
      : modifiedIssues = modifiedIssues ?? [],
        unmodifiedIssues = unmodifiedIssues ?? [];

  factory RemoveOptionFromIssuesResult.fromJson(Map<String, Object?> json) {
    return RemoveOptionFromIssuesResult(
      modifiedIssues: (json[r'modifiedIssues'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      unmodifiedIssues: (json[r'unmodifiedIssues'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      errors: json[r'errors'] != null
          ? SimpleErrorCollection.fromJson(
              json[r'errors']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var modifiedIssues = this.modifiedIssues;
    var unmodifiedIssues = this.unmodifiedIssues;
    var errors = this.errors;

    final json = <String, Object?>{};
    json[r'modifiedIssues'] = modifiedIssues;
    json[r'unmodifiedIssues'] = unmodifiedIssues;
    if (errors != null) {
      json[r'errors'] = errors.toJson();
    }
    return json;
  }

  RemoveOptionFromIssuesResult copyWith(
      {List<int>? modifiedIssues,
      List<int>? unmodifiedIssues,
      SimpleErrorCollection? errors}) {
    return RemoveOptionFromIssuesResult(
      modifiedIssues: modifiedIssues ?? this.modifiedIssues,
      unmodifiedIssues: unmodifiedIssues ?? this.unmodifiedIssues,
      errors: errors ?? this.errors,
    );
  }
}

class SimpleErrorCollection {
  /// The list of errors by parameter returned by the operation. For
  /// example,"projectKey": "Project keys must start with an uppercase letter,
  /// followed by one or more uppercase alphanumeric characters."
  final Map<String, dynamic>? errors;

  /// The list of error messages produced by this operation. For example, "input
  /// parameter 'key' must be provided"
  final List<String> errorMessages;
  final int? httpStatusCode;

  SimpleErrorCollection(
      {this.errors, List<String>? errorMessages, this.httpStatusCode})
      : errorMessages = errorMessages ?? [];

  factory SimpleErrorCollection.fromJson(Map<String, Object?> json) {
    return SimpleErrorCollection(
      errors: json[r'errors'] as Map<String, Object?>?,
      errorMessages: (json[r'errorMessages'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      httpStatusCode: (json[r'httpStatusCode'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var errors = this.errors;
    var errorMessages = this.errorMessages;
    var httpStatusCode = this.httpStatusCode;

    final json = <String, Object?>{};
    if (errors != null) {
      json[r'errors'] = errors;
    }
    json[r'errorMessages'] = errorMessages;
    if (httpStatusCode != null) {
      json[r'httpStatusCode'] = httpStatusCode;
    }
    return json;
  }

  SimpleErrorCollection copyWith(
      {Map<String, dynamic>? errors,
      List<String>? errorMessages,
      int? httpStatusCode}) {
    return SimpleErrorCollection(
      errors: errors ?? this.errors,
      errorMessages: errorMessages ?? this.errorMessages,
      httpStatusCode: httpStatusCode ?? this.httpStatusCode,
    );
  }
}

/// Details about a task.
class TaskProgressBeanRemoveOptionFromIssuesResult {
  /// The URL of the task.
  final String self;

  /// The ID of the task.
  final String id;

  /// The description of the task.
  final String? description;

  /// The status of the task.
  final TaskProgressBeanRemoveOptionFromIssuesResultStatus status;

  /// Information about the progress of the task.
  final String? message;

  /// The result of the task execution.
  final RemoveOptionFromIssuesResult? result;

  /// The ID of the user who submitted the task.
  final int submittedBy;

  /// The progress of the task, as a percentage complete.
  final int progress;

  /// The execution time of the task, in milliseconds.
  final int elapsedRuntime;

  /// A timestamp recording when the task was submitted.
  final int submitted;

  /// A timestamp recording when the task was started.
  final int? started;

  /// A timestamp recording when the task was finished.
  final int? finished;

  /// A timestamp recording when the task progress was last updated.
  final int lastUpdate;

  TaskProgressBeanRemoveOptionFromIssuesResult(
      {required this.self,
      required this.id,
      this.description,
      required this.status,
      this.message,
      this.result,
      required this.submittedBy,
      required this.progress,
      required this.elapsedRuntime,
      required this.submitted,
      this.started,
      this.finished,
      required this.lastUpdate});

  factory TaskProgressBeanRemoveOptionFromIssuesResult.fromJson(
      Map<String, Object?> json) {
    return TaskProgressBeanRemoveOptionFromIssuesResult(
      self: json[r'self'] as String? ?? '',
      id: json[r'id'] as String? ?? '',
      description: json[r'description'] as String?,
      status: TaskProgressBeanRemoveOptionFromIssuesResultStatus.fromValue(
          json[r'status'] as String? ?? ''),
      message: json[r'message'] as String?,
      result: json[r'result'] != null
          ? RemoveOptionFromIssuesResult.fromJson(
              json[r'result']! as Map<String, Object?>)
          : null,
      submittedBy: (json[r'submittedBy'] as num?)?.toInt() ?? 0,
      progress: (json[r'progress'] as num?)?.toInt() ?? 0,
      elapsedRuntime: (json[r'elapsedRuntime'] as num?)?.toInt() ?? 0,
      submitted: (json[r'submitted'] as num?)?.toInt() ?? 0,
      started: (json[r'started'] as num?)?.toInt(),
      finished: (json[r'finished'] as num?)?.toInt(),
      lastUpdate: (json[r'lastUpdate'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var id = this.id;
    var description = this.description;
    var status = this.status;
    var message = this.message;
    var result = this.result;
    var submittedBy = this.submittedBy;
    var progress = this.progress;
    var elapsedRuntime = this.elapsedRuntime;
    var submitted = this.submitted;
    var started = this.started;
    var finished = this.finished;
    var lastUpdate = this.lastUpdate;

    final json = <String, Object?>{};
    json[r'self'] = self;
    json[r'id'] = id;
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'status'] = status.value;
    if (message != null) {
      json[r'message'] = message;
    }
    if (result != null) {
      json[r'result'] = result.toJson();
    }
    json[r'submittedBy'] = submittedBy;
    json[r'progress'] = progress;
    json[r'elapsedRuntime'] = elapsedRuntime;
    json[r'submitted'] = submitted;
    if (started != null) {
      json[r'started'] = started;
    }
    if (finished != null) {
      json[r'finished'] = finished;
    }
    json[r'lastUpdate'] = lastUpdate;
    return json;
  }

  TaskProgressBeanRemoveOptionFromIssuesResult copyWith(
      {String? self,
      String? id,
      String? description,
      TaskProgressBeanRemoveOptionFromIssuesResultStatus? status,
      String? message,
      RemoveOptionFromIssuesResult? result,
      int? submittedBy,
      int? progress,
      int? elapsedRuntime,
      int? submitted,
      int? started,
      int? finished,
      int? lastUpdate}) {
    return TaskProgressBeanRemoveOptionFromIssuesResult(
      self: self ?? this.self,
      id: id ?? this.id,
      description: description ?? this.description,
      status: status ?? this.status,
      message: message ?? this.message,
      result: result ?? this.result,
      submittedBy: submittedBy ?? this.submittedBy,
      progress: progress ?? this.progress,
      elapsedRuntime: elapsedRuntime ?? this.elapsedRuntime,
      submitted: submitted ?? this.submitted,
      started: started ?? this.started,
      finished: finished ?? this.finished,
      lastUpdate: lastUpdate ?? this.lastUpdate,
    );
  }
}

class TaskProgressBeanRemoveOptionFromIssuesResultStatus {
  static const enqueued =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('ENQUEUED');
  static const running =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('RUNNING');
  static const complete =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('COMPLETE');
  static const failed =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('FAILED');
  static const cancelRequested =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('CANCEL_REQUESTED');
  static const cancelled =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('CANCELLED');
  static const dead =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('DEAD');

  static const values = [
    enqueued,
    running,
    complete,
    failed,
    cancelRequested,
    cancelled,
    dead,
  ];
  final String value;

  const TaskProgressBeanRemoveOptionFromIssuesResultStatus._(this.value);

  static TaskProgressBeanRemoveOptionFromIssuesResultStatus fromValue(
          String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              TaskProgressBeanRemoveOptionFromIssuesResultStatus._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of a field.
class Field {
  /// The ID of the field.
  final String id;

  /// The name of the field.
  final String name;
  final JsonTypeBean schema;

  /// The description of the field.
  final String? description;

  /// The key of the field.
  final String? key;

  /// Whether the field is locked.
  final bool isLocked;

  /// The searcher key of the field. Returned for custom fields.
  final String? searcherKey;

  /// Number of screens where the field is used.
  final int? screensCount;

  /// Number of contexts where the field is used.
  final int? contextsCount;
  final FieldLastUsed? lastUsed;

  Field(
      {required this.id,
      required this.name,
      required this.schema,
      this.description,
      this.key,
      bool? isLocked,
      this.searcherKey,
      this.screensCount,
      this.contextsCount,
      this.lastUsed})
      : isLocked = isLocked ?? false;

  factory Field.fromJson(Map<String, Object?> json) {
    return Field(
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      schema: JsonTypeBean.fromJson(
          json[r'schema'] as Map<String, Object?>? ?? const {}),
      description: json[r'description'] as String?,
      key: json[r'key'] as String?,
      isLocked: json[r'isLocked'] as bool? ?? false,
      searcherKey: json[r'searcherKey'] as String?,
      screensCount: (json[r'screensCount'] as num?)?.toInt(),
      contextsCount: (json[r'contextsCount'] as num?)?.toInt(),
      lastUsed: json[r'lastUsed'] != null
          ? FieldLastUsed.fromJson(json[r'lastUsed']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var schema = this.schema;
    var description = this.description;
    var key = this.key;
    var isLocked = this.isLocked;
    var searcherKey = this.searcherKey;
    var screensCount = this.screensCount;
    var contextsCount = this.contextsCount;
    var lastUsed = this.lastUsed;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    json[r'schema'] = schema.toJson();
    if (description != null) {
      json[r'description'] = description;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    json[r'isLocked'] = isLocked;
    if (searcherKey != null) {
      json[r'searcherKey'] = searcherKey;
    }
    if (screensCount != null) {
      json[r'screensCount'] = screensCount;
    }
    if (contextsCount != null) {
      json[r'contextsCount'] = contextsCount;
    }
    if (lastUsed != null) {
      json[r'lastUsed'] = lastUsed.toJson();
    }
    return json;
  }

  Field copyWith(
      {String? id,
      String? name,
      JsonTypeBean? schema,
      String? description,
      String? key,
      bool? isLocked,
      String? searcherKey,
      int? screensCount,
      int? contextsCount,
      FieldLastUsed? lastUsed}) {
    return Field(
      id: id ?? this.id,
      name: name ?? this.name,
      schema: schema ?? this.schema,
      description: description ?? this.description,
      key: key ?? this.key,
      isLocked: isLocked ?? this.isLocked,
      searcherKey: searcherKey ?? this.searcherKey,
      screensCount: screensCount ?? this.screensCount,
      contextsCount: contextsCount ?? this.contextsCount,
      lastUsed: lastUsed ?? this.lastUsed,
    );
  }
}

/// Information about the most recent use of a field.
class FieldLastUsed {
  /// Last used value type:
  ///
  ///  *  *TRACKED*: field is tracked and a last used date is available.
  ///  *  *NOT_TRACKED*: field is not tracked, last used date is not available.
  ///  *  *NO_INFORMATION*: field is tracked, but no last used date is
  /// available.
  final FieldLastUsedType? type;

  /// The date when the value of the field last changed.
  final DateTime? value;

  FieldLastUsed({this.type, this.value});

  factory FieldLastUsed.fromJson(Map<String, Object?> json) {
    return FieldLastUsed(
      type: json[r'type'] != null
          ? FieldLastUsedType.fromValue(json[r'type']! as String)
          : null,
      value: DateTime.tryParse(json[r'value'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var value = this.value;

    final json = <String, Object?>{};
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (value != null) {
      json[r'value'] = value.toIso8601String();
    }
    return json;
  }

  FieldLastUsed copyWith({FieldLastUsedType? type, DateTime? value}) {
    return FieldLastUsed(
      type: type ?? this.type,
      value: value ?? this.value,
    );
  }
}

class FieldLastUsedType {
  static const tracked = FieldLastUsedType._('TRACKED');
  static const notTracked = FieldLastUsedType._('NOT_TRACKED');
  static const noInformation = FieldLastUsedType._('NO_INFORMATION');

  static const values = [
    tracked,
    notTracked,
    noInformation,
  ];
  final String value;

  const FieldLastUsedType._(this.value);

  static FieldLastUsedType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldLastUsedType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A page of items.
class PageBeanField {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<Field> values;

  PageBeanField(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<Field>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanField.fromJson(Map<String, Object?> json) {
    return PageBeanField(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map(
                  (i) => Field.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanField copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<Field>? values}) {
    return PageBeanField(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Details of a field configuration scheme.
class FieldConfigurationScheme {
  /// The ID of the field configuration scheme.
  final String id;

  /// The name of the field configuration scheme.
  final String name;

  /// The description of the field configuration scheme.
  final String? description;

  FieldConfigurationScheme(
      {required this.id, required this.name, this.description});

  factory FieldConfigurationScheme.fromJson(Map<String, Object?> json) {
    return FieldConfigurationScheme(
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var description = this.description;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    return json;
  }

  FieldConfigurationScheme copyWith(
      {String? id, String? name, String? description}) {
    return FieldConfigurationScheme(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
    );
  }
}

/// A page of items.
class PageBeanFieldConfigurationScheme {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<FieldConfigurationScheme> values;

  PageBeanFieldConfigurationScheme(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<FieldConfigurationScheme>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanFieldConfigurationScheme.fromJson(Map<String, Object?> json) {
    return PageBeanFieldConfigurationScheme(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FieldConfigurationScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanFieldConfigurationScheme copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<FieldConfigurationScheme>? values}) {
    return PageBeanFieldConfigurationScheme(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// The field configuration for an issue type.
class FieldConfigurationIssueTypeItem {
  /// The ID of the field configuration scheme.
  final String fieldConfigurationSchemeId;

  /// The ID of the issue type or *default*. When set to *default* this field
  /// configuration issue type item applies to all issue types without a field
  /// configuration.
  final String issueTypeId;

  /// The ID of the field configuration.
  final String fieldConfigurationId;

  FieldConfigurationIssueTypeItem(
      {required this.fieldConfigurationSchemeId,
      required this.issueTypeId,
      required this.fieldConfigurationId});

  factory FieldConfigurationIssueTypeItem.fromJson(Map<String, Object?> json) {
    return FieldConfigurationIssueTypeItem(
      fieldConfigurationSchemeId:
          json[r'fieldConfigurationSchemeId'] as String? ?? '',
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
      fieldConfigurationId: json[r'fieldConfigurationId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var fieldConfigurationSchemeId = this.fieldConfigurationSchemeId;
    var issueTypeId = this.issueTypeId;
    var fieldConfigurationId = this.fieldConfigurationId;

    final json = <String, Object?>{};
    json[r'fieldConfigurationSchemeId'] = fieldConfigurationSchemeId;
    json[r'issueTypeId'] = issueTypeId;
    json[r'fieldConfigurationId'] = fieldConfigurationId;
    return json;
  }

  FieldConfigurationIssueTypeItem copyWith(
      {String? fieldConfigurationSchemeId,
      String? issueTypeId,
      String? fieldConfigurationId}) {
    return FieldConfigurationIssueTypeItem(
      fieldConfigurationSchemeId:
          fieldConfigurationSchemeId ?? this.fieldConfigurationSchemeId,
      issueTypeId: issueTypeId ?? this.issueTypeId,
      fieldConfigurationId: fieldConfigurationId ?? this.fieldConfigurationId,
    );
  }
}

/// A page of items.
class PageBeanFieldConfigurationIssueTypeItem {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<FieldConfigurationIssueTypeItem> values;

  PageBeanFieldConfigurationIssueTypeItem(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<FieldConfigurationIssueTypeItem>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanFieldConfigurationIssueTypeItem.fromJson(
      Map<String, Object?> json) {
    return PageBeanFieldConfigurationIssueTypeItem(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FieldConfigurationIssueTypeItem.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanFieldConfigurationIssueTypeItem copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<FieldConfigurationIssueTypeItem>? values}) {
    return PageBeanFieldConfigurationIssueTypeItem(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Project list with assigned field configuration schema.
class FieldConfigurationSchemeProjects {
  final FieldConfigurationScheme? fieldConfigurationScheme;

  /// The IDs of projects using the field configuration scheme.
  final List<String> projectIds;

  FieldConfigurationSchemeProjects(
      {this.fieldConfigurationScheme, required this.projectIds});

  factory FieldConfigurationSchemeProjects.fromJson(Map<String, Object?> json) {
    return FieldConfigurationSchemeProjects(
      fieldConfigurationScheme: json[r'fieldConfigurationScheme'] != null
          ? FieldConfigurationScheme.fromJson(
              json[r'fieldConfigurationScheme']! as Map<String, Object?>)
          : null,
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var fieldConfigurationScheme = this.fieldConfigurationScheme;
    var projectIds = this.projectIds;

    final json = <String, Object?>{};
    if (fieldConfigurationScheme != null) {
      json[r'fieldConfigurationScheme'] = fieldConfigurationScheme.toJson();
    }
    json[r'projectIds'] = projectIds;
    return json;
  }

  FieldConfigurationSchemeProjects copyWith(
      {FieldConfigurationScheme? fieldConfigurationScheme,
      List<String>? projectIds}) {
    return FieldConfigurationSchemeProjects(
      fieldConfigurationScheme:
          fieldConfigurationScheme ?? this.fieldConfigurationScheme,
      projectIds: projectIds ?? this.projectIds,
    );
  }
}

/// A page of items.
class PageBeanFieldConfigurationSchemeProjects {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<FieldConfigurationSchemeProjects> values;

  PageBeanFieldConfigurationSchemeProjects(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<FieldConfigurationSchemeProjects>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanFieldConfigurationSchemeProjects.fromJson(
      Map<String, Object?> json) {
    return PageBeanFieldConfigurationSchemeProjects(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FieldConfigurationSchemeProjects.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanFieldConfigurationSchemeProjects copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<FieldConfigurationSchemeProjects>? values}) {
    return PageBeanFieldConfigurationSchemeProjects(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Associated field configuration scheme and project.
class FieldConfigurationSchemeProjectAssociation {
  /// The ID of the field configuration scheme. If the field configuration
  /// scheme ID is `null`, the operation assigns the default field configuration
  /// scheme.
  final String? fieldConfigurationSchemeId;

  /// The ID of the project.
  final String projectId;

  FieldConfigurationSchemeProjectAssociation(
      {this.fieldConfigurationSchemeId, required this.projectId});

  factory FieldConfigurationSchemeProjectAssociation.fromJson(
      Map<String, Object?> json) {
    return FieldConfigurationSchemeProjectAssociation(
      fieldConfigurationSchemeId:
          json[r'fieldConfigurationSchemeId'] as String?,
      projectId: json[r'projectId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var fieldConfigurationSchemeId = this.fieldConfigurationSchemeId;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    if (fieldConfigurationSchemeId != null) {
      json[r'fieldConfigurationSchemeId'] = fieldConfigurationSchemeId;
    }
    json[r'projectId'] = projectId;
    return json;
  }

  FieldConfigurationSchemeProjectAssociation copyWith(
      {String? fieldConfigurationSchemeId, String? projectId}) {
    return FieldConfigurationSchemeProjectAssociation(
      fieldConfigurationSchemeId:
          fieldConfigurationSchemeId ?? this.fieldConfigurationSchemeId,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// Details of a field configuration.
class FieldConfiguration {
  /// The ID of the field configuration.
  final int id;

  /// The name of the field configuration.
  final String name;

  /// The description of the field configuration.
  final String description;

  /// Whether the field configuration is the default.
  final bool isDefault;

  FieldConfiguration(
      {required this.id,
      required this.name,
      required this.description,
      bool? isDefault})
      : isDefault = isDefault ?? false;

  factory FieldConfiguration.fromJson(Map<String, Object?> json) {
    return FieldConfiguration(
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String? ?? '',
      isDefault: json[r'isDefault'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var isDefault = this.isDefault;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    json[r'description'] = description;
    json[r'isDefault'] = isDefault;
    return json;
  }

  FieldConfiguration copyWith(
      {int? id, String? name, String? description, bool? isDefault}) {
    return FieldConfiguration(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      isDefault: isDefault ?? this.isDefault,
    );
  }
}

/// A page of items.
class PageBeanFieldConfiguration {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<FieldConfiguration> values;

  PageBeanFieldConfiguration(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<FieldConfiguration>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanFieldConfiguration.fromJson(Map<String, Object?> json) {
    return PageBeanFieldConfiguration(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FieldConfiguration.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanFieldConfiguration copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<FieldConfiguration>? values}) {
    return PageBeanFieldConfiguration(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// A field within a field configuration.
class FieldConfigurationItem {
  /// The ID of the field within the field configuration.
  final String id;

  /// The description of the field within the field configuration.
  final String? description;

  /// Whether the field is hidden in the field configuration.
  final bool isHidden;

  /// Whether the field is required in the field configuration.
  final bool isRequired;

  FieldConfigurationItem(
      {required this.id, this.description, bool? isHidden, bool? isRequired})
      : isHidden = isHidden ?? false,
        isRequired = isRequired ?? false;

  factory FieldConfigurationItem.fromJson(Map<String, Object?> json) {
    return FieldConfigurationItem(
      id: json[r'id'] as String? ?? '',
      description: json[r'description'] as String?,
      isHidden: json[r'isHidden'] as bool? ?? false,
      isRequired: json[r'isRequired'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var description = this.description;
    var isHidden = this.isHidden;
    var isRequired = this.isRequired;

    final json = <String, Object?>{};
    json[r'id'] = id;
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'isHidden'] = isHidden;
    json[r'isRequired'] = isRequired;
    return json;
  }

  FieldConfigurationItem copyWith(
      {String? id, String? description, bool? isHidden, bool? isRequired}) {
    return FieldConfigurationItem(
      id: id ?? this.id,
      description: description ?? this.description,
      isHidden: isHidden ?? this.isHidden,
      isRequired: isRequired ?? this.isRequired,
    );
  }
}

/// A page of items.
class PageBeanFieldConfigurationItem {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<FieldConfigurationItem> values;

  PageBeanFieldConfigurationItem(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<FieldConfigurationItem>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanFieldConfigurationItem.fromJson(Map<String, Object?> json) {
    return PageBeanFieldConfigurationItem(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FieldConfigurationItem.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanFieldConfigurationItem copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<FieldConfigurationItem>? values}) {
    return PageBeanFieldConfigurationItem(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanScreenScheme {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<ScreenScheme> values;

  PageBeanScreenScheme(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<ScreenScheme>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanScreenScheme.fromJson(Map<String, Object?> json) {
    return PageBeanScreenScheme(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  ScreenScheme.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanScreenScheme copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<ScreenScheme>? values}) {
    return PageBeanScreenScheme(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// A screen scheme.
class ScreenScheme {
  /// The ID of the screen scheme.
  final int? id;

  /// The name of the screen scheme.
  final String? name;

  /// The description of the screen scheme.
  final String? description;

  /// The IDs of the screens for the screen types of the screen scheme.
  final ScreenTypes? screens;

  /// Details of the issue type screen schemes associated with the screen
  /// scheme.
  final PageBeanIssueTypeScreenScheme? issueTypeScreenSchemes;

  ScreenScheme(
      {this.id,
      this.name,
      this.description,
      this.screens,
      this.issueTypeScreenSchemes});

  factory ScreenScheme.fromJson(Map<String, Object?> json) {
    return ScreenScheme(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      screens: json[r'screens'] != null
          ? ScreenTypes.fromJson(json[r'screens']! as Map<String, Object?>)
          : null,
      issueTypeScreenSchemes: json[r'issueTypeScreenSchemes'] != null
          ? PageBeanIssueTypeScreenScheme.fromJson(
              json[r'issueTypeScreenSchemes']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var screens = this.screens;
    var issueTypeScreenSchemes = this.issueTypeScreenSchemes;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (screens != null) {
      json[r'screens'] = screens.toJson();
    }
    if (issueTypeScreenSchemes != null) {
      json[r'issueTypeScreenSchemes'] = issueTypeScreenSchemes.toJson();
    }
    return json;
  }

  ScreenScheme copyWith(
      {int? id,
      String? name,
      String? description,
      ScreenTypes? screens,
      PageBeanIssueTypeScreenScheme? issueTypeScreenSchemes}) {
    return ScreenScheme(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      screens: screens ?? this.screens,
      issueTypeScreenSchemes:
          issueTypeScreenSchemes ?? this.issueTypeScreenSchemes,
    );
  }
}

/// The IDs of the screens for the screen types of the screen scheme.
class ScreenTypes {
  /// The ID of the edit screen.
  final int? edit;

  /// The ID of the create screen.
  final int? create;

  /// The ID of the view screen.
  final int? view;

  /// The ID of the default screen. Required when creating a screen scheme.
  final int? default$;

  ScreenTypes({this.edit, this.create, this.view, this.default$});

  factory ScreenTypes.fromJson(Map<String, Object?> json) {
    return ScreenTypes(
      edit: (json[r'edit'] as num?)?.toInt(),
      create: (json[r'create'] as num?)?.toInt(),
      view: (json[r'view'] as num?)?.toInt(),
      default$: (json[r'default'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var edit = this.edit;
    var create = this.create;
    var view = this.view;
    var default$ = this.default$;

    final json = <String, Object?>{};
    if (edit != null) {
      json[r'edit'] = edit;
    }
    if (create != null) {
      json[r'create'] = create;
    }
    if (view != null) {
      json[r'view'] = view;
    }
    if (default$ != null) {
      json[r'default'] = default$;
    }
    return json;
  }

  ScreenTypes copyWith({int? edit, int? create, int? view, int? default$}) {
    return ScreenTypes(
      edit: edit ?? this.edit,
      create: create ?? this.create,
      view: view ?? this.view,
      default$: default$ ?? this.default$,
    );
  }
}

/// Details of a screen scheme.
class ScreenSchemeDetails {
  /// The name of the screen scheme. The name must be unique. The maximum length
  /// is 255 characters.
  final String name;

  /// The description of the screen scheme. The maximum length is 255
  /// characters.
  final String? description;

  /// The IDs of the screens for the screen types of the screen scheme. Only
  /// screens used in classic projects are accepted.
  final ScreenTypes screens;

  ScreenSchemeDetails(
      {required this.name, this.description, required this.screens});

  factory ScreenSchemeDetails.fromJson(Map<String, Object?> json) {
    return ScreenSchemeDetails(
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
      screens: ScreenTypes.fromJson(
          json[r'screens'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;
    var screens = this.screens;

    final json = <String, Object?>{};
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'screens'] = screens.toJson();
    return json;
  }

  ScreenSchemeDetails copyWith(
      {String? name, String? description, ScreenTypes? screens}) {
    return ScreenSchemeDetails(
      name: name ?? this.name,
      description: description ?? this.description,
      screens: screens ?? this.screens,
    );
  }
}

/// The ID of a screen scheme.
class ScreenSchemeId {
  /// The ID of the screen scheme.
  final int id;

  ScreenSchemeId({required this.id});

  factory ScreenSchemeId.fromJson(Map<String, Object?> json) {
    return ScreenSchemeId(
      id: (json[r'id'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  ScreenSchemeId copyWith({int? id}) {
    return ScreenSchemeId(
      id: id ?? this.id,
    );
  }
}

/// Details of a screen scheme.
class UpdateScreenSchemeDetails {
  /// The name of the screen scheme. The name must be unique. The maximum length
  /// is 255 characters.
  final String? name;

  /// The description of the screen scheme. The maximum length is 255
  /// characters.
  final String? description;

  /// The IDs of the screens for the screen types of the screen scheme. Only
  /// screens used in classic projects are accepted.
  final UpdateScreenTypes? screens;

  UpdateScreenSchemeDetails({this.name, this.description, this.screens});

  factory UpdateScreenSchemeDetails.fromJson(Map<String, Object?> json) {
    return UpdateScreenSchemeDetails(
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      screens: json[r'screens'] != null
          ? UpdateScreenTypes.fromJson(
              json[r'screens']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;
    var screens = this.screens;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (screens != null) {
      json[r'screens'] = screens.toJson();
    }
    return json;
  }

  UpdateScreenSchemeDetails copyWith(
      {String? name, String? description, UpdateScreenTypes? screens}) {
    return UpdateScreenSchemeDetails(
      name: name ?? this.name,
      description: description ?? this.description,
      screens: screens ?? this.screens,
    );
  }
}

/// The IDs of the screens for the screen types of the screen scheme.
class UpdateScreenTypes {
  /// The ID of the edit screen. To remove the screen association, pass a null.
  final String? edit;

  /// The ID of the create screen. To remove the screen association, pass a
  /// null.
  final String? create;

  /// The ID of the view screen. To remove the screen association, pass a null.
  final String? view;

  /// The ID of the default screen. When specified, must include a screen ID as
  /// a default screen is required.
  final String? default$;

  UpdateScreenTypes({this.edit, this.create, this.view, this.default$});

  factory UpdateScreenTypes.fromJson(Map<String, Object?> json) {
    return UpdateScreenTypes(
      edit: json[r'edit'] as String?,
      create: json[r'create'] as String?,
      view: json[r'view'] as String?,
      default$: json[r'default'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var edit = this.edit;
    var create = this.create;
    var view = this.view;
    var default$ = this.default$;

    final json = <String, Object?>{};
    if (edit != null) {
      json[r'edit'] = edit;
    }
    if (create != null) {
      json[r'create'] = create;
    }
    if (view != null) {
      json[r'view'] = view;
    }
    if (default$ != null) {
      json[r'default'] = default$;
    }
    return json;
  }

  UpdateScreenTypes copyWith(
      {String? edit, String? create, String? view, String? default$}) {
    return UpdateScreenTypes(
      edit: edit ?? this.edit,
      create: create ?? this.create,
      view: view ?? this.view,
      default$: default$ ?? this.default$,
    );
  }
}

/// A project's sender email address.
class ProjectEmailAddress {
  /// The email address.
  final String? emailAddress;

  ProjectEmailAddress({this.emailAddress});

  factory ProjectEmailAddress.fromJson(Map<String, Object?> json) {
    return ProjectEmailAddress(
      emailAddress: json[r'emailAddress'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var emailAddress = this.emailAddress;

    final json = <String, Object?>{};
    if (emailAddress != null) {
      json[r'emailAddress'] = emailAddress;
    }
    return json;
  }

  ProjectEmailAddress copyWith({String? emailAddress}) {
    return ProjectEmailAddress(
      emailAddress: emailAddress ?? this.emailAddress,
    );
  }
}

/// Details about a project type.
class ProjectType {
  /// The key of the project type.
  final String? key;

  /// The formatted key of the project type.
  final String? formattedKey;

  /// The key of the project type's description.
  final String? descriptionI18nKey;

  /// The icon of the project type.
  final String? icon;

  /// The color of the project type.
  final String? color;

  ProjectType(
      {this.key,
      this.formattedKey,
      this.descriptionI18nKey,
      this.icon,
      this.color});

  factory ProjectType.fromJson(Map<String, Object?> json) {
    return ProjectType(
      key: json[r'key'] as String?,
      formattedKey: json[r'formattedKey'] as String?,
      descriptionI18nKey: json[r'descriptionI18nKey'] as String?,
      icon: json[r'icon'] as String?,
      color: json[r'color'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var formattedKey = this.formattedKey;
    var descriptionI18nKey = this.descriptionI18nKey;
    var icon = this.icon;
    var color = this.color;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key;
    }
    if (formattedKey != null) {
      json[r'formattedKey'] = formattedKey;
    }
    if (descriptionI18nKey != null) {
      json[r'descriptionI18nKey'] = descriptionI18nKey;
    }
    if (icon != null) {
      json[r'icon'] = icon;
    }
    if (color != null) {
      json[r'color'] = color;
    }
    return json;
  }

  ProjectType copyWith(
      {String? key,
      String? formattedKey,
      String? descriptionI18nKey,
      String? icon,
      String? color}) {
    return ProjectType(
      key: key ?? this.key,
      formattedKey: formattedKey ?? this.formattedKey,
      descriptionI18nKey: descriptionI18nKey ?? this.descriptionI18nKey,
      icon: icon ?? this.icon,
      color: color ?? this.color,
    );
  }
}

/// Details of a dashboard.
class Dashboard {
  final String? description;

  /// The ID of the dashboard.
  final String? id;

  /// Whether the dashboard is selected as a favorite by the user.
  final bool isFavourite;

  /// The name of the dashboard.
  final String? name;

  /// The owner of the dashboard.
  final UserBean? owner;

  /// The number of users who have this dashboard as a favorite.
  final int? popularity;

  /// The rank of this dashboard.
  final int? rank;

  /// The URL of these dashboard details.
  final String? self;

  /// The details of any share permissions for the dashboard.
  final List<SharePermission> sharePermissions;

  /// The URL of the dashboard.
  final String? view;

  Dashboard(
      {this.description,
      this.id,
      bool? isFavourite,
      this.name,
      this.owner,
      this.popularity,
      this.rank,
      this.self,
      List<SharePermission>? sharePermissions,
      this.view})
      : isFavourite = isFavourite ?? false,
        sharePermissions = sharePermissions ?? [];

  factory Dashboard.fromJson(Map<String, Object?> json) {
    return Dashboard(
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      isFavourite: json[r'isFavourite'] as bool? ?? false,
      name: json[r'name'] as String?,
      owner: json[r'owner'] != null
          ? UserBean.fromJson(json[r'owner']! as Map<String, Object?>)
          : null,
      popularity: (json[r'popularity'] as num?)?.toInt(),
      rank: (json[r'rank'] as num?)?.toInt(),
      self: json[r'self'] as String?,
      sharePermissions: (json[r'sharePermissions'] as List<Object?>?)
              ?.map((i) => SharePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      view: json[r'view'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var isFavourite = this.isFavourite;
    var name = this.name;
    var owner = this.owner;
    var popularity = this.popularity;
    var rank = this.rank;
    var self = this.self;
    var sharePermissions = this.sharePermissions;
    var view = this.view;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'isFavourite'] = isFavourite;
    if (name != null) {
      json[r'name'] = name;
    }
    if (owner != null) {
      json[r'owner'] = owner.toJson();
    }
    if (popularity != null) {
      json[r'popularity'] = popularity;
    }
    if (rank != null) {
      json[r'rank'] = rank;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'sharePermissions'] =
        sharePermissions.map((i) => i.toJson()).toList();
    if (view != null) {
      json[r'view'] = view;
    }
    return json;
  }

  Dashboard copyWith(
      {String? description,
      String? id,
      bool? isFavourite,
      String? name,
      UserBean? owner,
      int? popularity,
      int? rank,
      String? self,
      List<SharePermission>? sharePermissions,
      String? view}) {
    return Dashboard(
      description: description ?? this.description,
      id: id ?? this.id,
      isFavourite: isFavourite ?? this.isFavourite,
      name: name ?? this.name,
      owner: owner ?? this.owner,
      popularity: popularity ?? this.popularity,
      rank: rank ?? this.rank,
      self: self ?? this.self,
      sharePermissions: sharePermissions ?? this.sharePermissions,
      view: view ?? this.view,
    );
  }
}

/// A page containing dashboard details.
class PageOfDashboards {
  /// The index of the first item returned on the page.
  final int? startAt;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The number of results on the page.
  final int? total;

  /// The URL of the previous page of results, if any.
  final String? prev;

  /// The URL of the next page of results, if any.
  final String? next;

  /// List of dashboards.
  final List<Dashboard> dashboards;

  PageOfDashboards(
      {this.startAt,
      this.maxResults,
      this.total,
      this.prev,
      this.next,
      List<Dashboard>? dashboards})
      : dashboards = dashboards ?? [];

  factory PageOfDashboards.fromJson(Map<String, Object?> json) {
    return PageOfDashboards(
      startAt: (json[r'startAt'] as num?)?.toInt(),
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      prev: json[r'prev'] as String?,
      next: json[r'next'] as String?,
      dashboards: (json[r'dashboards'] as List<Object?>?)
              ?.map((i) =>
                  Dashboard.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var startAt = this.startAt;
    var maxResults = this.maxResults;
    var total = this.total;
    var prev = this.prev;
    var next = this.next;
    var dashboards = this.dashboards;

    final json = <String, Object?>{};
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    if (prev != null) {
      json[r'prev'] = prev;
    }
    if (next != null) {
      json[r'next'] = next;
    }
    json[r'dashboards'] = dashboards.map((i) => i.toJson()).toList();
    return json;
  }

  PageOfDashboards copyWith(
      {int? startAt,
      int? maxResults,
      int? total,
      String? prev,
      String? next,
      List<Dashboard>? dashboards}) {
    return PageOfDashboards(
      startAt: startAt ?? this.startAt,
      maxResults: maxResults ?? this.maxResults,
      total: total ?? this.total,
      prev: prev ?? this.prev,
      next: next ?? this.next,
      dashboards: dashboards ?? this.dashboards,
    );
  }
}

class UserBean {
  /// This property is deprecated in favor of `accountId` because of privacy
  /// changes. See the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  /// The key of the user.
  final String? key;

  /// The URL of the user.
  final String? self;

  /// This property is deprecated in favor of `accountId` because of privacy
  /// changes. See the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  /// The username of the user.
  final String? name;

  /// The display name of the user. Depending on the users privacy setting,
  /// this may return an alternative value.
  final String? displayName;

  /// Whether the user is active.
  final bool active;

  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
  final String? accountId;

  /// The avatars of the user.
  final UserBeanAvatarUrls? avatarUrls;

  UserBean(
      {this.key,
      this.self,
      this.name,
      this.displayName,
      bool? active,
      this.accountId,
      this.avatarUrls})
      : active = active ?? false;

  factory UserBean.fromJson(Map<String, Object?> json) {
    return UserBean(
      key: json[r'key'] as String?,
      self: json[r'self'] as String?,
      name: json[r'name'] as String?,
      displayName: json[r'displayName'] as String?,
      active: json[r'active'] as bool? ?? false,
      accountId: json[r'accountId'] as String?,
      avatarUrls: json[r'avatarUrls'] != null
          ? UserBeanAvatarUrls.fromJson(
              json[r'avatarUrls']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var self = this.self;
    var name = this.name;
    var displayName = this.displayName;
    var active = this.active;
    var accountId = this.accountId;
    var avatarUrls = this.avatarUrls;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    json[r'active'] = active;
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (avatarUrls != null) {
      json[r'avatarUrls'] = avatarUrls.toJson();
    }
    return json;
  }

  UserBean copyWith(
      {String? key,
      String? self,
      String? name,
      String? displayName,
      bool? active,
      String? accountId,
      UserBeanAvatarUrls? avatarUrls}) {
    return UserBean(
      key: key ?? this.key,
      self: self ?? this.self,
      name: name ?? this.name,
      displayName: displayName ?? this.displayName,
      active: active ?? this.active,
      accountId: accountId ?? this.accountId,
      avatarUrls: avatarUrls ?? this.avatarUrls,
    );
  }
}

class UserBeanAvatarUrls {
  /// The URL of the user's 24x24 pixel avatar.
  final String? $24X24;

  /// The URL of the user's 32x32 pixel avatar.
  final String? $32X32;

  /// The URL of the user's 16x16 pixel avatar.
  final String? $16X16;

  /// The URL of the user's 48x48 pixel avatar.
  final String? $48X48;

  UserBeanAvatarUrls({this.$24X24, this.$32X32, this.$16X16, this.$48X48});

  factory UserBeanAvatarUrls.fromJson(Map<String, Object?> json) {
    return UserBeanAvatarUrls(
      $24X24: json[r'24x24'] as String?,
      $32X32: json[r'32x32'] as String?,
      $16X16: json[r'16x16'] as String?,
      $48X48: json[r'48x48'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var $24X24 = this.$24X24;
    var $32X32 = this.$32X32;
    var $16X16 = this.$16X16;
    var $48X48 = this.$48X48;

    final json = <String, Object?>{};
    if ($24X24 != null) {
      json[r'24x24'] = $24X24;
    }
    if ($32X32 != null) {
      json[r'32x32'] = $32X32;
    }
    if ($16X16 != null) {
      json[r'16x16'] = $16X16;
    }
    if ($48X48 != null) {
      json[r'48x48'] = $48X48;
    }
    return json;
  }

  UserBeanAvatarUrls copyWith(
      {String? $24X24, String? $32X32, String? $16X16, String? $48X48}) {
    return UserBeanAvatarUrls(
      $24X24: $24X24 ?? this.$24X24,
      $32X32: $32X32 ?? this.$32X32,
      $16X16: $16X16 ?? this.$16X16,
      $48X48: $48X48 ?? this.$48X48,
    );
  }
}

/// A page of items.
class PageBeanDashboard {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<Dashboard> values;

  PageBeanDashboard(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<Dashboard>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanDashboard.fromJson(Map<String, Object?> json) {
    return PageBeanDashboard(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Dashboard.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanDashboard copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<Dashboard>? values}) {
    return PageBeanDashboard(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Details of a dashboard.
class DashboardDetails {
  /// The name of the dashboard.
  final String name;

  /// The description of the dashboard.
  final String? description;

  /// The details of any share permissions for the dashboard.
  final List<SharePermission> sharePermissions;

  DashboardDetails(
      {required this.name, this.description, required this.sharePermissions});

  factory DashboardDetails.fromJson(Map<String, Object?> json) {
    return DashboardDetails(
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String?,
      sharePermissions: (json[r'sharePermissions'] as List<Object?>?)
              ?.map((i) => SharePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;
    var sharePermissions = this.sharePermissions;

    final json = <String, Object?>{};
    json[r'name'] = name;
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'sharePermissions'] =
        sharePermissions.map((i) => i.toJson()).toList();
    return json;
  }

  DashboardDetails copyWith(
      {String? name,
      String? description,
      List<SharePermission>? sharePermissions}) {
    return DashboardDetails(
      name: name ?? this.name,
      description: description ?? this.description,
      sharePermissions: sharePermissions ?? this.sharePermissions,
    );
  }
}

/// A list of JQL queries to parse.
class JqlQueriesToParse {
  /// A list of queries to parse.
  final List<String> queries;

  JqlQueriesToParse({required this.queries});

  factory JqlQueriesToParse.fromJson(Map<String, Object?> json) {
    return JqlQueriesToParse(
      queries: (json[r'queries'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var queries = this.queries;

    final json = <String, Object?>{};
    json[r'queries'] = queries;
    return json;
  }

  JqlQueriesToParse copyWith({List<String>? queries}) {
    return JqlQueriesToParse(
      queries: queries ?? this.queries,
    );
  }
}

/// A JQL query clause that consists of nested clauses. For example, `(labels in
/// (urgent, blocker) OR lastCommentedBy = currentUser()). Note that, where
/// nesting is not defined, the parser nests JQL clauses based on the operator
/// precedence. For example, "A OR B AND C" is parsed as "(A OR B) AND C". See
/// Setting the precedence of operators for more information about precedence in
/// JQL queries.`
class CompoundClause {
  /// The list of nested clauses.
  final List<JqlQueryClause> clauses;

  /// The operator between the clauses.
  final CompoundClauseOperator operator$;

  CompoundClause({required this.clauses, required this.operator$});

  factory CompoundClause.fromJson(Map<String, Object?> json) {
    return CompoundClause(
      clauses: (json[r'clauses'] as List<Object?>?)
              ?.map((i) => JqlQueryClause.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      operator$:
          CompoundClauseOperator.fromValue(json[r'operator'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var clauses = this.clauses;
    var operator$ = this.operator$;

    final json = <String, Object?>{};
    json[r'clauses'] = clauses.map((i) => i.toJson()).toList();
    json[r'operator'] = operator$.value;
    return json;
  }

  CompoundClause copyWith(
      {List<JqlQueryClause>? clauses, CompoundClauseOperator? operator$}) {
    return CompoundClause(
      clauses: clauses ?? this.clauses,
      operator$: operator$ ?? this.operator$,
    );
  }
}

class CompoundClauseOperator {
  static const and = CompoundClauseOperator._('and');
  static const or = CompoundClauseOperator._('or');
  static const not = CompoundClauseOperator._('not');

  static const values = [
    and,
    or,
    not,
  ];
  final String value;

  const CompoundClauseOperator._(this.value);

  static CompoundClauseOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CompoundClauseOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A clause that asserts whether a field was changed. For example, `status
/// CHANGED AFTER startOfMonth(-1M)`.See
/// [CHANGED](https://confluence.atlassian.com/x/dgiiLQ#Advancedsearching-operatorsreference-CHANGEDCHANGED)
/// for more information about the CHANGED operator.
class FieldChangedClause {
  final JqlQueryField field;

  /// The operator applied to the field.
  final FieldChangedClauseOperator operator$;

  /// The list of time predicates.
  final List<JqlQueryClauseTimePredicate> predicates;

  FieldChangedClause(
      {required this.field, required this.operator$, required this.predicates});

  factory FieldChangedClause.fromJson(Map<String, Object?> json) {
    return FieldChangedClause(
      field: JqlQueryField.fromJson(
          json[r'field'] as Map<String, Object?>? ?? const {}),
      operator$: FieldChangedClauseOperator.fromValue(
          json[r'operator'] as String? ?? ''),
      predicates: (json[r'predicates'] as List<Object?>?)
              ?.map((i) => JqlQueryClauseTimePredicate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var field = this.field;
    var operator$ = this.operator$;
    var predicates = this.predicates;

    final json = <String, Object?>{};
    json[r'field'] = field.toJson();
    json[r'operator'] = operator$.value;
    json[r'predicates'] = predicates.map((i) => i.toJson()).toList();
    return json;
  }

  FieldChangedClause copyWith(
      {JqlQueryField? field,
      FieldChangedClauseOperator? operator$,
      List<JqlQueryClauseTimePredicate>? predicates}) {
    return FieldChangedClause(
      field: field ?? this.field,
      operator$: operator$ ?? this.operator$,
      predicates: predicates ?? this.predicates,
    );
  }
}

class FieldChangedClauseOperator {
  static const changed = FieldChangedClauseOperator._('changed');

  static const values = [
    changed,
  ];
  final String value;

  const FieldChangedClauseOperator._(this.value);

  static FieldChangedClauseOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldChangedClauseOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A clause that asserts the current value of a field. For example, `summary ~
/// test`.
class FieldValueClause {
  final JqlQueryField field;

  /// The operator between the field and operand.
  final FieldValueClauseOperator operator$;
  final JqlQueryClauseOperand operand;

  FieldValueClause(
      {required this.field, required this.operator$, required this.operand});

  factory FieldValueClause.fromJson(Map<String, Object?> json) {
    return FieldValueClause(
      field: JqlQueryField.fromJson(
          json[r'field'] as Map<String, Object?>? ?? const {}),
      operator$: FieldValueClauseOperator.fromValue(
          json[r'operator'] as String? ?? ''),
      operand: JqlQueryClauseOperand.fromJson(
          json[r'operand'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var field = this.field;
    var operator$ = this.operator$;
    var operand = this.operand;

    final json = <String, Object?>{};
    json[r'field'] = field.toJson();
    json[r'operator'] = operator$.value;
    json[r'operand'] = operand.toJson();
    return json;
  }

  FieldValueClause copyWith(
      {JqlQueryField? field,
      FieldValueClauseOperator? operator$,
      JqlQueryClauseOperand? operand}) {
    return FieldValueClause(
      field: field ?? this.field,
      operator$: operator$ ?? this.operator$,
      operand: operand ?? this.operand,
    );
  }
}

class FieldValueClauseOperator {
  static const equal = FieldValueClauseOperator._('=');
  static const different = FieldValueClauseOperator._('!=');
  static const greaterThan = FieldValueClauseOperator._('>');
  static const lessThan = FieldValueClauseOperator._('<');
  static const greaterThanOrEquals = FieldValueClauseOperator._('>=');
  static const lessThanOrEquals = FieldValueClauseOperator._('<=');
  static const in$ = FieldValueClauseOperator._('in');
  static const notIn = FieldValueClauseOperator._('not in');
  static const tilde = FieldValueClauseOperator._('~');
  static const tildeEqual = FieldValueClauseOperator._('~=');
  static const is$ = FieldValueClauseOperator._('is');
  static const isNot = FieldValueClauseOperator._('is not');

  static const values = [
    equal,
    different,
    greaterThan,
    lessThan,
    greaterThanOrEquals,
    lessThanOrEquals,
    in$,
    notIn,
    tilde,
    tildeEqual,
    is$,
    isNot,
  ];
  final String value;

  const FieldValueClauseOperator._(this.value);

  static FieldValueClauseOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldValueClauseOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A clause that asserts a previous value of a field. For example, `status WAS
/// "Resolved" BY currentUser() BEFORE "2019/02/02"`. See
/// [WAS](https://confluence.atlassian.com/x/dgiiLQ#Advancedsearching-operatorsreference-WASWAS)
/// for more information about the WAS operator.
class FieldWasClause {
  final JqlQueryField field;

  /// The operator between the field and operand.
  final FieldWasClauseOperator operator$;
  final JqlQueryClauseOperand operand;

  /// The list of time predicates.
  final List<JqlQueryClauseTimePredicate> predicates;

  FieldWasClause(
      {required this.field,
      required this.operator$,
      required this.operand,
      required this.predicates});

  factory FieldWasClause.fromJson(Map<String, Object?> json) {
    return FieldWasClause(
      field: JqlQueryField.fromJson(
          json[r'field'] as Map<String, Object?>? ?? const {}),
      operator$:
          FieldWasClauseOperator.fromValue(json[r'operator'] as String? ?? ''),
      operand: JqlQueryClauseOperand.fromJson(
          json[r'operand'] as Map<String, Object?>? ?? const {}),
      predicates: (json[r'predicates'] as List<Object?>?)
              ?.map((i) => JqlQueryClauseTimePredicate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var field = this.field;
    var operator$ = this.operator$;
    var operand = this.operand;
    var predicates = this.predicates;

    final json = <String, Object?>{};
    json[r'field'] = field.toJson();
    json[r'operator'] = operator$.value;
    json[r'operand'] = operand.toJson();
    json[r'predicates'] = predicates.map((i) => i.toJson()).toList();
    return json;
  }

  FieldWasClause copyWith(
      {JqlQueryField? field,
      FieldWasClauseOperator? operator$,
      JqlQueryClauseOperand? operand,
      List<JqlQueryClauseTimePredicate>? predicates}) {
    return FieldWasClause(
      field: field ?? this.field,
      operator$: operator$ ?? this.operator$,
      operand: operand ?? this.operand,
      predicates: predicates ?? this.predicates,
    );
  }
}

class FieldWasClauseOperator {
  static const was = FieldWasClauseOperator._('was');
  static const wasIn = FieldWasClauseOperator._('was in');
  static const wasNotIn = FieldWasClauseOperator._('was not in');
  static const wasNot = FieldWasClauseOperator._('was not');

  static const values = [
    was,
    wasIn,
    wasNotIn,
    wasNot,
  ];
  final String value;

  const FieldWasClauseOperator._(this.value);

  static FieldWasClauseOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldWasClauseOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// An operand that is a function. See
/// [Advanced searching - functions reference](https://confluence.atlassian.com/x/dwiiLQ)
/// for more information about JQL functions.
class FunctionOperand {
  /// The name of the function.
  final String function;

  /// The list of function arguments.
  final List<String> arguments;

  FunctionOperand({required this.function, required this.arguments});

  factory FunctionOperand.fromJson(Map<String, Object?> json) {
    return FunctionOperand(
      function: json[r'function'] as String? ?? '',
      arguments: (json[r'arguments'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var function = this.function;
    var arguments = this.arguments;

    final json = <String, Object?>{};
    json[r'function'] = function;
    json[r'arguments'] = arguments;
    return json;
  }

  FunctionOperand copyWith({String? function, List<String>? arguments}) {
    return FunctionOperand(
      function: function ?? this.function,
      arguments: arguments ?? this.arguments,
    );
  }
}

/// A parsed JQL query.
class JqlQuery {
  final JqlQueryClause? where;
  final JqlQueryOrderByClause? orderBy;

  JqlQuery({this.where, this.orderBy});

  factory JqlQuery.fromJson(Map<String, Object?> json) {
    return JqlQuery(
      where: json[r'where'] != null
          ? JqlQueryClause.fromJson(json[r'where']! as Map<String, Object?>)
          : null,
      orderBy: json[r'orderBy'] != null
          ? JqlQueryOrderByClause.fromJson(
              json[r'orderBy']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var where = this.where;
    var orderBy = this.orderBy;

    final json = <String, Object?>{};
    if (where != null) {
      json[r'where'] = where.toJson();
    }
    if (orderBy != null) {
      json[r'orderBy'] = orderBy.toJson();
    }
    return json;
  }

  JqlQuery copyWith({JqlQueryClause? where, JqlQueryOrderByClause? orderBy}) {
    return JqlQuery(
      where: where ?? this.where,
      orderBy: orderBy ?? this.orderBy,
    );
  }
}

/// A JQL query clause.
class JqlQueryClause {
  JqlQueryClause();

  factory JqlQueryClause.fromJson(Map<String, Object?> json) {
    return JqlQueryClause();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// Details of an operand in a JQL clause.
class JqlQueryClauseOperand {
  JqlQueryClauseOperand();

  factory JqlQueryClauseOperand.fromJson(Map<String, Object?> json) {
    return JqlQueryClauseOperand();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// A time predicate for a temporal JQL clause.
class JqlQueryClauseTimePredicate {
  /// The operator between the field and the operand.
  final JqlQueryClauseTimePredicateOperator operator$;
  final JqlQueryClauseOperand operand;

  JqlQueryClauseTimePredicate({required this.operator$, required this.operand});

  factory JqlQueryClauseTimePredicate.fromJson(Map<String, Object?> json) {
    return JqlQueryClauseTimePredicate(
      operator$: JqlQueryClauseTimePredicateOperator.fromValue(
          json[r'operator'] as String? ?? ''),
      operand: JqlQueryClauseOperand.fromJson(
          json[r'operand'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var operator$ = this.operator$;
    var operand = this.operand;

    final json = <String, Object?>{};
    json[r'operator'] = operator$.value;
    json[r'operand'] = operand.toJson();
    return json;
  }

  JqlQueryClauseTimePredicate copyWith(
      {JqlQueryClauseTimePredicateOperator? operator$,
      JqlQueryClauseOperand? operand}) {
    return JqlQueryClauseTimePredicate(
      operator$: operator$ ?? this.operator$,
      operand: operand ?? this.operand,
    );
  }
}

class JqlQueryClauseTimePredicateOperator {
  static const before = JqlQueryClauseTimePredicateOperator._('before');
  static const after = JqlQueryClauseTimePredicateOperator._('after');
  static const from = JqlQueryClauseTimePredicateOperator._('from');
  static const to = JqlQueryClauseTimePredicateOperator._('to');
  static const on = JqlQueryClauseTimePredicateOperator._('on');
  static const during = JqlQueryClauseTimePredicateOperator._('during');
  static const by = JqlQueryClauseTimePredicateOperator._('by');

  static const values = [
    before,
    after,
    from,
    to,
    on,
    during,
    by,
  ];
  final String value;

  const JqlQueryClauseTimePredicateOperator._(this.value);

  static JqlQueryClauseTimePredicateOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JqlQueryClauseTimePredicateOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A field used in a JQL query. See
/// [Advanced searching - fields reference](https://confluence.atlassian.com/x/dAiiLQ)
/// for more information about fields in JQL queries.
class JqlQueryField {
  /// The name of the field.
  final String name;

  /// When the field refers to a value in an entity property, details of the
  /// entity property value.
  final List<JqlQueryFieldEntityProperty> property;

  JqlQueryField(
      {required this.name, List<JqlQueryFieldEntityProperty>? property})
      : property = property ?? [];

  factory JqlQueryField.fromJson(Map<String, Object?> json) {
    return JqlQueryField(
      name: json[r'name'] as String? ?? '',
      property: (json[r'property'] as List<Object?>?)
              ?.map((i) => JqlQueryFieldEntityProperty.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var property = this.property;

    final json = <String, Object?>{};
    json[r'name'] = name;
    json[r'property'] = property.map((i) => i.toJson()).toList();
    return json;
  }

  JqlQueryField copyWith(
      {String? name, List<JqlQueryFieldEntityProperty>? property}) {
    return JqlQueryField(
      name: name ?? this.name,
      property: property ?? this.property,
    );
  }
}

/// Details of an entity property.
class JqlQueryFieldEntityProperty {
  /// The object on which the property is set.
  final String entity;

  /// The key of the property.
  final String key;

  /// The path in the property value to query.
  final String path;

  /// The type of the property value extraction. Not available if the extraction
  /// for the property is not registered on the instance with the
  /// [Entity property](https://developer.atlassian.com/cloud/jira/platform/modules/entity-property/)
  /// module.
  final JqlQueryFieldEntityPropertyType? type;

  JqlQueryFieldEntityProperty(
      {required this.entity, required this.key, required this.path, this.type});

  factory JqlQueryFieldEntityProperty.fromJson(Map<String, Object?> json) {
    return JqlQueryFieldEntityProperty(
      entity: json[r'entity'] as String? ?? '',
      key: json[r'key'] as String? ?? '',
      path: json[r'path'] as String? ?? '',
      type: json[r'type'] != null
          ? JqlQueryFieldEntityPropertyType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var entity = this.entity;
    var key = this.key;
    var path = this.path;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'entity'] = entity;
    json[r'key'] = key;
    json[r'path'] = path;
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  JqlQueryFieldEntityProperty copyWith(
      {String? entity,
      String? key,
      String? path,
      JqlQueryFieldEntityPropertyType? type}) {
    return JqlQueryFieldEntityProperty(
      entity: entity ?? this.entity,
      key: key ?? this.key,
      path: path ?? this.path,
      type: type ?? this.type,
    );
  }
}

class JqlQueryFieldEntityPropertyType {
  static const number = JqlQueryFieldEntityPropertyType._('number');
  static const string = JqlQueryFieldEntityPropertyType._('string');
  static const text = JqlQueryFieldEntityPropertyType._('text');
  static const date = JqlQueryFieldEntityPropertyType._('date');
  static const user = JqlQueryFieldEntityPropertyType._('user');

  static const values = [
    number,
    string,
    text,
    date,
    user,
  ];
  final String value;

  const JqlQueryFieldEntityPropertyType._(this.value);

  static JqlQueryFieldEntityPropertyType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JqlQueryFieldEntityPropertyType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of the order-by JQL clause.
class JqlQueryOrderByClause {
  /// The list of order-by clause fields and their ordering directives.
  final List<JqlQueryOrderByClauseElement> fields;

  JqlQueryOrderByClause({required this.fields});

  factory JqlQueryOrderByClause.fromJson(Map<String, Object?> json) {
    return JqlQueryOrderByClause(
      fields: (json[r'fields'] as List<Object?>?)
              ?.map((i) => JqlQueryOrderByClauseElement.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var fields = this.fields;

    final json = <String, Object?>{};
    json[r'fields'] = fields.map((i) => i.toJson()).toList();
    return json;
  }

  JqlQueryOrderByClause copyWith({List<JqlQueryOrderByClauseElement>? fields}) {
    return JqlQueryOrderByClause(
      fields: fields ?? this.fields,
    );
  }
}

/// An element of the order-by JQL clause.
class JqlQueryOrderByClauseElement {
  final JqlQueryField field;

  /// The direction in which to order the results.
  final JqlQueryOrderByClauseElementDirection? direction;

  JqlQueryOrderByClauseElement({required this.field, this.direction});

  factory JqlQueryOrderByClauseElement.fromJson(Map<String, Object?> json) {
    return JqlQueryOrderByClauseElement(
      field: JqlQueryField.fromJson(
          json[r'field'] as Map<String, Object?>? ?? const {}),
      direction: json[r'direction'] != null
          ? JqlQueryOrderByClauseElementDirection.fromValue(
              json[r'direction']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var field = this.field;
    var direction = this.direction;

    final json = <String, Object?>{};
    json[r'field'] = field.toJson();
    if (direction != null) {
      json[r'direction'] = direction.value;
    }
    return json;
  }

  JqlQueryOrderByClauseElement copyWith(
      {JqlQueryField? field,
      JqlQueryOrderByClauseElementDirection? direction}) {
    return JqlQueryOrderByClauseElement(
      field: field ?? this.field,
      direction: direction ?? this.direction,
    );
  }
}

class JqlQueryOrderByClauseElementDirection {
  static const asc = JqlQueryOrderByClauseElementDirection._('asc');
  static const desc = JqlQueryOrderByClauseElementDirection._('desc');

  static const values = [
    asc,
    desc,
  ];
  final String value;

  const JqlQueryOrderByClauseElementDirection._(this.value);

  static JqlQueryOrderByClauseElementDirection fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JqlQueryOrderByClauseElementDirection._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// An operand that can be part of a list operand.
class JqlQueryUnitaryOperand {
  JqlQueryUnitaryOperand();

  factory JqlQueryUnitaryOperand.fromJson(Map<String, Object?> json) {
    return JqlQueryUnitaryOperand();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// An operand that is a JQL keyword. See
/// [Advanced searching - keywords reference](https://confluence.atlassian.com/jiracorecloud/advanced-searching-keywords-reference-765593717.html#Advancedsearching-keywordsreference-EMPTYEMPTY)
/// for more information about operand keywords.
class KeywordOperand {
  /// The keyword that is the operand value.
  final KeywordOperandKeyword keyword;

  KeywordOperand({required this.keyword});

  factory KeywordOperand.fromJson(Map<String, Object?> json) {
    return KeywordOperand(
      keyword:
          KeywordOperandKeyword.fromValue(json[r'keyword'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var keyword = this.keyword;

    final json = <String, Object?>{};
    json[r'keyword'] = keyword.value;
    return json;
  }

  KeywordOperand copyWith({KeywordOperandKeyword? keyword}) {
    return KeywordOperand(
      keyword: keyword ?? this.keyword,
    );
  }
}

class KeywordOperandKeyword {
  static const empty = KeywordOperandKeyword._('empty');

  static const values = [
    empty,
  ];
  final String value;

  const KeywordOperandKeyword._(this.value);

  static KeywordOperandKeyword fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => KeywordOperandKeyword._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// An operand that is a list of values.
class ListOperand {
  /// The list of operand values.
  final List<JqlQueryUnitaryOperand> values;

  ListOperand({required this.values});

  factory ListOperand.fromJson(Map<String, Object?> json) {
    return ListOperand(
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => JqlQueryUnitaryOperand.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var values = this.values;

    final json = <String, Object?>{};
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  ListOperand copyWith({List<JqlQueryUnitaryOperand>? values}) {
    return ListOperand(
      values: values ?? this.values,
    );
  }
}

/// A list of parsed JQL queries.
class ParsedJqlQueries {
  /// A list of parsed JQL queries.
  final List<ParsedJqlQuery> queries;

  ParsedJqlQueries({required this.queries});

  factory ParsedJqlQueries.fromJson(Map<String, Object?> json) {
    return ParsedJqlQueries(
      queries: (json[r'queries'] as List<Object?>?)
              ?.map((i) => ParsedJqlQuery.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var queries = this.queries;

    final json = <String, Object?>{};
    json[r'queries'] = queries.map((i) => i.toJson()).toList();
    return json;
  }

  ParsedJqlQueries copyWith({List<ParsedJqlQuery>? queries}) {
    return ParsedJqlQueries(
      queries: queries ?? this.queries,
    );
  }
}

/// Details of a parsed JQL query.
class ParsedJqlQuery {
  /// The JQL query that was parsed and validated.
  final String query;

  /// The syntax tree of the query. Empty if the query was invalid.
  final JqlQuery? structure;

  /// The list of syntax or validation errors.
  final List<String> errors;

  ParsedJqlQuery({required this.query, this.structure, List<String>? errors})
      : errors = errors ?? [];

  factory ParsedJqlQuery.fromJson(Map<String, Object?> json) {
    return ParsedJqlQuery(
      query: json[r'query'] as String? ?? '',
      structure: json[r'structure'] != null
          ? JqlQuery.fromJson(json[r'structure']! as Map<String, Object?>)
          : null,
      errors: (json[r'errors'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var query = this.query;
    var structure = this.structure;
    var errors = this.errors;

    final json = <String, Object?>{};
    json[r'query'] = query;
    if (structure != null) {
      json[r'structure'] = structure.toJson();
    }
    json[r'errors'] = errors;
    return json;
  }

  ParsedJqlQuery copyWith(
      {String? query, JqlQuery? structure, List<String>? errors}) {
    return ParsedJqlQuery(
      query: query ?? this.query,
      structure: structure ?? this.structure,
      errors: errors ?? this.errors,
    );
  }
}

/// An operand that is a user-provided value.
class ValueOperand {
  /// The operand value.
  final String value;

  ValueOperand({required this.value});

  factory ValueOperand.fromJson(Map<String, Object?> json) {
    return ValueOperand(
      value: json[r'value'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;

    final json = <String, Object?>{};
    json[r'value'] = value;
    return json;
  }

  ValueOperand copyWith({String? value}) {
    return ValueOperand(
      value: value ?? this.value,
    );
  }
}

/// Details of an issue type.
class IssueTypeInfo {
  /// The ID of the issue type.
  final int? id;

  /// The name of the issue type.
  final String? name;

  /// The avatar of the issue type.
  final int? avatarId;

  IssueTypeInfo({this.id, this.name, this.avatarId});

  factory IssueTypeInfo.fromJson(Map<String, Object?> json) {
    return IssueTypeInfo(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      avatarId: (json[r'avatarId'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var avatarId = this.avatarId;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (avatarId != null) {
      json[r'avatarId'] = avatarId;
    }
    return json;
  }

  IssueTypeInfo copyWith({int? id, String? name, int? avatarId}) {
    return IssueTypeInfo(
      id: id ?? this.id,
      name: name ?? this.name,
      avatarId: avatarId ?? this.avatarId,
    );
  }
}

/// The hierarchy of issue types within a project.
class ProjectIssueTypeHierarchy {
  /// The ID of the project.
  final int? projectId;

  /// Details of an issue type hierarchy level.
  final List<ProjectIssueTypesHierarchyLevel> hierarchy;

  ProjectIssueTypeHierarchy(
      {this.projectId, List<ProjectIssueTypesHierarchyLevel>? hierarchy})
      : hierarchy = hierarchy ?? [];

  factory ProjectIssueTypeHierarchy.fromJson(Map<String, Object?> json) {
    return ProjectIssueTypeHierarchy(
      projectId: (json[r'projectId'] as num?)?.toInt(),
      hierarchy: (json[r'hierarchy'] as List<Object?>?)
              ?.map((i) => ProjectIssueTypesHierarchyLevel.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var projectId = this.projectId;
    var hierarchy = this.hierarchy;

    final json = <String, Object?>{};
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    json[r'hierarchy'] = hierarchy.map((i) => i.toJson()).toList();
    return json;
  }

  ProjectIssueTypeHierarchy copyWith(
      {int? projectId, List<ProjectIssueTypesHierarchyLevel>? hierarchy}) {
    return ProjectIssueTypeHierarchy(
      projectId: projectId ?? this.projectId,
      hierarchy: hierarchy ?? this.hierarchy,
    );
  }
}

/// Details of an issue type hierarchy level.
class ProjectIssueTypesHierarchyLevel {
  /// The ID of the issue type hierarchy level. This property is deprecated, see
  /// [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final String? entityId;

  /// The level of the issue type hierarchy level.
  final int? level;

  /// The name of the issue type hierarchy level.
  final String? name;

  /// The list of issue types in the hierarchy level.
  final List<IssueTypeInfo> issueTypes;

  ProjectIssueTypesHierarchyLevel(
      {this.entityId, this.level, this.name, List<IssueTypeInfo>? issueTypes})
      : issueTypes = issueTypes ?? [];

  factory ProjectIssueTypesHierarchyLevel.fromJson(Map<String, Object?> json) {
    return ProjectIssueTypesHierarchyLevel(
      entityId: json[r'entityId'] as String?,
      level: (json[r'level'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      issueTypes: (json[r'issueTypes'] as List<Object?>?)
              ?.map((i) => IssueTypeInfo.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var entityId = this.entityId;
    var level = this.level;
    var name = this.name;
    var issueTypes = this.issueTypes;

    final json = <String, Object?>{};
    if (entityId != null) {
      json[r'entityId'] = entityId;
    }
    if (level != null) {
      json[r'level'] = level;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'issueTypes'] = issueTypes.map((i) => i.toJson()).toList();
    return json;
  }

  ProjectIssueTypesHierarchyLevel copyWith(
      {String? entityId,
      int? level,
      String? name,
      List<IssueTypeInfo>? issueTypes}) {
    return ProjectIssueTypesHierarchyLevel(
      entityId: entityId ?? this.entityId,
      level: level ?? this.level,
      name: name ?? this.name,
      issueTypes: issueTypes ?? this.issueTypes,
    );
  }
}

/// Details about a workflow.
class DeprecatedWorkflow {
  /// The name of the workflow.
  final String? name;

  /// The description of the workflow.
  final String? description;

  /// The datetime the workflow was last modified.
  final String? lastModifiedDate;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? lastModifiedUser;

  /// The account ID of the user that last modified the workflow.
  final String? lastModifiedUserAccountId;

  /// The number of steps included in the workflow.
  final int? steps;

  /// The scope where this workflow applies
  final Scope? scope;
  final bool default$;

  DeprecatedWorkflow(
      {this.name,
      this.description,
      this.lastModifiedDate,
      this.lastModifiedUser,
      this.lastModifiedUserAccountId,
      this.steps,
      this.scope,
      bool? default$})
      : default$ = default$ ?? false;

  factory DeprecatedWorkflow.fromJson(Map<String, Object?> json) {
    return DeprecatedWorkflow(
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      lastModifiedDate: json[r'lastModifiedDate'] as String?,
      lastModifiedUser: json[r'lastModifiedUser'] as String?,
      lastModifiedUserAccountId: json[r'lastModifiedUserAccountId'] as String?,
      steps: (json[r'steps'] as num?)?.toInt(),
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      default$: json[r'default'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var description = this.description;
    var lastModifiedDate = this.lastModifiedDate;
    var lastModifiedUser = this.lastModifiedUser;
    var lastModifiedUserAccountId = this.lastModifiedUserAccountId;
    var steps = this.steps;
    var scope = this.scope;
    var default$ = this.default$;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (lastModifiedDate != null) {
      json[r'lastModifiedDate'] = lastModifiedDate;
    }
    if (lastModifiedUser != null) {
      json[r'lastModifiedUser'] = lastModifiedUser;
    }
    if (lastModifiedUserAccountId != null) {
      json[r'lastModifiedUserAccountId'] = lastModifiedUserAccountId;
    }
    if (steps != null) {
      json[r'steps'] = steps;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    json[r'default'] = default$;
    return json;
  }

  DeprecatedWorkflow copyWith(
      {String? name,
      String? description,
      String? lastModifiedDate,
      String? lastModifiedUser,
      String? lastModifiedUserAccountId,
      int? steps,
      Scope? scope,
      bool? default$}) {
    return DeprecatedWorkflow(
      name: name ?? this.name,
      description: description ?? this.description,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      lastModifiedUser: lastModifiedUser ?? this.lastModifiedUser,
      lastModifiedUserAccountId:
          lastModifiedUserAccountId ?? this.lastModifiedUserAccountId,
      steps: steps ?? this.steps,
      scope: scope ?? this.scope,
      default$: default$ ?? this.default$,
    );
  }
}

/// Details about the server Jira is running on.
class WorkflowTransitionProperty {
  /// The key of the transition property. Also known as the name of the
  /// transition property.
  final String? key;

  /// The value of the transition property.
  final String value;

  /// The ID of the transition property.
  final String? id;

  WorkflowTransitionProperty({this.key, required this.value, this.id});

  factory WorkflowTransitionProperty.fromJson(Map<String, Object?> json) {
    return WorkflowTransitionProperty(
      key: json[r'key'] as String?,
      value: json[r'value'] as String? ?? '',
      id: json[r'id'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var value = this.value;
    var id = this.id;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key;
    }
    json[r'value'] = value;
    if (id != null) {
      json[r'id'] = id;
    }
    return json;
  }

  WorkflowTransitionProperty copyWith(
      {String? key, String? value, String? id}) {
    return WorkflowTransitionProperty(
      key: key ?? this.key,
      value: value ?? this.value,
      id: id ?? this.id,
    );
  }
}

/// Details about the configuration of Jira.
class Configuration {
  /// Whether the ability for users to vote on issues is enabled. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  final bool votingEnabled;

  /// Whether the ability for users to watch issues is enabled. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  final bool watchingEnabled;

  /// Whether the ability to create unassigned issues is enabled. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  final bool unassignedIssuesAllowed;

  /// Whether the ability to create subtasks for issues is enabled.
  final bool subTasksEnabled;

  /// Whether the ability to link issues is enabled.
  final bool issueLinkingEnabled;

  /// Whether the ability to track time is enabled. This property is deprecated.
  final bool timeTrackingEnabled;

  /// Whether the ability to add attachments to issues is enabled.
  final bool attachmentsEnabled;

  /// The configuration of time tracking.
  final TimeTrackingConfiguration? timeTrackingConfiguration;

  Configuration(
      {bool? votingEnabled,
      bool? watchingEnabled,
      bool? unassignedIssuesAllowed,
      bool? subTasksEnabled,
      bool? issueLinkingEnabled,
      bool? timeTrackingEnabled,
      bool? attachmentsEnabled,
      this.timeTrackingConfiguration})
      : votingEnabled = votingEnabled ?? false,
        watchingEnabled = watchingEnabled ?? false,
        unassignedIssuesAllowed = unassignedIssuesAllowed ?? false,
        subTasksEnabled = subTasksEnabled ?? false,
        issueLinkingEnabled = issueLinkingEnabled ?? false,
        timeTrackingEnabled = timeTrackingEnabled ?? false,
        attachmentsEnabled = attachmentsEnabled ?? false;

  factory Configuration.fromJson(Map<String, Object?> json) {
    return Configuration(
      votingEnabled: json[r'votingEnabled'] as bool? ?? false,
      watchingEnabled: json[r'watchingEnabled'] as bool? ?? false,
      unassignedIssuesAllowed:
          json[r'unassignedIssuesAllowed'] as bool? ?? false,
      subTasksEnabled: json[r'subTasksEnabled'] as bool? ?? false,
      issueLinkingEnabled: json[r'issueLinkingEnabled'] as bool? ?? false,
      timeTrackingEnabled: json[r'timeTrackingEnabled'] as bool? ?? false,
      attachmentsEnabled: json[r'attachmentsEnabled'] as bool? ?? false,
      timeTrackingConfiguration: json[r'timeTrackingConfiguration'] != null
          ? TimeTrackingConfiguration.fromJson(
              json[r'timeTrackingConfiguration']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var votingEnabled = this.votingEnabled;
    var watchingEnabled = this.watchingEnabled;
    var unassignedIssuesAllowed = this.unassignedIssuesAllowed;
    var subTasksEnabled = this.subTasksEnabled;
    var issueLinkingEnabled = this.issueLinkingEnabled;
    var timeTrackingEnabled = this.timeTrackingEnabled;
    var attachmentsEnabled = this.attachmentsEnabled;
    var timeTrackingConfiguration = this.timeTrackingConfiguration;

    final json = <String, Object?>{};
    json[r'votingEnabled'] = votingEnabled;
    json[r'watchingEnabled'] = watchingEnabled;
    json[r'unassignedIssuesAllowed'] = unassignedIssuesAllowed;
    json[r'subTasksEnabled'] = subTasksEnabled;
    json[r'issueLinkingEnabled'] = issueLinkingEnabled;
    json[r'timeTrackingEnabled'] = timeTrackingEnabled;
    json[r'attachmentsEnabled'] = attachmentsEnabled;
    if (timeTrackingConfiguration != null) {
      json[r'timeTrackingConfiguration'] = timeTrackingConfiguration.toJson();
    }
    return json;
  }

  Configuration copyWith(
      {bool? votingEnabled,
      bool? watchingEnabled,
      bool? unassignedIssuesAllowed,
      bool? subTasksEnabled,
      bool? issueLinkingEnabled,
      bool? timeTrackingEnabled,
      bool? attachmentsEnabled,
      TimeTrackingConfiguration? timeTrackingConfiguration}) {
    return Configuration(
      votingEnabled: votingEnabled ?? this.votingEnabled,
      watchingEnabled: watchingEnabled ?? this.watchingEnabled,
      unassignedIssuesAllowed:
          unassignedIssuesAllowed ?? this.unassignedIssuesAllowed,
      subTasksEnabled: subTasksEnabled ?? this.subTasksEnabled,
      issueLinkingEnabled: issueLinkingEnabled ?? this.issueLinkingEnabled,
      timeTrackingEnabled: timeTrackingEnabled ?? this.timeTrackingEnabled,
      attachmentsEnabled: attachmentsEnabled ?? this.attachmentsEnabled,
      timeTrackingConfiguration:
          timeTrackingConfiguration ?? this.timeTrackingConfiguration,
    );
  }
}

/// Details of the time tracking configuration.
class TimeTrackingConfiguration {
  /// The number of hours in a working day.
  final num workingHoursPerDay;

  /// The number of days in a working week.
  final num workingDaysPerWeek;

  /// The format that will appear on an issue's *Time Spent* field.
  final TimeTrackingConfigurationTimeFormat timeFormat;

  /// The default unit of time applied to logged time.
  final TimeTrackingConfigurationDefaultUnit defaultUnit;

  TimeTrackingConfiguration(
      {required this.workingHoursPerDay,
      required this.workingDaysPerWeek,
      required this.timeFormat,
      required this.defaultUnit});

  factory TimeTrackingConfiguration.fromJson(Map<String, Object?> json) {
    return TimeTrackingConfiguration(
      workingHoursPerDay: json[r'workingHoursPerDay'] as num? ?? 0,
      workingDaysPerWeek: json[r'workingDaysPerWeek'] as num? ?? 0,
      timeFormat: TimeTrackingConfigurationTimeFormat.fromValue(
          json[r'timeFormat'] as String? ?? ''),
      defaultUnit: TimeTrackingConfigurationDefaultUnit.fromValue(
          json[r'defaultUnit'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var workingHoursPerDay = this.workingHoursPerDay;
    var workingDaysPerWeek = this.workingDaysPerWeek;
    var timeFormat = this.timeFormat;
    var defaultUnit = this.defaultUnit;

    final json = <String, Object?>{};
    json[r'workingHoursPerDay'] = workingHoursPerDay;
    json[r'workingDaysPerWeek'] = workingDaysPerWeek;
    json[r'timeFormat'] = timeFormat.value;
    json[r'defaultUnit'] = defaultUnit.value;
    return json;
  }

  TimeTrackingConfiguration copyWith(
      {num? workingHoursPerDay,
      num? workingDaysPerWeek,
      TimeTrackingConfigurationTimeFormat? timeFormat,
      TimeTrackingConfigurationDefaultUnit? defaultUnit}) {
    return TimeTrackingConfiguration(
      workingHoursPerDay: workingHoursPerDay ?? this.workingHoursPerDay,
      workingDaysPerWeek: workingDaysPerWeek ?? this.workingDaysPerWeek,
      timeFormat: timeFormat ?? this.timeFormat,
      defaultUnit: defaultUnit ?? this.defaultUnit,
    );
  }
}

class TimeTrackingConfigurationTimeFormat {
  static const pretty = TimeTrackingConfigurationTimeFormat._('pretty');
  static const days = TimeTrackingConfigurationTimeFormat._('days');
  static const hours = TimeTrackingConfigurationTimeFormat._('hours');

  static const values = [
    pretty,
    days,
    hours,
  ];
  final String value;

  const TimeTrackingConfigurationTimeFormat._(this.value);

  static TimeTrackingConfigurationTimeFormat fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => TimeTrackingConfigurationTimeFormat._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class TimeTrackingConfigurationDefaultUnit {
  static const minute = TimeTrackingConfigurationDefaultUnit._('minute');
  static const hour = TimeTrackingConfigurationDefaultUnit._('hour');
  static const day = TimeTrackingConfigurationDefaultUnit._('day');
  static const week = TimeTrackingConfigurationDefaultUnit._('week');

  static const values = [
    minute,
    hour,
    day,
    week,
  ];
  final String value;

  const TimeTrackingConfigurationDefaultUnit._(this.value);

  static TimeTrackingConfigurationDefaultUnit fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => TimeTrackingConfigurationDefaultUnit._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of an application property.
class ApplicationProperty {
  /// The ID of the application property. The ID and key are the same.
  final String? id;

  /// The key of the application property. The ID and key are the same.
  final String? key;

  /// The new value.
  final String? value;

  /// The name of the application property.
  final String? name;

  /// The description of the application property.
  final String? desc;

  /// The data type of the application property.
  final String? type;

  /// The default value of the application property.
  final String? defaultValue;
  final String? example;

  /// The allowed values, if applicable.
  final List<String> allowedValues;

  ApplicationProperty(
      {this.id,
      this.key,
      this.value,
      this.name,
      this.desc,
      this.type,
      this.defaultValue,
      this.example,
      List<String>? allowedValues})
      : allowedValues = allowedValues ?? [];

  factory ApplicationProperty.fromJson(Map<String, Object?> json) {
    return ApplicationProperty(
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      value: json[r'value'] as String?,
      name: json[r'name'] as String?,
      desc: json[r'desc'] as String?,
      type: json[r'type'] as String?,
      defaultValue: json[r'defaultValue'] as String?,
      example: json[r'example'] as String?,
      allowedValues: (json[r'allowedValues'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;
    var value = this.value;
    var name = this.name;
    var desc = this.desc;
    var type = this.type;
    var defaultValue = this.defaultValue;
    var example = this.example;
    var allowedValues = this.allowedValues;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (desc != null) {
      json[r'desc'] = desc;
    }
    if (type != null) {
      json[r'type'] = type;
    }
    if (defaultValue != null) {
      json[r'defaultValue'] = defaultValue;
    }
    if (example != null) {
      json[r'example'] = example;
    }
    json[r'allowedValues'] = allowedValues;
    return json;
  }

  ApplicationProperty copyWith(
      {String? id,
      String? key,
      String? value,
      String? name,
      String? desc,
      String? type,
      String? defaultValue,
      String? example,
      List<String>? allowedValues}) {
    return ApplicationProperty(
      id: id ?? this.id,
      key: key ?? this.key,
      value: value ?? this.value,
      name: name ?? this.name,
      desc: desc ?? this.desc,
      type: type ?? this.type,
      defaultValue: defaultValue ?? this.defaultValue,
      example: example ?? this.example,
      allowedValues: allowedValues ?? this.allowedValues,
    );
  }
}

class SimpleApplicationPropertyBean {
  /// The ID of the application property.
  final String? id;

  /// The new value.
  final String? value;

  SimpleApplicationPropertyBean({this.id, this.value});

  factory SimpleApplicationPropertyBean.fromJson(Map<String, Object?> json) {
    return SimpleApplicationPropertyBean(
      id: json[r'id'] as String?,
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var value = this.value;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  SimpleApplicationPropertyBean copyWith({String? id, String? value}) {
    return SimpleApplicationPropertyBean(
      id: id ?? this.id,
      value: value ?? this.value,
    );
  }
}

/// List of all permission schemes.
class PermissionSchemes {
  /// Permission schemes list.
  final List<PermissionScheme> permissionSchemes;

  PermissionSchemes({List<PermissionScheme>? permissionSchemes})
      : permissionSchemes = permissionSchemes ?? [];

  factory PermissionSchemes.fromJson(Map<String, Object?> json) {
    return PermissionSchemes(
      permissionSchemes: (json[r'permissionSchemes'] as List<Object?>?)
              ?.map((i) => PermissionScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var permissionSchemes = this.permissionSchemes;

    final json = <String, Object?>{};
    json[r'permissionSchemes'] =
        permissionSchemes.map((i) => i.toJson()).toList();
    return json;
  }

  PermissionSchemes copyWith({List<PermissionScheme>? permissionSchemes}) {
    return PermissionSchemes(
      permissionSchemes: permissionSchemes ?? this.permissionSchemes,
    );
  }
}

/// List of permission grants.
class PermissionGrants {
  /// Permission grants list.
  final List<PermissionGrant> permissions;

  /// Expand options that include additional permission grant details in the
  /// response.
  final String? expand;

  PermissionGrants({List<PermissionGrant>? permissions, this.expand})
      : permissions = permissions ?? [];

  factory PermissionGrants.fromJson(Map<String, Object?> json) {
    return PermissionGrants(
      permissions: (json[r'permissions'] as List<Object?>?)
              ?.map((i) => PermissionGrant.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      expand: json[r'expand'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var permissions = this.permissions;
    var expand = this.expand;

    final json = <String, Object?>{};
    json[r'permissions'] = permissions.map((i) => i.toJson()).toList();
    if (expand != null) {
      json[r'expand'] = expand;
    }
    return json;
  }

  PermissionGrants copyWith(
      {List<PermissionGrant>? permissions, String? expand}) {
    return PermissionGrants(
      permissions: permissions ?? this.permissions,
      expand: expand ?? this.expand,
    );
  }
}

/// A page of items.
class PageBeanWorkflowScheme {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<WorkflowScheme> values;

  PageBeanWorkflowScheme(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<WorkflowScheme>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanWorkflowScheme.fromJson(Map<String, Object?> json) {
    return PageBeanWorkflowScheme(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => WorkflowScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanWorkflowScheme copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<WorkflowScheme>? values}) {
    return PageBeanWorkflowScheme(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Details about a workflow scheme.
class WorkflowScheme {
  /// The ID of the workflow scheme.
  final int? id;

  /// The name of the workflow scheme. The name must be unique. The maximum
  /// length is 255 characters. Required when creating a workflow scheme.
  final String? name;

  /// The description of the workflow scheme.
  final String? description;

  /// The name of the default workflow for the workflow scheme. The default
  /// workflow has *All Unassigned Issue Types* assigned to it in Jira. If
  /// `defaultWorkflow` is not specified when creating a workflow scheme, it is
  /// set to *Jira Workflow (jira)*.
  final String? defaultWorkflow;

  /// The issue type to workflow mappings, where each mapping is an issue type
  /// ID and workflow name pair. Note that an issue type can only be mapped to
  /// one workflow in a workflow scheme.
  final Map<String, dynamic>? issueTypeMappings;

  /// For draft workflow schemes, this property is the name of the default
  /// workflow for the original workflow scheme. The default workflow has *All
  /// Unassigned Issue Types* assigned to it in Jira.
  final String? originalDefaultWorkflow;

  /// For draft workflow schemes, this property is the issue type to workflow
  /// mappings for the original workflow scheme, where each mapping is an issue
  /// type ID and workflow name pair. Note that an issue type can only be mapped
  /// to one workflow in a workflow scheme.
  final Map<String, dynamic>? originalIssueTypeMappings;

  /// Whether the workflow scheme is a draft or not.
  final bool draft;

  /// The user that last modified the draft workflow scheme. A modification is a
  /// change to the issue type-project mappings only. This property does not
  /// apply to non-draft workflows.
  final User? lastModifiedUser;

  /// The date-time that the draft workflow scheme was last modified. A
  /// modification is a change to the issue type-project mappings only. This
  /// property does not apply to non-draft workflows.
  final String? lastModified;
  final String? self;

  /// Whether to create or update a draft workflow scheme when updating an
  /// active workflow scheme. An active workflow scheme is a workflow scheme
  /// that is used by at least one project. The following examples show how this
  /// property works:
  ///
  ///  *  Update an active workflow scheme with `updateDraftIfNeeded` set to
  /// `true`: If a draft workflow scheme exists, it is updated. Otherwise, a
  /// draft workflow scheme is created.
  ///  *  Update an active workflow scheme with `updateDraftIfNeeded` set to
  /// `false`: An error is returned, as active workflow schemes cannot be
  /// updated.
  ///  *  Update an inactive workflow scheme with `updateDraftIfNeeded` set to
  /// `true`: The workflow scheme is updated, as inactive workflow schemes do
  /// not require drafts to update.
  ///
  /// Defaults to `false`.
  final bool updateDraftIfNeeded;

  /// The issue types available in Jira.
  final Map<String, dynamic>? issueTypes;

  WorkflowScheme(
      {this.id,
      this.name,
      this.description,
      this.defaultWorkflow,
      this.issueTypeMappings,
      this.originalDefaultWorkflow,
      this.originalIssueTypeMappings,
      bool? draft,
      this.lastModifiedUser,
      this.lastModified,
      this.self,
      bool? updateDraftIfNeeded,
      this.issueTypes})
      : draft = draft ?? false,
        updateDraftIfNeeded = updateDraftIfNeeded ?? false;

  factory WorkflowScheme.fromJson(Map<String, Object?> json) {
    return WorkflowScheme(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      description: json[r'description'] as String?,
      defaultWorkflow: json[r'defaultWorkflow'] as String?,
      issueTypeMappings: json[r'issueTypeMappings'] as Map<String, Object?>?,
      originalDefaultWorkflow: json[r'originalDefaultWorkflow'] as String?,
      originalIssueTypeMappings:
          json[r'originalIssueTypeMappings'] as Map<String, Object?>?,
      draft: json[r'draft'] as bool? ?? false,
      lastModifiedUser: json[r'lastModifiedUser'] != null
          ? User.fromJson(json[r'lastModifiedUser']! as Map<String, Object?>)
          : null,
      lastModified: json[r'lastModified'] as String?,
      self: json[r'self'] as String?,
      updateDraftIfNeeded: json[r'updateDraftIfNeeded'] as bool? ?? false,
      issueTypes: json[r'issueTypes'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var defaultWorkflow = this.defaultWorkflow;
    var issueTypeMappings = this.issueTypeMappings;
    var originalDefaultWorkflow = this.originalDefaultWorkflow;
    var originalIssueTypeMappings = this.originalIssueTypeMappings;
    var draft = this.draft;
    var lastModifiedUser = this.lastModifiedUser;
    var lastModified = this.lastModified;
    var self = this.self;
    var updateDraftIfNeeded = this.updateDraftIfNeeded;
    var issueTypes = this.issueTypes;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (defaultWorkflow != null) {
      json[r'defaultWorkflow'] = defaultWorkflow;
    }
    if (issueTypeMappings != null) {
      json[r'issueTypeMappings'] = issueTypeMappings;
    }
    if (originalDefaultWorkflow != null) {
      json[r'originalDefaultWorkflow'] = originalDefaultWorkflow;
    }
    if (originalIssueTypeMappings != null) {
      json[r'originalIssueTypeMappings'] = originalIssueTypeMappings;
    }
    json[r'draft'] = draft;
    if (lastModifiedUser != null) {
      json[r'lastModifiedUser'] = lastModifiedUser.toJson();
    }
    if (lastModified != null) {
      json[r'lastModified'] = lastModified;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'updateDraftIfNeeded'] = updateDraftIfNeeded;
    if (issueTypes != null) {
      json[r'issueTypes'] = issueTypes;
    }
    return json;
  }

  WorkflowScheme copyWith(
      {int? id,
      String? name,
      String? description,
      String? defaultWorkflow,
      Map<String, dynamic>? issueTypeMappings,
      String? originalDefaultWorkflow,
      Map<String, dynamic>? originalIssueTypeMappings,
      bool? draft,
      User? lastModifiedUser,
      String? lastModified,
      String? self,
      bool? updateDraftIfNeeded,
      Map<String, dynamic>? issueTypes}) {
    return WorkflowScheme(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      defaultWorkflow: defaultWorkflow ?? this.defaultWorkflow,
      issueTypeMappings: issueTypeMappings ?? this.issueTypeMappings,
      originalDefaultWorkflow:
          originalDefaultWorkflow ?? this.originalDefaultWorkflow,
      originalIssueTypeMappings:
          originalIssueTypeMappings ?? this.originalIssueTypeMappings,
      draft: draft ?? this.draft,
      lastModifiedUser: lastModifiedUser ?? this.lastModifiedUser,
      lastModified: lastModified ?? this.lastModified,
      self: self ?? this.self,
      updateDraftIfNeeded: updateDraftIfNeeded ?? this.updateDraftIfNeeded,
      issueTypes: issueTypes ?? this.issueTypes,
    );
  }
}

/// Details about the mapping between issue types and a workflow.
class IssueTypesWorkflowMapping {
  /// The name of the workflow. Optional if updating the workflow-issue types
  /// mapping.
  final String? workflow;

  /// The list of issue type IDs.
  final List<String> issueTypes;

  /// Whether the workflow is the default workflow for the workflow scheme.
  final bool defaultMapping;

  /// Whether a draft workflow scheme is created or updated when updating an
  /// active workflow scheme. The draft is updated with the new workflow-issue
  /// types mapping. Defaults to `false`.
  final bool updateDraftIfNeeded;

  IssueTypesWorkflowMapping(
      {this.workflow,
      List<String>? issueTypes,
      bool? defaultMapping,
      bool? updateDraftIfNeeded})
      : issueTypes = issueTypes ?? [],
        defaultMapping = defaultMapping ?? false,
        updateDraftIfNeeded = updateDraftIfNeeded ?? false;

  factory IssueTypesWorkflowMapping.fromJson(Map<String, Object?> json) {
    return IssueTypesWorkflowMapping(
      workflow: json[r'workflow'] as String?,
      issueTypes: (json[r'issueTypes'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      defaultMapping: json[r'defaultMapping'] as bool? ?? false,
      updateDraftIfNeeded: json[r'updateDraftIfNeeded'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var workflow = this.workflow;
    var issueTypes = this.issueTypes;
    var defaultMapping = this.defaultMapping;
    var updateDraftIfNeeded = this.updateDraftIfNeeded;

    final json = <String, Object?>{};
    if (workflow != null) {
      json[r'workflow'] = workflow;
    }
    json[r'issueTypes'] = issueTypes;
    json[r'defaultMapping'] = defaultMapping;
    json[r'updateDraftIfNeeded'] = updateDraftIfNeeded;
    return json;
  }

  IssueTypesWorkflowMapping copyWith(
      {String? workflow,
      List<String>? issueTypes,
      bool? defaultMapping,
      bool? updateDraftIfNeeded}) {
    return IssueTypesWorkflowMapping(
      workflow: workflow ?? this.workflow,
      issueTypes: issueTypes ?? this.issueTypes,
      defaultMapping: defaultMapping ?? this.defaultMapping,
      updateDraftIfNeeded: updateDraftIfNeeded ?? this.updateDraftIfNeeded,
    );
  }
}

/// Details about the mapping between an issue type and a workflow.
class IssueTypeWorkflowMapping {
  /// The ID of the issue type. Not required if updating the issue type-workflow
  /// mapping.
  final String? issueType;

  /// The name of the workflow.
  final String? workflow;

  /// Set to true to create or update the draft of a workflow scheme and update
  /// the mapping in the draft, when the workflow scheme cannot be edited.
  /// Defaults to `false`. Only applicable when updating the workflow-issue
  /// types mapping.
  final bool updateDraftIfNeeded;

  IssueTypeWorkflowMapping(
      {this.issueType, this.workflow, bool? updateDraftIfNeeded})
      : updateDraftIfNeeded = updateDraftIfNeeded ?? false;

  factory IssueTypeWorkflowMapping.fromJson(Map<String, Object?> json) {
    return IssueTypeWorkflowMapping(
      issueType: json[r'issueType'] as String?,
      workflow: json[r'workflow'] as String?,
      updateDraftIfNeeded: json[r'updateDraftIfNeeded'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var issueType = this.issueType;
    var workflow = this.workflow;
    var updateDraftIfNeeded = this.updateDraftIfNeeded;

    final json = <String, Object?>{};
    if (issueType != null) {
      json[r'issueType'] = issueType;
    }
    if (workflow != null) {
      json[r'workflow'] = workflow;
    }
    json[r'updateDraftIfNeeded'] = updateDraftIfNeeded;
    return json;
  }

  IssueTypeWorkflowMapping copyWith(
      {String? issueType, String? workflow, bool? updateDraftIfNeeded}) {
    return IssueTypeWorkflowMapping(
      issueType: issueType ?? this.issueType,
      workflow: workflow ?? this.workflow,
      updateDraftIfNeeded: updateDraftIfNeeded ?? this.updateDraftIfNeeded,
    );
  }
}

/// Details about the default workflow.
class DefaultWorkflow {
  /// The name of the workflow to set as the default workflow.
  final String workflow;

  /// Whether a draft workflow scheme is created or updated when updating an
  /// active workflow scheme. The draft is updated with the new default
  /// workflow. Defaults to `false`.
  final bool updateDraftIfNeeded;

  DefaultWorkflow({required this.workflow, bool? updateDraftIfNeeded})
      : updateDraftIfNeeded = updateDraftIfNeeded ?? false;

  factory DefaultWorkflow.fromJson(Map<String, Object?> json) {
    return DefaultWorkflow(
      workflow: json[r'workflow'] as String? ?? '',
      updateDraftIfNeeded: json[r'updateDraftIfNeeded'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var workflow = this.workflow;
    var updateDraftIfNeeded = this.updateDraftIfNeeded;

    final json = <String, Object?>{};
    json[r'workflow'] = workflow;
    json[r'updateDraftIfNeeded'] = updateDraftIfNeeded;
    return json;
  }

  DefaultWorkflow copyWith({String? workflow, bool? updateDraftIfNeeded}) {
    return DefaultWorkflow(
      workflow: workflow ?? this.workflow,
      updateDraftIfNeeded: updateDraftIfNeeded ?? this.updateDraftIfNeeded,
    );
  }
}

/// A container for a list of workflow schemes together with the projects they
/// are associated with.
class ContainerOfWorkflowSchemeAssociations {
  /// A list of workflow schemes together with projects they are associated
  /// with.
  final List<WorkflowSchemeAssociations> values;

  ContainerOfWorkflowSchemeAssociations({required this.values});

  factory ContainerOfWorkflowSchemeAssociations.fromJson(
      Map<String, Object?> json) {
    return ContainerOfWorkflowSchemeAssociations(
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => WorkflowSchemeAssociations.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var values = this.values;

    final json = <String, Object?>{};
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  ContainerOfWorkflowSchemeAssociations copyWith(
      {List<WorkflowSchemeAssociations>? values}) {
    return ContainerOfWorkflowSchemeAssociations(
      values: values ?? this.values,
    );
  }
}

/// A workflow scheme along with a list of projects that use it.
class WorkflowSchemeAssociations {
  /// The list of projects that use the workflow scheme.
  final List<String> projectIds;

  /// The workflow scheme.
  final WorkflowScheme workflowScheme;

  WorkflowSchemeAssociations(
      {required this.projectIds, required this.workflowScheme});

  factory WorkflowSchemeAssociations.fromJson(Map<String, Object?> json) {
    return WorkflowSchemeAssociations(
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      workflowScheme: WorkflowScheme.fromJson(
          json[r'workflowScheme'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var projectIds = this.projectIds;
    var workflowScheme = this.workflowScheme;

    final json = <String, Object?>{};
    json[r'projectIds'] = projectIds;
    json[r'workflowScheme'] = workflowScheme.toJson();
    return json;
  }

  WorkflowSchemeAssociations copyWith(
      {List<String>? projectIds, WorkflowScheme? workflowScheme}) {
    return WorkflowSchemeAssociations(
      projectIds: projectIds ?? this.projectIds,
      workflowScheme: workflowScheme ?? this.workflowScheme,
    );
  }
}

/// An associated workflow scheme and project.
class WorkflowSchemeProjectAssociation {
  /// The ID of the workflow scheme.
  final String workflowSchemeId;

  /// The ID of the project.
  final String projectId;

  WorkflowSchemeProjectAssociation(
      {required this.workflowSchemeId, required this.projectId});

  factory WorkflowSchemeProjectAssociation.fromJson(Map<String, Object?> json) {
    return WorkflowSchemeProjectAssociation(
      workflowSchemeId: json[r'workflowSchemeId'] as String? ?? '',
      projectId: json[r'projectId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var workflowSchemeId = this.workflowSchemeId;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    json[r'workflowSchemeId'] = workflowSchemeId;
    json[r'projectId'] = projectId;
    return json;
  }

  WorkflowSchemeProjectAssociation copyWith(
      {String? workflowSchemeId, String? projectId}) {
    return WorkflowSchemeProjectAssociation(
      workflowSchemeId: workflowSchemeId ?? this.workflowSchemeId,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// A page of items.
class PageBeanWorkflow {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<Workflow> values;

  PageBeanWorkflow(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<Workflow>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanWorkflow.fromJson(Map<String, Object?> json) {
    return PageBeanWorkflow(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Workflow.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanWorkflow copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<Workflow>? values}) {
    return PageBeanWorkflow(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// Properties that identify a published workflow.
class PublishedWorkflowId {
  /// The name of the workflow.
  final String name;

  /// The entity ID of the workflow.
  final String? entityId;

  PublishedWorkflowId({required this.name, this.entityId});

  factory PublishedWorkflowId.fromJson(Map<String, Object?> json) {
    return PublishedWorkflowId(
      name: json[r'name'] as String? ?? '',
      entityId: json[r'entityId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var entityId = this.entityId;

    final json = <String, Object?>{};
    json[r'name'] = name;
    if (entityId != null) {
      json[r'entityId'] = entityId;
    }
    return json;
  }

  PublishedWorkflowId copyWith({String? name, String? entityId}) {
    return PublishedWorkflowId(
      name: name ?? this.name,
      entityId: entityId ?? this.entityId,
    );
  }
}

/// ID of a screen.
class ScreenID {
  /// The ID of the screen.
  final String id;

  ScreenID({required this.id});

  factory ScreenID.fromJson(Map<String, Object?> json) {
    return ScreenID(
      id: json[r'id'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  ScreenID copyWith({String? id}) {
    return ScreenID(
      id: id ?? this.id,
    );
  }
}

/// Details of a workflow transition.
class Transition {
  /// The ID of the transition.
  final String id;

  /// The name of the transition.
  final String name;

  /// The description of the transition.
  final String description;

  /// The statuses the transition can start from.
  final List<String> from;

  /// The status the transition goes to.
  final String to;

  /// The type of the transition.
  final TransitionType type;
  final ScreenID? screen;
  final WorkflowRules? rules;

  Transition(
      {required this.id,
      required this.name,
      required this.description,
      required this.from,
      required this.to,
      required this.type,
      this.screen,
      this.rules});

  factory Transition.fromJson(Map<String, Object?> json) {
    return Transition(
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      description: json[r'description'] as String? ?? '',
      from: (json[r'from'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      to: json[r'to'] as String? ?? '',
      type: TransitionType.fromValue(json[r'type'] as String? ?? ''),
      screen: json[r'screen'] != null
          ? ScreenID.fromJson(json[r'screen']! as Map<String, Object?>)
          : null,
      rules: json[r'rules'] != null
          ? WorkflowRules.fromJson(json[r'rules']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var description = this.description;
    var from = this.from;
    var to = this.to;
    var type = this.type;
    var screen = this.screen;
    var rules = this.rules;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    json[r'description'] = description;
    json[r'from'] = from;
    json[r'to'] = to;
    json[r'type'] = type.value;
    if (screen != null) {
      json[r'screen'] = screen.toJson();
    }
    if (rules != null) {
      json[r'rules'] = rules.toJson();
    }
    return json;
  }

  Transition copyWith(
      {String? id,
      String? name,
      String? description,
      List<String>? from,
      String? to,
      TransitionType? type,
      ScreenID? screen,
      WorkflowRules? rules}) {
    return Transition(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      from: from ?? this.from,
      to: to ?? this.to,
      type: type ?? this.type,
      screen: screen ?? this.screen,
      rules: rules ?? this.rules,
    );
  }
}

class TransitionType {
  static const global = TransitionType._('global');
  static const initial = TransitionType._('initial');
  static const directed = TransitionType._('directed');

  static const values = [
    global,
    initial,
    directed,
  ];
  final String value;

  const TransitionType._(this.value);

  static TransitionType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => TransitionType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about a workflow.
class Workflow {
  final PublishedWorkflowId id;

  /// The description of the workflow.
  final String description;

  /// The transitions of the workflow.
  final List<Transition> transitions;

  /// The statuses of the workflow.
  final List<WorkflowStatus> statuses;

  /// Whether this is the default workflow.
  final bool isDefault;

  Workflow(
      {required this.id,
      required this.description,
      List<Transition>? transitions,
      List<WorkflowStatus>? statuses,
      bool? isDefault})
      : transitions = transitions ?? [],
        statuses = statuses ?? [],
        isDefault = isDefault ?? false;

  factory Workflow.fromJson(Map<String, Object?> json) {
    return Workflow(
      id: PublishedWorkflowId.fromJson(
          json[r'id'] as Map<String, Object?>? ?? const {}),
      description: json[r'description'] as String? ?? '',
      transitions: (json[r'transitions'] as List<Object?>?)
              ?.map((i) =>
                  Transition.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      statuses: (json[r'statuses'] as List<Object?>?)
              ?.map((i) => WorkflowStatus.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      isDefault: json[r'isDefault'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var description = this.description;
    var transitions = this.transitions;
    var statuses = this.statuses;
    var isDefault = this.isDefault;

    final json = <String, Object?>{};
    json[r'id'] = id.toJson();
    json[r'description'] = description;
    json[r'transitions'] = transitions.map((i) => i.toJson()).toList();
    json[r'statuses'] = statuses.map((i) => i.toJson()).toList();
    json[r'isDefault'] = isDefault;
    return json;
  }

  Workflow copyWith(
      {PublishedWorkflowId? id,
      String? description,
      List<Transition>? transitions,
      List<WorkflowStatus>? statuses,
      bool? isDefault}) {
    return Workflow(
      id: id ?? this.id,
      description: description ?? this.description,
      transitions: transitions ?? this.transitions,
      statuses: statuses ?? this.statuses,
      isDefault: isDefault ?? this.isDefault,
    );
  }
}

/// A workflow transition compound condition rule.
class WorkflowCompoundCondition {
  /// The conditions operator.
  final WorkflowCompoundConditionOperator operator$;

  /// The list of workflow conditions.
  final List<WorkflowConditionBean> conditions;
  final String nodeType;

  WorkflowCompoundCondition(
      {required this.operator$,
      required this.conditions,
      required this.nodeType});

  factory WorkflowCompoundCondition.fromJson(Map<String, Object?> json) {
    return WorkflowCompoundCondition(
      operator$: WorkflowCompoundConditionOperator.fromValue(
          json[r'operator'] as String? ?? ''),
      conditions: (json[r'conditions'] as List<Object?>?)
              ?.map((i) => WorkflowConditionBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      nodeType: json[r'nodeType'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var operator$ = this.operator$;
    var conditions = this.conditions;
    var nodeType = this.nodeType;

    final json = <String, Object?>{};
    json[r'operator'] = operator$.value;
    json[r'conditions'] = conditions.map((i) => i.toJson()).toList();
    json[r'nodeType'] = nodeType;
    return json;
  }

  WorkflowCompoundCondition copyWith(
      {WorkflowCompoundConditionOperator? operator$,
      List<WorkflowConditionBean>? conditions,
      String? nodeType}) {
    return WorkflowCompoundCondition(
      operator$: operator$ ?? this.operator$,
      conditions: conditions ?? this.conditions,
      nodeType: nodeType ?? this.nodeType,
    );
  }
}

class WorkflowCompoundConditionOperator {
  static const and = WorkflowCompoundConditionOperator._('AND');
  static const or = WorkflowCompoundConditionOperator._('OR');

  static const values = [
    and,
    or,
  ];
  final String value;

  const WorkflowCompoundConditionOperator._(this.value);

  static WorkflowCompoundConditionOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => WorkflowCompoundConditionOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The workflow conditions tree.
class WorkflowConditionBean {
  WorkflowConditionBean();

  factory WorkflowConditionBean.fromJson(Map<String, Object?> json) {
    return WorkflowConditionBean();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// A collection of transition rules.
class WorkflowRules {
  /// The workflow conditions.
  final List<WorkflowTransitionRule> conditions;
  final WorkflowConditionBean? conditionsTree;

  /// The workflow validators.
  final List<WorkflowTransitionRule> validators;

  /// The workflow post functions.
  final List<WorkflowTransitionRule> postFunctions;

  WorkflowRules(
      {required this.conditions,
      this.conditionsTree,
      required this.validators,
      required this.postFunctions});

  factory WorkflowRules.fromJson(Map<String, Object?> json) {
    return WorkflowRules(
      conditions: (json[r'conditions'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      conditionsTree: json[r'conditionsTree'] != null
          ? WorkflowConditionBean.fromJson(
              json[r'conditionsTree']! as Map<String, Object?>)
          : null,
      validators: (json[r'validators'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      postFunctions: (json[r'postFunctions'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var conditions = this.conditions;
    var conditionsTree = this.conditionsTree;
    var validators = this.validators;
    var postFunctions = this.postFunctions;

    final json = <String, Object?>{};
    json[r'conditions'] = conditions.map((i) => i.toJson()).toList();
    if (conditionsTree != null) {
      json[r'conditionsTree'] = conditionsTree.toJson();
    }
    json[r'validators'] = validators.map((i) => i.toJson()).toList();
    json[r'postFunctions'] = postFunctions.map((i) => i.toJson()).toList();
    return json;
  }

  WorkflowRules copyWith(
      {List<WorkflowTransitionRule>? conditions,
      WorkflowConditionBean? conditionsTree,
      List<WorkflowTransitionRule>? validators,
      List<WorkflowTransitionRule>? postFunctions}) {
    return WorkflowRules(
      conditions: conditions ?? this.conditions,
      conditionsTree: conditionsTree ?? this.conditionsTree,
      validators: validators ?? this.validators,
      postFunctions: postFunctions ?? this.postFunctions,
    );
  }
}

/// A workflow transition condition rule.
class WorkflowSimpleCondition {
  /// The type of the transition rule.
  final String type;

  /// The configuration of the transition rule. This is currently returned only
  /// for some of the rule types. Availability of this property is subject to
  /// change.
  final Map<String, dynamic>? configuration;
  final String nodeType;

  WorkflowSimpleCondition(
      {required this.type, this.configuration, required this.nodeType});

  factory WorkflowSimpleCondition.fromJson(Map<String, Object?> json) {
    return WorkflowSimpleCondition(
      type: json[r'type'] as String? ?? '',
      configuration: json[r'configuration'] as Map<String, Object?>?,
      nodeType: json[r'nodeType'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var configuration = this.configuration;
    var nodeType = this.nodeType;

    final json = <String, Object?>{};
    json[r'type'] = type;
    if (configuration != null) {
      json[r'configuration'] = configuration;
    }
    json[r'nodeType'] = nodeType;
    return json;
  }

  WorkflowSimpleCondition copyWith(
      {String? type, Map<String, dynamic>? configuration, String? nodeType}) {
    return WorkflowSimpleCondition(
      type: type ?? this.type,
      configuration: configuration ?? this.configuration,
      nodeType: nodeType ?? this.nodeType,
    );
  }
}

/// Details of a workflow status.
class WorkflowStatus {
  /// The ID of the issue status.
  final String id;

  /// The name of the status in the workflow.
  final String name;
  final WorkflowStatusProperties? properties;

  WorkflowStatus({required this.id, required this.name, this.properties});

  factory WorkflowStatus.fromJson(Map<String, Object?> json) {
    return WorkflowStatus(
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      properties: json[r'properties'] != null
          ? WorkflowStatusProperties.fromJson(
              json[r'properties']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var properties = this.properties;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    if (properties != null) {
      json[r'properties'] = properties.toJson();
    }
    return json;
  }

  WorkflowStatus copyWith(
      {String? id, String? name, WorkflowStatusProperties? properties}) {
    return WorkflowStatus(
      id: id ?? this.id,
      name: name ?? this.name,
      properties: properties ?? this.properties,
    );
  }
}

/// Properties of a workflow status.
class WorkflowStatusProperties {
  /// Whether issues are editable in this status.
  final bool issueEditable;

  WorkflowStatusProperties({required this.issueEditable});

  factory WorkflowStatusProperties.fromJson(Map<String, Object?> json) {
    return WorkflowStatusProperties(
      issueEditable: json[r'issueEditable'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var issueEditable = this.issueEditable;

    final json = <String, Object?>{};
    json[r'issueEditable'] = issueEditable;
    return json;
  }

  WorkflowStatusProperties copyWith({bool? issueEditable}) {
    return WorkflowStatusProperties(
      issueEditable: issueEditable ?? this.issueEditable,
    );
  }
}

/// A workflow transition rule.
class WorkflowTransitionRule {
  /// The type of the transition rule.
  final String type;

  /// The configuration of the transition rule. This is currently returned only
  /// for some of the rule types. Availability of this property is subject to
  /// change.
  final dynamic configuration;

  WorkflowTransitionRule({required this.type, this.configuration});

  factory WorkflowTransitionRule.fromJson(Map<String, Object?> json) {
    return WorkflowTransitionRule(
      type: json[r'type'] as String? ?? '',
      configuration: json[r'configuration'],
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var configuration = this.configuration;

    final json = <String, Object?>{};
    json[r'type'] = type;
    if (configuration != null) {
      json[r'configuration'] = configuration;
    }
    return json;
  }

  WorkflowTransitionRule copyWith({String? type, dynamic configuration}) {
    return WorkflowTransitionRule(
      type: type ?? this.type,
      configuration: configuration ?? this.configuration,
    );
  }
}

/// A workflow transition rule.
class ConnectWorkflowTransitionRule {
  /// The ID of the transition rule.
  final String id;

  /// The key of the rule, as defined in the Connect app descriptor.
  final String key;
  final RuleConfiguration configuration;
  final WorkflowTransition? transition;

  ConnectWorkflowTransitionRule(
      {required this.id,
      required this.key,
      required this.configuration,
      this.transition});

  factory ConnectWorkflowTransitionRule.fromJson(Map<String, Object?> json) {
    return ConnectWorkflowTransitionRule(
      id: json[r'id'] as String? ?? '',
      key: json[r'key'] as String? ?? '',
      configuration: RuleConfiguration.fromJson(
          json[r'configuration'] as Map<String, Object?>? ?? const {}),
      transition: json[r'transition'] != null
          ? WorkflowTransition.fromJson(
              json[r'transition']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;
    var configuration = this.configuration;
    var transition = this.transition;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'key'] = key;
    json[r'configuration'] = configuration.toJson();
    if (transition != null) {
      json[r'transition'] = transition.toJson();
    }
    return json;
  }

  ConnectWorkflowTransitionRule copyWith(
      {String? id,
      String? key,
      RuleConfiguration? configuration,
      WorkflowTransition? transition}) {
    return ConnectWorkflowTransitionRule(
      id: id ?? this.id,
      key: key ?? this.key,
      configuration: configuration ?? this.configuration,
      transition: transition ?? this.transition,
    );
  }
}

/// A page of items.
class PageBeanWorkflowTransitionRules {
  /// The URL of the page.
  final String? self;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// Whether this is the last page.
  final bool isLast;

  /// The list of items.
  final List<WorkflowTransitionRules> values;

  PageBeanWorkflowTransitionRules(
      {this.self,
      this.nextPage,
      this.maxResults,
      this.startAt,
      this.total,
      bool? isLast,
      List<WorkflowTransitionRules>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanWorkflowTransitionRules.fromJson(Map<String, Object?> json) {
    return PageBeanWorkflowTransitionRules(
      self: json[r'self'] as String?,
      nextPage: json[r'nextPage'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      isLast: json[r'isLast'] as bool? ?? false,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRules.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var nextPage = this.nextPage;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var isLast = this.isLast;
    var values = this.values;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'isLast'] = isLast;
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanWorkflowTransitionRules copyWith(
      {String? self,
      String? nextPage,
      int? maxResults,
      int? startAt,
      int? total,
      bool? isLast,
      List<WorkflowTransitionRules>? values}) {
    return PageBeanWorkflowTransitionRules(
      self: self ?? this.self,
      nextPage: nextPage ?? this.nextPage,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      isLast: isLast ?? this.isLast,
      values: values ?? this.values,
    );
  }
}

/// A rule configuration.
class RuleConfiguration {
  /// Configuration of the rule, as it is stored by the Connect app on the rule
  /// configuration page.
  final String value;

  RuleConfiguration({required this.value});

  factory RuleConfiguration.fromJson(Map<String, Object?> json) {
    return RuleConfiguration(
      value: json[r'value'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var value = this.value;

    final json = <String, Object?>{};
    json[r'value'] = value;
    return json;
  }

  RuleConfiguration copyWith({String? value}) {
    return RuleConfiguration(
      value: value ?? this.value,
    );
  }
}

/// Properties that identify a workflow.
class WorkflowId {
  /// The name of the workflow.
  final String name;

  /// Whether the workflow is in the draft state.
  final bool draft;

  WorkflowId({required this.name, required this.draft});

  factory WorkflowId.fromJson(Map<String, Object?> json) {
    return WorkflowId(
      name: json[r'name'] as String? ?? '',
      draft: json[r'draft'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var draft = this.draft;

    final json = <String, Object?>{};
    json[r'name'] = name;
    json[r'draft'] = draft;
    return json;
  }

  WorkflowId copyWith({String? name, bool? draft}) {
    return WorkflowId(
      name: name ?? this.name,
      draft: draft ?? this.draft,
    );
  }
}

/// A workflow transition.
class WorkflowTransition {
  /// The transition ID.
  final int id;

  /// The transition name.
  final String name;

  WorkflowTransition({required this.id, required this.name});

  factory WorkflowTransition.fromJson(Map<String, Object?> json) {
    return WorkflowTransition(
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    return json;
  }

  WorkflowTransition copyWith({int? id, String? name}) {
    return WorkflowTransition(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// A workflow with transition rules.
class WorkflowTransitionRules {
  final WorkflowId workflowId;

  /// The list of post functions within the workflow.
  final List<ConnectWorkflowTransitionRule> postFunctions;

  /// The list of conditions within the workflow.
  final List<ConnectWorkflowTransitionRule> conditions;

  /// The list of validators within the workflow.
  final List<ConnectWorkflowTransitionRule> validators;

  WorkflowTransitionRules(
      {required this.workflowId,
      required this.postFunctions,
      required this.conditions,
      required this.validators});

  factory WorkflowTransitionRules.fromJson(Map<String, Object?> json) {
    return WorkflowTransitionRules(
      workflowId: WorkflowId.fromJson(
          json[r'workflowId'] as Map<String, Object?>? ?? const {}),
      postFunctions: (json[r'postFunctions'] as List<Object?>?)
              ?.map((i) => ConnectWorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      conditions: (json[r'conditions'] as List<Object?>?)
              ?.map((i) => ConnectWorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      validators: (json[r'validators'] as List<Object?>?)
              ?.map((i) => ConnectWorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var workflowId = this.workflowId;
    var postFunctions = this.postFunctions;
    var conditions = this.conditions;
    var validators = this.validators;

    final json = <String, Object?>{};
    json[r'workflowId'] = workflowId.toJson();
    json[r'postFunctions'] = postFunctions.map((i) => i.toJson()).toList();
    json[r'conditions'] = conditions.map((i) => i.toJson()).toList();
    json[r'validators'] = validators.map((i) => i.toJson()).toList();
    return json;
  }

  WorkflowTransitionRules copyWith(
      {WorkflowId? workflowId,
      List<ConnectWorkflowTransitionRule>? postFunctions,
      List<ConnectWorkflowTransitionRule>? conditions,
      List<ConnectWorkflowTransitionRule>? validators}) {
    return WorkflowTransitionRules(
      workflowId: workflowId ?? this.workflowId,
      postFunctions: postFunctions ?? this.postFunctions,
      conditions: conditions ?? this.conditions,
      validators: validators ?? this.validators,
    );
  }
}

/// Details about a workflow configuration update request.
class WorkflowTransitionRulesUpdate {
  /// The list of workflows with transition rules to update.
  final List<WorkflowTransitionRules> workflows;

  WorkflowTransitionRulesUpdate({required this.workflows});

  factory WorkflowTransitionRulesUpdate.fromJson(Map<String, Object?> json) {
    return WorkflowTransitionRulesUpdate(
      workflows: (json[r'workflows'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRules.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var workflows = this.workflows;

    final json = <String, Object?>{};
    json[r'workflows'] = workflows.map((i) => i.toJson()).toList();
    return json;
  }

  WorkflowTransitionRulesUpdate copyWith(
      {List<WorkflowTransitionRules>? workflows}) {
    return WorkflowTransitionRulesUpdate(
      workflows: workflows ?? this.workflows,
    );
  }
}

/// Details of any errors encountered while updating workflow transition rules
/// for a workflow.
class WorkflowTransitionRulesUpdateErrorDetails {
  final WorkflowId workflowId;

  /// A list of transition rule update errors, indexed by the transition rule
  /// ID. Any transition rule that appears here wasn't updated.
  final Map<String, dynamic> ruleUpdateErrors;

  /// The list of errors that specify why the workflow update failed. The
  /// workflow was not updated if the list contains any entries.
  final List<String> updateErrors;

  WorkflowTransitionRulesUpdateErrorDetails(
      {required this.workflowId,
      required this.ruleUpdateErrors,
      required this.updateErrors});

  factory WorkflowTransitionRulesUpdateErrorDetails.fromJson(
      Map<String, Object?> json) {
    return WorkflowTransitionRulesUpdateErrorDetails(
      workflowId: WorkflowId.fromJson(
          json[r'workflowId'] as Map<String, Object?>? ?? const {}),
      ruleUpdateErrors:
          json[r'ruleUpdateErrors'] as Map<String, Object?>? ?? {},
      updateErrors: (json[r'updateErrors'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var workflowId = this.workflowId;
    var ruleUpdateErrors = this.ruleUpdateErrors;
    var updateErrors = this.updateErrors;

    final json = <String, Object?>{};
    json[r'workflowId'] = workflowId.toJson();
    json[r'ruleUpdateErrors'] = ruleUpdateErrors;
    json[r'updateErrors'] = updateErrors;
    return json;
  }

  WorkflowTransitionRulesUpdateErrorDetails copyWith(
      {WorkflowId? workflowId,
      Map<String, dynamic>? ruleUpdateErrors,
      List<String>? updateErrors}) {
    return WorkflowTransitionRulesUpdateErrorDetails(
      workflowId: workflowId ?? this.workflowId,
      ruleUpdateErrors: ruleUpdateErrors ?? this.ruleUpdateErrors,
      updateErrors: updateErrors ?? this.updateErrors,
    );
  }
}

/// Details of any errors encountered while updating workflow transition rules.
class WorkflowTransitionRulesUpdateErrors {
  /// A list of workflows.
  final List<WorkflowTransitionRulesUpdateErrorDetails> updateResults;

  WorkflowTransitionRulesUpdateErrors({required this.updateResults});

  factory WorkflowTransitionRulesUpdateErrors.fromJson(
      Map<String, Object?> json) {
    return WorkflowTransitionRulesUpdateErrors(
      updateResults: (json[r'updateResults'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRulesUpdateErrorDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var updateResults = this.updateResults;

    final json = <String, Object?>{};
    json[r'updateResults'] = updateResults.map((i) => i.toJson()).toList();
    return json;
  }

  WorkflowTransitionRulesUpdateErrors copyWith(
      {List<WorkflowTransitionRulesUpdateErrorDetails>? updateResults}) {
    return WorkflowTransitionRulesUpdateErrors(
      updateResults: updateResults ?? this.updateResults,
    );
  }
}

/// Details of an item associated with the changed record.
class AssociatedItemBean {
  /// The ID of the associated record.
  final String? id;

  /// The name of the associated record.
  final String? name;

  /// The type of the associated record.
  final String? typeName;

  /// The ID of the associated parent record.
  final String? parentId;

  /// The name of the associated parent record.
  final String? parentName;

  AssociatedItemBean(
      {this.id, this.name, this.typeName, this.parentId, this.parentName});

  factory AssociatedItemBean.fromJson(Map<String, Object?> json) {
    return AssociatedItemBean(
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      typeName: json[r'typeName'] as String?,
      parentId: json[r'parentId'] as String?,
      parentName: json[r'parentName'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var typeName = this.typeName;
    var parentId = this.parentId;
    var parentName = this.parentName;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (typeName != null) {
      json[r'typeName'] = typeName;
    }
    if (parentId != null) {
      json[r'parentId'] = parentId;
    }
    if (parentName != null) {
      json[r'parentName'] = parentName;
    }
    return json;
  }

  AssociatedItemBean copyWith(
      {String? id,
      String? name,
      String? typeName,
      String? parentId,
      String? parentName}) {
    return AssociatedItemBean(
      id: id ?? this.id,
      name: name ?? this.name,
      typeName: typeName ?? this.typeName,
      parentId: parentId ?? this.parentId,
      parentName: parentName ?? this.parentName,
    );
  }
}

/// An audit record.
class AuditRecordBean {
  /// The ID of the audit record.
  final int? id;

  /// The summary of the audit record.
  final String? summary;

  /// The URL of the computer where the creation of the audit record was
  /// initiated.
  final String? remoteAddress;

  /// Deprecated, use `authorAccountId` instead. The key of the user who created
  /// the audit record.
  final String? authorKey;

  /// The date and time on which the audit record was created.
  final DateTime? created;

  /// The category of the audit record. For a list of these categories, see the
  /// help article
  /// [Auditing in Jira applications](https://confluence.atlassian.com/x/noXKM).
  final String? category;

  /// The event the audit record originated from.
  final String? eventSource;

  /// The description of the audit record.
  final String? description;
  final AssociatedItemBean? objectItem;

  /// The list of values changed in the record event.
  final List<ChangedValueBean> changedValues;

  /// The list of items associated with the changed record.
  final List<AssociatedItemBean> associatedItems;

  AuditRecordBean(
      {this.id,
      this.summary,
      this.remoteAddress,
      this.authorKey,
      this.created,
      this.category,
      this.eventSource,
      this.description,
      this.objectItem,
      List<ChangedValueBean>? changedValues,
      List<AssociatedItemBean>? associatedItems})
      : changedValues = changedValues ?? [],
        associatedItems = associatedItems ?? [];

  factory AuditRecordBean.fromJson(Map<String, Object?> json) {
    return AuditRecordBean(
      id: (json[r'id'] as num?)?.toInt(),
      summary: json[r'summary'] as String?,
      remoteAddress: json[r'remoteAddress'] as String?,
      authorKey: json[r'authorKey'] as String?,
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      category: json[r'category'] as String?,
      eventSource: json[r'eventSource'] as String?,
      description: json[r'description'] as String?,
      objectItem: json[r'objectItem'] != null
          ? AssociatedItemBean.fromJson(
              json[r'objectItem']! as Map<String, Object?>)
          : null,
      changedValues: (json[r'changedValues'] as List<Object?>?)
              ?.map((i) => ChangedValueBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      associatedItems: (json[r'associatedItems'] as List<Object?>?)
              ?.map((i) => AssociatedItemBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var summary = this.summary;
    var remoteAddress = this.remoteAddress;
    var authorKey = this.authorKey;
    var created = this.created;
    var category = this.category;
    var eventSource = this.eventSource;
    var description = this.description;
    var objectItem = this.objectItem;
    var changedValues = this.changedValues;
    var associatedItems = this.associatedItems;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (summary != null) {
      json[r'summary'] = summary;
    }
    if (remoteAddress != null) {
      json[r'remoteAddress'] = remoteAddress;
    }
    if (authorKey != null) {
      json[r'authorKey'] = authorKey;
    }
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    if (category != null) {
      json[r'category'] = category;
    }
    if (eventSource != null) {
      json[r'eventSource'] = eventSource;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (objectItem != null) {
      json[r'objectItem'] = objectItem.toJson();
    }
    json[r'changedValues'] = changedValues.map((i) => i.toJson()).toList();
    json[r'associatedItems'] = associatedItems.map((i) => i.toJson()).toList();
    return json;
  }

  AuditRecordBean copyWith(
      {int? id,
      String? summary,
      String? remoteAddress,
      String? authorKey,
      DateTime? created,
      String? category,
      String? eventSource,
      String? description,
      AssociatedItemBean? objectItem,
      List<ChangedValueBean>? changedValues,
      List<AssociatedItemBean>? associatedItems}) {
    return AuditRecordBean(
      id: id ?? this.id,
      summary: summary ?? this.summary,
      remoteAddress: remoteAddress ?? this.remoteAddress,
      authorKey: authorKey ?? this.authorKey,
      created: created ?? this.created,
      category: category ?? this.category,
      eventSource: eventSource ?? this.eventSource,
      description: description ?? this.description,
      objectItem: objectItem ?? this.objectItem,
      changedValues: changedValues ?? this.changedValues,
      associatedItems: associatedItems ?? this.associatedItems,
    );
  }
}

/// Container for a list of audit records.
class AuditRecords {
  /// The number of audit items skipped before the first item in this list.
  final int? offset;

  /// The requested or default limit on the number of audit items to be
  /// returned.
  final int? limit;

  /// The total number of audit items returned.
  final int? total;

  /// The list of audit items.
  final List<AuditRecordBean> records;

  AuditRecords(
      {this.offset, this.limit, this.total, List<AuditRecordBean>? records})
      : records = records ?? [];

  factory AuditRecords.fromJson(Map<String, Object?> json) {
    return AuditRecords(
      offset: (json[r'offset'] as num?)?.toInt(),
      limit: (json[r'limit'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      records: (json[r'records'] as List<Object?>?)
              ?.map((i) => AuditRecordBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var offset = this.offset;
    var limit = this.limit;
    var total = this.total;
    var records = this.records;

    final json = <String, Object?>{};
    if (offset != null) {
      json[r'offset'] = offset;
    }
    if (limit != null) {
      json[r'limit'] = limit;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'records'] = records.map((i) => i.toJson()).toList();
    return json;
  }

  AuditRecords copyWith(
      {int? offset, int? limit, int? total, List<AuditRecordBean>? records}) {
    return AuditRecords(
      offset: offset ?? this.offset,
      limit: limit ?? this.limit,
      total: total ?? this.total,
      records: records ?? this.records,
    );
  }
}

/// Details of names changed in the record event.
class ChangedValueBean {
  /// The name of the field changed.
  final String? fieldName;

  /// The value of the field before the change.
  final String? changedFrom;

  /// The value of the field after the change.
  final String? changedTo;

  ChangedValueBean({this.fieldName, this.changedFrom, this.changedTo});

  factory ChangedValueBean.fromJson(Map<String, Object?> json) {
    return ChangedValueBean(
      fieldName: json[r'fieldName'] as String?,
      changedFrom: json[r'changedFrom'] as String?,
      changedTo: json[r'changedTo'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var fieldName = this.fieldName;
    var changedFrom = this.changedFrom;
    var changedTo = this.changedTo;

    final json = <String, Object?>{};
    if (fieldName != null) {
      json[r'fieldName'] = fieldName;
    }
    if (changedFrom != null) {
      json[r'changedFrom'] = changedFrom;
    }
    if (changedTo != null) {
      json[r'changedTo'] = changedTo;
    }
    return json;
  }

  ChangedValueBean copyWith(
      {String? fieldName, String? changedFrom, String? changedTo}) {
    return ChangedValueBean(
      fieldName: fieldName ?? this.fieldName,
      changedFrom: changedFrom ?? this.changedFrom,
      changedTo: changedTo ?? this.changedTo,
    );
  }
}

/// Details about the time tracking provider.
class TimeTrackingProvider {
  /// The key for the time tracking provider. For example, *JIRA*.
  final String key;

  /// The name of the time tracking provider. For example, *JIRA provided time
  /// tracking*.
  final String? name;

  /// The URL of the configuration page for the time tracking provider app. For
  /// example, */example/config/url*. This property is only returned if the
  /// `adminPageKey` property is set in the module descriptor of the time
  /// tracking provider app.
  final String? url;

  TimeTrackingProvider({required this.key, this.name, this.url});

  factory TimeTrackingProvider.fromJson(Map<String, Object?> json) {
    return TimeTrackingProvider(
      key: json[r'key'] as String? ?? '',
      name: json[r'name'] as String?,
      url: json[r'url'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var name = this.name;
    var url = this.url;

    final json = <String, Object?>{};
    json[r'key'] = key;
    if (name != null) {
      json[r'name'] = name;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    return json;
  }

  TimeTrackingProvider copyWith({String? key, String? name, String? url}) {
    return TimeTrackingProvider(
      key: key ?? this.key,
      name: name ?? this.name,
      url: url ?? this.url,
    );
  }
}

class OperationMessage {
  /// The human-readable message that describes the result.
  final String message;

  /// The status code of the response.
  final int statusCode;

  OperationMessage({required this.message, required this.statusCode});

  factory OperationMessage.fromJson(Map<String, Object?> json) {
    return OperationMessage(
      message: json[r'message'] as String? ?? '',
      statusCode: (json[r'statusCode'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var message = this.message;
    var statusCode = this.statusCode;

    final json = <String, Object?>{};
    json[r'message'] = message;
    json[r'statusCode'] = statusCode;
    return json;
  }

  OperationMessage copyWith({String? message, int? statusCode}) {
    return OperationMessage(
      message: message ?? this.message,
      statusCode: statusCode ?? this.statusCode,
    );
  }
}

class ErrorMessage {
  /// The error message.
  final String message;

  ErrorMessage({required this.message});

  factory ErrorMessage.fromJson(Map<String, Object?> json) {
    return ErrorMessage(
      message: json[r'message'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var message = this.message;

    final json = <String, Object?>{};
    json[r'message'] = message;
    return json;
  }

  ErrorMessage copyWith({String? message}) {
    return ErrorMessage(
      message: message ?? this.message,
    );
  }
}

class ConnectModules {
  /// A list of app modules in the same format as the `modules` property in the
  /// [app descriptor](https://developer.atlassian.com/cloud/jira/platform/app-descriptor/).
  final List<ConnectModule> modules;

  ConnectModules({required this.modules});

  factory ConnectModules.fromJson(Map<String, Object?> json) {
    return ConnectModules(
      modules: (json[r'modules'] as List<Object?>?)
              ?.map((i) => ConnectModule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var modules = this.modules;

    final json = <String, Object?>{};
    json[r'modules'] = modules.map((i) => i.toJson()).toList();
    return json;
  }

  ConnectModules copyWith({List<ConnectModule>? modules}) {
    return ConnectModules(
      modules: modules ?? this.modules,
    );
  }
}

/// A
/// [Connect module](https://developer.atlassian.com/cloud/jira/platform/about-jira-modules/)
/// in the same format as in the
/// [app descriptor](https://developer.atlassian.com/cloud/jira/platform/app-descriptor/).
class ConnectModule {
  ConnectModule();

  factory ConnectModule.fromJson(Map<String, Object?> json) {
    return ConnectModule();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}
