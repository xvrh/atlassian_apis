// Generated code - Do not edit manually

import '../api_utils.dart';

// ignore_for_file: deprecated_member_use_from_same_package

class JiraPlatformApi {
  final ApiClient _client;

  JiraPlatformApi(this._client);

  /// This resource represents an announcement banner. Use it to retrieve and
  /// update banner configuration.
  late final announcementBanner = AnnouncementBannerApi(_client);

  /// This resource supports
  /// [app migrations](https://developer.atlassian.com/platform/app-migration/).
  /// Use it to:
  /// -
  /// [to request migrated workflow rules details](https://developer.atlassian.com/platform/app-migration/tutorials/migration-app-workflow-rules/).
  /// -
  /// [perform bulk updates of entity properties](https://developer.atlassian.com/platform/app-migration/tutorials/entity-properties-bulk-api/).
  /// -
  /// [perform bulk updates of issue custom field values](https://developer.atlassian.com/platform/app-migration/tutorials/migrating-app-custom-fields/).
  late final appMigration = AppMigrationApi(_client);

  /// This resource represents app properties. Use it to store arbitrary data
  /// for your
  /// [Connect app](https://developer.atlassian.com/cloud/jira/platform/index/#connect-apps).
  late final appProperties = AppPropertiesApi(_client);

  /// This resource represents application roles. Use it to get details of an
  /// application role or all application roles.
  late final applicationRoles = ApplicationRolesApi(_client);

  /// This resource represents audits that record activities undertaken in Jira.
  /// Use it to get a list of audit records.
  late final auditRecords = AuditRecordsApi(_client);

  /// This resource represents system and custom avatars. Use it to obtain the
  /// details of system or custom avatars, add and remove avatars from a project
  /// or issue type, and obtain avatar images.
  late final avatars = AvatarsApi(_client);

  /// This resource represents dashboards. Use it to obtain the details of
  /// dashboards as well as get, create, update, or remove item properties and
  /// gadgets from dashboards.
  late final dashboards = DashboardsApi(_client);

  /// This resource represents
  /// [modules registered dynamically](https://developer.atlassian.com/cloud/jira/platform/dynamic-modules/)
  /// by
  /// [Connect apps](https://developer.atlassian.com/cloud/jira/platform/index/#connect-apps).
  late final dynamicModules = DynamicModulesApi(_client);

  /// This resource represents options for sharing
  /// [filters](#api-group-Filters). Use it to get share scopes as well as add
  /// and remove share scopes from filters.
  late final filterSharing = FilterSharingApi(_client);

  /// This resource represents
  /// [filters](https://confluence.atlassian.com/x/eQiiLQ). Use it to get,
  /// create, update, or delete filters. Also use it to configure the columns
  /// for a filter and set favorite filters.
  late final filters = FiltersApi(_client);

  /// This resource represents a list of users and a list of groups. Use it to
  /// obtain the details to populate user and group picker suggestions list.
  late final groupAndUserPicker = GroupAndUserPickerApi(_client);

  /// This resource represents groups of users. Use it to get, create, find, and
  /// delete groups as well as add and remove users from groups. ([WARNING] The
  /// standard Atlassian group names are default names only and can be edited or
  /// deleted. For example, an admin or Atlassian support could delete the
  /// default group jira-software-users or rename it to jsw-users at any point.
  /// See
  /// https://support.atlassian.com/user-management/docs/create-and-update-groups/
  /// for details.)
  late final groups = GroupsApi(_client);

  /// This resource represents information about the Jira instance. Use it to
  /// get license details.
  late final instanceInformation = InstanceInformationApi(_client);

  /// This resource represents issue attachments and the attachment settings for
  /// Jira. Use it to get the metadata for an attachment, delete an attachment,
  /// and view the metadata for the contents of an attachment. Also, use it to
  /// get the attachment settings for Jira.
  late final issueAttachments = IssueAttachmentsApi(_client);

  /// This resource represents [issue comment](#api-group-Issue-comments)
  /// properties, which provides for storing custom data against an issue
  /// comment. Use is to get, set, and delete issue comment properties as well
  /// as obtain the keys of all properties on a comment. Comment properties are
  /// a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  late final issueCommentProperties = IssueCommentPropertiesApi(_client);

  /// This resource represents issue comments. Use it to:
  ///
  ///  *  get, create, update, and delete a comment from an issue.
  ///  *  get all comments from issue.
  ///  *  get a list of comments by comment ID.
  late final issueComments = IssueCommentsApi(_client);

  /// This resource represents configurations stored against a custom field
  /// context by a [Forge app](https://developer.atlassian.com/platform/forge/).
  /// Configurations are information used by the Forge app at runtime to
  /// determine how to handle or process the data in a custom field in a given
  /// context. Use this resource to set and read configurations.
  late final issueCustomFieldConfigurationApps =
      IssueCustomFieldConfigurationAppsApi(_client);

  /// This resource represents issue custom field contexts. Use it to:
  ///
  ///  *  get, create, update, and delete custom field contexts.
  ///  *  get context to issue types and projects mappings.
  ///  *  get custom field contexts for projects and issue types.
  ///  *  assign custom field contexts to projects.
  ///  *  remove custom field contexts from projects.
  ///  *  add issue types to custom field contexts.
  late final issueCustomFieldContexts = IssueCustomFieldContextsApi(_client);

  /// This resource represents custom issue field select list options created in
  /// Jira or using the REST API. This resource supports the following field
  /// types:
  ///
  ///  *  Checkboxes.
  ///  *  Radio Buttons.
  ///  *  Select List (single choice).
  ///  *  Select List (multiple choices).
  ///  *  Select List (cascading).
  ///
  /// See
  /// [Issue custom field options (apps)](#api-group-Issue-custom-field-options--apps-)
  /// to manipulate custom issue field select list options created by a Connect
  /// app.
  ///
  /// Use it to retrieve, create, update, order, and delete custom field
  /// options.
  late final issueCustomFieldOptions = IssueCustomFieldOptionsApi(_client);

  /// This resource represents custom issue field select list options created by
  /// a Connect app. See
  /// [Issue custom field options](#api-group-Issue-custom-field-options) to
  /// manipulate options created in Jira or using the REST API.
  ///
  /// A select list issue field is a type of
  /// [issue field](https://developer.atlassian.com/cloud/jira/platform/modules/issue-field/)
  /// that enables a user to select an option from a list. Use it to add,
  /// remove, and update the options of a select list issue field.
  late final issueCustomFieldOptionsApps =
      IssueCustomFieldOptionsAppsApi(_client);

  /// This resource represents the values of custom fields added by
  /// [Forge apps](https://developer.atlassian.com/platform/forge/). Use it to
  /// update the value of a custom field on issues.
  late final issueCustomFieldValuesApps =
      IssueCustomFieldValuesAppsApi(_client);

  /// This resource represents issue field configurations. Use it to get, set,
  /// and delete field configurations and field configuration schemes.
  late final issueFieldConfigurations = IssueFieldConfigurationsApi(_client);

  /// This resource represents issue fields, both system and custom fields. Use
  /// it to get fields, field configurations, and create custom fields.
  late final issueFields = IssueFieldsApi(_client);

  /// This resource represents [issue link](#api-group-Issue-links) types. Use
  /// it to get, create, update, and delete link issue types as well as get
  /// lists of all link issue types.
  ///
  /// To use it, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  late final issueLinkTypes = IssueLinkTypesApi(_client);

  /// This resource represents links between issues. Use it to get, create, and
  /// delete links between issues.
  ///
  /// To use it, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  late final issueLinks = IssueLinksApi(_client);

  /// This resource represents issue navigator settings. Use it to get and set
  /// issue navigator default columns.
  late final issueNavigatorSettings = IssueNavigatorSettingsApi(_client);

  /// This resource represents notification schemes, lists of events and the
  /// recipients who will receive notifications for those events. Use it to get
  /// details of a notification scheme and a list of notification schemes.
  ///
  /// ### About notification schemes ###
  ///
  /// A notification scheme is a list of events and recipients who will receive
  /// notifications for those events. The list is contained within the
  /// `notificationSchemeEvents` object and contains pairs of `events` and
  /// `notifications`:
  ///
  ///  *  `event` Identifies the type of event. The events can be
  /// [Jira system events](https://support.atlassian.com/jira-cloud-administration/docs/configure-notification-schemes/)
  /// (see the *Events* section) or
  /// [custom events](https://support.atlassian.com/jira-cloud-administration/docs/add-a-custom-event/).
  ///  *  `notifications` Identifies the
  /// [recipients](https://confluence.atlassian.com/x/8YdKLg#Creatinganotificationscheme-recipientsRecipients)
  /// of notifications for each event. Recipients can be any of the following
  /// types:
  ///
  ///      *  `CurrentAssignee`
  ///      *  `Reporter`
  ///      *  `CurrentUser`
  ///      *  `ProjectLead`
  ///      *  `ComponentLead`
  ///      *  `User` (the `parameter` is the user key)
  ///      *  `Group` (the `parameter` is the group name)
  ///      *  `ProjectRole` (the `parameter` is the project role ID)
  ///      *  `EmailAddress`
  ///      *  `AllWatchers`
  ///      *  `UserCustomField` (the `parameter` is the ID of the custom field)
  ///      *  `GroupCustomField`(the `parameter` is the ID of the custom field)
  late final issueNotificationSchemes = IssueNotificationSchemesApi(_client);

  /// This resource represents issue priorities. Use it to get, create and
  /// update issue priorities and details for individual issue priorities.
  late final issuePriorities = IssuePrioritiesApi(_client);

  /// This resource represents [issue](#api-group-Issues) properties, which
  /// provides for storing custom data against an issue. Use it to get, set, and
  /// delete issue properties as well as obtain details of all properties on an
  /// issue. Operations to bulk update and delete issue properties are also
  /// provided. Issue properties are a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  late final issueProperties = IssuePropertiesApi(_client);

  /// This resource represents remote issue links, a way of linking Jira to
  /// information in other systems. Use it to get, create, update, and delete
  /// remote issue links either by ID or global ID. The global ID provides a way
  /// of accessing remote issue links using information about the item's remote
  /// system host and remote system identifier.
  late final issueRemoteLinks = IssueRemoteLinksApi(_client);

  /// This resource represents issue resolution values. Use it to obtain a list
  /// of all issue resolution values and the details of individual resolution
  /// values.
  late final issueResolutions = IssueResolutionsApi(_client);

  /// This resource represents various ways to search for issues. Use it to
  /// search for issues with a JQL query and find issues to populate an issue
  /// picker.
  late final issueSearch = IssueSearchApi(_client);

  /// This resource represents issue security levels. Use it to obtain the
  /// details of any issue security level. For more information about issue
  /// security levels, see
  /// [Configuring issue-level security](https://confluence.atlassian.com/x/J4lKLg).
  late final issueSecurityLevel = IssueSecurityLevelApi(_client);

  /// This resource represents issue security schemes. Use it to get an issue
  /// security scheme or a list of issue security schemes.
  ///
  /// Issue security schemes control which users or groups of users can view an
  /// issue. When an issue security scheme is associated with a project, its
  /// security levels can be applied to issues in that project. Sub-tasks also
  /// inherit the security level of their parent issue.
  late final issueSecuritySchemes = IssueSecuritySchemesApi(_client);

  /// This resource represents [issue type](#api-group-Issue-types) properties,
  /// which provides for storing custom data against an issue type. Use it to
  /// get, create, and delete issue type properties as well as obtain the keys
  /// of all properties on a issues type. Issue type properties are a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  late final issueTypeProperties = IssueTypePropertiesApi(_client);

  /// This resource represents issue type schemes in classic projects. Use it
  /// to:
  ///
  ///  *  get issue type schemes and a list of the projects that use them.
  ///  *  associate issue type schemes with projects.
  ///  *  add issue types to issue type schemes.
  ///  *  delete issue types from issue type schemes.
  ///  *  create, update, and delete issue type schemes.
  ///  *  change the order of issue types in issue type schemes.
  late final issueTypeSchemes = IssueTypeSchemesApi(_client);

  /// This resource represents issue type screen schemes. Use it to:
  ///
  ///  *  get issue type screen schemes and a list of the projects that use
  /// them.
  ///  *  create issue type screen schemes.
  ///  *  update issue type screen schemes.
  ///  *  delete issue type screen schemes.
  ///  *  associate issue type screen schemes with projects.
  ///  *  append issue type to screen scheme mappings to issue type screen
  /// schemes.
  ///  *  remove issue type to screen scheme mappings from issue type screen
  /// schemes.
  ///  *  update default screen scheme of issue type screen scheme.
  late final issueTypeScreenSchemes = IssueTypeScreenSchemesApi(_client);

  /// This resource represents issues types. Use it to:
  ///
  ///  *  get, create, update, and delete issue types.
  ///  *  get all issue types for a user.
  ///  *  get alternative issue types.
  ///  *  set an avatar for an issue type.
  late final issueTypes = IssueTypesApi(_client);

  /// This resource represents votes cast by users on an issue. Use it to get
  /// details of votes on an issue as well as cast and withdrawal votes.
  late final issueVotes = IssueVotesApi(_client);

  /// This resource represents users watching an issue. Use it to get details of
  /// users watching an issue as well as start and stop a user watching an
  /// issue.
  late final issueWatchers = IssueWatchersApi(_client);

  /// This resource represents [issue worklog](#api-group-Issue-worklogs)
  /// properties, which provides for storing custom data against an issue
  /// worklog. Use it to get, create, and delete issue worklog properties as
  /// well as obtain the keys of all properties on a issue worklog. Issue
  /// worklog properties are a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  late final issueWorklogProperties = IssueWorklogPropertiesApi(_client);

  /// This resource represents issue worklogs. Use it to:
  ///
  ///  *  get, create, update, and delete worklogs.
  ///  *  obtain lists of updated or deleted worklogs.
  late final issueWorklogs = IssueWorklogsApi(_client);

  /// This resource represents Jira issues. Use it to:
  ///
  ///  *  create or edit issues, individually or in bulk.
  ///  *  retrieve metadata about the options for creating or editing issues.
  ///  *  delete an issue.
  ///  *  assign a user to an issue.
  ///  *  get issue changelogs.
  ///  *  send notifications about an issue.
  ///  *  get details of the transitions available for an issue.
  ///  *  transition an issue.
  late final issues = IssuesApi(_client);

  /// This resource represents JQL search auto-complete details. Use it to
  /// obtain JQL search auto-complete data and suggestions for use in
  /// programmatic construction of queries or custom query builders. It also
  /// provides operations to:
  ///
  ///  *  convert one or more JQL queries with user identifiers (username or
  /// user key) to equivalent JQL queries with account IDs.
  ///  *  convert readable details in one or more JQL queries to IDs where a
  /// user doesn't have permission to view the entity whose details are
  /// readable.
  late final jql = JQLApi(_client);

  /// This resource represents JQL function's precomputations. Precomputation is
  /// a mapping between custom function call and JQL fragment returned by this
  /// function. Use it to get and update precomputations.
  late final jqlFunctionsApps = JQLFunctionsAppsApi(_client);

  /// This resource is a collection of operations for
  /// [Jira expressions](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/).
  late final jiraExpressions = JiraExpressionsApi(_client);

  /// This resource represents various settings in Jira. Use it to get and
  /// update Jira settings and properties.
  late final jiraSettings = JiraSettingsApi(_client);

  /// This resource represents available labels. Use it to get available labels
  /// for the global label field.
  late final labels = LabelsApi(_client);

  /// This resource represents license metrics. Use it to get available metrics
  /// for Jira licences.
  late final licenseMetrics = LicenseMetricsApi(_client);

  /// This resource represents information about the current user, such as basic
  /// details, group membership, application roles, preferences, and locale. Use
  /// it to get, create, update, and delete (restore default) values of the
  /// user's preferences and locale.
  late final myself = MyselfApi(_client);

  /// This resource represents permission schemes. Use it to get, create,
  /// update, and delete permission schemes as well as get, create, update, and
  /// delete details of the permissions granted in those schemes.
  late final permissionSchemes = PermissionSchemesApi(_client);

  /// This resource represents permissions. Use it to obtain details of all
  /// permissions and determine whether the user has certain permissions.
  late final permissions = PermissionsApi(_client);

  /// This resource represents avatars associated with a project. Use it to get,
  /// load, set, and remove project avatars.
  late final projectAvatars = ProjectAvatarsApi(_client);

  /// This resource represents project categories. Use it to create, update, and
  /// delete project categories as well as obtain a list of all project
  /// categories and details of individual categories. For more information on
  /// managing project categories, see
  /// [Adding, assigning, and deleting project categories](https://confluence.atlassian.com/x/-A5WMg).
  late final projectCategories = ProjectCategoriesApi(_client);

  /// This resource represents project components. Use it to get, create,
  /// update, and delete project components. Also get components for project and
  /// get a count of issues by component.
  late final projectComponents = ProjectComponentsApi(_client);

  /// This resource represents the email address used to send a project's
  /// notifications. Use it to get and set the
  /// [project's sender email address](https://confluence.atlassian.com/x/dolKLg).
  late final projectEmail = ProjectEmailApi(_client);

  /// This resource represents project features. Use it to get the list of
  /// features for a project and modify the state of a feature. The project
  /// feature endpoint is available only for Jira Software, both for team- and
  /// company-managed projects.
  late final projectFeatures = ProjectFeaturesApi(_client);

  /// This resource provides validation for project keys and names.
  late final projectKeyAndNameValidation =
      ProjectKeyAndNameValidationApi(_client);

  /// This resource represents permission schemes for a project. Use this
  /// resource to:
  ///
  ///  *  get details of a project's issue security levels available to the
  /// calling user.
  ///  *  get the permission scheme associated with the project or assign
  /// different permission scheme to the project.
  ///  *  get details of a project's issue security scheme.
  ///
  /// See
  /// [Managing project permissions](https://confluence.atlassian.com/x/yodKLg)
  /// for more information about permission schemes.
  late final projectPermissionSchemes = ProjectPermissionSchemesApi(_client);

  /// This resource represents [project](#api-group-Projects) properties, which
  /// provides for storing custom data against a project. Use it to get, create,
  /// and delete project properties as well as get a list of property keys for a
  /// project. Project properties are a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  late final projectProperties = ProjectPropertiesApi(_client);

  /// This resource represents the users assigned to
  /// [project roles](#api-group-Issue-comments). Use it to get, add, and remove
  /// default users from project roles. Also use it to add and remove users from
  /// a project role associated with a project.
  late final projectRoleActors = ProjectRoleActorsApi(_client);

  /// This resource represents the roles that users can play in projects. Use
  /// this resource to get, create, update, and delete project roles.
  late final projectRoles = ProjectRolesApi(_client);

  /// This resource represents project types. Use it to obtain a list of all
  /// project types, a list of project types accessible to the calling user, and
  /// details of a project type.
  late final projectTypes = ProjectTypesApi(_client);

  /// This resource represents project versions. Use it to get, get lists of,
  /// create, update, move, merge, and delete project versions. This resource
  /// also provides counts of issues by version.
  late final projectVersions = ProjectVersionsApi(_client);

  /// This resource represents projects. Use it to get, create, update, and
  /// delete projects. Also get statuses available to a project, a project's
  /// notification schemes, and update a project's type.
  late final projects = ProjectsApi(_client);

  /// This resource represents screen schemes in classic projects. Use it to
  /// get, create, update, and delete screen schemes.
  late final screenSchemes = ScreenSchemesApi(_client);

  /// This resource represents the screen tab fields used to record issue
  /// details. Use it to get, add, move, and remove fields from screen tabs.
  late final screenTabFields = ScreenTabFieldsApi(_client);

  /// This resource represents the screen tabs used to record issue details. Use
  /// it to get, create, update, move, and delete screen tabs.
  late final screenTabs = ScreenTabsApi(_client);

  /// This resource represents the screens used to record issue details. Use it
  /// to:
  ///
  ///  *  get details of all screens.
  ///  *  get details of all the fields available for use on screens.
  ///  *  create screens.
  ///  *  delete screens.
  ///  *  update screens.
  ///  *  add a field to the default screen.
  late final screens = ScreensApi(_client);

  /// This resource provides information about the Jira instance.
  late final serverInfo = ServerInfoApi(_client);

  /// This resource represents statuses. Use it to search, get, create, delete,
  /// and change statuses.
  late final status = StatusApi(_client);

  /// This resource represents a
  /// [long-running asynchronous tasks](#async-operations). Use it to obtain
  /// details about the progress of a long-running task or cancel a long-running
  /// task.
  late final tasks = TasksApi(_client);

  /// This resource represents time tracking and time tracking providers. Use it
  /// to get and set the time tracking provider, get and set the time tracking
  /// options, and disable time tracking.
  late final timeTracking = TimeTrackingApi(_client);

  /// UI modifications is an experimental feature available for **Forge apps
  /// only**. It enables Forge apps to control how selected Jira fields behave
  /// on global create issue dialog. For example: hide specific fields, set them
  /// as required, etc.
  late final uiModificationsApps = UIModificationsAppsApi(_client);

  /// This resource represents [user](#api-group-Users) properties and provides
  /// for storing custom data against a user. Use it to get, create, and delete
  /// user properties as well as get a list of property keys for a user. This
  /// resourse is designed for integrations and apps to store per-user data and
  /// settings. This enables data used to customized the user experience to be
  /// kept in the Jira Cloud instance's database. User properties are a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  ///
  /// This resource does not access the
  /// [user properties](https://confluence.atlassian.com/x/8YxjL) created and
  /// maintained in Jira.
  late final userProperties = UserPropertiesApi(_client);

  /// This resource represents various ways to search for and find users. Use it
  /// to obtain list of users including users assignable to projects and issues,
  /// users with permissions, user lists for pickup fields, and user lists
  /// generated using structured queries. Note that the operations in this
  /// resource only return users found within the first 1000 users.
  late final userSearch = UserSearchApi(_client);

  /// This resource represent users. Use it to:
  ///
  ///  *  get, get a list of, create, and delete users.
  ///  *  get, set, and reset a user's default issue table columns.
  ///  *  get a list of the groups the user belongs to.
  ///  *  get a list of user account IDs for a list of usernames or user keys.
  late final users = UsersApi(_client);

  /// This resource represents webhooks. Webhooks are calls sent to a URL when
  /// an event occurs in Jira for issues specified by a JQL query. Only Connect
  /// and OAuth 2.0 apps can register and manage webhooks. For more information,
  /// see
  /// [Webhooks](https://developer.atlassian.com/cloud/jira/platform/webhooks/#registering-a-webhook-via-the-jira-rest-api-for-connect-apps).
  late final webhooks = WebhooksApi(_client);

  /// This resource represents draft workflow schemes. Use it to manage drafts
  /// of workflow schemes.
  ///
  /// A workflow scheme maps issue types to workflows. A workflow scheme can be
  /// associated with one or more projects, which enables the projects to use
  /// the workflow-issue type mappings.
  ///
  /// Active workflow schemes (workflow schemes that are used by projects)
  /// cannot be edited. Editing an active workflow scheme creates a draft copy
  /// of the scheme. The draft workflow scheme can then be edited and published
  /// (replacing the active scheme).
  ///
  /// See
  /// [Configuring workflow schemes](https://confluence.atlassian.com/x/tohKLg)
  /// for more information.
  late final workflowSchemeDrafts = WorkflowSchemeDraftsApi(_client);

  /// This resource represents the associations between workflow schemes and
  /// projects.
  ///
  /// For more information, see
  /// [Managing your workflows](https://confluence.atlassian.com/x/q4hKLg).
  late final workflowSchemeProjectAssociations =
      WorkflowSchemeProjectAssociationsApi(_client);

  /// This resource represents workflow schemes. Use it to manage workflow
  /// schemes and the workflow scheme's workflows and issue types.
  ///
  /// A workflow scheme maps issue types to workflows. A workflow scheme can be
  /// associated with one or more projects, which enables the projects to use
  /// the workflow-issue type mappings.
  ///
  /// Active workflow schemes (workflow schemes that are used by projects)
  /// cannot be edited. When an active workflow scheme is edited, a draft copy
  /// of the scheme is created. The draft workflow scheme is then be edited and
  /// published (replacing the active scheme).
  ///
  /// See
  /// [Configuring workflow schemes](https://confluence.atlassian.com/x/tohKLg)
  /// for more information.
  late final workflowSchemes = WorkflowSchemesApi(_client);

  /// This resource represents status categories. Use it to obtain a list of all
  /// status categories and the details of a category. Status categories
  /// provided a mechanism for categorizing
  /// [statuses](#api-group-Workflow-statuses).
  late final workflowStatusCategories = WorkflowStatusCategoriesApi(_client);

  /// This resource represents issue workflow statuses. Use it to obtain a list
  /// of all statuses associated with workflows and the details of a status.
  late final workflowStatuses = WorkflowStatusesApi(_client);

  /// This resource represents workflow transition properties, which provides
  /// for storing custom data against a workflow transition. Use it to get,
  /// create, and delete workflow transition properties as well as get a list of
  /// property keys for a workflow transition. Workflow transition properties
  /// are a type of
  /// [entity property](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
  late final workflowTransitionProperties =
      WorkflowTransitionPropertiesApi(_client);

  /// This resource represents workflow transition rules. Workflow transition
  /// rules define a Connect or a Forge app routine, such as a
  /// [workflow post functions](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-post-function/)
  /// that is executed in association with the workflow. Use it to read and
  /// modify configuration of workflow transition rules.
  late final workflowTransitionRules = WorkflowTransitionRulesApi(_client);

  /// This resource represents workflows. Use it to:
  ///
  ///  *  get workflows.
  ///  *  create workflows.
  ///  *  delete inactive workflows.
  late final workflows = WorkflowsApi(_client);

  void close() => _client.close();
}

/// Jira Cloud platform REST API documentation

class AnnouncementBannerApi {
  final ApiClient _client;

  AnnouncementBannerApi(this._client);

  /// Returns the current announcement banner configuration.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<AnnouncementBannerConfiguration> getBanner() async {
    return AnnouncementBannerConfiguration.fromJson(await _client.send(
      'get',
      'rest/api/3/announcementBanner',
    ));
  }

  /// Updates the announcement banner configuration.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> setBanner(
      {required AnnouncementBannerConfigurationUpdate body}) async {
    return await _client.send(
      'put',
      'rest/api/3/announcementBanner',
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class AppMigrationApi {
  final ApiClient _client;

  AppMigrationApi(this._client);

  /// Updates the value of a custom field added by Connect apps on one or more
  /// issues.
  /// The values of up to 200 custom fields can be updated.
  ///
  /// **[Permissions](#permissions) required:** Only Connect apps can make this
  /// request.
  Future<dynamic> updateIssueFields(
      {required String atlassianTransferId,
      required ConnectCustomFieldValues body}) async {
    return await _client.send(
      'put',
      'rest/atlassian-connect/1/migration/field',
      headers: {
        'Atlassian-Transfer-Id': 'null',
      },
      body: body.toJson(),
    );
  }

  /// Updates the values of multiple entity properties for an object, up to 50
  /// updates per request. This operation is for use by Connect apps during app
  /// migration.
  Future<void> updateEntityPropertiesValue(
      {required String atlassianTransferId,
      required String entityType,
      required List<EntityPropertyDetails> body}) async {
    await _client.send(
      'put',
      'rest/atlassian-connect/1/migration/properties/{entityType}',
      pathParameters: {
        'entityType': entityType,
      },
      headers: {
        'Atlassian-Transfer-Id': 'null',
      },
      body: body.map((i) => i.toJson()).toList(),
    );
  }

  /// Returns configurations for workflow transition rules migrated from server
  /// to cloud and owned by the calling Connect app.
  Future<WorkflowRulesSearchDetails> workflowRuleSearch(
      {required String atlassianTransferId,
      required WorkflowRulesSearch body}) async {
    return WorkflowRulesSearchDetails.fromJson(await _client.send(
      'post',
      'rest/atlassian-connect/1/migration/workflow/rule/search',
      headers: {
        'Atlassian-Transfer-Id': 'null',
      },
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class AppPropertiesApi {
  final ApiClient _client;

  AppPropertiesApi(this._client);

  /// Gets all the properties of an app.
  ///
  /// **[Permissions](#permissions) required:** Only a Connect app whose key
  /// matches `addonKey` can make this request.
  /// Additionally, Forge apps published on the Marketplace can access
  /// properties of Connect apps they were
  /// [migrated from](https://developer.atlassian.com/platform/forge/build-a-connect-on-forge-app/).
  Future<PropertyKeys> getAddonProperties(String addonKey) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/atlassian-connect/1/addons/{addonKey}/properties',
      pathParameters: {
        'addonKey': addonKey,
      },
    ));
  }

  /// Returns the key and value of an app's property.
  ///
  /// **[Permissions](#permissions) required:** Only a Connect app whose key
  /// matches `addonKey` can make this request.
  /// Additionally, Forge apps published on the Marketplace can access
  /// properties of Connect apps they were
  /// [migrated from](https://developer.atlassian.com/platform/forge/build-a-connect-on-forge-app/).
  Future<EntityProperty> getAddonProperty(
      {required String addonKey, required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}',
      pathParameters: {
        'addonKey': addonKey,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Sets the value of an app's property. Use this resource to store custom
  /// data for your app.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// **[Permissions](#permissions) required:** Only a Connect app whose key
  /// matches `addonKey` can make this request.
  Future<OperationMessage> putAddonProperty(
      {required String addonKey,
      required String propertyKey,
      required dynamic body}) async {
    return OperationMessage.fromJson(await _client.send(
      'put',
      'rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}',
      pathParameters: {
        'addonKey': addonKey,
        'propertyKey': propertyKey,
      },
      body: body,
    ));
  }

  /// Deletes an app's property.
  ///
  /// **[Permissions](#permissions) required:** Only a Connect app whose key
  /// matches `addonKey` can make this request.
  Future<void> deleteAddonProperty(
      {required String addonKey, required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}',
      pathParameters: {
        'addonKey': addonKey,
        'propertyKey': propertyKey,
      },
    );
  }

  /// Sets the value of a Forge app's property.
  /// These values can be retrieved in
  /// [Jira expressions](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/)
  /// through the `app`
  /// [context variable](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#context-variables).
  ///
  /// For other use cases, use the
  /// [Storage API](https://developer.atlassian.com/platform/forge/runtime-reference/storage-api/).
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// **[Permissions](#permissions) required:** Only Forge apps can make this
  /// request.
  Future<OperationMessage> putAppProperty(
      {required String propertyKey, required dynamic body}) async {
    return OperationMessage.fromJson(await _client.send(
      'put',
      'rest/forge/1/app/properties/{propertyKey}',
      pathParameters: {
        'propertyKey': propertyKey,
      },
      body: body,
    ));
  }

  /// Deletes a Forge app's property.
  ///
  /// **[Permissions](#permissions) required:** Only Forge apps can make this
  /// request.
  Future<void> deleteAppProperty(String propertyKey) async {
    await _client.send(
      'delete',
      'rest/forge/1/app/properties/{propertyKey}',
      pathParameters: {
        'propertyKey': propertyKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class ApplicationRolesApi {
  final ApiClient _client;

  ApplicationRolesApi(this._client);

  /// Returns all application roles. In Jira, application roles are managed
  /// using the
  /// [Application access configuration](https://confluence.atlassian.com/x/3YxjL)
  /// page.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<ApplicationRole>> getAllApplicationRoles() async {
    return (await _client.send(
      'get',
      'rest/api/3/applicationrole',
    ) as List<Object?>)
        .map((i) =>
            ApplicationRole.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns an application role.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ApplicationRole> getApplicationRole(String key) async {
    return ApplicationRole.fromJson(await _client.send(
      'get',
      'rest/api/3/applicationrole/{key}',
      pathParameters: {
        'key': key,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class AuditRecordsApi {
  final ApiClient _client;

  AuditRecordsApi(this._client);

  /// Returns a list of audit records. The list can be filtered to include
  /// items:
  ///
  ///  *  where each item in `filter` has at least one match in any of these
  /// fields:
  ///
  ///      *  `summary`
  ///      *  `category`
  ///      *  `eventSource`
  ///      *  `objectItem.name` If the object is a user, account ID is available
  /// to filter.
  ///      *  `objectItem.parentName`
  ///      *  `objectItem.typeName`
  ///      *  `changedValues.changedFrom`
  ///      *  `changedValues.changedTo`
  ///      *  `remoteAddress`
  ///
  ///     For example, if `filter` contains *man ed*, an audit record containing
  /// `summary": "User added to group"` and `"category": "group management"` is
  /// returned.
  ///  *  created on or after a date and time.
  ///  *  created or or before a date and time.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<AuditRecords> getAuditRecords(
      {int? offset,
      int? limit,
      String? filter,
      DateTime? from,
      DateTime? to}) async {
    return AuditRecords.fromJson(await _client.send(
      'get',
      'rest/api/3/auditing/record',
      queryParameters: {
        if (offset != null) 'offset': '$offset',
        if (limit != null) 'limit': '$limit',
        if (filter != null) 'filter': filter,
        if (from != null) 'from': '$from',
        if (to != null) 'to': '$to',
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class AvatarsApi {
  final ApiClient _client;

  AvatarsApi(this._client);

  /// Returns a list of system avatar details by owner type, where the owner
  /// types are issue type, project, or user.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<SystemAvatars> getAllSystemAvatars(String type) async {
    return SystemAvatars.fromJson(await _client.send(
      'get',
      'rest/api/3/avatar/{type}/system',
      pathParameters: {
        'type': type,
      },
    ));
  }

  /// Returns the system and custom avatars for a project or issue type.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  for custom project avatars, *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project the avatar belongs to.
  ///  *  for custom issue type avatars, *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for at
  /// least one project the issue type is used in.
  ///  *  for system avatars, none.
  Future<Avatars> getAvatars(
      {required String type, required String entityId}) async {
    return Avatars.fromJson(await _client.send(
      'get',
      'rest/api/3/universal_avatar/type/{type}/owner/{entityId}',
      pathParameters: {
        'type': type,
        'entityId': entityId,
      },
    ));
  }

  /// Loads a custom avatar for a project or issue type.
  ///
  /// Specify the avatar's local file location in the body of the request. Also,
  /// include the following headers:
  ///
  ///  *  `X-Atlassian-Token: no-check` To prevent XSRF protection blocking the
  /// request, for more information see
  /// [Special Headers](#special-request-headers).
  ///  *  `Content-Type: image/image type` Valid image types are JPEG, GIF, or
  /// PNG.
  ///
  /// For example:
  /// `curl --request POST `
  ///
  /// `--user email@example.com:<api_token> `
  ///
  /// `--header 'X-Atlassian-Token: no-check' `
  ///
  /// `--header 'Content-Type: image/< image_type>' `
  ///
  /// `--data-binary "<@/path/to/file/with/your/avatar>" `
  ///
  /// `--url
  /// 'https://your-domain.atlassian.net/rest/api/3/universal_avatar/type/{type}/owner/{entityId}'`
  ///
  /// The avatar is cropped to a square. If no crop parameters are specified,
  /// the square originates at the top left of the image. The length of the
  /// square's sides is set to the smaller of the height or width of the image.
  ///
  /// The cropped image is then used to create avatars of 16x16, 24x24, 32x32,
  /// and 48x48 in size.
  ///
  /// After creating the avatar use:
  ///
  ///  *  [Update issue type](#api-rest-api-3-issuetype-id-put) to set it as the
  /// issue type's displayed avatar.
  ///  *
  /// [Set project avatar](#api-rest-api-3-project-projectIdOrKey-avatar-put) to
  /// set it as the project's displayed avatar.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Avatar> storeAvatar(
      {required String type,
      required String entityId,
      int? x,
      int? y,
      required int size,
      required dynamic body}) async {
    return Avatar.fromJson(await _client.send(
      'post',
      'rest/api/3/universal_avatar/type/{type}/owner/{entityId}',
      pathParameters: {
        'type': type,
        'entityId': entityId,
      },
      queryParameters: {
        if (x != null) 'x': '$x',
        if (y != null) 'y': '$y',
        'size': '$size',
      },
      body: body,
    ));
  }

  /// Deletes an avatar from a project or issue type.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteAvatar(
      {required String type,
      required String owningObjectId,
      required int id}) async {
    await _client.send(
      'delete',
      'rest/api/3/universal_avatar/type/{type}/owner/{owningObjectId}/avatar/{id}',
      pathParameters: {
        'type': type,
        'owningObjectId': owningObjectId,
        'id': '$id',
      },
    );
  }

  /// Returns the default project or issue type avatar image.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<void> getAvatarImageByType(
      {required String type, String? size, String? format}) async {
    await _client.send(
      'get',
      'rest/api/3/universal_avatar/view/type/{type}',
      pathParameters: {
        'type': type,
      },
      queryParameters: {
        if (size != null) 'size': size,
        if (format != null) 'format': format,
      },
    );
  }

  /// Returns a project or issue type avatar image by ID.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  For system avatars, none.
  ///  *  For custom project avatars, *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project the avatar belongs to.
  ///  *  For custom issue type avatars, *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for at
  /// least one project the issue type is used in.
  Future<void> getAvatarImageByID(
      {required String type,
      required int id,
      String? size,
      String? format}) async {
    await _client.send(
      'get',
      'rest/api/3/universal_avatar/view/type/{type}/avatar/{id}',
      pathParameters: {
        'type': type,
        'id': '$id',
      },
      queryParameters: {
        if (size != null) 'size': size,
        if (format != null) 'format': format,
      },
    );
  }

  /// Returns the avatar image for a project or issue type.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  For system avatars, none.
  ///  *  For custom project avatars, *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project the avatar belongs to.
  ///  *  For custom issue type avatars, *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for at
  /// least one project the issue type is used in.
  Future<void> getAvatarImageByOwner(
      {required String type,
      required String entityId,
      String? size,
      String? format}) async {
    await _client.send(
      'get',
      'rest/api/3/universal_avatar/view/type/{type}/owner/{entityId}',
      pathParameters: {
        'type': type,
        'entityId': entityId,
      },
      queryParameters: {
        if (size != null) 'size': size,
        if (format != null) 'format': format,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class DashboardsApi {
  final ApiClient _client;

  DashboardsApi(this._client);

  /// Returns a list of dashboards owned by or shared with the user. The list
  /// may be filtered to include only favorite or owned dashboards.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<PageOfDashboards> getAllDashboards(
      {String? filter, int? startAt, int? maxResults}) async {
    return PageOfDashboards.fromJson(await _client.send(
      'get',
      'rest/api/3/dashboard',
      queryParameters: {
        if (filter != null) 'filter': filter,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Creates a dashboard.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<Dashboard> createDashboard({required DashboardDetails body}) async {
    return Dashboard.fromJson(await _client.send(
      'post',
      'rest/api/3/dashboard',
      body: body.toJson(),
    ));
  }

  /// Gets a list of all available gadgets that can be added to all dashboards.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<AvailableDashboardGadgetsResponse>
      getAllAvailableDashboardGadgets() async {
    return AvailableDashboardGadgetsResponse.fromJson(await _client.send(
      'get',
      'rest/api/3/dashboard/gadgets',
    ));
  }

  /// Returns a [paginated](#pagination) list of dashboards. This operation is
  /// similar to [Get dashboards](#api-rest-api-3-dashboard-get) except that the
  /// results can be refined to include dashboards that have specific
  /// attributes. For example, dashboards with a particular name. When multiple
  /// attributes are specified only filters matching all attributes are
  /// returned.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** The following dashboards that
  /// match the query parameters are returned:
  ///
  ///  *  Dashboards owned by the user. Not returned for anonymous users.
  ///  *  Dashboards shared with a group that the user is a member of. Not
  /// returned for anonymous users.
  ///  *  Dashboards shared with a private project that the user can browse. Not
  /// returned for anonymous users.
  ///  *  Dashboards shared with a public project.
  ///  *  Dashboards shared with the public.
  Future<PageBeanDashboard> getDashboardsPaginated(
      {String? dashboardName,
      String? accountId,
      String? owner,
      String? groupname,
      String? groupId,
      int? projectId,
      String? orderBy,
      int? startAt,
      int? maxResults,
      String? status,
      String? expand}) async {
    return PageBeanDashboard.fromJson(await _client.send(
      'get',
      'rest/api/3/dashboard/search',
      queryParameters: {
        if (dashboardName != null) 'dashboardName': dashboardName,
        if (accountId != null) 'accountId': accountId,
        if (owner != null) 'owner': owner,
        if (groupname != null) 'groupname': groupname,
        if (groupId != null) 'groupId': groupId,
        if (projectId != null) 'projectId': '$projectId',
        if (orderBy != null) 'orderBy': orderBy,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (status != null) 'status': status,
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns a list of dashboard gadgets on a dashboard.
  ///
  /// This operation returns:
  ///
  ///  *  Gadgets from a list of IDs, when `id` is set.
  ///  *  Gadgets with a module key, when `moduleKey` is set.
  ///  *  Gadgets from a list of URIs, when `uri` is set.
  ///  *  All gadgets, when no other parameters are set.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<DashboardGadgetResponse> getAllGadgets(
      {required int dashboardId,
      List<String>? moduleKey,
      List<String>? uri,
      List<int>? gadgetId}) async {
    return DashboardGadgetResponse.fromJson(await _client.send(
      'get',
      'rest/api/3/dashboard/{dashboardId}/gadget',
      pathParameters: {
        'dashboardId': '$dashboardId',
      },
      queryParameters: {
        if (moduleKey != null) 'moduleKey': moduleKey.map((e) => e).join(','),
        if (uri != null) 'uri': uri.map((e) => e).join(','),
        if (gadgetId != null) 'gadgetId': gadgetId.map((e) => '$e').join(','),
      },
    ));
  }

  /// Adds a gadget to a dashboard.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<DashboardGadget> addGadget(
      {required int dashboardId, required DashboardGadgetSettings body}) async {
    return DashboardGadget.fromJson(await _client.send(
      'post',
      'rest/api/3/dashboard/{dashboardId}/gadget',
      pathParameters: {
        'dashboardId': '$dashboardId',
      },
      body: body.toJson(),
    ));
  }

  /// Changes the title, position, and color of the gadget on a dashboard.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<dynamic> updateGadget(
      {required int dashboardId,
      required int gadgetId,
      required DashboardGadgetUpdateRequest body}) async {
    return await _client.send(
      'put',
      'rest/api/3/dashboard/{dashboardId}/gadget/{gadgetId}',
      pathParameters: {
        'dashboardId': '$dashboardId',
        'gadgetId': '$gadgetId',
      },
      body: body.toJson(),
    );
  }

  /// Removes a dashboard gadget from a dashboard.
  ///
  /// When a gadget is removed from a dashboard, other gadgets in the same
  /// column are moved up to fill the emptied position.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<dynamic> removeGadget(
      {required int dashboardId, required int gadgetId}) async {
    return await _client.send(
      'delete',
      'rest/api/3/dashboard/{dashboardId}/gadget/{gadgetId}',
      pathParameters: {
        'dashboardId': '$dashboardId',
        'gadgetId': '$gadgetId',
      },
    );
  }

  /// Returns the keys of all properties for a dashboard item.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** The user must be the owner of
  /// the dashboard or have the dashboard shared with them. Note, users with the
  /// *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) are
  /// considered owners of the System dashboard. The System dashboard is
  /// considered to be shared with all other users, and is accessible to
  /// anonymous users when Jira’s anonymous access is permitted.
  Future<PropertyKeys> getDashboardItemPropertyKeys(
      {required String dashboardId, required String itemId}) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties',
      pathParameters: {
        'dashboardId': dashboardId,
        'itemId': itemId,
      },
    ));
  }

  /// Returns the key and value of a dashboard item property.
  ///
  /// A dashboard item enables an app to add user-specific information to a user
  /// dashboard. Dashboard items are exposed to users as gadgets that users can
  /// add to their dashboards. For more information on how users do this, see
  /// [Adding and customizing gadgets](https://confluence.atlassian.com/x/7AeiLQ).
  ///
  /// When an app creates a dashboard item it registers a callback to receive
  /// the dashboard item ID. The callback fires whenever the item is rendered
  /// or, where the item is configurable, the user edits the item. The app then
  /// uses this resource to store the item's content or configuration details.
  /// For more information on working with dashboard items, see
  /// [ Building a dashboard item for a JIRA Connect add-on](https://developer.atlassian.com/server/jira/platform/guide-building-a-dashboard-item-for-a-jira-connect-add-on-33746254/)
  /// and the
  /// [Dashboard Item](https://developer.atlassian.com/cloud/jira/platform/modules/dashboard-item/)
  /// documentation.
  ///
  /// There is no resource to set or get dashboard items.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** The user must be the owner of
  /// the dashboard or have the dashboard shared with them. Note, users with the
  /// *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) are
  /// considered owners of the System dashboard. The System dashboard is
  /// considered to be shared with all other users, and is accessible to
  /// anonymous users when Jira’s anonymous access is permitted.
  Future<EntityProperty> getDashboardItemProperty(
      {required String dashboardId,
      required String itemId,
      required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}',
      pathParameters: {
        'dashboardId': dashboardId,
        'itemId': itemId,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Sets the value of a dashboard item property. Use this resource in apps to
  /// store custom data against a dashboard item.
  ///
  /// A dashboard item enables an app to add user-specific information to a user
  /// dashboard. Dashboard items are exposed to users as gadgets that users can
  /// add to their dashboards. For more information on how users do this, see
  /// [Adding and customizing gadgets](https://confluence.atlassian.com/x/7AeiLQ).
  ///
  /// When an app creates a dashboard item it registers a callback to receive
  /// the dashboard item ID. The callback fires whenever the item is rendered
  /// or, where the item is configurable, the user edits the item. The app then
  /// uses this resource to store the item's content or configuration details.
  /// For more information on working with dashboard items, see
  /// [ Building a dashboard item for a JIRA Connect add-on](https://developer.atlassian.com/server/jira/platform/guide-building-a-dashboard-item-for-a-jira-connect-add-on-33746254/)
  /// and the
  /// [Dashboard Item](https://developer.atlassian.com/cloud/jira/platform/modules/dashboard-item/)
  /// documentation.
  ///
  /// There is no resource to set or get dashboard items.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** The user must be the owner of
  /// the dashboard. Note, users with the *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) are
  /// considered owners of the System dashboard.
  Future<dynamic> setDashboardItemProperty(
      {required String dashboardId,
      required String itemId,
      required String propertyKey,
      required dynamic body}) async {
    return await _client.send(
      'put',
      'rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}',
      pathParameters: {
        'dashboardId': dashboardId,
        'itemId': itemId,
        'propertyKey': propertyKey,
      },
      body: body,
    );
  }

  /// Deletes a dashboard item property.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** The user must be the owner of
  /// the dashboard. Note, users with the *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) are
  /// considered owners of the System dashboard.
  Future<void> deleteDashboardItemProperty(
      {required String dashboardId,
      required String itemId,
      required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}',
      pathParameters: {
        'dashboardId': dashboardId,
        'itemId': itemId,
        'propertyKey': propertyKey,
      },
    );
  }

  /// Returns a dashboard.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  ///
  /// However, to get a dashboard, the dashboard must be shared with the user or
  /// the user must own it. Note, users with the *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) are
  /// considered owners of the System dashboard. The System dashboard is
  /// considered to be shared with all other users.
  Future<Dashboard> getDashboard(String id) async {
    return Dashboard.fromJson(await _client.send(
      'get',
      'rest/api/3/dashboard/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Updates a dashboard, replacing all the dashboard details with those
  /// provided.
  ///
  /// **[Permissions](#permissions) required:** None
  ///
  /// The dashboard to be updated must be owned by the user.
  Future<Dashboard> updateDashboard(
      {required String id, required DashboardDetails body}) async {
    return Dashboard.fromJson(await _client.send(
      'put',
      'rest/api/3/dashboard/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a dashboard.
  ///
  /// **[Permissions](#permissions) required:** None
  ///
  /// The dashboard to be deleted must be owned by the user.
  Future<void> deleteDashboard(String id) async {
    await _client.send(
      'delete',
      'rest/api/3/dashboard/{id}',
      pathParameters: {
        'id': id,
      },
    );
  }

  /// Copies a dashboard. Any values provided in the `dashboard` parameter
  /// replace those in the copied dashboard.
  ///
  /// **[Permissions](#permissions) required:** None
  ///
  /// The dashboard to be copied must be owned by or shared with the user.
  Future<Dashboard> copyDashboard(
      {required String id, required DashboardDetails body}) async {
    return Dashboard.fromJson(await _client.send(
      'post',
      'rest/api/3/dashboard/{id}/copy',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class DynamicModulesApi {
  final ApiClient _client;

  DynamicModulesApi(this._client);

  /// Returns all modules registered dynamically by the calling app.
  ///
  /// **[Permissions](#permissions) required:** Only Connect apps can make this
  /// request.
  Future<ConnectModules> getModules() async {
    return ConnectModules.fromJson(await _client.send(
      'get',
      'rest/atlassian-connect/1/app/module/dynamic',
    ));
  }

  /// Registers a list of modules.
  ///
  /// **[Permissions](#permissions) required:** Only Connect apps can make this
  /// request.
  Future<void> registerModules({required ConnectModules body}) async {
    await _client.send(
      'post',
      'rest/atlassian-connect/1/app/module/dynamic',
      body: body.toJson(),
    );
  }

  /// Remove all or a list of modules registered by the calling app.
  ///
  /// **[Permissions](#permissions) required:** Only Connect apps can make this
  /// request.
  Future<void> removeModules({List<String>? moduleKey}) async {
    await _client.send(
      'delete',
      'rest/atlassian-connect/1/app/module/dynamic',
      queryParameters: {
        if (moduleKey != null) 'moduleKey': moduleKey.map((e) => e).join(','),
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class FilterSharingApi {
  final ApiClient _client;

  FilterSharingApi(this._client);

  /// Returns the default sharing settings for new filters and dashboards for a
  /// user.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<DefaultShareScope> getDefaultShareScope() async {
    return DefaultShareScope.fromJson(await _client.send(
      'get',
      'rest/api/3/filter/defaultShareScope',
    ));
  }

  /// Sets the default sharing for new filters and dashboards for a user.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<DefaultShareScope> setDefaultShareScope(
      {required DefaultShareScope body}) async {
    return DefaultShareScope.fromJson(await _client.send(
      'put',
      'rest/api/3/filter/defaultShareScope',
      body: body.toJson(),
    ));
  }

  /// Returns the share permissions for a filter. A filter can be shared with
  /// groups, projects, all logged-in users, or the public. Sharing with all
  /// logged-in users or the public is known as a global share permission.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None, however, share permissions
  /// are only returned for:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<List<SharePermission>> getSharePermissions(int id) async {
    return (await _client.send(
      'get',
      'rest/api/3/filter/{id}/permission',
      pathParameters: {
        'id': '$id',
      },
    ) as List<Object?>)
        .map((i) =>
            SharePermission.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Add a share permissions to a filter. If you add a global share permission
  /// (one for all logged-in users or the public) it will overwrite all share
  /// permissions for the filter.
  ///
  /// Be aware that this operation uses different objects for updating share
  /// permissions compared to [Update filter](#api-rest-api-3-filter-id-put).
  ///
  /// **[Permissions](#permissions) required:** *Share dashboards and filters*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) and the
  /// user must own the filter.
  Future<List<SharePermission>> addSharePermission(
      {required int id, required SharePermissionInputBean body}) async {
    return (await _client.send(
      'post',
      'rest/api/3/filter/{id}/permission',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ) as List<Object?>)
        .map((i) =>
            SharePermission.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a share permission for a filter. A filter can be shared with
  /// groups, projects, all logged-in users, or the public. Sharing with all
  /// logged-in users or the public is known as a global share permission.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None, however, a share
  /// permission is only returned for:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<SharePermission> getSharePermission(
      {required int id, required int permissionId}) async {
    return SharePermission.fromJson(await _client.send(
      'get',
      'rest/api/3/filter/{id}/permission/{permissionId}',
      pathParameters: {
        'id': '$id',
        'permissionId': '$permissionId',
      },
    ));
  }

  /// Deletes a share permission from a filter.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira and
  /// the user must own the filter.
  Future<void> deleteSharePermission(
      {required int id, required int permissionId}) async {
    await _client.send(
      'delete',
      'rest/api/3/filter/{id}/permission/{permissionId}',
      pathParameters: {
        'id': '$id',
        'permissionId': '$permissionId',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class FiltersApi {
  final ApiClient _client;

  FiltersApi(this._client);

  /// Creates a filter. The filter is shared according to the
  /// [default share scope](#api-rest-api-3-filter-post). The filter is not
  /// selected as a favorite.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<Filter> createFilter(
      {String? expand,
      bool? overrideSharePermissions,
      required Filter body}) async {
    return Filter.fromJson(await _client.send(
      'post',
      'rest/api/3/filter',
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (overrideSharePermissions != null)
          'overrideSharePermissions': '$overrideSharePermissions',
      },
      body: body.toJson(),
    ));
  }

  /// Returns the visible favorite filters of the user.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** A favorite filter is only
  /// visible to the user where the filter is:
  ///
  ///  *  owned by the user.
  ///  *  shared with a group that the user is a member of.
  ///  *  shared with a private project that the user has *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for.
  ///  *  shared with a public project.
  ///  *  shared with the public.
  ///
  /// For example, if the user favorites a public filter that is subsequently
  /// made private that filter is not returned by this operation.
  Future<List<Filter>> getFavouriteFilters({String? expand}) async {
    return (await _client.send(
      'get',
      'rest/api/3/filter/favourite',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ) as List<Object?>)
        .map((i) => Filter.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns the filters owned by the user. If `includeFavourites` is `true`,
  /// the user's visible favorite filters are also returned.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, a favorite filters is only visible to the user where the filter
  /// is:
  ///
  ///  *  owned by the user.
  ///  *  shared with a group that the user is a member of.
  ///  *  shared with a private project that the user has *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for.
  ///  *  shared with a public project.
  ///  *  shared with the public.
  ///
  /// For example, if the user favorites a public filter that is subsequently
  /// made private that filter is not returned by this operation.
  Future<List<Filter>> getMyFilters(
      {String? expand, bool? includeFavourites}) async {
    return (await _client.send(
      'get',
      'rest/api/3/filter/my',
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (includeFavourites != null)
          'includeFavourites': '$includeFavourites',
      },
    ) as List<Object?>)
        .map((i) => Filter.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a [paginated](#pagination) list of filters. Use this operation to
  /// get:
  ///
  ///  *  specific filters, by defining `id` only.
  ///  *  filters that match all of the specified attributes. For example, all
  /// filters for a user with a particular word in their name. When multiple
  /// attributes are specified only filters matching all attributes are
  /// returned.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None, however, only the
  /// following filters that match the query parameters are returned:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<PageBeanFilterDetails> getFiltersPaginated(
      {String? filterName,
      String? accountId,
      String? owner,
      String? groupname,
      String? groupId,
      int? projectId,
      List<int>? id,
      String? orderBy,
      int? startAt,
      int? maxResults,
      String? expand,
      bool? overrideSharePermissions}) async {
    return PageBeanFilterDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/filter/search',
      queryParameters: {
        if (filterName != null) 'filterName': filterName,
        if (accountId != null) 'accountId': accountId,
        if (owner != null) 'owner': owner,
        if (groupname != null) 'groupname': groupname,
        if (groupId != null) 'groupId': groupId,
        if (projectId != null) 'projectId': '$projectId',
        if (id != null) 'id': id.map((e) => '$e').join(','),
        if (orderBy != null) 'orderBy': orderBy,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (expand != null) 'expand': expand,
        if (overrideSharePermissions != null)
          'overrideSharePermissions': '$overrideSharePermissions',
      },
    ));
  }

  /// Returns a filter.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None, however, the filter is
  /// only returned where it is:
  ///
  ///  *  owned by the user.
  ///  *  shared with a group that the user is a member of.
  ///  *  shared with a private project that the user has *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for.
  ///  *  shared with a public project.
  ///  *  shared with the public.
  Future<Filter> getFilter(
      {required int id, String? expand, bool? overrideSharePermissions}) async {
    return Filter.fromJson(await _client.send(
      'get',
      'rest/api/3/filter/{id}',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (overrideSharePermissions != null)
          'overrideSharePermissions': '$overrideSharePermissions',
      },
    ));
  }

  /// Updates a filter. Use this operation to update a filter's name,
  /// description, JQL, or sharing.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however the user must own the filter.
  Future<Filter> updateFilter(
      {required int id,
      String? expand,
      bool? overrideSharePermissions,
      required Filter body}) async {
    return Filter.fromJson(await _client.send(
      'put',
      'rest/api/3/filter/{id}',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (overrideSharePermissions != null)
          'overrideSharePermissions': '$overrideSharePermissions',
      },
      body: body.toJson(),
    ));
  }

  /// Delete a filter.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however filters can only be deleted by the creator of the filter or a user
  /// with *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteFilter(int id) async {
    await _client.send(
      'delete',
      'rest/api/3/filter/{id}',
      pathParameters: {
        'id': '$id',
      },
    );
  }

  /// Returns the columns configured for a filter. The column configuration is
  /// used when the filter's results are viewed in *List View* with the
  /// *Columns* set to *Filter*.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None, however, column details
  /// are only returned for:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<List<ColumnItem>> getColumns(int id) async {
    return (await _client.send(
      'get',
      'rest/api/3/filter/{id}/columns',
      pathParameters: {
        'id': '$id',
      },
    ) as List<Object?>)
        .map((i) => ColumnItem.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Sets the columns for a filter. Only navigable fields can be set as
  /// columns. Use [Get fields](#api-rest-api-3-field-get) to get the list
  /// fields in Jira. A navigable field has `navigable` set to `true`.
  ///
  /// The parameters for this resource are expressed as HTML form data. For
  /// example, in curl:
  ///
  /// `curl -X PUT -d columns=summary -d columns=description
  /// https://your-domain.atlassian.net/rest/api/3/filter/10000/columns`
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, columns are only set for:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<dynamic> setColumns(
      {required int id, required List<String> body}) async {
    return await _client.send(
      'put',
      'rest/api/3/filter/{id}/columns',
      pathParameters: {
        'id': '$id',
      },
      body: body,
    );
  }

  /// Reset the user's column configuration for the filter to the default.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, columns are only reset for:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<void> resetColumns(int id) async {
    await _client.send(
      'delete',
      'rest/api/3/filter/{id}/columns',
      pathParameters: {
        'id': '$id',
      },
    );
  }

  /// Add a filter as a favorite for the user.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, the user can only favorite:
  ///
  ///  *  filters owned by the user.
  ///  *  filters shared with a group that the user is a member of.
  ///  *  filters shared with a private project that the user has *Browse
  /// projects* [project permission](https://confluence.atlassian.com/x/yodKLg)
  /// for.
  ///  *  filters shared with a public project.
  ///  *  filters shared with the public.
  Future<Filter> setFavouriteForFilter(
      {required int id, String? expand}) async {
    return Filter.fromJson(await _client.send(
      'put',
      'rest/api/3/filter/{id}/favourite',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Removes a filter as a favorite for the user. Note that this operation only
  /// removes filters visible to the user from the user's favorites list. For
  /// example, if the user favorites a public filter that is subsequently made
  /// private (and is therefore no longer visible on their favorites list) they
  /// cannot remove it from their favorites list.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<Filter> deleteFavouriteForFilter(
      {required int id, String? expand}) async {
    return Filter.fromJson(await _client.send(
      'delete',
      'rest/api/3/filter/{id}/favourite',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Changes the owner of the filter.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  /// However, the user must own the filter or have the *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> changeFilterOwner(
      {required int id, required ChangeFilterOwner body}) async {
    return await _client.send(
      'put',
      'rest/api/3/filter/{id}/owner',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class GroupAndUserPickerApi {
  final ApiClient _client;

  GroupAndUserPickerApi(this._client);

  /// Returns a list of users and groups matching a string. The string is used:
  ///
  ///  *  for users, to find a case-insensitive match with display name and
  /// e-mail address. Note that if a user has hidden their email address in
  /// their user profile, partial matches of the email address will not find the
  /// user. An exact match is required.
  ///  *  for groups, to find a case-sensitive match with group name.
  ///
  /// For example, if the string *tin* is used, records with the display name
  /// *Tina*, email address *sarah@tinplatetraining.com*, and the group
  /// *accounting* would be returned.
  ///
  /// Optionally, the search can be refined to:
  ///
  ///  *  the projects and issue types associated with a custom field, such as a
  /// user picker. The search can then be further refined to return only users
  /// and groups that have permission to view specific:
  ///
  ///      *  projects.
  ///      *  issue types.
  ///
  ///     If multiple projects or issue types are specified, they must be a
  /// subset of those enabled for the custom field or no results are returned.
  /// For example, if a field is enabled for projects A, B, and C then the
  /// search could be limited to projects B and C. However, if the search is
  /// limited to projects B and D, nothing is returned.
  ///  *  not return Connect app users and groups.
  ///  *  return groups that have a case-insensitive match with the query.
  ///
  /// The primary use case for this resource is to populate a picker field
  /// suggestion list with users or groups. To this end, the returned object
  /// includes an `html` field for each list. This field highlights the matched
  /// query term in the item name with the HTML strong tag. Also, each list is
  /// wrapped in a response object that contains a header for use in a picker,
  /// specifically *Showing X of Y matching groups*.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/yodKLg).
  Future<FoundUsersAndGroups> findUsersAndGroups(
      {required String query,
      int? maxResults,
      bool? showAvatar,
      String? fieldId,
      List<String>? projectId,
      List<String>? issueTypeId,
      String? avatarSize,
      bool? caseInsensitive,
      bool? excludeConnectAddons}) async {
    return FoundUsersAndGroups.fromJson(await _client.send(
      'get',
      'rest/api/3/groupuserpicker',
      queryParameters: {
        'query': query,
        if (maxResults != null) 'maxResults': '$maxResults',
        if (showAvatar != null) 'showAvatar': '$showAvatar',
        if (fieldId != null) 'fieldId': fieldId,
        if (projectId != null) 'projectId': projectId.map((e) => e).join(','),
        if (issueTypeId != null)
          'issueTypeId': issueTypeId.map((e) => e).join(','),
        if (avatarSize != null) 'avatarSize': avatarSize,
        if (caseInsensitive != null) 'caseInsensitive': '$caseInsensitive',
        if (excludeConnectAddons != null)
          'excludeConnectAddons': '$excludeConnectAddons',
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class GroupsApi {
  final ApiClient _client;

  GroupsApi(this._client);

  /// This operation is deprecated, use
  /// [`group/member`](#api-rest-api-3-group-member-get).
  ///
  /// Returns all users in a group.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Group> getGroup(
      {String? groupname, String? groupId, String? expand}) async {
    return Group.fromJson(await _client.send(
      'get',
      'rest/api/3/group',
      queryParameters: {
        if (groupname != null) 'groupname': groupname,
        if (groupId != null) 'groupId': groupId,
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Creates a group.
  ///
  /// **[Permissions](#permissions) required:** Site administration (that is,
  /// member of the *site-admin*
  /// [group](https://confluence.atlassian.com/x/24xjL)).
  Future<Group> createGroup({required AddGroupBean body}) async {
    return Group.fromJson(await _client.send(
      'post',
      'rest/api/3/group',
      body: body.toJson(),
    ));
  }

  /// Deletes a group.
  ///
  /// **[Permissions](#permissions) required:** Site administration (that is,
  /// member of the *site-admin* strategic
  /// [group](https://confluence.atlassian.com/x/24xjL)).
  Future<void> removeGroup(
      {String? groupname,
      String? groupId,
      String? swapGroup,
      String? swapGroupId}) async {
    await _client.send(
      'delete',
      'rest/api/3/group',
      queryParameters: {
        if (groupname != null) 'groupname': groupname,
        if (groupId != null) 'groupId': groupId,
        if (swapGroup != null) 'swapGroup': swapGroup,
        if (swapGroupId != null) 'swapGroupId': swapGroupId,
      },
    );
  }

  /// Returns a [paginated](#pagination) list of groups.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanGroupDetails> bulkGetGroups(
      {int? startAt,
      int? maxResults,
      List<String>? groupId,
      List<String>? groupName,
      String? accessType,
      String? applicationKey}) async {
    return PageBeanGroupDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/group/bulk',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (groupId != null) 'groupId': groupId.map((e) => e).join(','),
        if (groupName != null) 'groupName': groupName.map((e) => e).join(','),
        if (accessType != null) 'accessType': accessType,
        if (applicationKey != null) 'applicationKey': applicationKey,
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of all users in a group.
  ///
  /// Note that users are ordered by username, however the username is not
  /// returned in the results due to privacy reasons.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanUserDetails> getUsersFromGroup(
      {String? groupname,
      String? groupId,
      bool? includeInactiveUsers,
      int? startAt,
      int? maxResults}) async {
    return PageBeanUserDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/group/member',
      queryParameters: {
        if (groupname != null) 'groupname': groupname,
        if (groupId != null) 'groupId': groupId,
        if (includeInactiveUsers != null)
          'includeInactiveUsers': '$includeInactiveUsers',
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Adds a user to a group.
  ///
  /// **[Permissions](#permissions) required:** Site administration (that is,
  /// member of the *site-admin*
  /// [group](https://confluence.atlassian.com/x/24xjL)).
  Future<Group> addUserToGroup(
      {String? groupname,
      String? groupId,
      required UpdateUserToGroupBean body}) async {
    return Group.fromJson(await _client.send(
      'post',
      'rest/api/3/group/user',
      queryParameters: {
        if (groupname != null) 'groupname': groupname,
        if (groupId != null) 'groupId': groupId,
      },
      body: body.toJson(),
    ));
  }

  /// Removes a user from a group.
  ///
  /// **[Permissions](#permissions) required:** Site administration (that is,
  /// member of the *site-admin*
  /// [group](https://confluence.atlassian.com/x/24xjL)).
  Future<void> removeUserFromGroup(
      {String? groupname,
      String? groupId,
      String? username,
      required String accountId}) async {
    await _client.send(
      'delete',
      'rest/api/3/group/user',
      queryParameters: {
        if (groupname != null) 'groupname': groupname,
        if (groupId != null) 'groupId': groupId,
        if (username != null) 'username': username,
        'accountId': accountId,
      },
    );
  }

  /// Returns a list of groups whose names contain a query string. A list of
  /// group names can be provided to exclude groups from the results.
  ///
  /// The primary use case for this resource is to populate a group picker
  /// suggestions list. To this end, the returned object includes the `html`
  /// field where the matched query term is highlighted in the group name with
  /// the HTML strong tag. Also, the groups list is wrapped in a response object
  /// that contains a header for use in the picker, specifically *Showing X of Y
  /// matching groups*.
  ///
  /// The list returns with the groups sorted. If no groups match the list
  /// criteria, an empty list is returned.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg). Anonymous
  /// calls and calls by users without the required permission return an empty
  /// list.
  ///
  /// *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Without
  /// this permission, calls where query is not an exact match to an existing
  /// group will return an empty list.
  Future<FoundGroups> findGroups(
      {String? accountId,
      String? query,
      List<String>? exclude,
      List<String>? excludeId,
      int? maxResults,
      bool? caseInsensitive,
      String? userName}) async {
    return FoundGroups.fromJson(await _client.send(
      'get',
      'rest/api/3/groups/picker',
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (query != null) 'query': query,
        if (exclude != null) 'exclude': exclude.map((e) => e).join(','),
        if (excludeId != null) 'excludeId': excludeId.map((e) => e).join(','),
        if (maxResults != null) 'maxResults': '$maxResults',
        if (caseInsensitive != null) 'caseInsensitive': '$caseInsensitive',
        if (userName != null) 'userName': userName,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class InstanceInformationApi {
  final ApiClient _client;

  InstanceInformationApi(this._client);

  /// Returns licensing information about the Jira instance.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<License> getLicense() async {
    return License.fromJson(await _client.send(
      'get',
      'rest/api/3/instance/license',
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueAttachmentsApi {
  final ApiClient _client;

  IssueAttachmentsApi(this._client);

  /// Returns the contents of an attachment. A `Range` header can be set to
  /// define a range of bytes within the attachment to download. See the
  /// [HTTP Range header standard](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range)
  /// for details.
  ///
  /// To return a thumbnail of the attachment, use
  /// [Get attachment thumbnail](#api-rest-api-3-attachment-thumbnail-id-get).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** For the issue containing the
  /// attachment:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<Map<String, dynamic>> getAttachmentContent(
      {required String id, bool? redirect}) async {
    return await _client.send(
      'get',
      'rest/api/3/attachment/content/{id}',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        if (redirect != null) 'redirect': '$redirect',
      },
    ) as Map<String, Object?>;
  }

  /// Returns the attachment settings, that is, whether attachments are enabled
  /// and the maximum attachment size allowed.
  ///
  /// Note that there are also
  /// [project permissions](https://confluence.atlassian.com/x/yodKLg) that
  /// restrict whether users can create and delete attachments.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<AttachmentSettings> getAttachmentMeta() async {
    return AttachmentSettings.fromJson(await _client.send(
      'get',
      'rest/api/3/attachment/meta',
    ));
  }

  /// Returns the thumbnail of an attachment.
  ///
  /// To return the attachment contents, use
  /// [Get attachment content](#api-rest-api-3-attachment-content-id-get).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** For the issue containing the
  /// attachment:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<Map<String, dynamic>> getAttachmentThumbnail(
      {required String id,
      bool? redirect,
      bool? fallbackToDefault,
      int? width,
      int? height}) async {
    return await _client.send(
      'get',
      'rest/api/3/attachment/thumbnail/{id}',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        if (redirect != null) 'redirect': '$redirect',
        if (fallbackToDefault != null)
          'fallbackToDefault': '$fallbackToDefault',
        if (width != null) 'width': '$width',
        if (height != null) 'height': '$height',
      },
    ) as Map<String, Object?>;
  }

  /// Returns the metadata for an attachment. Note that the attachment itself is
  /// not returned.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<AttachmentMetadata> getAttachment(String id) async {
    return AttachmentMetadata.fromJson(await _client.send(
      'get',
      'rest/api/3/attachment/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Deletes an attachment from an issue.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** For the project holding the
  /// issue containing the attachment:
  ///
  ///  *  *Delete own attachments*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to delete
  /// an attachment created by the calling user.
  ///  *  *Delete all attachments*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to delete
  /// an attachment created by any user.
  Future<void> removeAttachment(String id) async {
    await _client.send(
      'delete',
      'rest/api/3/attachment/{id}',
      pathParameters: {
        'id': id,
      },
    );
  }

  /// Returns the metadata for the contents of an attachment, if it is an
  /// archive, and metadata for the attachment itself. For example, if the
  /// attachment is a ZIP archive, then information about the files in the
  /// archive is returned and metadata for the ZIP archive. Currently, only the
  /// ZIP archive format is supported.
  ///
  /// Use this operation to retrieve data that is presented to the user, as this
  /// operation returns the metadata for the attachment itself, such as the
  /// attachment's ID and name. Otherwise, use
  /// [ Get contents metadata for an expanded attachment](#api-rest-api-3-attachment-id-expand-raw-get),
  /// which only returns the metadata for the attachment's contents.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** For the issue containing the
  /// attachment:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<AttachmentArchiveMetadataReadable> expandAttachmentForHumans(
      String id) async {
    return AttachmentArchiveMetadataReadable.fromJson(await _client.send(
      'get',
      'rest/api/3/attachment/{id}/expand/human',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Returns the metadata for the contents of an attachment, if it is an
  /// archive. For example, if the attachment is a ZIP archive, then information
  /// about the files in the archive is returned. Currently, only the ZIP
  /// archive format is supported.
  ///
  /// Use this operation if you are processing the data without presenting it to
  /// the user, as this operation only returns the metadata for the contents of
  /// the attachment. Otherwise, to retrieve data to present to the user, use
  /// [ Get all metadata for an expanded attachment](#api-rest-api-3-attachment-id-expand-human-get)
  /// which also returns the metadata for the attachment itself, such as the
  /// attachment's ID and name.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** For the issue containing the
  /// attachment:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<AttachmentArchiveImpl> expandAttachmentForMachines(String id) async {
    return AttachmentArchiveImpl.fromJson(await _client.send(
      'get',
      'rest/api/3/attachment/{id}/expand/raw',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Adds one or more attachments to an issue. Attachments are posted as
  /// multipart/form-data ([RFC 1867](https://www.ietf.org/rfc/rfc1867.txt)).
  ///
  /// Note that:
  ///
  ///  *  The request must have a `X-Atlassian-Token: no-check` header, if not
  /// it is blocked. See [Special headers](#special-request-headers) for more
  /// information.
  ///  *  The name of the multipart/form-data parameter that contains the
  /// attachments must be `file`.
  ///
  /// The following examples upload a file called *myfile.txt* to the issue
  /// *TEST-123*:
  ///
  /// #### curl ####
  ///
  ///     curl --location --request POST
  /// 'https://your-domain.atlassian.net/rest/api/3/issue/TEST-123/attachments'
  ///      -u 'email@example.com:<api_token>'
  ///      -H 'X-Atlassian-Token: no-check'
  ///      --form 'file=@"myfile.txt"'
  ///
  /// #### Node.js ####
  ///
  ///     // This code sample uses the 'node-fetch' and 'form-data' libraries:
  ///      // https://www.npmjs.com/package/node-fetch
  ///      // https://www.npmjs.com/package/form-data
  ///      const fetch = require('node-fetch');
  ///      const FormData = require('form-data');
  ///      const fs = require('fs');
  ///
  ///      const filePath = 'myfile.txt';
  ///      const form = new FormData();
  ///      const stats = fs.statSync(filePath);
  ///      const fileSizeInBytes = stats.size;
  ///      const fileStream = fs.createReadStream(filePath);
  ///
  ///      form.append('file', fileStream, {knownLength: fileSizeInBytes});
  ///
  ///
  /// fetch('https://your-domain.atlassian.net/rest/api/3/issue/TEST-123/attachments',
  /// {
  ///          method: 'POST',
  ///          body: form,
  ///          headers: {
  ///              'Authorization': `Basic ${Buffer.from(
  ///                  'email@example.com:'
  ///              ).toString('base64')}`,
  ///              'Accept': 'application/json',
  ///              'X-Atlassian-Token': 'no-check'
  ///          }
  ///      })
  ///          .then(response => {
  ///              console.log(
  ///                  `Response: ${response.status} ${response.statusText}`
  ///              );
  ///              return response.text();
  ///          })
  ///          .then(text => console.log(text))
  ///          .catch(err => console.error(err));
  ///
  /// #### Java ####
  ///
  ///     // This code sample uses the  'Unirest' library:
  ///      // http://unirest.io/java.html
  ///      HttpResponse response =
  /// Unirest.post("https://your-domain.atlassian.net/rest/api/2/issue/{issueIdOrKey}/attachments")
  ///              .basicAuth("email@example.com", "")
  ///              .header("Accept", "application/json")
  ///              .header("X-Atlassian-Token", "no-check")
  ///              .field("file", new File("myfile.txt"))
  ///              .asJson();
  ///
  ///              System.out.println(response.getBody());
  ///
  /// #### Python ####
  ///
  ///     # This code sample uses the 'requests' library:
  ///      # http://docs.python-requests.org
  ///      import requests
  ///      from requests.auth import HTTPBasicAuth
  ///      import json
  ///
  ///      url =
  /// "https://your-domain.atlassian.net/rest/api/2/issue/{issueIdOrKey}/attachments"
  ///
  ///      auth = HTTPBasicAuth("email@example.com", "")
  ///
  ///      headers = {
  ///         "Accept": "application/json",
  ///         "X-Atlassian-Token": "no-check"
  ///      }
  ///
  ///      response = requests.request(
  ///         "POST",
  ///         url,
  ///         headers = headers,
  ///         auth = auth,
  ///         files = {
  ///              "file": ("myfile.txt", open("myfile.txt","rb"),
  /// "application-type")
  ///         }
  ///      )
  ///
  ///      print(json.dumps(json.loads(response.text), sort_keys=True, indent=4,
  /// separators=(",", ": ")))
  ///
  /// #### PHP ####
  ///
  ///     // This code sample uses the 'Unirest' library:
  ///      // http://unirest.io/php.html
  ///      UnirestRequest::auth('email@example.com', '');
  ///
  ///      $headers = array(
  ///        'Accept' => 'application/json',
  ///        'X-Atlassian-Token' => 'no-check'
  ///      );
  ///
  ///      $parameters = array(
  ///        'file' => File::add('myfile.txt')
  ///      );
  ///
  ///      $response = UnirestRequest::post(
  ///
  /// 'https://your-domain.atlassian.net/rest/api/2/issue/{issueIdOrKey}/attachments',
  ///        $headers,
  ///        $parameters
  ///      );
  ///
  ///      var_dump($response)
  ///
  /// #### Forge ####
  ///
  ///     // This sample uses Atlassian Forge and the `form-data` library.
  ///      // https://developer.atlassian.com/platform/forge/
  ///      // https://www.npmjs.com/package/form-data
  ///      import api from "@forge/api";
  ///      import FormData from "form-data";
  ///
  ///      const form = new FormData();
  ///      form.append('file', fileStream, {knownLength: fileSizeInBytes});
  ///
  ///      const response = await
  /// api.asApp().requestJira('/rest/api/2/issue/{issueIdOrKey}/attachments', {
  ///          method: 'POST',
  ///          body: form,
  ///          headers: {
  ///              'Accept': 'application/json',
  ///              'X-Atlassian-Token': 'no-check'
  ///          }
  ///      });
  ///
  ///      console.log(`Response: ${response.status} ${response.statusText}`);
  ///      console.log(await response.json());
  ///
  /// Tip: Use a client library. Many client libraries have classes for handling
  /// multipart POST operations. For example, in Java, the Apache HTTP
  /// Components library provides a
  /// [MultiPartEntity](http://hc.apache.org/httpcomponents-client-ga/httpmime/apidocs/org/apache/http/entity/mime/MultipartEntity.html)
  /// class for multipart POST operations.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse Projects* and *Create attachments*
  /// [ project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<List<Attachment>> addAttachment(
      {required String issueIdOrKey, required MultipartFile file}) async {
    return (await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/attachments',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      file: file,
    ) as List<Object?>)
        .map((i) => Attachment.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }
}

/// Jira Cloud platform REST API documentation

class IssueCommentPropertiesApi {
  final ApiClient _client;

  IssueCommentPropertiesApi(this._client);

  /// Returns the keys of all the properties of a comment.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the comment has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<PropertyKeys> getCommentPropertyKeys(String commentId) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/comment/{commentId}/properties',
      pathParameters: {
        'commentId': commentId,
      },
    ));
  }

  /// Returns the value of a comment property.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the comment has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<EntityProperty> getCommentProperty(
      {required String commentId, required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/comment/{commentId}/properties/{propertyKey}',
      pathParameters: {
        'commentId': commentId,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Creates or updates the value of a property for a comment. Use this
  /// resource to store custom data against a comment.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// **[Permissions](#permissions) required:** either of:
  ///
  ///  *  *Edit All Comments*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to create
  /// or update the value of a property on any comment.
  ///  *  *Edit Own Comments*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to create
  /// or update the value of a property on a comment created by the user.
  ///
  /// Also, when the visibility of a comment is restricted to a role or group
  /// the user must be a member of that role or group.
  Future<dynamic> setCommentProperty(
      {required String commentId,
      required String propertyKey,
      required dynamic body}) async {
    return await _client.send(
      'put',
      'rest/api/3/comment/{commentId}/properties/{propertyKey}',
      pathParameters: {
        'commentId': commentId,
        'propertyKey': propertyKey,
      },
      body: body,
    );
  }

  /// Deletes a comment property.
  ///
  /// **[Permissions](#permissions) required:** either of:
  ///
  ///  *  *Edit All Comments*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to delete
  /// a property from any comment.
  ///  *  *Edit Own Comments*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to delete
  /// a property from a comment created by the user.
  ///
  /// Also, when the visibility of a comment is restricted to a role or group
  /// the user must be a member of that role or group.
  Future<void> deleteCommentProperty(
      {required String commentId, required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/comment/{commentId}/properties/{propertyKey}',
      pathParameters: {
        'commentId': commentId,
        'propertyKey': propertyKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueCommentsApi {
  final ApiClient _client;

  IssueCommentsApi(this._client);

  /// Returns a [paginated](#pagination) list of comments specified by a list of
  /// comment IDs.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Comments are returned where the
  /// user:
  ///
  ///  *  has *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the comment.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the comment has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<PageBeanComment> getCommentsByIds(
      {String? expand, required IssueCommentListRequestBean body}) async {
    return PageBeanComment.fromJson(await _client.send(
      'post',
      'rest/api/3/comment/list',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Returns all comments for an issue.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Comments are included in the
  /// response where the user has:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the comment.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the comment has visibility restrictions, belongs to the group or
  /// has the role visibility is role visibility is restricted to.
  Future<PageOfComments> getComments(
      {required String issueIdOrKey,
      int? startAt,
      int? maxResults,
      String? orderBy,
      String? expand}) async {
    return PageOfComments.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/comment',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (orderBy != null) 'orderBy': orderBy,
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Adds a comment to an issue.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Add comments*
  /// [ project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue containing the comment is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<Comment> addComment(
      {required String issueIdOrKey,
      String? expand,
      required Comment body}) async {
    return Comment.fromJson(await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/comment',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Returns a comment.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the comment.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the comment has visibility restrictions, the user belongs to the
  /// group or has the role visibility is restricted to.
  Future<Comment> getComment(
      {required String issueIdOrKey,
      required String id,
      String? expand}) async {
    return Comment.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/comment/{id}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'id': id,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates a comment.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue containing the comment is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Edit all
  /// comments*[ project permission](https://confluence.atlassian.com/x/yodKLg)
  /// to update any comment or *Edit own comments* to update comment created by
  /// the user.
  ///  *  If the comment has visibility restrictions, the user belongs to the
  /// group or has the role visibility is restricted to.
  Future<Comment> updateComment(
      {required String issueIdOrKey,
      required String id,
      bool? notifyUsers,
      bool? overrideEditableFlag,
      String? expand,
      required Comment body}) async {
    return Comment.fromJson(await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}/comment/{id}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'id': id,
      },
      queryParameters: {
        if (notifyUsers != null) 'notifyUsers': '$notifyUsers',
        if (overrideEditableFlag != null)
          'overrideEditableFlag': '$overrideEditableFlag',
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a comment.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue containing the comment is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Delete all
  /// comments*[ project permission](https://confluence.atlassian.com/x/yodKLg)
  /// to delete any comment or *Delete own comments* to delete comment created
  /// by the user,
  ///  *  If the comment has visibility restrictions, the user belongs to the
  /// group or has the role visibility is restricted to.
  Future<void> deleteComment(
      {required String issueIdOrKey, required String id}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/comment/{id}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'id': id,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueCustomFieldConfigurationAppsApi {
  final ApiClient _client;

  IssueCustomFieldConfigurationAppsApi(this._client);

  /// Returns a [paginated](#pagination) list of configurations for a custom
  /// field created by a
  /// [Forge app](https://developer.atlassian.com/platform/forge/).
  ///
  /// The result can be filtered by one of these criteria:
  ///
  ///  *  `id`.
  ///  *  `fieldContextId`.
  ///  *  `issueId`.
  ///  *  `projectKeyOrId` and `issueTypeId`.
  ///
  /// Otherwise, all configurations are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the Forge app that created the custom
  /// field.
  Future<PageBeanContextualConfiguration> getCustomFieldConfiguration(
      {required String fieldIdOrKey,
      List<int>? id,
      List<int>? fieldContextId,
      int? issueId,
      String? projectKeyOrId,
      String? issueTypeId,
      int? startAt,
      int? maxResults}) async {
    return PageBeanContextualConfiguration.fromJson(await _client.send(
      'get',
      'rest/api/3/app/field/{fieldIdOrKey}/context/configuration',
      pathParameters: {
        'fieldIdOrKey': fieldIdOrKey,
      },
      queryParameters: {
        if (id != null) 'id': id.map((e) => '$e').join(','),
        if (fieldContextId != null)
          'fieldContextId': fieldContextId.map((e) => '$e').join(','),
        if (issueId != null) 'issueId': '$issueId',
        if (projectKeyOrId != null) 'projectKeyOrId': projectKeyOrId,
        if (issueTypeId != null) 'issueTypeId': issueTypeId,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Update the configuration for contexts of a custom field created by a
  /// [Forge app](https://developer.atlassian.com/platform/forge/).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the Forge app that created the custom
  /// field.
  Future<dynamic> updateCustomFieldConfiguration(
      {required String fieldIdOrKey,
      required CustomFieldConfigurations body}) async {
    return await _client.send(
      'put',
      'rest/api/3/app/field/{fieldIdOrKey}/context/configuration',
      pathParameters: {
        'fieldIdOrKey': fieldIdOrKey,
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueCustomFieldContextsApi {
  final ApiClient _client;

  IssueCustomFieldContextsApi(this._client);

  /// Returns a [paginated](#pagination) list of
  /// [ contexts](https://confluence.atlassian.com/adminjiracloud/what-are-custom-field-contexts-991923859.html)
  /// for a custom field. Contexts can be returned as follows:
  ///
  ///  *  With no other parameters set, all contexts.
  ///  *  By defining `id` only, all contexts from the list of IDs.
  ///  *  By defining `isAnyIssueType`, limit the list of contexts returned to
  /// either those that apply to all issue types (true) or those that apply to
  /// only a subset of issue types (false)
  ///  *  By defining `isGlobalContext`, limit the list of contexts return to
  /// either those that apply to all projects (global contexts) (true) or those
  /// that apply to only a subset of projects (false).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanCustomFieldContext> getContextsForField(
      {required String fieldId,
      bool? isAnyIssueType,
      bool? isGlobalContext,
      List<int>? contextId,
      int? startAt,
      int? maxResults}) async {
    return PageBeanCustomFieldContext.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/context',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (isAnyIssueType != null) 'isAnyIssueType': '$isAnyIssueType',
        if (isGlobalContext != null) 'isGlobalContext': '$isGlobalContext',
        if (contextId != null)
          'contextId': contextId.map((e) => '$e').join(','),
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Creates a custom field context.
  ///
  /// If `projectIds` is empty, a global context is created. A global context is
  /// one that applies to all project. If `issueTypeIds` is empty, the context
  /// applies to all issue types.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<CreateCustomFieldContext> createCustomFieldContext(
      {required String fieldId, required CreateCustomFieldContext body}) async {
    return CreateCustomFieldContext.fromJson(await _client.send(
      'post',
      'rest/api/3/field/{fieldId}/context',
      pathParameters: {
        'fieldId': fieldId,
      },
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of defaults for a custom field.
  /// The results can be filtered by `contextId`, otherwise all values are
  /// returned. If no defaults are set for a context, nothing is returned.
  /// The returned object depends on type of the custom field:
  ///
  ///  *  `CustomFieldContextDefaultValueDate` (type `datepicker`) for date
  /// fields.
  ///  *  `CustomFieldContextDefaultValueDateTime` (type `datetimepicker`) for
  /// date-time fields.
  ///  *  `CustomFieldContextDefaultValueSingleOption` (type `option.single`)
  /// for single choice select lists and radio buttons.
  ///  *  `CustomFieldContextDefaultValueMultipleOption` (type
  /// `option.multiple`) for multiple choice select lists and checkboxes.
  ///  *  `CustomFieldContextDefaultValueCascadingOption` (type
  /// `option.cascading`) for cascading select lists.
  ///  *  `CustomFieldContextSingleUserPickerDefaults` (type
  /// `single.user.select`) for single users.
  ///  *  `CustomFieldContextDefaultValueMultiUserPicker` (type
  /// `multi.user.select`) for user lists.
  ///  *  `CustomFieldContextDefaultValueSingleGroupPicker` (type
  /// `grouppicker.single`) for single choice group pickers.
  ///  *  `CustomFieldContextDefaultValueMultipleGroupPicker` (type
  /// `grouppicker.multiple`) for multiple choice group pickers.
  ///  *  `CustomFieldContextDefaultValueURL` (type `url`) for URLs.
  ///  *  `CustomFieldContextDefaultValueProject` (type `project`) for project
  /// pickers.
  ///  *  `CustomFieldContextDefaultValueFloat` (type `float`) for floats
  /// (floating-point numbers).
  ///  *  `CustomFieldContextDefaultValueLabels` (type `labels`) for labels.
  ///  *  `CustomFieldContextDefaultValueTextField` (type `textfield`) for text
  /// fields.
  ///  *  `CustomFieldContextDefaultValueTextArea` (type `textarea`) for text
  /// area fields.
  ///  *  `CustomFieldContextDefaultValueReadOnly` (type `readonly`) for read
  /// only (text) fields.
  ///  *  `CustomFieldContextDefaultValueMultipleVersion` (type
  /// `version.multiple`) for single choice version pickers.
  ///  *  `CustomFieldContextDefaultValueSingleVersion` (type `version.single`)
  /// for multiple choice version pickers.
  ///
  /// Forge custom fields
  /// [types](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field-type/#data-types)
  /// are also supported, returning:
  ///
  ///  *  `CustomFieldContextDefaultValueForgeStringFieldBean` (type
  /// `forge.string`) for Forge string fields.
  ///  *  `CustomFieldContextDefaultValueForgeMultiStringFieldBean` (type
  /// `forge.string.list`) for Forge string collection fields.
  ///  *  `CustomFieldContextDefaultValueForgeObjectFieldBean` (type
  /// `forge.object`) for Forge object fields.
  ///  *  `CustomFieldContextDefaultValueForgeDateTimeFieldBean` (type
  /// `forge.datetime`) for Forge date-time fields.
  ///  *  `CustomFieldContextDefaultValueForgeGroupFieldBean` (type
  /// `forge.group`) for Forge group fields.
  ///  *  `CustomFieldContextDefaultValueForgeMultiGroupFieldBean` (type
  /// `forge.group.list`) for Forge group collection fields.
  ///  *  `CustomFieldContextDefaultValueForgeNumberFieldBean` (type
  /// `forge.number`) for Forge number fields.
  ///  *  `CustomFieldContextDefaultValueForgeUserFieldBean` (type `forge.user`)
  /// for Forge user fields.
  ///  *  `CustomFieldContextDefaultValueForgeMultiUserFieldBean` (type
  /// `forge.user.list`) for Forge user collection fields.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanCustomFieldContextDefaultValue> getDefaultValues(
      {required String fieldId,
      List<int>? contextId,
      int? startAt,
      int? maxResults}) async {
    return PageBeanCustomFieldContextDefaultValue.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/context/defaultValue',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (contextId != null)
          'contextId': contextId.map((e) => '$e').join(','),
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Sets default for contexts of a custom field. Default are defined using
  /// these objects:
  ///
  ///  *  `CustomFieldContextDefaultValueDate` (type `datepicker`) for date
  /// fields.
  ///  *  `CustomFieldContextDefaultValueDateTime` (type `datetimepicker`) for
  /// date-time fields.
  ///  *  `CustomFieldContextDefaultValueSingleOption` (type `option.single`)
  /// for single choice select lists and radio buttons.
  ///  *  `CustomFieldContextDefaultValueMultipleOption` (type
  /// `option.multiple`) for multiple choice select lists and checkboxes.
  ///  *  `CustomFieldContextDefaultValueCascadingOption` (type
  /// `option.cascading`) for cascading select lists.
  ///  *  `CustomFieldContextSingleUserPickerDefaults` (type
  /// `single.user.select`) for single users.
  ///  *  `CustomFieldContextDefaultValueMultiUserPicker` (type
  /// `multi.user.select`) for user lists.
  ///  *  `CustomFieldContextDefaultValueSingleGroupPicker` (type
  /// `grouppicker.single`) for single choice group pickers.
  ///  *  `CustomFieldContextDefaultValueMultipleGroupPicker` (type
  /// `grouppicker.multiple`) for multiple choice group pickers.
  ///  *  `CustomFieldContextDefaultValueURL` (type `url`) for URLs.
  ///  *  `CustomFieldContextDefaultValueProject` (type `project`) for project
  /// pickers.
  ///  *  `CustomFieldContextDefaultValueFloat` (type `float`) for floats
  /// (floating-point numbers).
  ///  *  `CustomFieldContextDefaultValueLabels` (type `labels`) for labels.
  ///  *  `CustomFieldContextDefaultValueTextField` (type `textfield`) for text
  /// fields.
  ///  *  `CustomFieldContextDefaultValueTextArea` (type `textarea`) for text
  /// area fields.
  ///  *  `CustomFieldContextDefaultValueReadOnly` (type `readonly`) for read
  /// only (text) fields.
  ///  *  `CustomFieldContextDefaultValueMultipleVersion` (type
  /// `version.multiple`) for single choice version pickers.
  ///  *  `CustomFieldContextDefaultValueSingleVersion` (type `version.single`)
  /// for multiple choice version pickers.
  ///
  /// Forge custom fields
  /// [types](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field-type/#data-types)
  /// are also supported, returning:
  ///
  ///  *  `CustomFieldContextDefaultValueForgeStringFieldBean` (type
  /// `forge.string`) for Forge string fields.
  ///  *  `CustomFieldContextDefaultValueForgeMultiStringFieldBean` (type
  /// `forge.string.list`) for Forge string collection fields.
  ///  *  `CustomFieldContextDefaultValueForgeObjectFieldBean` (type
  /// `forge.object`) for Forge object fields.
  ///  *  `CustomFieldContextDefaultValueForgeDateTimeFieldBean` (type
  /// `forge.datetime`) for Forge date-time fields.
  ///  *  `CustomFieldContextDefaultValueForgeGroupFieldBean` (type
  /// `forge.group`) for Forge group fields.
  ///  *  `CustomFieldContextDefaultValueForgeMultiGroupFieldBean` (type
  /// `forge.group.list`) for Forge group collection fields.
  ///  *  `CustomFieldContextDefaultValueForgeNumberFieldBean` (type
  /// `forge.number`) for Forge number fields.
  ///  *  `CustomFieldContextDefaultValueForgeUserFieldBean` (type `forge.user`)
  /// for Forge user fields.
  ///  *  `CustomFieldContextDefaultValueForgeMultiUserFieldBean` (type
  /// `forge.user.list`) for Forge user collection fields.
  ///
  /// Only one type of default object can be included in a request. To remove a
  /// default for a context, set the default parameter to `null`.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> setDefaultValues(
      {required String fieldId,
      required CustomFieldContextDefaultValueUpdate body}) async {
    return await _client.send(
      'put',
      'rest/api/3/field/{fieldId}/context/defaultValue',
      pathParameters: {
        'fieldId': fieldId,
      },
      body: body.toJson(),
    );
  }

  /// Returns a [paginated](#pagination) list of context to issue type mappings
  /// for a custom field. Mappings are returned for all contexts or a list of
  /// contexts. Mappings are ordered first by context ID and then by issue type
  /// ID.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeToContextMapping> getIssueTypeMappingsForContexts(
      {required String fieldId,
      List<int>? contextId,
      int? startAt,
      int? maxResults}) async {
    return PageBeanIssueTypeToContextMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/context/issuetypemapping',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (contextId != null)
          'contextId': contextId.map((e) => '$e').join(','),
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of project and issue type mappings
  /// and, for each mapping, the ID of a
  /// [custom field context](https://confluence.atlassian.com/x/k44fOw) that
  /// applies to the project and issue type.
  ///
  /// If there is no custom field context assigned to the project then, if
  /// present, the custom field context that applies to all projects is returned
  /// if it also applies to the issue type or all issue types. If a custom field
  /// context is not found, the returned custom field context ID is `null`.
  ///
  /// Duplicate project and issue type mappings cannot be provided in the
  /// request.
  ///
  /// The order of the returned values is the same as provided in the request.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanContextForProjectAndIssueType>
      getCustomFieldContextsForProjectsAndIssueTypes(
          {required String fieldId,
          int? startAt,
          int? maxResults,
          required ProjectIssueTypeMappings body}) async {
    return PageBeanContextForProjectAndIssueType.fromJson(await _client.send(
      'post',
      'rest/api/3/field/{fieldId}/context/mapping',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of context to project mappings for
  /// a custom field. The result can be filtered by `contextId`. Otherwise, all
  /// mappings are returned. Invalid IDs are ignored.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanCustomFieldContextProjectMapping> getProjectContextMapping(
      {required String fieldId,
      List<int>? contextId,
      int? startAt,
      int? maxResults}) async {
    return PageBeanCustomFieldContextProjectMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/context/projectmapping',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (contextId != null)
          'contextId': contextId.map((e) => '$e').join(','),
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Updates a
  /// [ custom field context](https://confluence.atlassian.com/adminjiracloud/what-are-custom-field-contexts-991923859.html).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateCustomFieldContext(
      {required String fieldId,
      required int contextId,
      required CustomFieldContextUpdateDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/field/{fieldId}/context/{contextId}',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    );
  }

  /// Deletes a
  /// [ custom field context](https://confluence.atlassian.com/adminjiracloud/what-are-custom-field-contexts-991923859.html).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> deleteCustomFieldContext(
      {required String fieldId, required int contextId}) async {
    return await _client.send(
      'delete',
      'rest/api/3/field/{fieldId}/context/{contextId}',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
    );
  }

  /// Adds issue types to a custom field context, appending the issue types to
  /// the issue types list.
  ///
  /// A custom field context without any issue types applies to all issue types.
  /// Adding issue types to such a custom field context would result in it
  /// applying to only the listed issue types.
  ///
  /// If any of the issue types exists in the custom field context, the
  /// operation fails and no issue types are added.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> addIssueTypesToContext(
      {required String fieldId,
      required int contextId,
      required IssueTypeIds body}) async {
    return await _client.send(
      'put',
      'rest/api/3/field/{fieldId}/context/{contextId}/issuetype',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    );
  }

  /// Removes issue types from a custom field context.
  ///
  /// A custom field context without any issue types applies to all issue types.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> removeIssueTypesFromContext(
      {required String fieldId,
      required int contextId,
      required IssueTypeIds body}) async {
    return await _client.send(
      'post',
      'rest/api/3/field/{fieldId}/context/{contextId}/issuetype/remove',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    );
  }

  /// Assigns a custom field context to projects.
  ///
  /// If any project in the request is assigned to any context of the custom
  /// field, the operation fails.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> assignProjectsToCustomFieldContext(
      {required String fieldId,
      required int contextId,
      required ProjectIds body}) async {
    return await _client.send(
      'put',
      'rest/api/3/field/{fieldId}/context/{contextId}/project',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    );
  }

  /// Removes a custom field context from projects.
  ///
  /// A custom field context without any projects applies to all projects.
  /// Removing all projects from a custom field context would result in it
  /// applying to all projects.
  ///
  /// If any project in the request is not assigned to the context, or the
  /// operation would result in two global contexts for the field, the operation
  /// fails.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> removeCustomFieldContextFromProjects(
      {required String fieldId,
      required int contextId,
      required ProjectIds body}) async {
    return await _client.send(
      'post',
      'rest/api/3/field/{fieldId}/context/{contextId}/project/remove',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueCustomFieldOptionsApi {
  final ApiClient _client;

  IssueCustomFieldOptionsApi(this._client);

  /// Returns a custom field option. For example, an option in a select list.
  ///
  /// Note that this operation **only works for issue field select list options
  /// created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource**, it cannot be used with issue field select list options created
  /// by Connect apps.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** The custom field option is
  /// returned as follows:
  ///
  ///  *  if the user has the *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///  *  if the user has the *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for at
  /// least one project the custom field is used in, and the field is visible in
  /// at least one layout the user has permission to view.
  Future<CustomFieldOption> getCustomFieldOption(String id) async {
    return CustomFieldOption.fromJson(await _client.send(
      'get',
      'rest/api/3/customFieldOption/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of all custom field option for a
  /// context. Options are returned first then cascading options, in the order
  /// they display in Jira.
  ///
  /// This operation works for custom field options created in Jira or the
  /// operations from this resource. **To work with issue field select list
  /// options created for Connect apps use the
  /// [Issue custom field options (apps)](#api-group-issue-custom-field-options--apps-)
  /// operations.**
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanCustomFieldContextOption> getOptionsForContext(
      {required String fieldId,
      required int contextId,
      int? optionId,
      bool? onlyOptions,
      int? startAt,
      int? maxResults}) async {
    return PageBeanCustomFieldContextOption.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/context/{contextId}/option',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      queryParameters: {
        if (optionId != null) 'optionId': '$optionId',
        if (onlyOptions != null) 'onlyOptions': '$onlyOptions',
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Updates the options of a custom field.
  ///
  /// If any of the options are not found, no options are updated. Options where
  /// the values in the request match the current values aren't updated and
  /// aren't reported in the response.
  ///
  /// Note that this operation **only works for issue field select list options
  /// created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource**, it cannot be used with issue field select list options created
  /// by Connect apps.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<CustomFieldUpdatedContextOptionsList> updateCustomFieldOption(
      {required String fieldId,
      required int contextId,
      required BulkCustomFieldOptionUpdateRequest body}) async {
    return CustomFieldUpdatedContextOptionsList.fromJson(await _client.send(
      'put',
      'rest/api/3/field/{fieldId}/context/{contextId}/option',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    ));
  }

  /// Creates options and, where the custom select field is of the type Select
  /// List (cascading), cascading options for a custom select field. The options
  /// are added to a context of the field.
  ///
  /// The maximum number of options that can be created per request is 1000 and
  /// each field can have a maximum of 10000 options.
  ///
  /// This operation works for custom field options created in Jira or the
  /// operations from this resource. **To work with issue field select list
  /// options created for Connect apps use the
  /// [Issue custom field options (apps)](#api-group-issue-custom-field-options--apps-)
  /// operations.**
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<CustomFieldCreatedContextOptionsList> createCustomFieldOption(
      {required String fieldId,
      required int contextId,
      required BulkCustomFieldOptionCreateRequest body}) async {
    return CustomFieldCreatedContextOptionsList.fromJson(await _client.send(
      'post',
      'rest/api/3/field/{fieldId}/context/{contextId}/option',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    ));
  }

  /// Changes the order of custom field options or cascading options in a
  /// context.
  ///
  /// This operation works for custom field options created in Jira or the
  /// operations from this resource. **To work with issue field select list
  /// options created for Connect apps use the
  /// [Issue custom field options (apps)](#api-group-issue-custom-field-options--apps-)
  /// operations.**
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> reorderCustomFieldOptions(
      {required String fieldId,
      required int contextId,
      required OrderOfCustomFieldOptions body}) async {
    return await _client.send(
      'put',
      'rest/api/3/field/{fieldId}/context/{contextId}/option/move',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
      },
      body: body.toJson(),
    );
  }

  /// Deletes a custom field option.
  ///
  /// Options with cascading options cannot be deleted without deleting the
  /// cascading options first.
  ///
  /// This operation works for custom field options created in Jira or the
  /// operations from this resource. **To work with issue field select list
  /// options created for Connect apps use the
  /// [Issue custom field options (apps)](#api-group-issue-custom-field-options--apps-)
  /// operations.**
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteCustomFieldOption(
      {required String fieldId,
      required int contextId,
      required int optionId}) async {
    await _client.send(
      'delete',
      'rest/api/3/field/{fieldId}/context/{contextId}/option/{optionId}',
      pathParameters: {
        'fieldId': fieldId,
        'contextId': '$contextId',
        'optionId': '$optionId',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueCustomFieldOptionsAppsApi {
  final ApiClient _client;

  IssueCustomFieldOptionsAppsApi(this._client);

  /// Returns a [paginated](#pagination) list of all the options of a select
  /// list issue field. A select list issue field is a type of
  /// [issue field](https://developer.atlassian.com/cloud/jira/platform/modules/issue-field/)
  /// that enables a user to select a value from a list of options.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the app providing the field.
  Future<PageBeanIssueFieldOption> getAllIssueFieldOptions(
      {int? startAt, int? maxResults, required String fieldKey}) async {
    return PageBeanIssueFieldOption.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldKey}/option',
      pathParameters: {
        'fieldKey': fieldKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Creates an option for a select list issue field.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the app providing the field.
  Future<IssueFieldOption> createIssueFieldOption(
      {required String fieldKey,
      required IssueFieldOptionCreateBean body}) async {
    return IssueFieldOption.fromJson(await _client.send(
      'post',
      'rest/api/3/field/{fieldKey}/option',
      pathParameters: {
        'fieldKey': fieldKey,
      },
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of options for a select list issue
  /// field that can be viewed and selected by the user.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PageBeanIssueFieldOption> getSelectableIssueFieldOptions(
      {int? startAt,
      int? maxResults,
      int? projectId,
      required String fieldKey}) async {
    return PageBeanIssueFieldOption.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldKey}/option/suggestions/edit',
      pathParameters: {
        'fieldKey': fieldKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (projectId != null) 'projectId': '$projectId',
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of options for a select list issue
  /// field that can be viewed by the user.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PageBeanIssueFieldOption> getVisibleIssueFieldOptions(
      {int? startAt,
      int? maxResults,
      int? projectId,
      required String fieldKey}) async {
    return PageBeanIssueFieldOption.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldKey}/option/suggestions/search',
      pathParameters: {
        'fieldKey': fieldKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (projectId != null) 'projectId': '$projectId',
      },
    ));
  }

  /// Returns an option from a select list issue field.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the app providing the field.
  Future<IssueFieldOption> getIssueFieldOption(
      {required String fieldKey, required int optionId}) async {
    return IssueFieldOption.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldKey}/option/{optionId}',
      pathParameters: {
        'fieldKey': fieldKey,
        'optionId': '$optionId',
      },
    ));
  }

  /// Updates or creates an option for a select list issue field. This operation
  /// requires that the option ID is provided when creating an option,
  /// therefore, the option ID needs to be specified as a path and body
  /// parameter. The option ID provided in the path and body must be identical.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the app providing the field.
  Future<IssueFieldOption> updateIssueFieldOption(
      {required String fieldKey,
      required int optionId,
      required IssueFieldOption body}) async {
    return IssueFieldOption.fromJson(await _client.send(
      'put',
      'rest/api/3/field/{fieldKey}/option/{optionId}',
      pathParameters: {
        'fieldKey': fieldKey,
        'optionId': '$optionId',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes an option from a select list issue field.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the app providing the field.
  Future<dynamic> deleteIssueFieldOption(
      {required String fieldKey, required int optionId}) async {
    return await _client.send(
      'delete',
      'rest/api/3/field/{fieldKey}/option/{optionId}',
      pathParameters: {
        'fieldKey': fieldKey,
        'optionId': '$optionId',
      },
    );
  }

  /// Deselects an issue-field select-list option from all issues where it is
  /// selected. A different option can be selected to replace the deselected
  /// option. The update can also be limited to a smaller set of issues by using
  /// a JQL query.
  ///
  /// Connect and Forge app users with *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) can
  /// override the screen security configuration using `overrideScreenSecurity`
  /// and `overrideEditableFlag`.
  ///
  /// This is an [asynchronous operation](#async). The response object contains
  /// a link to the long-running task.
  ///
  /// Note that this operation **only works for issue field select list options
  /// added by Connect apps**, it cannot be used with issue field select list
  /// options created in Jira or using operations from the
  /// [Issue custom field options](#api-group-Issue-custom-field-options)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Jira
  /// permissions are not required for the app providing the field.
  Future<TaskProgressBeanRemoveOptionFromIssuesResult> replaceIssueFieldOption(
      {int? replaceWith,
      String? jql,
      bool? overrideScreenSecurity,
      bool? overrideEditableFlag,
      required String fieldKey,
      required int optionId}) async {
    return TaskProgressBeanRemoveOptionFromIssuesResult.fromJson(
        await _client.send(
      'delete',
      'rest/api/3/field/{fieldKey}/option/{optionId}/issue',
      pathParameters: {
        'fieldKey': fieldKey,
        'optionId': '$optionId',
      },
      queryParameters: {
        if (replaceWith != null) 'replaceWith': '$replaceWith',
        if (jql != null) 'jql': jql,
        if (overrideScreenSecurity != null)
          'overrideScreenSecurity': '$overrideScreenSecurity',
        if (overrideEditableFlag != null)
          'overrideEditableFlag': '$overrideEditableFlag',
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueCustomFieldValuesAppsApi {
  final ApiClient _client;

  IssueCustomFieldValuesAppsApi(this._client);

  /// Updates the value of one or more custom fields on one or more issues.
  /// Combinations of custom field and issue should be unique within the
  /// request. Custom fields can only be updated by the Forge app that created
  /// them.
  ///
  /// **[Permissions](#permissions) required:** Only the app that created the
  /// custom field can update its values with this operation.
  Future<dynamic> updateMultipleCustomFieldValues(
      {bool? generateChangelog,
      required MultipleCustomFieldValuesUpdateDetails body}) async {
    return await _client.send(
      'post',
      'rest/api/3/app/field/value',
      queryParameters: {
        if (generateChangelog != null)
          'generateChangelog': '$generateChangelog',
      },
      body: body.toJson(),
    );
  }

  /// Updates the value of a custom field on one or more issues. Custom fields
  /// can only be updated by the Forge app that created them.
  ///
  /// **[Permissions](#permissions) required:** Only the app that created the
  /// custom field can update its values with this operation.
  Future<dynamic> updateCustomFieldValue(
      {required String fieldIdOrKey,
      bool? generateChangelog,
      required CustomFieldValueUpdateDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/app/field/{fieldIdOrKey}/value',
      pathParameters: {
        'fieldIdOrKey': fieldIdOrKey,
      },
      queryParameters: {
        if (generateChangelog != null)
          'generateChangelog': '$generateChangelog',
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueFieldConfigurationsApi {
  final ApiClient _client;

  IssueFieldConfigurationsApi(this._client);

  /// Returns a [paginated](#pagination) list of field configurations. The list
  /// can be for all field configurations or a subset determined by any
  /// combination of these criteria:
  ///
  ///  *  a list of field configuration item IDs.
  ///  *  whether the field configuration is a default.
  ///  *  whether the field configuration name or description contains a query
  /// string.
  ///
  /// Only field configurations used in company-managed (classic) projects are
  /// returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanFieldConfigurationDetails> getAllFieldConfigurations(
      {int? startAt,
      int? maxResults,
      List<int>? id,
      bool? isDefault,
      String? query}) async {
    return PageBeanFieldConfigurationDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/fieldconfiguration',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': id.map((e) => '$e').join(','),
        if (isDefault != null) 'isDefault': '$isDefault',
        if (query != null) 'query': query,
      },
    ));
  }

  /// Creates a field configuration. The field configuration is created with the
  /// same field properties as the default configuration, with all the fields
  /// being optional.
  ///
  /// This operation can only create configurations for use in company-managed
  /// (classic) projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<FieldConfiguration> createFieldConfiguration(
      {required FieldConfigurationDetails body}) async {
    return FieldConfiguration.fromJson(await _client.send(
      'post',
      'rest/api/3/fieldconfiguration',
      body: body.toJson(),
    ));
  }

  /// Updates a field configuration. The name and the description provided in
  /// the request override the existing values.
  ///
  /// This operation can only update configurations used in company-managed
  /// (classic) projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateFieldConfiguration(
      {required int id, required FieldConfigurationDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/fieldconfiguration/{id}',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    );
  }

  /// Deletes a field configuration.
  ///
  /// This operation can only delete configurations used in company-managed
  /// (classic) projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> deleteFieldConfiguration(int id) async {
    return await _client.send(
      'delete',
      'rest/api/3/fieldconfiguration/{id}',
      pathParameters: {
        'id': '$id',
      },
    );
  }

  /// Returns a [paginated](#pagination) list of all fields for a configuration.
  ///
  /// Only the fields from configurations used in company-managed (classic)
  /// projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanFieldConfigurationItem> getFieldConfigurationItems(
      {required int id, int? startAt, int? maxResults}) async {
    return PageBeanFieldConfigurationItem.fromJson(await _client.send(
      'get',
      'rest/api/3/fieldconfiguration/{id}/fields',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Updates fields in a field configuration. The properties of the field
  /// configuration fields provided override the existing values.
  ///
  /// This operation can only update field configurations used in
  /// company-managed (classic) projects.
  ///
  /// The operation can set the renderer for text fields to the default text
  /// renderer (`text-renderer`) or wiki style renderer (`wiki-renderer`).
  /// However, the renderer cannot be updated for fields using the autocomplete
  /// renderer (`autocomplete-renderer`).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateFieldConfigurationItems(
      {required int id, required FieldConfigurationItemsDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/fieldconfiguration/{id}/fields',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    );
  }

  /// Returns a [paginated](#pagination) list of field configuration schemes.
  ///
  /// Only field configuration schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanFieldConfigurationScheme> getAllFieldConfigurationSchemes(
      {int? startAt, int? maxResults, List<int>? id}) async {
    return PageBeanFieldConfigurationScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/fieldconfigurationscheme',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': id.map((e) => '$e').join(','),
      },
    ));
  }

  /// Creates a field configuration scheme.
  ///
  /// This operation can only create field configuration schemes used in
  /// company-managed (classic) projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<FieldConfigurationScheme> createFieldConfigurationScheme(
      {required UpdateFieldConfigurationSchemeDetails body}) async {
    return FieldConfigurationScheme.fromJson(await _client.send(
      'post',
      'rest/api/3/fieldconfigurationscheme',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of field configuration issue type
  /// items.
  ///
  /// Only items used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanFieldConfigurationIssueTypeItem>
      getFieldConfigurationSchemeMappings(
          {int? startAt,
          int? maxResults,
          List<int>? fieldConfigurationSchemeId}) async {
    return PageBeanFieldConfigurationIssueTypeItem.fromJson(await _client.send(
      'get',
      'rest/api/3/fieldconfigurationscheme/mapping',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (fieldConfigurationSchemeId != null)
          'fieldConfigurationSchemeId':
              fieldConfigurationSchemeId.map((e) => '$e').join(','),
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of field configuration schemes
  /// and, for each scheme, a list of the projects that use it.
  ///
  /// The list is sorted by field configuration scheme ID. The first item
  /// contains the list of project IDs assigned to the default field
  /// configuration scheme.
  ///
  /// Only field configuration schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanFieldConfigurationSchemeProjects>
      getFieldConfigurationSchemeProjectMapping(
          {int? startAt, int? maxResults, required List<int> projectId}) async {
    return PageBeanFieldConfigurationSchemeProjects.fromJson(await _client.send(
      'get',
      'rest/api/3/fieldconfigurationscheme/project',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        'projectId': projectId.map((e) => '$e').join(','),
      },
    ));
  }

  /// Assigns a field configuration scheme to a project. If the field
  /// configuration scheme ID is `null`, the operation assigns the default field
  /// configuration scheme.
  ///
  /// Field configuration schemes can only be assigned to classic projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> assignFieldConfigurationSchemeToProject(
      {required FieldConfigurationSchemeProjectAssociation body}) async {
    return await _client.send(
      'put',
      'rest/api/3/fieldconfigurationscheme/project',
      body: body.toJson(),
    );
  }

  /// Updates a field configuration scheme.
  ///
  /// This operation can only update field configuration schemes used in
  /// company-managed (classic) projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateFieldConfigurationScheme(
      {required int id,
      required UpdateFieldConfigurationSchemeDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/fieldconfigurationscheme/{id}',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    );
  }

  /// Deletes a field configuration scheme.
  ///
  /// This operation can only delete field configuration schemes used in
  /// company-managed (classic) projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> deleteFieldConfigurationScheme(int id) async {
    return await _client.send(
      'delete',
      'rest/api/3/fieldconfigurationscheme/{id}',
      pathParameters: {
        'id': '$id',
      },
    );
  }

  /// Assigns issue types to field configurations on field configuration scheme.
  ///
  /// This operation can only modify field configuration schemes used in
  /// company-managed (classic) projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> setFieldConfigurationSchemeMapping(
      {required int id,
      required AssociateFieldConfigurationsWithIssueTypesRequest body}) async {
    return await _client.send(
      'put',
      'rest/api/3/fieldconfigurationscheme/{id}/mapping',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    );
  }

  /// Removes issue types from the field configuration scheme.
  ///
  /// This operation can only modify field configuration schemes used in
  /// company-managed (classic) projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> removeIssueTypesFromGlobalFieldConfigurationScheme(
      {required int id, required IssueTypeIdsToRemove body}) async {
    return await _client.send(
      'post',
      'rest/api/3/fieldconfigurationscheme/{id}/mapping/delete',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueFieldsApi {
  final ApiClient _client;

  IssueFieldsApi(this._client);

  /// Returns system and custom issue fields according to the following rules:
  ///
  ///  *  Fields that cannot be added to the issue navigator are always
  /// returned.
  ///  *  Fields that cannot be placed on an issue screen are always returned.
  ///  *  Fields that depend on global Jira settings are only returned if the
  /// setting is enabled. That is, timetracking fields, subtasks, votes, and
  /// watches.
  ///  *  For all other fields, this operation only returns the fields that the
  /// user has permission to view (that is, the field is used in at least one
  /// project that the user has *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for.)
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<List<FieldDetails>> getFields() async {
    return (await _client.send(
      'get',
      'rest/api/3/field',
    ) as List<Object?>)
        .map((i) =>
            FieldDetails.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a custom field.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<FieldDetails> createCustomField(
      {required CustomFieldDefinitionJsonBean body}) async {
    return FieldDetails.fromJson(await _client.send(
      'post',
      'rest/api/3/field',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of fields for Classic Jira
  /// projects. The list can include:
  ///
  ///  *  all fields
  ///  *  specific fields, by defining `id`
  ///  *  fields that contain a string in the field name or description, by
  /// defining `query`
  ///  *  specific fields that contain a string in the field name or
  /// description, by defining `id` and `query`
  ///
  /// Only custom fields can be queried, `type` must be set to `custom`.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanField> getFieldsPaginated(
      {int? startAt,
      int? maxResults,
      List<String>? type,
      List<String>? id,
      String? query,
      String? orderBy,
      String? expand}) async {
    return PageBeanField.fromJson(await _client.send(
      'get',
      'rest/api/3/field/search',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (type != null) 'type': type.map((e) => e).join(','),
        if (id != null) 'id': id.map((e) => e).join(','),
        if (query != null) 'query': query,
        if (orderBy != null) 'orderBy': orderBy,
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of fields in the trash. The list
  /// may be restricted to fields whose field name or description partially
  /// match a string.
  ///
  /// Only custom fields can be queried, `type` must be set to `custom`.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanField> getTrashedFieldsPaginated(
      {int? startAt,
      int? maxResults,
      List<String>? id,
      String? query,
      String? expand,
      String? orderBy}) async {
    return PageBeanField.fromJson(await _client.send(
      'get',
      'rest/api/3/field/search/trashed',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': id.map((e) => e).join(','),
        if (query != null) 'query': query,
        if (expand != null) 'expand': expand,
        if (orderBy != null) 'orderBy': orderBy,
      },
    ));
  }

  /// Updates a custom field.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateCustomField(
      {required String fieldId, required UpdateCustomFieldDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/field/{fieldId}',
      pathParameters: {
        'fieldId': fieldId,
      },
      body: body.toJson(),
    );
  }

  /// Returns a [paginated](#pagination) list of the contexts a field is used
  /// in. Deprecated, use
  /// [ Get custom field contexts](#api-rest-api-3-field-fieldId-context-get).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanContext> getContextsForFieldDeprecated(
      {required String fieldId, int? startAt, int? maxResults}) async {
    return PageBeanContext.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/contexts',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Deletes a custom field. The custom field is deleted whether it is in the
  /// trash or not. See
  /// [Edit or delete a custom field](https://confluence.atlassian.com/x/Z44fOw)
  /// for more information on trashing and deleting custom fields.
  ///
  /// This operation is [asynchronous](#async). Follow the `location` link in
  /// the response to determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TaskProgressBeanObject> deleteCustomField(String id) async {
    return TaskProgressBeanObject.fromJson(await _client.send(
      'delete',
      'rest/api/3/field/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Restores a custom field from trash. See
  /// [Edit or delete a custom field](https://confluence.atlassian.com/x/Z44fOw)
  /// for more information on trashing and deleting custom fields.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> restoreCustomField(String id) async {
    return await _client.send(
      'post',
      'rest/api/3/field/{id}/restore',
      pathParameters: {
        'id': id,
      },
    );
  }

  /// Moves a custom field to trash. See
  /// [Edit or delete a custom field](https://confluence.atlassian.com/x/Z44fOw)
  /// for more information on trashing and deleting custom fields.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> trashCustomField(String id) async {
    return await _client.send(
      'post',
      'rest/api/3/field/{id}/trash',
      pathParameters: {
        'id': id,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueLinkTypesApi {
  final ApiClient _client;

  IssueLinkTypesApi(this._client);

  /// Returns a list of all issue link types.
  ///
  /// To use this operation, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for a
  /// project in the site.
  Future<IssueLinkTypes> getIssueLinkTypes() async {
    return IssueLinkTypes.fromJson(await _client.send(
      'get',
      'rest/api/3/issueLinkType',
    ));
  }

  /// Creates an issue link type. Use this operation to create descriptions of
  /// the reasons why issues are linked. The issue link type consists of a name
  /// and descriptions for a link's inward and outward relationships.
  ///
  /// To use this operation, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueLinkType> createIssueLinkType(
      {required IssueLinkType body}) async {
    return IssueLinkType.fromJson(await _client.send(
      'post',
      'rest/api/3/issueLinkType',
      body: body.toJson(),
    ));
  }

  /// Returns an issue link type.
  ///
  /// To use this operation, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for a
  /// project in the site.
  Future<IssueLinkType> getIssueLinkType(String issueLinkTypeId) async {
    return IssueLinkType.fromJson(await _client.send(
      'get',
      'rest/api/3/issueLinkType/{issueLinkTypeId}',
      pathParameters: {
        'issueLinkTypeId': issueLinkTypeId,
      },
    ));
  }

  /// Updates an issue link type.
  ///
  /// To use this operation, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueLinkType> updateIssueLinkType(
      {required String issueLinkTypeId, required IssueLinkType body}) async {
    return IssueLinkType.fromJson(await _client.send(
      'put',
      'rest/api/3/issueLinkType/{issueLinkTypeId}',
      pathParameters: {
        'issueLinkTypeId': issueLinkTypeId,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes an issue link type.
  ///
  /// To use this operation, the site must have
  /// [issue linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteIssueLinkType(String issueLinkTypeId) async {
    await _client.send(
      'delete',
      'rest/api/3/issueLinkType/{issueLinkTypeId}',
      pathParameters: {
        'issueLinkTypeId': issueLinkTypeId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueLinksApi {
  final ApiClient _client;

  IssueLinksApi(this._client);

  /// Creates a link between two issues. Use this operation to indicate a
  /// relationship between two issues and optionally add a comment to the from
  /// (outward) issue. To use this resource the site must have
  /// [Issue Linking](https://confluence.atlassian.com/x/yoXKM) enabled.
  ///
  /// This resource returns nothing on the creation of an issue link. To obtain
  /// the ID of the issue link, use
  /// `https://your-domain.atlassian.net/rest/api/3/issue/[linked issue key]?fields=issuelinks`.
  ///
  /// If the link request duplicates a link, the response indicates that the
  /// issue link was created. If the request included a comment, the comment is
  /// added.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse project*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for all
  /// the projects containing the issues to be linked,
  ///  *  *Link issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) on the
  /// project containing the from (outward) issue,
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the comment has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<dynamic> linkIssues({required LinkIssueRequestJsonBean body}) async {
    return await _client.send(
      'post',
      'rest/api/3/issueLink',
      body: body.toJson(),
    );
  }

  /// Returns an issue link.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse project*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for all
  /// the projects containing the linked issues.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, permission to view both of the issues.
  Future<IssueLink> getIssueLink(String linkId) async {
    return IssueLink.fromJson(await _client.send(
      'get',
      'rest/api/3/issueLink/{linkId}',
      pathParameters: {
        'linkId': linkId,
      },
    ));
  }

  /// Deletes an issue link.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  Browse project
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for all
  /// the projects containing the issues in the link.
  ///  *  *Link issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for at
  /// least one of the projects containing issues in the link.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, permission to view both of the issues.
  Future<void> deleteIssueLink(String linkId) async {
    await _client.send(
      'delete',
      'rest/api/3/issueLink/{linkId}',
      pathParameters: {
        'linkId': linkId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueNavigatorSettingsApi {
  final ApiClient _client;

  IssueNavigatorSettingsApi(this._client);

  /// Returns the default issue navigator columns.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<ColumnItem>> getIssueNavigatorDefaultColumns() async {
    return (await _client.send(
      'get',
      'rest/api/3/settings/columns',
    ) as List<Object?>)
        .map((i) => ColumnItem.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Sets the default issue navigator columns.
  ///
  /// The `columns` parameter accepts a navigable field value and is expressed
  /// as HTML form data. To specify multiple columns, pass multiple `columns`
  /// parameters. For example, in curl:
  ///
  /// `curl -X PUT -d columns=summary -d columns=description
  /// https://your-domain.atlassian.net/rest/api/3/settings/columns`
  ///
  /// If no column details are sent, then all default columns are removed.
  ///
  /// A navigable field is one that can be used as a column on the issue
  /// navigator. Find details of navigable issue columns using
  /// [Get fields](#api-rest-api-3-field-get).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> setIssueNavigatorDefaultColumns(
      {required List<String> body}) async {
    return await _client.send(
      'put',
      'rest/api/3/settings/columns',
      body: body,
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueNotificationSchemesApi {
  final ApiClient _client;

  IssueNotificationSchemesApi(this._client);

  /// Returns a [paginated](#pagination) list of
  /// [notification schemes](https://confluence.atlassian.com/x/8YdKLg) ordered
  /// by the display name.
  ///
  /// *Note that you should allow for events without recipients to appear in
  /// responses.*
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, the user must have permission to administer at least one project
  /// associated with a notification scheme for it to be returned.
  Future<PageBeanNotificationScheme> getNotificationSchemes(
      {String? startAt,
      String? maxResults,
      List<String>? id,
      List<String>? projectId,
      bool? onlyDefault,
      String? expand}) async {
    return PageBeanNotificationScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/notificationscheme',
      queryParameters: {
        if (startAt != null) 'startAt': startAt,
        if (maxResults != null) 'maxResults': maxResults,
        if (id != null) 'id': id.map((e) => e).join(','),
        if (projectId != null) 'projectId': projectId.map((e) => e).join(','),
        if (onlyDefault != null) 'onlyDefault': '$onlyDefault',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Creates a notification scheme with notifications. You can create up to
  /// 1000 notifications per request.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<NotificationSchemeId> createNotificationScheme(
      {required CreateNotificationSchemeDetails body}) async {
    return NotificationSchemeId.fromJson(await _client.send(
      'post',
      'rest/api/3/notificationscheme',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) mapping of project that have
  /// notification scheme assigned. You can provide either one or multiple
  /// notification scheme IDs or project IDs to filter by. If you don't provide
  /// any, this will return a list of all mappings. Note that only
  /// company-managed (classic) projects are supported. This is because
  /// team-managed projects don't have a concept of a default notification
  /// scheme. The mappings are ordered by projectId.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PageBeanNotificationSchemeAndProjectMappingJsonBean>
      getNotificationSchemeToProjectMappings(
          {String? startAt,
          String? maxResults,
          List<String>? notificationSchemeId,
          List<String>? projectId}) async {
    return PageBeanNotificationSchemeAndProjectMappingJsonBean.fromJson(
        await _client.send(
      'get',
      'rest/api/3/notificationscheme/project',
      queryParameters: {
        if (startAt != null) 'startAt': startAt,
        if (maxResults != null) 'maxResults': maxResults,
        if (notificationSchemeId != null)
          'notificationSchemeId': notificationSchemeId.map((e) => e).join(','),
        if (projectId != null) 'projectId': projectId.map((e) => e).join(','),
      },
    ));
  }

  /// Returns a
  /// [notification scheme](https://confluence.atlassian.com/x/8YdKLg),
  /// including the list of events and the recipients who will receive
  /// notifications for those events.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, the user must have permission to administer at least one project
  /// associated with the notification scheme.
  Future<NotificationScheme> getNotificationScheme(
      {required int id, String? expand}) async {
    return NotificationScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/notificationscheme/{id}',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates a notification scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateNotificationScheme(
      {required String id,
      required UpdateNotificationSchemeDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/notificationscheme/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    );
  }

  /// Adds notifications to a notification scheme. You can add up to 1000
  /// notifications per request.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> addNotifications(
      {required String id, required AddNotificationsDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/notificationscheme/{id}/notification',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    );
  }

  /// Deletes a notification scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> deleteNotificationScheme(String notificationSchemeId) async {
    return await _client.send(
      'delete',
      'rest/api/3/notificationscheme/{notificationSchemeId}',
      pathParameters: {
        'notificationSchemeId': notificationSchemeId,
      },
    );
  }

  /// Removes a notification from a notification scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> removeNotificationFromNotificationScheme(
      {required String notificationSchemeId,
      required String notificationId}) async {
    return await _client.send(
      'delete',
      'rest/api/3/notificationscheme/{notificationSchemeId}/notification/{notificationId}',
      pathParameters: {
        'notificationSchemeId': notificationSchemeId,
        'notificationId': notificationId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssuePrioritiesApi {
  final ApiClient _client;

  IssuePrioritiesApi(this._client);

  /// Returns the list of all issue priorities.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<List<Priority>> getPriorities() async {
    return (await _client.send(
      'get',
      'rest/api/3/priority',
    ) as List<Object?>)
        .map((i) => Priority.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates an issue priority.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PriorityId> createPriority(
      {required CreatePriorityDetails body}) async {
    return PriorityId.fromJson(await _client.send(
      'post',
      'rest/api/3/priority',
      body: body.toJson(),
    ));
  }

  /// Sets default issue priority.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> setDefaultPriority(
      {required SetDefaultPriorityRequest body}) async {
    return await _client.send(
      'put',
      'rest/api/3/priority/default',
      body: body.toJson(),
    );
  }

  /// Changes the order of issue priorities.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> movePriorities({required ReorderIssuePriorities body}) async {
    return await _client.send(
      'put',
      'rest/api/3/priority/move',
      body: body.toJson(),
    );
  }

  /// Returns a [paginated](#pagination) list of priorities. The list can
  /// contain all priorities or a subset determined by any combination of these
  /// criteria:
  ///
  ///  *  a list of priority IDs. Any invalid priority IDs are ignored.
  ///  *  whether the field configuration is a default. This returns priorities
  /// from company-managed (classic) projects only, as there is no concept of
  /// default priorities in team-managed projects.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PageBeanPriority> searchPriorities(
      {String? startAt,
      String? maxResults,
      List<String>? id,
      bool? onlyDefault}) async {
    return PageBeanPriority.fromJson(await _client.send(
      'get',
      'rest/api/3/priority/search',
      queryParameters: {
        if (startAt != null) 'startAt': startAt,
        if (maxResults != null) 'maxResults': maxResults,
        if (id != null) 'id': id.map((e) => e).join(','),
        if (onlyDefault != null) 'onlyDefault': '$onlyDefault',
      },
    ));
  }

  /// Returns an issue priority.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<Priority> getPriority(String id) async {
    return Priority.fromJson(await _client.send(
      'get',
      'rest/api/3/priority/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Updates an issue priority.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updatePriority(
      {required String id, required UpdatePriorityDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/priority/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    );
  }

  /// Deletes an issue priority.
  ///
  /// This operation is [asynchronous](#async). Follow the `location` link in
  /// the response to determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TaskProgressBeanObject> deletePriority(
      {required String id, required String replaceWith}) async {
    return TaskProgressBeanObject.fromJson(await _client.send(
      'delete',
      'rest/api/3/priority/{id}',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        'replaceWith': replaceWith,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssuePropertiesApi {
  final ApiClient _client;

  IssuePropertiesApi(this._client);

  /// Sets or updates a list of entity property values on issues. A list of up
  /// to 10 entity properties can be specified along with up to 10,000 issues on
  /// which to set or update that list of entity properties.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON. The maximum
  /// length of single issue property value is 32768 characters. This operation
  /// can be accessed anonymously.
  ///
  /// This operation is:
  ///
  ///  *  transactional, either all properties are updated in all eligible
  /// issues or, when errors occur, no properties are updated.
  ///  *  [asynchronous](#async). Follow the `location` link in the response to
  /// determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Edit issues*
  /// [project permissions](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> bulkSetIssuesPropertiesList(
      {required IssueEntityProperties body}) async {
    await _client.send(
      'post',
      'rest/api/3/issue/properties',
      body: body.toJson(),
    );
  }

  /// Sets or updates entity property values on issues. Up to 10 entity
  /// properties can be specified for each issue and up to 100 issues included
  /// in the request.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON.
  ///
  /// This operation is:
  ///
  ///  *  [asynchronous](#async). Follow the `location` link in the response to
  /// determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///  *  non-transactional. Updating some entities may fail. Such information
  /// will available in the task result.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Edit issues*
  /// [project permissions](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> bulkSetIssuePropertiesByIssue(
      {required MultiIssueEntityProperties body}) async {
    await _client.send(
      'post',
      'rest/api/3/issue/properties/multi',
      body: body.toJson(),
    );
  }

  /// Sets a property value on multiple issues.
  ///
  /// The value set can be a constant or determined by a
  /// [Jira expression](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/).
  /// Expressions must be computable with constant complexity when applied to a
  /// set of issues. Expressions must also comply with the
  /// [restrictions](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#restrictions)
  /// that apply to all Jira expressions.
  ///
  /// The issues to be updated can be specified by a filter.
  ///
  /// The filter identifies issues eligible for update using these criteria:
  ///
  ///  *  `entityIds` Only issues from this list are eligible.
  ///  *  `currentValue` Only issues with the property set to this value are
  /// eligible.
  ///  *  `hasProperty`:
  ///
  ///      *  If *true*, only issues with the property are eligible.
  ///      *  If *false*, only issues without the property are eligible.
  ///
  /// If more than one criteria is specified, they are joined with the logical
  /// *AND*: only issues that satisfy all criteria are eligible.
  ///
  /// If an invalid combination of criteria is provided, an error is returned.
  /// For example, specifying a `currentValue` and `hasProperty` as *false*
  /// would not match any issues (because without the property the property
  /// cannot have a value).
  ///
  /// The filter is optional. Without the filter all the issues visible to the
  /// user and where the user has the EDIT_ISSUES permission for the issue are
  /// considered eligible.
  ///
  /// This operation is:
  ///
  ///  *  transactional, either all eligible issues are updated or, when errors
  /// occur, none are updated.
  ///  *  [asynchronous](#async). Follow the `location` link in the response to
  /// determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for each
  /// project containing issues.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Edit issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for each
  /// issue.
  Future<void> bulkSetIssueProperty(
      {required String propertyKey,
      required BulkIssuePropertyUpdateRequest body}) async {
    await _client.send(
      'put',
      'rest/api/3/issue/properties/{propertyKey}',
      pathParameters: {
        'propertyKey': propertyKey,
      },
      body: body.toJson(),
    );
  }

  /// Deletes a property value from multiple issues. The issues to be updated
  /// can be specified by filter criteria.
  ///
  /// The criteria the filter used to identify eligible issues are:
  ///
  ///  *  `entityIds` Only issues from this list are eligible.
  ///  *  `currentValue` Only issues with the property set to this value are
  /// eligible.
  ///
  /// If both criteria is specified, they are joined with the logical *AND*:
  /// only issues that satisfy both criteria are considered eligible.
  ///
  /// If no filter criteria are specified, all the issues visible to the user
  /// and where the user has the EDIT_ISSUES permission for the issue are
  /// considered eligible.
  ///
  /// This operation is:
  ///
  ///  *  transactional, either the property is deleted from all eligible issues
  /// or, when errors occur, no properties are deleted.
  ///  *  [asynchronous](#async). Follow the `location` link in the response to
  /// determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [ project permission](https://confluence.atlassian.com/x/yodKLg) for each
  /// project containing issues.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Edit issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for each
  /// issue.
  Future<void> bulkDeleteIssueProperty(
      {required String propertyKey,
      required IssueFilterForBulkPropertyDelete body}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/properties/{propertyKey}',
      pathParameters: {
        'propertyKey': propertyKey,
      },
      body: body.toJson(),
    );
  }

  /// Returns the URLs and keys of an issue's properties.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Property details are only
  /// returned where the user has:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<PropertyKeys> getIssuePropertyKeys(String issueIdOrKey) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/properties',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
    ));
  }

  /// Returns the key and value of an issue's property.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<EntityProperty> getIssueProperty(
      {required String issueIdOrKey, required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/properties/{propertyKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Sets the value of an issue's property. Use this resource to store custom
  /// data against an issue.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Edit issues*
  /// [project permissions](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<dynamic> setIssueProperty(
      {required String issueIdOrKey,
      required String propertyKey,
      required dynamic body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}/properties/{propertyKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'propertyKey': propertyKey,
      },
      body: body,
    );
  }

  /// Deletes an issue's property.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Edit issues*
  /// [project permissions](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> deleteIssueProperty(
      {required String issueIdOrKey, required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/properties/{propertyKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'propertyKey': propertyKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueRemoteLinksApi {
  final ApiClient _client;

  IssueRemoteLinksApi(this._client);

  /// Returns the remote issue links for an issue. When a remote issue link
  /// global ID is provided the record with that global ID is returned,
  /// otherwise all remote issue links are returned. Where a global ID includes
  /// reserved URL characters these must be escaped in the request. For example,
  /// pass `system=http://www.mycompany.com/support&id=1` as
  /// `system%3Dhttp%3A%2F%2Fwww.mycompany.com%2Fsupport%26id%3D1`.
  ///
  /// This operation requires
  /// [issue linking to be active](https://confluence.atlassian.com/x/yoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<RemoteIssueLink> getRemoteIssueLinks(
      {required String issueIdOrKey, String? globalId}) async {
    return RemoteIssueLink.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/remotelink',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (globalId != null) 'globalId': globalId,
      },
    ));
  }

  /// Creates or updates a remote issue link for an issue.
  ///
  /// If a `globalId` is provided and a remote issue link with that global ID is
  /// found it is updated. Any fields without values in the request are set to
  /// null. Otherwise, the remote issue link is created.
  ///
  /// This operation requires
  /// [issue linking to be active](https://confluence.atlassian.com/x/yoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Link issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<RemoteIssueLinkIdentifies> createOrUpdateRemoteIssueLink(
      {required String issueIdOrKey,
      required RemoteIssueLinkRequest body}) async {
    return RemoteIssueLinkIdentifies.fromJson(await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/remotelink',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the remote issue link from the issue using the link's global ID.
  /// Where the global ID includes reserved URL characters these must be escaped
  /// in the request. For example, pass
  /// `system=http://www.mycompany.com/support&id=1` as
  /// `system%3Dhttp%3A%2F%2Fwww.mycompany.com%2Fsupport%26id%3D1`.
  ///
  /// This operation requires
  /// [issue linking to be active](https://confluence.atlassian.com/x/yoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Link issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is implemented, issue-level security permission to view the issue.
  Future<void> deleteRemoteIssueLinkByGlobalId(
      {required String issueIdOrKey, required String globalId}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/remotelink',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        'globalId': globalId,
      },
    );
  }

  /// Returns a remote issue link for an issue.
  ///
  /// This operation requires
  /// [issue linking to be active](https://confluence.atlassian.com/x/yoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<RemoteIssueLink> getRemoteIssueLinkById(
      {required String issueIdOrKey, required String linkId}) async {
    return RemoteIssueLink.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/remotelink/{linkId}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'linkId': linkId,
      },
    ));
  }

  /// Updates a remote issue link for an issue.
  ///
  /// Note: Fields without values in the request are set to null.
  ///
  /// This operation requires
  /// [issue linking to be active](https://confluence.atlassian.com/x/yoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Link issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<dynamic> updateRemoteIssueLink(
      {required String issueIdOrKey,
      required String linkId,
      required RemoteIssueLinkRequest body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}/remotelink/{linkId}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'linkId': linkId,
      },
      body: body.toJson(),
    );
  }

  /// Deletes a remote issue link from an issue.
  ///
  /// This operation requires
  /// [issue linking to be active](https://confluence.atlassian.com/x/yoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*, *Edit issues*, and *Link issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> deleteRemoteIssueLinkById(
      {required String issueIdOrKey, required String linkId}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/remotelink/{linkId}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'linkId': linkId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueResolutionsApi {
  final ApiClient _client;

  IssueResolutionsApi(this._client);

  /// Returns a list of all issue resolution values.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<List<Resolution>> getResolutions() async {
    return (await _client.send(
      'get',
      'rest/api/3/resolution',
    ) as List<Object?>)
        .map((i) => Resolution.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates an issue resolution.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ResolutionId> createResolution(
      {required CreateResolutionDetails body}) async {
    return ResolutionId.fromJson(await _client.send(
      'post',
      'rest/api/3/resolution',
      body: body.toJson(),
    ));
  }

  /// Sets default issue resolution.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> setDefaultResolution(
      {required SetDefaultResolutionRequest body}) async {
    return await _client.send(
      'put',
      'rest/api/3/resolution/default',
      body: body.toJson(),
    );
  }

  /// Changes the order of issue resolutions.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> moveResolutions(
      {required ReorderIssueResolutionsRequest body}) async {
    return await _client.send(
      'put',
      'rest/api/3/resolution/move',
      body: body.toJson(),
    );
  }

  /// Returns a [paginated](#pagination) list of resolutions. The list can
  /// contain all resolutions or a subset determined by any combination of these
  /// criteria:
  ///
  ///  *  a list of resolutions IDs.
  ///  *  whether the field configuration is a default. This returns resolutions
  /// from company-managed (classic) projects only, as there is no concept of
  /// default resolutions in team-managed projects.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PageBeanResolutionJsonBean> searchResolutions(
      {String? startAt,
      String? maxResults,
      List<String>? id,
      bool? onlyDefault}) async {
    return PageBeanResolutionJsonBean.fromJson(await _client.send(
      'get',
      'rest/api/3/resolution/search',
      queryParameters: {
        if (startAt != null) 'startAt': startAt,
        if (maxResults != null) 'maxResults': maxResults,
        if (id != null) 'id': id.map((e) => e).join(','),
        if (onlyDefault != null) 'onlyDefault': '$onlyDefault',
      },
    ));
  }

  /// Returns an issue resolution value.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<Resolution> getResolution(String id) async {
    return Resolution.fromJson(await _client.send(
      'get',
      'rest/api/3/resolution/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Updates an issue resolution.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateResolution(
      {required String id, required UpdateResolutionDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/resolution/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    );
  }

  /// Deletes an issue resolution.
  ///
  /// This operation is [asynchronous](#async). Follow the `location` link in
  /// the response to determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TaskProgressBeanObject> deleteResolution(
      {required String id, required String replaceWith}) async {
    return TaskProgressBeanObject.fromJson(await _client.send(
      'delete',
      'rest/api/3/resolution/{id}',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        'replaceWith': replaceWith,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueSearchApi {
  final ApiClient _client;

  IssueSearchApi(this._client);

  /// Returns lists of issues matching a query string. Use this resource to
  /// provide auto-completion suggestions when the user is looking for an issue
  /// using a word or string.
  ///
  /// This operation returns two lists:
  ///
  ///  *  `History Search` which includes issues from the user's history of
  /// created, edited, or viewed issues that contain the string in the `query`
  /// parameter.
  ///  *  `Current Search` which includes issues that match the JQL expression
  /// in `currentJQL` and contain the string in the `query` parameter.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<IssuePickerSuggestions> getIssuePickerResource(
      {String? query,
      String? currentJql,
      String? currentIssueKey,
      String? currentProjectId,
      bool? showSubTasks,
      bool? showSubTaskParent}) async {
    return IssuePickerSuggestions.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/picker',
      queryParameters: {
        if (query != null) 'query': query,
        if (currentJql != null) 'currentJQL': currentJql,
        if (currentIssueKey != null) 'currentIssueKey': currentIssueKey,
        if (currentProjectId != null) 'currentProjectId': currentProjectId,
        if (showSubTasks != null) 'showSubTasks': '$showSubTasks',
        if (showSubTaskParent != null)
          'showSubTaskParent': '$showSubTaskParent',
      },
    ));
  }

  /// Checks whether one or more issues would be returned by one or more JQL
  /// queries.
  ///
  /// **[Permissions](#permissions) required:** None, however, issues are only
  /// matched against JQL queries where the user has:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<IssueMatches> matchIssues({required IssuesAndJQLQueries body}) async {
    return IssueMatches.fromJson(await _client.send(
      'post',
      'rest/api/3/jql/match',
      body: body.toJson(),
    ));
  }

  /// Searches for issues using
  /// [JQL](https://confluence.atlassian.com/x/egORLQ).
  ///
  /// If the JQL query expression is too large to be encoded as a query
  /// parameter, use the [POST](#api-rest-api-3-search-post) version of this
  /// resource.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Issues are included in the
  /// response where the user has:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<SearchResults> searchForIssuesUsingJql(
      {String? jql,
      int? startAt,
      int? maxResults,
      String? validateQuery,
      List<String>? fields,
      String? expand,
      List<String>? properties,
      bool? fieldsByKeys}) async {
    return SearchResults.fromJson(await _client.send(
      'get',
      'rest/api/3/search',
      queryParameters: {
        if (jql != null) 'jql': jql,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (validateQuery != null) 'validateQuery': validateQuery,
        if (fields != null) 'fields': fields.map((e) => e).join(','),
        if (expand != null) 'expand': expand,
        if (properties != null)
          'properties': properties.map((e) => e).join(','),
        if (fieldsByKeys != null) 'fieldsByKeys': '$fieldsByKeys',
      },
    ));
  }

  /// Searches for issues using
  /// [JQL](https://confluence.atlassian.com/x/egORLQ).
  ///
  /// There is a [GET](#api-rest-api-3-search-get) version of this resource that
  /// can be used for smaller JQL query expressions.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Issues are included in the
  /// response where the user has:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<SearchResults> searchForIssuesUsingJqlPost(
      {required SearchRequestBean body}) async {
    return SearchResults.fromJson(await _client.send(
      'post',
      'rest/api/3/search',
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueSecurityLevelApi {
  final ApiClient _client;

  IssueSecurityLevelApi(this._client);

  /// Returns issue security level members.
  ///
  /// Only issue security level members in context of classic projects are
  /// returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueSecurityLevelMember> getIssueSecurityLevelMembers(
      {required int issueSecuritySchemeId,
      int? startAt,
      int? maxResults,
      List<int>? issueSecurityLevelId,
      String? expand}) async {
    return PageBeanIssueSecurityLevelMember.fromJson(await _client.send(
      'get',
      'rest/api/3/issuesecurityschemes/{issueSecuritySchemeId}/members',
      pathParameters: {
        'issueSecuritySchemeId': '$issueSecuritySchemeId',
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (issueSecurityLevelId != null)
          'issueSecurityLevelId':
              issueSecurityLevelId.map((e) => '$e').join(','),
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns details of an issue security level.
  ///
  /// Use
  /// [Get issue security scheme](#api-rest-api-3-issuesecurityschemes-id-get)
  /// to obtain the IDs of issue security levels associated with the issue
  /// security scheme.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<SecurityLevel> getIssueSecurityLevel(String id) async {
    return SecurityLevel.fromJson(await _client.send(
      'get',
      'rest/api/3/securitylevel/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueSecuritySchemesApi {
  final ApiClient _client;

  IssueSecuritySchemesApi(this._client);

  /// Returns all
  /// [issue security schemes](https://confluence.atlassian.com/x/J4lKLg).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<SecuritySchemes> getIssueSecuritySchemes() async {
    return SecuritySchemes.fromJson(await _client.send(
      'get',
      'rest/api/3/issuesecurityschemes',
    ));
  }

  /// Creates a security scheme with security scheme levels and levels' members.
  /// You can create up to 100 security scheme levels and security scheme
  /// levels' members per request.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<SecuritySchemeId> createIssueSecurityScheme(
      {required CreateIssueSecuritySchemeDetails body}) async {
    return SecuritySchemeId.fromJson(await _client.send(
      'post',
      'rest/api/3/issuesecurityschemes',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of issue security levels.
  ///
  /// Only issue security levels in the context of classic projects are
  /// returned.
  ///
  /// Filtering using IDs is inclusive: if you specify both security scheme IDs
  /// and level IDs, the result will include both specified issue security
  /// levels and all issue security levels from the specified schemes.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanSecurityLevel> getSecurityLevels(
      {String? startAt,
      String? maxResults,
      List<String>? id,
      List<String>? schemeId,
      bool? onlyDefault}) async {
    return PageBeanSecurityLevel.fromJson(await _client.send(
      'get',
      'rest/api/3/issuesecurityschemes/level',
      queryParameters: {
        if (startAt != null) 'startAt': startAt,
        if (maxResults != null) 'maxResults': maxResults,
        if (id != null) 'id': id.map((e) => e).join(','),
        if (schemeId != null) 'schemeId': schemeId.map((e) => e).join(','),
        if (onlyDefault != null) 'onlyDefault': '$onlyDefault',
      },
    ));
  }

  /// Sets default issue security levels for schemes.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> setDefaultLevels(
      {required SetDefaultLevelsRequest body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuesecurityschemes/level/default',
      body: body.toJson(),
    );
  }

  /// Returns a [paginated](#pagination) list of issue security level members.
  ///
  /// Only issue security level members in the context of classic projects are
  /// returned.
  ///
  /// Filtering using parameters is inclusive: if you specify both security
  /// scheme IDs and level IDs, the result will include all issue security level
  /// members from the specified schemes and levels.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanSecurityLevelMember> getSecurityLevelMembers(
      {String? startAt,
      String? maxResults,
      List<String>? id,
      List<String>? schemeId,
      List<String>? levelId,
      String? expand}) async {
    return PageBeanSecurityLevelMember.fromJson(await _client.send(
      'get',
      'rest/api/3/issuesecurityschemes/level/member',
      queryParameters: {
        if (startAt != null) 'startAt': startAt,
        if (maxResults != null) 'maxResults': maxResults,
        if (id != null) 'id': id.map((e) => e).join(','),
        if (schemeId != null) 'schemeId': schemeId.map((e) => e).join(','),
        if (levelId != null) 'levelId': levelId.map((e) => e).join(','),
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns a [paginated](#pagination) mapping of projects that are using
  /// security schemes. You can provide either one or multiple security scheme
  /// IDs or project IDs to filter by. If you don't provide any, this will
  /// return a list of all mappings. Only issue security schemes in the context
  /// of classic projects are supported. **[Permissions](#permissions)
  /// required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueSecuritySchemeToProjectMapping>
      searchProjectsUsingSecuritySchemes(
          {String? startAt,
          String? maxResults,
          List<String>? issueSecuritySchemeId,
          List<String>? projectId}) async {
    return PageBeanIssueSecuritySchemeToProjectMapping.fromJson(
        await _client.send(
      'get',
      'rest/api/3/issuesecurityschemes/project',
      queryParameters: {
        if (startAt != null) 'startAt': startAt,
        if (maxResults != null) 'maxResults': maxResults,
        if (issueSecuritySchemeId != null)
          'issueSecuritySchemeId':
              issueSecuritySchemeId.map((e) => e).join(','),
        if (projectId != null) 'projectId': projectId.map((e) => e).join(','),
      },
    ));
  }

  /// Associates an issue security scheme with a project and remaps security
  /// levels of issues to the new levels, if provided.
  ///
  /// This operation is [asynchronous](#async). Follow the `location` link in
  /// the response to determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TaskProgressBeanObject> associateSchemesToProjects(
      {required AssociateSecuritySchemeWithProjectDetails body}) async {
    return TaskProgressBeanObject.fromJson(await _client.send(
      'put',
      'rest/api/3/issuesecurityschemes/project',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of issue security schemes.
  /// If you specify the project ID parameter, the result will contain issue
  /// security schemes and related project IDs you filter by. Use {@link
  /// IssueSecuritySchemeResource#searchProjectsUsingSecuritySchemes(String,
  /// String, Set, Set)} to obtain all projects related to scheme.
  ///
  /// Only issue security schemes in the context of classic projects are
  /// returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanSecuritySchemeWithProjects> searchSecuritySchemes(
      {String? startAt,
      String? maxResults,
      List<String>? id,
      List<String>? projectId}) async {
    return PageBeanSecuritySchemeWithProjects.fromJson(await _client.send(
      'get',
      'rest/api/3/issuesecurityschemes/search',
      queryParameters: {
        if (startAt != null) 'startAt': startAt,
        if (maxResults != null) 'maxResults': maxResults,
        if (id != null) 'id': id.map((e) => e).join(','),
        if (projectId != null) 'projectId': projectId.map((e) => e).join(','),
      },
    ));
  }

  /// Returns an issue security scheme along with its security levels.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///  *  *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for a
  /// project that uses the requested issue security scheme.
  Future<SecurityScheme> getIssueSecurityScheme(int id) async {
    return SecurityScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/issuesecurityschemes/{id}',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Updates the issue security scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateIssueSecurityScheme(
      {required String id,
      required UpdateIssueSecuritySchemeRequestBean body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuesecurityschemes/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    );
  }

  /// Deletes an issue security scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> deleteSecurityScheme(String schemeId) async {
    return await _client.send(
      'delete',
      'rest/api/3/issuesecurityschemes/{schemeId}',
      pathParameters: {
        'schemeId': schemeId,
      },
    );
  }

  /// Adds levels and levels' members to the issue security scheme. You can add
  /// up to 100 levels per request.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> addSecurityLevel(
      {required String schemeId,
      required AddSecuritySchemeLevelsRequestBean body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuesecurityschemes/{schemeId}/level',
      pathParameters: {
        'schemeId': schemeId,
      },
      body: body.toJson(),
    );
  }

  /// Updates the issue security level.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateSecurityLevel(
      {required String schemeId,
      required String levelId,
      required UpdateIssueSecurityLevelDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuesecurityschemes/{schemeId}/level/{levelId}',
      pathParameters: {
        'schemeId': schemeId,
        'levelId': levelId,
      },
      body: body.toJson(),
    );
  }

  /// Deletes an issue security level.
  ///
  /// This operation is [asynchronous](#async). Follow the `location` link in
  /// the response to determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TaskProgressBeanObject> removeLevel(
      {required String schemeId,
      required String levelId,
      String? replaceWith}) async {
    return TaskProgressBeanObject.fromJson(await _client.send(
      'delete',
      'rest/api/3/issuesecurityschemes/{schemeId}/level/{levelId}',
      pathParameters: {
        'schemeId': schemeId,
        'levelId': levelId,
      },
      queryParameters: {
        if (replaceWith != null) 'replaceWith': replaceWith,
      },
    ));
  }

  /// Adds members to the issue security level. You can add up to 100 members
  /// per request.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> addSecurityLevelMembers(
      {required String schemeId,
      required String levelId,
      required SecuritySchemeMembersRequest body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuesecurityschemes/{schemeId}/level/{levelId}/member',
      pathParameters: {
        'schemeId': schemeId,
        'levelId': levelId,
      },
      body: body.toJson(),
    );
  }

  /// Removes an issue security level member from an issue security scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> removeMemberFromSecurityLevel(
      {required String schemeId,
      required String levelId,
      required String memberId}) async {
    return await _client.send(
      'delete',
      'rest/api/3/issuesecurityschemes/{schemeId}/level/{levelId}/member/{memberId}',
      pathParameters: {
        'schemeId': schemeId,
        'levelId': levelId,
        'memberId': memberId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueTypePropertiesApi {
  final ApiClient _client;

  IssueTypePropertiesApi(this._client);

  /// Returns all the
  /// [issue type property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties)
  /// keys of the issue type.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) to get the
  /// property keys of any issue type.
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to get the
  /// property keys of any issue types associated with the projects the user has
  /// permission to browse.
  Future<PropertyKeys> getIssueTypePropertyKeys(String issueTypeId) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetype/{issueTypeId}/properties',
      pathParameters: {
        'issueTypeId': issueTypeId,
      },
    ));
  }

  /// Returns the key and value of the
  /// [issue type property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) to get the
  /// details of any issue type.
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) to get the
  /// details of any issue types associated with the projects the user has
  /// permission to browse.
  Future<EntityProperty> getIssueTypeProperty(
      {required String issueTypeId, required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetype/{issueTypeId}/properties/{propertyKey}',
      pathParameters: {
        'issueTypeId': issueTypeId,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Creates or updates the value of the
  /// [issue type property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties).
  /// Use this resource to store and update data against an issue type.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> setIssueTypeProperty(
      {required String issueTypeId,
      required String propertyKey,
      required dynamic body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuetype/{issueTypeId}/properties/{propertyKey}',
      pathParameters: {
        'issueTypeId': issueTypeId,
        'propertyKey': propertyKey,
      },
      body: body,
    );
  }

  /// Deletes the
  /// [issue type property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteIssueTypeProperty(
      {required String issueTypeId, required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/issuetype/{issueTypeId}/properties/{propertyKey}',
      pathParameters: {
        'issueTypeId': issueTypeId,
        'propertyKey': propertyKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueTypeSchemesApi {
  final ApiClient _client;

  IssueTypeSchemesApi(this._client);

  /// Returns a [paginated](#pagination) list of issue type schemes.
  ///
  /// Only issue type schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeScheme> getAllIssueTypeSchemes(
      {int? startAt,
      int? maxResults,
      List<int>? id,
      String? orderBy,
      String? expand,
      String? queryString}) async {
    return PageBeanIssueTypeScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescheme',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': id.map((e) => '$e').join(','),
        if (orderBy != null) 'orderBy': orderBy,
        if (expand != null) 'expand': expand,
        if (queryString != null) 'queryString': queryString,
      },
    ));
  }

  /// Creates an issue type scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeSchemeID> createIssueTypeScheme(
      {required IssueTypeSchemeDetails body}) async {
    return IssueTypeSchemeID.fromJson(await _client.send(
      'post',
      'rest/api/3/issuetypescheme',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of issue type scheme items.
  ///
  /// Only issue type scheme items used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeSchemeMapping> getIssueTypeSchemesMapping(
      {int? startAt, int? maxResults, List<int>? issueTypeSchemeId}) async {
    return PageBeanIssueTypeSchemeMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescheme/mapping',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (issueTypeSchemeId != null)
          'issueTypeSchemeId': issueTypeSchemeId.map((e) => '$e').join(','),
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of issue type schemes and, for
  /// each issue type scheme, a list of the projects that use it.
  ///
  /// Only issue type schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeSchemeProjects> getIssueTypeSchemeForProjects(
      {int? startAt, int? maxResults, required List<int> projectId}) async {
    return PageBeanIssueTypeSchemeProjects.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescheme/project',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        'projectId': projectId.map((e) => '$e').join(','),
      },
    ));
  }

  /// Assigns an issue type scheme to a project.
  ///
  /// If any issues in the project are assigned issue types not present in the
  /// new scheme, the operation will fail. To complete the assignment those
  /// issues must be updated to use issue types in the new scheme.
  ///
  /// Issue type schemes can only be assigned to classic projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> assignIssueTypeSchemeToProject(
      {required IssueTypeSchemeProjectAssociation body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuetypescheme/project',
      body: body.toJson(),
    );
  }

  /// Updates an issue type scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateIssueTypeScheme(
      {required int issueTypeSchemeId,
      required IssueTypeSchemeUpdateDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuetypescheme/{issueTypeSchemeId}',
      pathParameters: {
        'issueTypeSchemeId': '$issueTypeSchemeId',
      },
      body: body.toJson(),
    );
  }

  /// Deletes an issue type scheme.
  ///
  /// Only issue type schemes used in classic projects can be deleted.
  ///
  /// Any projects assigned to the scheme are reassigned to the default issue
  /// type scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> deleteIssueTypeScheme(int issueTypeSchemeId) async {
    return await _client.send(
      'delete',
      'rest/api/3/issuetypescheme/{issueTypeSchemeId}',
      pathParameters: {
        'issueTypeSchemeId': '$issueTypeSchemeId',
      },
    );
  }

  /// Adds issue types to an issue type scheme.
  ///
  /// The added issue types are appended to the issue types list.
  ///
  /// If any of the issue types exist in the issue type scheme, the operation
  /// fails and no issue types are added.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> addIssueTypesToIssueTypeScheme(
      {required int issueTypeSchemeId, required IssueTypeIds body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype',
      pathParameters: {
        'issueTypeSchemeId': '$issueTypeSchemeId',
      },
      body: body.toJson(),
    );
  }

  /// Changes the order of issue types in an issue type scheme.
  ///
  /// The request body parameters must meet the following requirements:
  ///
  ///  *  all of the issue types must belong to the issue type scheme.
  ///  *  either `after` or `position` must be provided.
  ///  *  the issue type in `after` must not be in the issue type list.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> reorderIssueTypesInIssueTypeScheme(
      {required int issueTypeSchemeId, required OrderOfIssueTypes body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype/move',
      pathParameters: {
        'issueTypeSchemeId': '$issueTypeSchemeId',
      },
      body: body.toJson(),
    );
  }

  /// Removes an issue type from an issue type scheme.
  ///
  /// This operation cannot remove:
  ///
  ///  *  any issue type used by issues.
  ///  *  any issue types from the default issue type scheme.
  ///  *  the last standard issue type from an issue type scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> removeIssueTypeFromIssueTypeScheme(
      {required int issueTypeSchemeId, required int issueTypeId}) async {
    return await _client.send(
      'delete',
      'rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype/{issueTypeId}',
      pathParameters: {
        'issueTypeSchemeId': '$issueTypeSchemeId',
        'issueTypeId': '$issueTypeId',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueTypeScreenSchemesApi {
  final ApiClient _client;

  IssueTypeScreenSchemesApi(this._client);

  /// Returns a [paginated](#pagination) list of issue type screen schemes.
  ///
  /// Only issue type screen schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeScreenScheme> getIssueTypeScreenSchemes(
      {int? startAt,
      int? maxResults,
      List<int>? id,
      String? queryString,
      String? orderBy,
      String? expand}) async {
    return PageBeanIssueTypeScreenScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescreenscheme',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': id.map((e) => '$e').join(','),
        if (queryString != null) 'queryString': queryString,
        if (orderBy != null) 'orderBy': orderBy,
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Creates an issue type screen scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeScreenSchemeId> createIssueTypeScreenScheme(
      {required IssueTypeScreenSchemeDetails body}) async {
    return IssueTypeScreenSchemeId.fromJson(await _client.send(
      'post',
      'rest/api/3/issuetypescreenscheme',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of issue type screen scheme items.
  ///
  /// Only issue type screen schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeScreenSchemeItem> getIssueTypeScreenSchemeMappings(
      {int? startAt,
      int? maxResults,
      List<int>? issueTypeScreenSchemeId}) async {
    return PageBeanIssueTypeScreenSchemeItem.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescreenscheme/mapping',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (issueTypeScreenSchemeId != null)
          'issueTypeScreenSchemeId':
              issueTypeScreenSchemeId.map((e) => '$e').join(','),
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of issue type screen schemes and,
  /// for each issue type screen scheme, a list of the projects that use it.
  ///
  /// Only issue type screen schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanIssueTypeScreenSchemesProjects>
      getIssueTypeScreenSchemeProjectAssociations(
          {int? startAt, int? maxResults, required List<int> projectId}) async {
    return PageBeanIssueTypeScreenSchemesProjects.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescreenscheme/project',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        'projectId': projectId.map((e) => '$e').join(','),
      },
    ));
  }

  /// Assigns an issue type screen scheme to a project.
  ///
  /// Issue type screen schemes can only be assigned to classic projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> assignIssueTypeScreenSchemeToProject(
      {required IssueTypeScreenSchemeProjectAssociation body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuetypescreenscheme/project',
      body: body.toJson(),
    );
  }

  /// Updates an issue type screen scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateIssueTypeScreenScheme(
      {required String issueTypeScreenSchemeId,
      required IssueTypeScreenSchemeUpdateDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}',
      pathParameters: {
        'issueTypeScreenSchemeId': issueTypeScreenSchemeId,
      },
      body: body.toJson(),
    );
  }

  /// Deletes an issue type screen scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> deleteIssueTypeScreenScheme(
      String issueTypeScreenSchemeId) async {
    return await _client.send(
      'delete',
      'rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}',
      pathParameters: {
        'issueTypeScreenSchemeId': issueTypeScreenSchemeId,
      },
    );
  }

  /// Appends issue type to screen scheme mappings to an issue type screen
  /// scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> appendMappingsForIssueTypeScreenScheme(
      {required String issueTypeScreenSchemeId,
      required IssueTypeScreenSchemeMappingDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping',
      pathParameters: {
        'issueTypeScreenSchemeId': issueTypeScreenSchemeId,
      },
      body: body.toJson(),
    );
  }

  /// Updates the default screen scheme of an issue type screen scheme. The
  /// default screen scheme is used for all unmapped issue types.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateDefaultScreenScheme(
      {required String issueTypeScreenSchemeId,
      required UpdateDefaultScreenScheme body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping/default',
      pathParameters: {
        'issueTypeScreenSchemeId': issueTypeScreenSchemeId,
      },
      body: body.toJson(),
    );
  }

  /// Removes issue type to screen scheme mappings from an issue type screen
  /// scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> removeMappingsFromIssueTypeScreenScheme(
      {required String issueTypeScreenSchemeId,
      required IssueTypeIds body}) async {
    return await _client.send(
      'post',
      'rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping/remove',
      pathParameters: {
        'issueTypeScreenSchemeId': issueTypeScreenSchemeId,
      },
      body: body.toJson(),
    );
  }

  /// Returns a [paginated](#pagination) list of projects associated with an
  /// issue type screen scheme.
  ///
  /// Only company-managed projects associated with an issue type screen scheme
  /// are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanProjectDetails> getProjectsForIssueTypeScreenScheme(
      {required int issueTypeScreenSchemeId,
      int? startAt,
      int? maxResults,
      String? query}) async {
    return PageBeanProjectDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/project',
      pathParameters: {
        'issueTypeScreenSchemeId': '$issueTypeScreenSchemeId',
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (query != null) 'query': query,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueTypesApi {
  final ApiClient _client;

  IssueTypesApi(this._client);

  /// Returns all issue types.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Issue types are only returned as
  /// follows:
  ///
  ///  *  if the user has the *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), all issue
  /// types are returned.
  ///  *  if the user has the *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for one or
  /// more projects, the issue types associated with the projects the user has
  /// permission to browse are returned.
  Future<List<IssueTypeDetails>> getIssueAllTypes() async {
    return (await _client.send(
      'get',
      'rest/api/3/issuetype',
    ) as List<Object?>)
        .map((i) =>
            IssueTypeDetails.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates an issue type and adds it to the default issue type scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeDetails> createIssueType(
      {required IssueTypeCreateBean body}) async {
    return IssueTypeDetails.fromJson(await _client.send(
      'post',
      'rest/api/3/issuetype',
      body: body.toJson(),
    ));
  }

  /// Returns issue types for a project.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) in the
  /// relevant project or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<IssueTypeDetails>> getIssueTypesForProject(
      {required int projectId, int? level}) async {
    return (await _client.send(
      'get',
      'rest/api/3/issuetype/project',
      queryParameters: {
        'projectId': '$projectId',
        if (level != null) 'level': '$level',
      },
    ) as List<Object?>)
        .map((i) =>
            IssueTypeDetails.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns an issue type.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) in a
  /// project the issue type is associated with or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeDetails> getIssueType(String id) async {
    return IssueTypeDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/issuetype/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Updates the issue type.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeDetails> updateIssueType(
      {required String id, required IssueTypeUpdateBean body}) async {
    return IssueTypeDetails.fromJson(await _client.send(
      'put',
      'rest/api/3/issuetype/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the issue type. If the issue type is in use, all uses are updated
  /// with the alternative issue type (`alternativeIssueTypeId`). A list of
  /// alternative issue types are obtained from the
  /// [Get alternative issue types](#api-rest-api-3-issuetype-id-alternatives-get)
  /// resource.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteIssueType(
      {required String id, String? alternativeIssueTypeId}) async {
    await _client.send(
      'delete',
      'rest/api/3/issuetype/{id}',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        if (alternativeIssueTypeId != null)
          'alternativeIssueTypeId': alternativeIssueTypeId,
      },
    );
  }

  /// Returns a list of issue types that can be used to replace the issue type.
  /// The alternative issue types are those assigned to the same workflow
  /// scheme, field configuration scheme, and screen scheme.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<List<IssueTypeDetails>> getAlternativeIssueTypes(String id) async {
    return (await _client.send(
      'get',
      'rest/api/3/issuetype/{id}/alternatives',
      pathParameters: {
        'id': id,
      },
    ) as List<Object?>)
        .map((i) =>
            IssueTypeDetails.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Loads an avatar for the issue type.
  ///
  /// Specify the avatar's local file location in the body of the request. Also,
  /// include the following headers:
  ///
  ///  *  `X-Atlassian-Token: no-check` To prevent XSRF protection blocking the
  /// request, for more information see
  /// [Special Headers](#special-request-headers).
  ///  *  `Content-Type: image/image type` Valid image types are JPEG, GIF, or
  /// PNG.
  ///
  /// For example:
  /// `curl --request POST  --user email@example.com:<api_token>  --header
  /// 'X-Atlassian-Token: no-check'  --header 'Content-Type: image/<
  /// image_type>'  --data-binary "<@/path/to/file/with/your/avatar>"  --url
  /// 'https://your-domain.atlassian.net/rest/api/3/issuetype/{issueTypeId}'This`
  ///
  /// The avatar is cropped to a square. If no crop parameters are specified,
  /// the square originates at the top left of the image. The length of the
  /// square's sides is set to the smaller of the height or width of the image.
  ///
  /// The cropped image is then used to create avatars of 16x16, 24x24, 32x32,
  /// and 48x48 in size.
  ///
  /// After creating the avatar, use
  /// [ Update issue type](#api-rest-api-3-issuetype-id-put) to set it as the
  /// issue type's displayed avatar.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Avatar> createIssueTypeAvatar(
      {required String id,
      int? x,
      int? y,
      required int size,
      required dynamic body}) async {
    return Avatar.fromJson(await _client.send(
      'post',
      'rest/api/3/issuetype/{id}/avatar2',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        if (x != null) 'x': '$x',
        if (y != null) 'y': '$y',
        'size': '$size',
      },
      body: body,
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssueVotesApi {
  final ApiClient _client;

  IssueVotesApi(this._client);

  /// Returns details about the votes on an issue.
  ///
  /// This operation requires the **Allow users to vote on issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is ini
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///
  /// Note that users with the necessary permissions for this operation but
  /// without the *View voters and watchers* project permissions are not
  /// returned details in the `voters` field.
  Future<Votes> getVotes(String issueIdOrKey) async {
    return Votes.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/votes',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
    ));
  }

  /// Adds the user's vote to an issue. This is the equivalent of the user
  /// clicking *Vote* on an issue in Jira.
  ///
  /// This operation requires the **Allow users to vote on issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<dynamic> addVote(String issueIdOrKey) async {
    return await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/votes',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
    );
  }

  /// Deletes a user's vote from an issue. This is the equivalent of the user
  /// clicking *Unvote* on an issue in Jira.
  ///
  /// This operation requires the **Allow users to vote on issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> removeVote(String issueIdOrKey) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/votes',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueWatchersApi {
  final ApiClient _client;

  IssueWatchersApi(this._client);

  /// Returns, for the user, details of the watched status of issues from a
  /// list. If an issue ID is invalid, the returned watched status is `false`.
  ///
  /// This operation requires the **Allow users to watch issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<BulkIssueIsWatching> getIsWatchingIssueBulk(
      {required IssueList body}) async {
    return BulkIssueIsWatching.fromJson(await _client.send(
      'post',
      'rest/api/3/issue/watching',
      body: body.toJson(),
    ));
  }

  /// Returns the watchers for an issue.
  ///
  /// This operation requires the **Allow users to watch issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is ini
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  To see details of users on the watchlist other than themselves, *View
  /// voters and watchers*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  Future<Watchers> getIssueWatchers(String issueIdOrKey) async {
    return Watchers.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/watchers',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
    ));
  }

  /// Adds a user as a watcher of an issue by passing the account ID of the
  /// user. For example, `"5b10ac8d82e05b22cc7d4ef5"`. If no user is specified
  /// the calling user is added.
  ///
  /// This operation requires the **Allow users to watch issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  To add users other than themselves to the watchlist, *Manage watcher
  /// list* [project permission](https://confluence.atlassian.com/x/yodKLg) for
  /// the project that the issue is in.
  Future<dynamic> addWatcher(
      {required String issueIdOrKey, required String body}) async {
    return await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/watchers',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      body: body,
    );
  }

  /// Deletes a user as a watcher of an issue.
  ///
  /// This operation requires the **Allow users to watch issues** option to be
  /// *ON*. This option is set in General configuration for Jira. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  To remove users other than themselves from the watchlist, *Manage
  /// watcher list*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  Future<void> removeWatcher(
      {required String issueIdOrKey,
      String? username,
      String? accountId}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/watchers',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (username != null) 'username': username,
        if (accountId != null) 'accountId': accountId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueWorklogPropertiesApi {
  final ApiClient _client;

  IssueWorklogPropertiesApi(this._client);

  /// Returns the keys of all properties for a worklog.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<PropertyKeys> getWorklogPropertyKeys(
      {required String issueIdOrKey, required String worklogId}) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'worklogId': worklogId,
      },
    ));
  }

  /// Returns the value of a worklog property.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<EntityProperty> getWorklogProperty(
      {required String issueIdOrKey,
      required String worklogId,
      required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'worklogId': worklogId,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Sets the value of a worklog property. Use this operation to store custom
  /// data against the worklog.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Edit all
  /// worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg)
  /// to update any worklog or *Edit own worklogs* to update worklogs created by
  /// the user.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<dynamic> setWorklogProperty(
      {required String issueIdOrKey,
      required String worklogId,
      required String propertyKey,
      required dynamic body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'worklogId': worklogId,
        'propertyKey': propertyKey,
      },
      body: body,
    );
  }

  /// Deletes a worklog property.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<void> deleteWorklogProperty(
      {required String issueIdOrKey,
      required String worklogId,
      required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'worklogId': worklogId,
        'propertyKey': propertyKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class IssueWorklogsApi {
  final ApiClient _client;

  IssueWorklogsApi(this._client);

  /// Returns worklogs for an issue, starting from the oldest worklog or from
  /// the worklog started on or after a date and time.
  ///
  /// Time tracking must be enabled in Jira, otherwise this operation returns an
  /// error. For more information, see
  /// [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Workloads are only returned
  /// where the user has:
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<PageOfWorklogs> getIssueWorklog(
      {required String issueIdOrKey,
      int? startAt,
      int? maxResults,
      int? startedAfter,
      int? startedBefore,
      String? expand}) async {
    return PageOfWorklogs.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/worklog',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (startedAfter != null) 'startedAfter': '$startedAfter',
        if (startedBefore != null) 'startedBefore': '$startedBefore',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Adds a worklog to an issue.
  ///
  /// Time tracking must be enabled in Jira, otherwise this operation returns an
  /// error. For more information, see
  /// [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Work on issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<Worklog> addWorklog(
      {required String issueIdOrKey,
      bool? notifyUsers,
      String? adjustEstimate,
      String? newEstimate,
      String? reduceBy,
      String? expand,
      bool? overrideEditableFlag,
      required Worklog body}) async {
    return Worklog.fromJson(await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/worklog',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (notifyUsers != null) 'notifyUsers': '$notifyUsers',
        if (adjustEstimate != null) 'adjustEstimate': adjustEstimate,
        if (newEstimate != null) 'newEstimate': newEstimate,
        if (reduceBy != null) 'reduceBy': reduceBy,
        if (expand != null) 'expand': expand,
        if (overrideEditableFlag != null)
          'overrideEditableFlag': '$overrideEditableFlag',
      },
      body: body.toJson(),
    ));
  }

  /// Returns a worklog.
  ///
  /// Time tracking must be enabled in Jira, otherwise this operation returns an
  /// error. For more information, see
  /// [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<Worklog> getWorklog(
      {required String issueIdOrKey,
      required String id,
      String? expand}) async {
    return Worklog.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{id}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'id': id,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates a worklog.
  ///
  /// Time tracking must be enabled in Jira, otherwise this operation returns an
  /// error. For more information, see
  /// [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Edit all
  /// worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg)
  /// to update any worklog or *Edit own worklogs* to update worklogs created by
  /// the user.
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<Worklog> updateWorklog(
      {required String issueIdOrKey,
      required String id,
      bool? notifyUsers,
      String? adjustEstimate,
      String? newEstimate,
      String? expand,
      bool? overrideEditableFlag,
      required Worklog body}) async {
    return Worklog.fromJson(await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{id}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'id': id,
      },
      queryParameters: {
        if (notifyUsers != null) 'notifyUsers': '$notifyUsers',
        if (adjustEstimate != null) 'adjustEstimate': adjustEstimate,
        if (newEstimate != null) 'newEstimate': newEstimate,
        if (expand != null) 'expand': expand,
        if (overrideEditableFlag != null)
          'overrideEditableFlag': '$overrideEditableFlag',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a worklog from an issue.
  ///
  /// Time tracking must be enabled in Jira, otherwise this operation returns an
  /// error. For more information, see
  /// [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///  *  *Delete all
  /// worklogs*[ project permission](https://confluence.atlassian.com/x/yodKLg)
  /// to delete any worklog or *Delete own worklogs* to delete worklogs created
  /// by the user,
  ///  *  If the worklog has visibility restrictions, belongs to the group or
  /// has the role visibility is restricted to.
  Future<void> deleteWorklog(
      {required String issueIdOrKey,
      required String id,
      bool? notifyUsers,
      String? adjustEstimate,
      String? newEstimate,
      String? increaseBy,
      bool? overrideEditableFlag}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}/worklog/{id}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
        'id': id,
      },
      queryParameters: {
        if (notifyUsers != null) 'notifyUsers': '$notifyUsers',
        if (adjustEstimate != null) 'adjustEstimate': adjustEstimate,
        if (newEstimate != null) 'newEstimate': newEstimate,
        if (increaseBy != null) 'increaseBy': increaseBy,
        if (overrideEditableFlag != null)
          'overrideEditableFlag': '$overrideEditableFlag',
      },
    );
  }

  /// Returns a list of IDs and delete timestamps for worklogs deleted after a
  /// date and time.
  ///
  /// This resource is paginated, with a limit of 1000 worklogs per page. Each
  /// page lists worklogs from oldest to youngest. If the number of items in the
  /// date range exceeds 1000, `until` indicates the timestamp of the youngest
  /// item on the page. Also, `nextPage` provides the URL for the next page of
  /// worklogs. The `lastPage` parameter is set to true on the last page of
  /// worklogs.
  ///
  /// This resource does not return worklogs deleted during the minute preceding
  /// the request.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<ChangedWorklogs> getIdsOfWorklogsDeletedSince({int? since}) async {
    return ChangedWorklogs.fromJson(await _client.send(
      'get',
      'rest/api/3/worklog/deleted',
      queryParameters: {
        if (since != null) 'since': '$since',
      },
    ));
  }

  /// Returns worklog details for a list of worklog IDs.
  ///
  /// The returned list of worklogs is limited to 1000 items.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, worklogs are only returned where either of the following is true:
  ///
  ///  *  the worklog is set as *Viewable by All Users*.
  ///  *  the user is a member of a project role or group with permission to
  /// view the worklog.
  Future<List<Worklog>> getWorklogsForIds(
      {String? expand, required WorklogIdsRequestBean body}) async {
    return (await _client.send(
      'post',
      'rest/api/3/worklog/list',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ) as List<Object?>)
        .map((i) => Worklog.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a list of IDs and update timestamps for worklogs updated after a
  /// date and time.
  ///
  /// This resource is paginated, with a limit of 1000 worklogs per page. Each
  /// page lists worklogs from oldest to youngest. If the number of items in the
  /// date range exceeds 1000, `until` indicates the timestamp of the youngest
  /// item on the page. Also, `nextPage` provides the URL for the next page of
  /// worklogs. The `lastPage` parameter is set to true on the last page of
  /// worklogs.
  ///
  /// This resource does not return worklogs updated during the minute preceding
  /// the request.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira,
  /// however, worklogs are only returned where either of the following is true:
  ///
  ///  *  the worklog is set as *Viewable by All Users*.
  ///  *  the user is a member of a project role or group with permission to
  /// view the worklog.
  Future<ChangedWorklogs> getIdsOfWorklogsModifiedSince(
      {int? since, String? expand}) async {
    return ChangedWorklogs.fromJson(await _client.send(
      'get',
      'rest/api/3/worklog/updated',
      queryParameters: {
        if (since != null) 'since': '$since',
        if (expand != null) 'expand': expand,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class IssuesApi {
  final ApiClient _client;

  IssuesApi(this._client);

  /// Returns all issue events.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<IssueEvent>> getEvents() async {
    return (await _client.send(
      'get',
      'rest/api/3/events',
    ) as List<Object?>)
        .map((i) => IssueEvent.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates an issue or, where the option to create subtasks is enabled in
  /// Jira, a subtask. A transition may be applied, to move the issue or subtask
  /// to a workflow step other than the default start step, and issue properties
  /// set.
  ///
  /// The content of the issue or subtask is defined using `update` and
  /// `fields`. The fields that can be set in the issue or subtask are
  /// determined using the
  /// [ Get create issue metadata](#api-rest-api-3-issue-createmeta-get). These
  /// are the same fields that appear on the issue's create screen. Note that
  /// the `description`, `environment`, and any `textarea` type custom fields
  /// (multi-line text fields) take Atlassian Document Format content. Single
  /// line custom fields (`textfield`) accept a string and don't handle
  /// Atlassian Document Format content.
  ///
  /// Creating a subtask differs from creating an issue as follows:
  ///
  ///  *  `issueType` must be set to a subtask issue type (use
  /// [ Get create issue metadata](#api-rest-api-3-issue-createmeta-get) to find
  /// subtask issue types).
  ///  *  `parent` must contain the ID or key of the parent issue.
  ///
  /// In a next-gen project any issue may be made a child providing that the
  /// parent and child are members of the same project.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects* and *Create
  /// issues* [project permissions](https://confluence.atlassian.com/x/yodKLg)
  /// for the project in which the issue or subtask is created.
  Future<CreatedIssue> createIssue(
      {bool? updateHistory, required IssueUpdateDetails body}) async {
    return CreatedIssue.fromJson(await _client.send(
      'post',
      'rest/api/3/issue',
      queryParameters: {
        if (updateHistory != null) 'updateHistory': '$updateHistory',
      },
      body: body.toJson(),
    ));
  }

  /// Creates upto **50** issues and, where the option to create subtasks is
  /// enabled in Jira, subtasks. Transitions may be applied, to move the issues
  /// or subtasks to a workflow step other than the default start step, and
  /// issue properties set.
  ///
  /// The content of each issue or subtask is defined using `update` and
  /// `fields`. The fields that can be set in the issue or subtask are
  /// determined using the
  /// [ Get create issue metadata](#api-rest-api-3-issue-createmeta-get). These
  /// are the same fields that appear on the issues' create screens. Note that
  /// the `description`, `environment`, and any `textarea` type custom fields
  /// (multi-line text fields) take Atlassian Document Format content. Single
  /// line custom fields (`textfield`) accept a string and don't handle
  /// Atlassian Document Format content.
  ///
  /// Creating a subtask differs from creating an issue as follows:
  ///
  ///  *  `issueType` must be set to a subtask issue type (use
  /// [ Get create issue metadata](#api-rest-api-3-issue-createmeta-get) to find
  /// subtask issue types).
  ///  *  `parent` the must contain the ID or key of the parent issue.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects* and *Create
  /// issues* [project permissions](https://confluence.atlassian.com/x/yodKLg)
  /// for the project in which each issue or subtask is created.
  Future<CreatedIssues> createIssues({required IssuesUpdateBean body}) async {
    return CreatedIssues.fromJson(await _client.send(
      'post',
      'rest/api/3/issue/bulk',
      body: body.toJson(),
    ));
  }

  /// Returns details of projects, issue types within projects, and, when
  /// requested, the create screen fields for each issue type for the user. Use
  /// the information to populate the requests in
  /// [ Create issue](#api-rest-api-3-issue-post) and
  /// [Create issues](#api-rest-api-3-issue-bulk-post).
  ///
  /// The request can be restricted to specific projects or issue types using
  /// the query parameters. The response will contain information for the valid
  /// projects, issue types, or project and issue type combinations requested.
  /// Note that invalid project, issue type, or project and issue type
  /// combinations do not generate errors.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Create issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) in the
  /// requested projects.
  Future<IssueCreateMetadata> getCreateIssueMeta(
      {List<String>? projectIds,
      List<String>? projectKeys,
      List<String>? issuetypeIds,
      List<String>? issuetypeNames,
      String? expand}) async {
    return IssueCreateMetadata.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/createmeta',
      queryParameters: {
        if (projectIds != null)
          'projectIds': projectIds.map((e) => e).join(','),
        if (projectKeys != null)
          'projectKeys': projectKeys.map((e) => e).join(','),
        if (issuetypeIds != null)
          'issuetypeIds': issuetypeIds.map((e) => e).join(','),
        if (issuetypeNames != null)
          'issuetypeNames': issuetypeNames.map((e) => e).join(','),
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns the details for an issue.
  ///
  /// The issue is identified by its ID or key, however, if the identifier
  /// doesn't match an issue, a case-insensitive search and check for moved
  /// issues is performed. If a matching issue is found its details are
  /// returned, a 302 or other redirect is **not** returned. The issue key
  /// returned in the response is the key of the issue found.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<IssueBean> getIssue(
      {required String issueIdOrKey,
      List<String>? fields,
      bool? fieldsByKeys,
      String? expand,
      List<String>? properties,
      bool? updateHistory}) async {
    return IssueBean.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (fields != null) 'fields': fields.map((e) => e).join(','),
        if (fieldsByKeys != null) 'fieldsByKeys': '$fieldsByKeys',
        if (expand != null) 'expand': expand,
        if (properties != null)
          'properties': properties.map((e) => e).join(','),
        if (updateHistory != null) 'updateHistory': '$updateHistory',
      },
    ));
  }

  /// Edits an issue. A transition may be applied and issue properties updated
  /// as part of the edit.
  ///
  /// The edits to the issue's fields are defined using `update` and `fields`.
  /// The fields that can be edited are determined using
  /// [ Get edit issue metadata](#api-rest-api-3-issue-issueIdOrKey-editmeta-get).
  ///
  /// The parent field may be set by key or ID. For standard issue types, the
  /// parent may be removed by setting `update.parent.set.none` to *true*. Note
  /// that the `description`, `environment`, and any `textarea` type custom
  /// fields (multi-line text fields) take Atlassian Document Format content.
  /// Single line custom fields (`textfield`) accept a string and don't handle
  /// Atlassian Document Format content.
  ///
  /// Connect apps having an app user with *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge
  /// apps acting on behalf of users with *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), can
  /// override the screen security configuration using `overrideScreenSecurity`
  /// and `overrideEditableFlag`.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Edit issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<dynamic> editIssue(
      {required String issueIdOrKey,
      bool? notifyUsers,
      bool? overrideScreenSecurity,
      bool? overrideEditableFlag,
      required IssueUpdateDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (notifyUsers != null) 'notifyUsers': '$notifyUsers',
        if (overrideScreenSecurity != null)
          'overrideScreenSecurity': '$overrideScreenSecurity',
        if (overrideEditableFlag != null)
          'overrideEditableFlag': '$overrideEditableFlag',
      },
      body: body.toJson(),
    );
  }

  /// Deletes an issue.
  ///
  /// An issue cannot be deleted if it has one or more subtasks. To delete an
  /// issue with subtasks, set `deleteSubtasks`. This causes the issue's
  /// subtasks to be deleted with the issue.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Delete issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the issue.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<void> deleteIssue(
      {required String issueIdOrKey, String? deleteSubtasks}) async {
    await _client.send(
      'delete',
      'rest/api/3/issue/{issueIdOrKey}',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (deleteSubtasks != null) 'deleteSubtasks': deleteSubtasks,
      },
    );
  }

  /// Assigns an issue to a user. Use this operation when the calling user does
  /// not have the *Edit Issues* permission but has the *Assign issue*
  /// permission for the project that the issue is in.
  ///
  /// If `name` or `accountId` is set to:
  ///
  ///  *  `"-1"`, the issue is assigned to the default assignee for the project.
  ///  *  `null`, the issue is set to unassigned.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse Projects* and *Assign Issues*
  /// [ project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<dynamic> assignIssue(
      {required String issueIdOrKey, required User body}) async {
    return await _client.send(
      'put',
      'rest/api/3/issue/{issueIdOrKey}/assignee',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      body: body.toJson(),
    );
  }

  /// Returns a [paginated](#pagination) list of all changelogs for an issue
  /// sorted by date, starting from the oldest.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<PageBeanChangelog> getChangeLogs(
      {required String issueIdOrKey, int? startAt, int? maxResults}) async {
    return PageBeanChangelog.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/changelog',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Returns changelogs for an issue specified by a list of changelog IDs.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<PageOfChangelogs> getChangeLogsByIds(
      {required String issueIdOrKey, required IssueChangelogIds body}) async {
    return PageOfChangelogs.fromJson(await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/changelog/list',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      body: body.toJson(),
    ));
  }

  /// Returns the edit screen fields for an issue that are visible to and
  /// editable by the user. Use the information to populate the requests in
  /// [Edit issue](#api-rest-api-3-issue-issueIdOrKey-put).
  ///
  /// This endpoint will check for these conditions:
  ///
  /// 1.  Field is available on a field screen - through screen, screen scheme,
  /// issue type screen scheme, and issue type scheme configuration.
  /// `overrideScreenSecurity=true` skips this condition.
  /// 2.  Field is visible in the
  /// [field configuration](https://support.atlassian.com/jira-cloud-administration/docs/change-a-field-configuration/).
  /// `overrideScreenSecurity=true` skips this condition.
  /// 3.  Field is shown on the issue: each field has different conditions here.
  /// For example: Attachment field only shows if attachments are enabled.
  /// Assignee only shows if user has permissions to assign the issue.
  /// 4.  If a field is custom then it must have valid custom field context,
  /// applicable for its project and issue type. All system fields are assumed
  /// to have context in all projects and all issue types.
  /// 5.  Issue has a project, issue type, and status defined.
  /// 6.  Issue is assigned to a valid workflow, and the current status has
  /// assigned a workflow step. `overrideEditableFlag=true` skips this
  /// condition.
  /// 7.  The current workflow step is editable. This is true by default, but
  /// [can be disabled by setting](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/)
  /// the `jira.issue.editable` property to `false`. `overrideEditableFlag=true`
  /// skips this condition.
  /// 8.  User has
  /// [Edit issues permission](https://support.atlassian.com/jira-cloud-administration/docs/permissions-for-company-managed-projects/).
  /// 9.  Workflow permissions allow editing a field. This is true by default
  /// but
  /// [can be modified](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/)
  /// using `jira.permission.*` workflow properties.
  ///
  /// Fields hidden using
  /// [Issue layout settings page](https://support.atlassian.com/jira-software-cloud/docs/configure-field-layout-in-the-issue-view/)
  /// remain editable.
  ///
  /// Connect apps having an app user with *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge
  /// apps acting on behalf of users with *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), can return
  /// additional details using:
  ///
  ///  *  `overrideScreenSecurity` When this flag is `true`, then this endpoint
  /// skips checking if fields are available through screens, and field
  /// configuration (conditions 1. and 2. from the list above).
  ///  *  `overrideEditableFlag` When this flag is `true`, then this endpoint
  /// skips checking if workflow is present and if the current step is editable
  /// (conditions 6. and 7. from the list above).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///
  /// Note: For any fields to be editable the user must have the *Edit issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// issue.
  Future<IssueUpdateMetadata> getEditIssueMeta(
      {required String issueIdOrKey,
      bool? overrideScreenSecurity,
      bool? overrideEditableFlag}) async {
    return IssueUpdateMetadata.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/editmeta',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (overrideScreenSecurity != null)
          'overrideScreenSecurity': '$overrideScreenSecurity',
        if (overrideEditableFlag != null)
          'overrideEditableFlag': '$overrideEditableFlag',
      },
    ));
  }

  /// Creates an email notification for an issue and adds it to the mail queue.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<dynamic> notify(
      {required String issueIdOrKey, required Notification body}) async {
    return await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/notify',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      body: body.toJson(),
    );
  }

  /// Returns either all transitions or a transition that can be performed by
  /// the user on an issue, based on the issue's status.
  ///
  /// Note, if a request is made for a transition that does not exist or cannot
  /// be performed on the issue, given its status, the response will return any
  /// empty transitions list.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required: A list or transition is returned
  /// only when the user has:**
  ///
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  ///
  /// However, if the user does not have the *Transition issues*
  /// [ project permission](https://confluence.atlassian.com/x/yodKLg) the
  /// response will not list any transitions.
  Future<Transitions> getTransitions(
      {required String issueIdOrKey,
      String? expand,
      String? transitionId,
      bool? skipRemoteOnlyCondition,
      bool? includeUnavailableTransitions,
      bool? sortByOpsBarAndStatus}) async {
    return Transitions.fromJson(await _client.send(
      'get',
      'rest/api/3/issue/{issueIdOrKey}/transitions',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (transitionId != null) 'transitionId': transitionId,
        if (skipRemoteOnlyCondition != null)
          'skipRemoteOnlyCondition': '$skipRemoteOnlyCondition',
        if (includeUnavailableTransitions != null)
          'includeUnavailableTransitions': '$includeUnavailableTransitions',
        if (sortByOpsBarAndStatus != null)
          'sortByOpsBarAndStatus': '$sortByOpsBarAndStatus',
      },
    ));
  }

  /// Performs an issue transition and, if the transition has a screen, updates
  /// the fields from the transition screen.
  ///
  /// sortByCategory To update the fields on the transition screen, specify the
  /// fields in the `fields` or `update` parameters in the request body. Get
  /// details about the fields using
  /// [ Get transitions](#api-rest-api-3-issue-issueIdOrKey-transitions-get)
  /// with the `transitions.fields` expand.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Browse projects* and *Transition issues*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that the issue is in.
  ///  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg)
  /// is configured, issue-level security permission to view the issue.
  Future<dynamic> doTransition(
      {required String issueIdOrKey, required IssueUpdateDetails body}) async {
    return await _client.send(
      'post',
      'rest/api/3/issue/{issueIdOrKey}/transitions',
      pathParameters: {
        'issueIdOrKey': issueIdOrKey,
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class JQLApi {
  final ApiClient _client;

  JQLApi(this._client);

  /// Returns reference data for JQL searches. This is a downloadable version of
  /// the documentation provided in
  /// [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ)
  /// and
  /// [Advanced searching - functions reference](https://confluence.atlassian.com/x/hgORLQ),
  /// along with a list of JQL-reserved words. Use this information to assist
  /// with the programmatic creation of JQL queries or the validation of queries
  /// built in a custom query builder.
  ///
  /// To filter visible field details by project or collapse non-unique fields
  /// by field type then
  /// [Get field reference data (POST)](#api-rest-api-3-jql-autocompletedata-post)
  /// can be used.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<JQLReferenceData> getAutoComplete() async {
    return JQLReferenceData.fromJson(await _client.send(
      'get',
      'rest/api/3/jql/autocompletedata',
    ));
  }

  /// Returns reference data for JQL searches. This is a downloadable version of
  /// the documentation provided in
  /// [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ)
  /// and
  /// [Advanced searching - functions reference](https://confluence.atlassian.com/x/hgORLQ),
  /// along with a list of JQL-reserved words. Use this information to assist
  /// with the programmatic creation of JQL queries or the validation of queries
  /// built in a custom query builder.
  ///
  /// This operation can filter the custom fields returned by project. Invalid
  /// project IDs in `projectIds` are ignored. System fields are always
  /// returned.
  ///
  /// It can also return the collapsed field for custom fields. Collapsed fields
  /// enable searches to be performed across all fields with the same name and
  /// of the same field type. For example, the collapsed field `Component -
  /// Component[Dropdown]` enables dropdown fields `Component - cf[10061]` and
  /// `Component - cf[10062]` to be searched simultaneously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<JQLReferenceData> getAutoCompletePost(
      {required SearchAutoCompleteFilter body}) async {
    return JQLReferenceData.fromJson(await _client.send(
      'post',
      'rest/api/3/jql/autocompletedata',
      body: body.toJson(),
    ));
  }

  /// Returns the JQL search auto complete suggestions for a field.
  ///
  /// Suggestions can be obtained by providing:
  ///
  ///  *  `fieldName` to get a list of all values for the field.
  ///  *  `fieldName` and `fieldValue` to get a list of values containing the
  /// text in `fieldValue`.
  ///  *  `fieldName` and `predicateName` to get a list of all predicate values
  /// for the field.
  ///  *  `fieldName`, `predicateName`, and `predicateValue` to get a list of
  /// predicate values containing the text in `predicateValue`.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<AutoCompleteSuggestions> getFieldAutoCompleteForQueryString(
      {String? fieldName,
      String? fieldValue,
      String? predicateName,
      String? predicateValue}) async {
    return AutoCompleteSuggestions.fromJson(await _client.send(
      'get',
      'rest/api/3/jql/autocompletedata/suggestions',
      queryParameters: {
        if (fieldName != null) 'fieldName': fieldName,
        if (fieldValue != null) 'fieldValue': fieldValue,
        if (predicateName != null) 'predicateName': predicateName,
        if (predicateValue != null) 'predicateValue': predicateValue,
      },
    ));
  }

  /// Parses and validates JQL queries.
  ///
  /// Validation is performed in context of the current user.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<ParsedJqlQueries> parseJqlQueries(
      {String? validation, required JqlQueriesToParse body}) async {
    return ParsedJqlQueries.fromJson(await _client.send(
      'post',
      'rest/api/3/jql/parse',
      queryParameters: {
        if (validation != null) 'validation': validation,
      },
      body: body.toJson(),
    ));
  }

  /// Converts one or more JQL queries with user identifiers (username or user
  /// key) to equivalent JQL queries with account IDs.
  ///
  /// You may wish to use this operation if your system stores JQL queries and
  /// you want to make them GDPR-compliant. For more information about
  /// GDPR-related changes, see the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/).
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<ConvertedJQLQueries> migrateQueries(
      {required JQLPersonalDataMigrationRequest body}) async {
    return ConvertedJQLQueries.fromJson(await _client.send(
      'post',
      'rest/api/3/jql/pdcleaner',
      body: body.toJson(),
    ));
  }

  /// Sanitizes one or more JQL queries by converting readable details into IDs
  /// where a user doesn't have permission to view the entity.
  ///
  /// For example, if the query contains the clause *project = 'Secret
  /// project'*, and a user does not have browse permission for the project
  /// "Secret project", the sanitized query replaces the clause with *project =
  /// 12345"* (where 12345 is the ID of the project). If a user has the required
  /// permission, the clause is not sanitized. If the account ID is null,
  /// sanitizing is performed for an anonymous user.
  ///
  /// Note that sanitization doesn't make the queries GDPR-compliant, because it
  /// doesn't remove user identifiers (username or user key). If you need to
  /// make queries GDPR-compliant, use
  /// [Convert user identifiers to account IDs in JQL queries](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-jql/#api-rest-api-3-jql-sanitize-post).
  ///
  /// Before sanitization each JQL query is parsed. The queries are returned in
  /// the same order that they were passed.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<SanitizedJqlQueries> sanitiseJqlQueries(
      {required JqlQueriesToSanitize body}) async {
    return SanitizedJqlQueries.fromJson(await _client.send(
      'post',
      'rest/api/3/jql/sanitize',
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class JQLFunctionsAppsApi {
  final ApiClient _client;

  JQLFunctionsAppsApi(this._client);

  /// Returns the list of a function's precomputations along with information
  /// about when they were created, updated, and last used. Each precomputation
  /// has a `value` - the JQL fragment to replace the custom function clause
  /// with.
  ///
  /// **[Permissions](#permissions) required:** This API is only accessible to
  /// apps and apps can only inspect their own functions.
  Future<PageBeanJqlFunctionPrecomputationBean> getPrecomputations(
      {List<String>? functionKey,
      int? startAt,
      int? maxResults,
      String? orderBy,
      String? filter}) async {
    return PageBeanJqlFunctionPrecomputationBean.fromJson(await _client.send(
      'get',
      'rest/api/3/jql/function/computation',
      queryParameters: {
        if (functionKey != null)
          'functionKey': functionKey.map((e) => e).join(','),
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (orderBy != null) 'orderBy': orderBy,
        if (filter != null) 'filter': filter,
      },
    ));
  }

  /// Update the precomputation value of a function created by a Forge/Connect
  /// app.
  ///
  /// **[Permissions](#permissions) required:** An API for apps to update their
  /// own precomputations.
  Future<dynamic> updatePrecomputations(
      {required JqlFunctionPrecomputationUpdateRequestBean body}) async {
    return await _client.send(
      'post',
      'rest/api/3/jql/function/computation',
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class JiraExpressionsApi {
  final ApiClient _client;

  JiraExpressionsApi(this._client);

  /// Analyses and validates Jira expressions.
  ///
  /// As an experimental feature, this operation can also attempt to type-check
  /// the expressions.
  ///
  /// Learn more about Jira expressions in the
  /// [documentation](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/).
  ///
  /// **[Permissions](#permissions) required**: None.
  Future<JiraExpressionsAnalysis> analyseExpression(
      {String? check, required JiraExpressionForAnalysis body}) async {
    return JiraExpressionsAnalysis.fromJson(await _client.send(
      'post',
      'rest/api/3/expression/analyse',
      queryParameters: {
        if (check != null) 'check': check,
      },
      body: body.toJson(),
    ));
  }

  /// Evaluates a Jira expression and returns its value.
  ///
  /// This resource can be used to test Jira expressions that you plan to use
  /// elsewhere, or to fetch data in a flexible way. Consult the
  /// [Jira expressions documentation](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/)
  /// for more details.
  ///
  /// #### Context variables ####
  ///
  /// The following context variables are available to Jira expressions
  /// evaluated by this resource. Their presence depends on various factors;
  /// usually you need to manually request them in the context object sent in
  /// the payload, but some of them are added automatically under certain
  /// conditions.
  ///
  ///  *  `user`
  /// ([User](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user)):
  /// The current user. Always available and equal to `null` if the request is
  /// anonymous.
  ///  *  `app`
  /// ([App](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#app)):
  /// The
  /// [Connect app](https://developer.atlassian.com/cloud/jira/platform/index/#connect-apps)
  /// that made the request. Available only for authenticated requests made by
  /// Connect Apps (read more here:
  /// [Authentication for Connect apps](https://developer.atlassian.com/cloud/jira/platform/security-for-connect-apps/)).
  ///  *  `issue`
  /// ([Issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue)):
  /// The current issue. Available only when the issue is provided in the
  /// request context object.
  ///  *  `issues`
  /// ([List](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#list)
  /// of
  /// [Issues](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue)):
  /// A collection of issues matching a JQL query. Available only when JQL is
  /// provided in the request context object.
  ///  *  `project`
  /// ([Project](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#project)):
  /// The current project. Available only when the project is provided in the
  /// request context object.
  ///  *  `sprint`
  /// ([Sprint](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#sprint)):
  /// The current sprint. Available only when the sprint is provided in the
  /// request context object.
  ///  *  `board`
  /// ([Board](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#board)):
  /// The current board. Available only when the board is provided in the
  /// request context object.
  ///  *  `serviceDesk`
  /// ([ServiceDesk](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#servicedesk)):
  /// The current service desk. Available only when the service desk is provided
  /// in the request context object.
  ///  *  `customerRequest`
  /// ([CustomerRequest](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#customerrequest)):
  /// The current customer request. Available only when the customer request is
  /// provided in the request context object.
  ///
  /// Also, custom context variables can be passed in the request with their
  /// types. Those variables can be accessed by key in the Jira expression.
  /// These variable types are available for use in a custom context:
  ///
  ///  *  `user`: A
  /// [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user)
  /// specified as an Atlassian account ID.
  ///  *  `issue`: An
  /// [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue)
  /// specified by ID or key. All the fields of the issue object are available
  /// in the Jira expression.
  ///  *  `json`: A JSON object containing custom content.
  ///  *  `list`: A JSON list of `user`, `issue`, or `json` variable types.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required**: None. However, an expression may
  /// return different results for different users depending on their
  /// permissions. For example, different users may see different comments on
  /// the same issue.
  /// Permission to access Jira Software is required to access Jira Software
  /// context variables (`board` and `sprint`) or fields (for example,
  /// `issue.sprint`).
  Future<JiraExpressionResult> evaluateJiraExpression(
      {String? expand, required JiraExpressionEvalRequestBean body}) async {
    return JiraExpressionResult.fromJson(await _client.send(
      'post',
      'rest/api/3/expression/eval',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class JiraSettingsApi {
  final ApiClient _client;

  JiraSettingsApi(this._client);

  /// Returns all application properties or an application property.
  ///
  /// If you specify a value for the `key` parameter, then an application
  /// property is returned as an object (not in an array). Otherwise, an array
  /// of all editable application properties is returned. See
  /// [Set application property](#api-rest-api-3-application-properties-id-put)
  /// for descriptions of editable properties.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<ApplicationProperty>> getApplicationProperty(
      {String? key, String? permissionLevel, String? keyFilter}) async {
    return (await _client.send(
      'get',
      'rest/api/3/application-properties',
      queryParameters: {
        if (key != null) 'key': key,
        if (permissionLevel != null) 'permissionLevel': permissionLevel,
        if (keyFilter != null) 'keyFilter': keyFilter,
      },
    ) as List<Object?>)
        .map((i) => ApplicationProperty.fromJson(
            i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns the application properties that are accessible on the *Advanced
  /// Settings* page. To navigate to the *Advanced Settings* page in Jira,
  /// choose the Jira icon > **Jira settings** > **System**, **General
  /// Configuration** and then click **Advanced Settings** (in the upper right).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<ApplicationProperty>> getAdvancedSettings() async {
    return (await _client.send(
      'get',
      'rest/api/3/application-properties/advanced-settings',
    ) as List<Object?>)
        .map((i) => ApplicationProperty.fromJson(
            i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Changes the value of an application property. For example, you can change
  /// the value of the `jira.clone.prefix` from its default value of *CLONE -*
  /// to *Clone -* if you prefer sentence case capitalization. Editable
  /// properties are described below along with their default values.
  ///
  /// #### Advanced settings ####
  ///
  /// The advanced settings below are also accessible in
  /// [Jira](https://confluence.atlassian.com/x/vYXKM).
  ///
  /// | Key | Description | Default value |
  /// | -- | -- | -- |
  /// | `jira.clone.prefix` | The string of text prefixed to the title of a
  /// cloned issue. | `CLONE -` |
  /// | `jira.date.picker.java.format` | The date format for the Java
  /// (server-side) generated dates. This must be the same as the
  /// `jira.date.picker.javascript.format` format setting. | `d/MMM/yy` |
  /// | `jira.date.picker.javascript.format` | The date format for the
  /// JavaScript (client-side) generated dates. This must be the same as the
  /// `jira.date.picker.java.format` format setting. | `%e/%b/%y` |
  /// | `jira.date.time.picker.java.format` | The date format for the Java
  /// (server-side) generated date times. This must be the same as the
  /// `jira.date.time.picker.javascript.format` format setting. | `dd/MMM/yy
  /// h:mm a` |
  /// | `jira.date.time.picker.javascript.format` | The date format for the
  /// JavaScript (client-side) generated date times. This must be the same as
  /// the `jira.date.time.picker.java.format` format setting. | `%e/%b/%y %I:%M
  /// %p` |
  /// | `jira.issue.actions.order` | The default order of actions (such as
  /// *Comments* or *Change history*) displayed on the issue view. | `asc` |
  /// | `jira.table.cols.subtasks` | The columns to show while viewing subtask
  /// issues in a table. For example, a list of subtasks on an issue. |
  /// `issuetype, status, assignee, progress` |
  /// | `jira.view.issue.links.sort.order` | The sort order of the list of issue
  /// links on the issue view. | `type, status, priority` |
  /// | `jira.comment.collapsing.minimum.hidden` | The minimum number of
  /// comments required for comment collapsing to occur. A value of `0` disables
  /// comment collapsing. | `4` |
  /// | `jira.newsletter.tip.delay.days` | The number of days before a prompt to
  /// sign up to the Jira Insiders newsletter is shown. A value of `-1` disables
  /// this feature. | `7` |
  ///
  ///
  /// #### Look and feel ####
  ///
  /// The settings listed below adjust the
  /// [look and feel](https://confluence.atlassian.com/x/VwCLLg).
  ///
  /// | Key | Description | Default value |
  /// | -- | -- | -- |
  /// | `jira.lf.date.time` | The
  /// [ time format](https://docs.oracle.com/javase/6/docs/api/index.html?java/text/SimpleDateFormat.html).
  /// | `h:mm a` |
  /// | `jira.lf.date.day` | The
  /// [ day format](https://docs.oracle.com/javase/6/docs/api/index.html?java/text/SimpleDateFormat.html).
  /// | `EEEE h:mm a` |
  /// | `jira.lf.date.complete` | The
  /// [ date and time format](https://docs.oracle.com/javase/6/docs/api/index.html?java/text/SimpleDateFormat.html).
  /// | `dd/MMM/yy h:mm a` |
  /// | `jira.lf.date.dmy` | The
  /// [ date format](https://docs.oracle.com/javase/6/docs/api/index.html?java/text/SimpleDateFormat.html).
  /// | `dd/MMM/yy` |
  /// | `jira.date.time.picker.use.iso8061` | When enabled, sets Monday as the
  /// first day of the week in the date picker, as specified by the ISO8601
  /// standard. | `false` |
  /// | `jira.lf.logo.url` | The URL of the logo image file. |
  /// `/images/icon-jira-logo.png` |
  /// | `jira.lf.logo.show.application.title` | Controls the visibility of the
  /// application title on the sidebar. | `false` |
  /// | `jira.lf.favicon.url` | The URL of the favicon. | `/favicon.ico` |
  /// | `jira.lf.favicon.hires.url` | The URL of the high-resolution favicon. |
  /// `/images/64jira.png` |
  /// | `jira.lf.navigation.bgcolour` | The background color of the sidebar. |
  /// `#0747A6` |
  /// | `jira.lf.navigation.highlightcolour` | The color of the text and logo of
  /// the sidebar. | `#DEEBFF` |
  /// | `jira.lf.hero.button.base.bg.colour` | The background color of the hero
  /// button. | `#3b7fc4` |
  /// | `jira.title` | The text for the application title. The application title
  /// can also be set in *General settings*. | `Jira` |
  /// | `jira.option.globalsharing` | Whether filters and dashboards can be
  /// shared with anyone signed into Jira. | `true` |
  /// | `xflow.product.suggestions.enabled` | Whether to expose product
  /// suggestions for other Atlassian products within Jira. | `true` |
  ///
  ///
  /// #### Other settings ####
  ///
  /// | Key | Description | Default value |
  /// | -- | -- | -- |
  /// | `jira.issuenav.criteria.autoupdate` | Whether instant updates to search
  /// criteria is active. | `true` |
  ///
  ///
  /// *Note: Be careful when changing
  /// [application properties and advanced settings](https://confluence.atlassian.com/x/vYXKM).*
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ApplicationProperty> setApplicationProperty(
      {required String id, required SimpleApplicationPropertyBean body}) async {
    return ApplicationProperty.fromJson(await _client.send(
      'put',
      'rest/api/3/application-properties/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }

  /// Returns the [global settings](https://confluence.atlassian.com/x/qYXKM) in
  /// Jira. These settings determine whether optional features (for example,
  /// subtasks, time tracking, and others) are enabled. If time tracking is
  /// enabled, this operation also returns the time tracking configuration.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<Configuration> getConfiguration() async {
    return Configuration.fromJson(await _client.send(
      'get',
      'rest/api/3/configuration',
    ));
  }
}

/// Jira Cloud platform REST API documentation

class LabelsApi {
  final ApiClient _client;

  LabelsApi(this._client);

  /// Returns a [paginated](#pagination) list of labels.
  Future<PageBeanString> getAllLabels({int? startAt, int? maxResults}) async {
    return PageBeanString.fromJson(await _client.send(
      'get',
      'rest/api/3/label',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class LicenseMetricsApi {
  final ApiClient _client;

  LicenseMetricsApi(this._client);

  /// Returns the total approximate user account across all jira licenced
  /// application keys. Please note this information is cached with a 7-day
  /// lifecycle and could be stale at the time of call.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<LicenseMetric> getApproximateLicenseCount() async {
    return LicenseMetric.fromJson(await _client.send(
      'get',
      'rest/api/3/license/approximateLicenseCount',
    ));
  }

  /// Returns the total approximate user account for a specific `jira licence
  /// application key`. Please note this information is cached with a 7-day
  /// lifecycle and could be stale at the time of call.
  ///
  /// #### Application Key ####
  ///
  /// An application key represents a specific version of Jira. See {@link
  /// ApplicationKey} for details
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<LicenseMetric> getApproximateApplicationLicenseCount(
      String applicationKey) async {
    return LicenseMetric.fromJson(await _client.send(
      'get',
      'rest/api/3/license/approximateLicenseCount/product/{applicationKey}',
      pathParameters: {
        'applicationKey': applicationKey,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class MyselfApi {
  final ApiClient _client;

  MyselfApi(this._client);

  /// Returns the value of a preference of the current user.
  ///
  /// Note that these keys are deprecated:
  ///
  ///  *  *jira.user.locale* The locale of the user. By default this is not set
  /// and the user takes the locale of the instance.
  ///  *  *jira.user.timezone* The time zone of the user. By default this is not
  /// set and the user takes the timezone of the instance.
  ///
  /// Use
  /// [ Update a user profile](https://developer.atlassian.com/cloud/admin/user-management/rest/#api-users-account-id-manage-profile-patch)
  /// from the user management REST API to manage timezone and locale instead.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<String> getPreference(String key) async {
    return await _client.send(
      'get',
      'rest/api/3/mypreferences',
      queryParameters: {
        'key': key,
      },
    ) as String;
  }

  /// Creates a preference for the user or updates a preference's value by
  /// sending a plain text string. For example, `false`. An arbitrary preference
  /// can be created with the value containing up to 255 characters. In
  /// addition, the following keys define system preferences that can be set or
  /// created:
  ///
  ///  *  *user.notifications.mimetype* The mime type used in notifications sent
  /// to the user. Defaults to `html`.
  ///  *  *user.notify.own.changes* Whether the user gets notified of their own
  /// changes. Defaults to `false`.
  ///  *  *user.default.share.private* Whether new
  /// [ filters](https://confluence.atlassian.com/x/eQiiLQ) are set to private.
  /// Defaults to `true`.
  ///  *  *user.keyboard.shortcuts.disabled* Whether keyboard shortcuts are
  /// disabled. Defaults to `false`.
  ///  *  *user.autowatch.disabled* Whether the user automatically watches
  /// issues they create or add a comment to. By default, not set: the user
  /// takes the instance autowatch setting.
  ///
  /// Note that these keys are deprecated:
  ///
  ///  *  *jira.user.locale* The locale of the user. By default, not set. The
  /// user takes the instance locale.
  ///  *  *jira.user.timezone* The time zone of the user. By default, not set.
  /// The user takes the instance timezone.
  ///
  /// Use
  /// [ Update a user profile](https://developer.atlassian.com/cloud/admin/user-management/rest/#api-users-account-id-manage-profile-patch)
  /// from the user management REST API to manage timezone and locale instead.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<dynamic> setPreference(
      {required String key, required String body}) async {
    return await _client.send(
      'put',
      'rest/api/3/mypreferences',
      queryParameters: {
        'key': key,
      },
      body: body,
    );
  }

  /// Deletes a preference of the user, which restores the default value of
  /// system defined settings.
  ///
  /// Note that these keys are deprecated:
  ///
  ///  *  *jira.user.locale* The locale of the user. By default, not set. The
  /// user takes the instance locale.
  ///  *  *jira.user.timezone* The time zone of the user. By default, not set.
  /// The user takes the instance timezone.
  ///
  /// Use
  /// [ Update a user profile](https://developer.atlassian.com/cloud/admin/user-management/rest/#api-users-account-id-manage-profile-patch)
  /// from the user management REST API to manage timezone and locale instead.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<void> removePreference(String key) async {
    await _client.send(
      'delete',
      'rest/api/3/mypreferences',
      queryParameters: {
        'key': key,
      },
    );
  }

  /// Returns the locale for the user.
  ///
  /// If the user has no language preference set (which is the default setting)
  /// or this resource is accessed anonymous, the browser locale detected by
  /// Jira is returned. Jira detects the browser locale using the
  /// *Accept-Language* header in the request. However, if this doesn't match a
  /// locale available Jira, the site default locale is returned.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<Locale> getLocale() async {
    return Locale.fromJson(await _client.send(
      'get',
      'rest/api/3/mypreferences/locale',
    ));
  }

  /// Deprecated, use
  /// [ Update a user profile](https://developer.atlassian.com/cloud/admin/user-management/rest/#api-users-account-id-manage-profile-patch)
  /// from the user management REST API instead.
  ///
  /// Sets the locale of the user. The locale must be one supported by the
  /// instance of Jira.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<dynamic> setLocale({required Locale body}) async {
    return await _client.send(
      'put',
      'rest/api/3/mypreferences/locale',
      body: body.toJson(),
    );
  }

  /// Deprecated, use
  /// [ Update a user profile](https://developer.atlassian.com/cloud/admin/user-management/rest/#api-users-account-id-manage-profile-patch)
  /// from the user management REST API instead.
  ///
  /// Deletes the locale of the user, which restores the default setting.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<dynamic> deleteLocale() async {
    return await _client.send(
      'delete',
      'rest/api/3/mypreferences/locale',
    );
  }

  /// Returns details for the current user.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<User> getCurrentUser({String? expand}) async {
    return User.fromJson(await _client.send(
      'get',
      'rest/api/3/myself',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class PermissionSchemesApi {
  final ApiClient _client;

  PermissionSchemesApi(this._client);

  /// Returns all permission schemes.
  ///
  /// ### About permission schemes and grants ###
  ///
  /// A permission scheme is a collection of permission grants. A permission
  /// grant consists of a `holder` and a `permission`.
  ///
  /// #### Holder object ####
  ///
  /// The `holder` object contains information about the user or group being
  /// granted the permission. For example, the *Administer projects* permission
  /// is granted to a group named *Teams in space administrators*. In this case,
  /// the type is `"type": "group"`, and the parameter is the group name,
  /// `"parameter": "Teams in space administrators"` and the value is group ID,
  /// `"value": "ca85fac0-d974-40ca-a615-7af99c48d24f"`. The `holder` object is
  /// defined by the following properties:
  ///
  ///  *  `type` Identifies the user or group (see the list of types below).
  ///  *  `parameter` As a group's name can change, use of `value` is
  /// recommended. The value of this property depends on the `type`. For
  /// example, if the `type` is a group, then you need to specify the group
  /// name.
  ///  *  `value` The value of this property depends on the `type`. If the
  /// `type` is a group, then you need to specify the group ID. For other `type`
  /// it has the same value as `parameter`
  ///
  /// The following `types` are available. The expected values for `parameter`
  /// and `value` are given in parentheses (some types may not have a
  /// `parameter` or `value`):
  ///
  ///  *  `anyone` Grant for anonymous users.
  ///  *  `applicationRole` Grant for users with access to the specified
  /// application (application name, application name). See
  /// [Update product access settings](https://confluence.atlassian.com/x/3YxjL)
  /// for more information.
  ///  *  `assignee` Grant for the user currently assigned to an issue.
  ///  *  `group` Grant for the specified group (`parameter` : group name,
  /// `value` : group ID).
  ///  *  `groupCustomField` Grant for a user in the group selected in the
  /// specified custom field (`parameter` : custom field ID, `value` : custom
  /// field ID).
  ///  *  `projectLead` Grant for a project lead.
  ///  *  `projectRole` Grant for the specified project role (`parameter`
  /// :project role ID, `value` : project role ID).
  ///  *  `reporter` Grant for the user who reported the issue.
  ///  *  `sd.customer.portal.only` Jira Service Desk only. Grants customers
  /// permission to access the customer portal but not Jira. See
  /// [Customizing Jira Service Desk permissions](https://confluence.atlassian.com/x/24dKLg)
  /// for more information.
  ///  *  `user` Grant for the specified user (`parameter` : user ID -
  /// historically this was the userkey but that is deprecated and the account
  /// ID should be used, `value` : user ID).
  ///  *  `userCustomField` Grant for a user selected in the specified custom
  /// field (`parameter` : custom field ID, `value` : custom field ID).
  ///
  /// #### Built-in permissions ####
  ///
  /// The [built-in Jira permissions](https://confluence.atlassian.com/x/yodKLg)
  /// are listed below. Apps can also define custom permissions. See the
  /// [project permission](https://developer.atlassian.com/cloud/jira/platform/modules/project-permission/)
  /// and
  /// [global permission](https://developer.atlassian.com/cloud/jira/platform/modules/global-permission/)
  /// module documentation for more information.
  ///
  /// **Project permissions**
  ///
  ///  *  `ADMINISTER_PROJECTS`
  ///  *  `BROWSE_PROJECTS`
  ///  *  `MANAGE_SPRINTS_PERMISSION` (Jira Software only)
  ///  *  `SERVICEDESK_AGENT` (Jira Service Desk only)
  ///  *  `VIEW_DEV_TOOLS` (Jira Software only)
  ///  *  `VIEW_READONLY_WORKFLOW`
  ///
  /// **Issue permissions**
  ///
  ///  *  `ASSIGNABLE_USER`
  ///  *  `ASSIGN_ISSUES`
  ///  *  `CLOSE_ISSUES`
  ///  *  `CREATE_ISSUES`
  ///  *  `DELETE_ISSUES`
  ///  *  `EDIT_ISSUES`
  ///  *  `LINK_ISSUES`
  ///  *  `MODIFY_REPORTER`
  ///  *  `MOVE_ISSUES`
  ///  *  `RESOLVE_ISSUES`
  ///  *  `SCHEDULE_ISSUES`
  ///  *  `SET_ISSUE_SECURITY`
  ///  *  `TRANSITION_ISSUES`
  ///
  /// **Voters and watchers permissions**
  ///
  ///  *  `MANAGE_WATCHERS`
  ///  *  `VIEW_VOTERS_AND_WATCHERS`
  ///
  /// **Comments permissions**
  ///
  ///  *  `ADD_COMMENTS`
  ///  *  `DELETE_ALL_COMMENTS`
  ///  *  `DELETE_OWN_COMMENTS`
  ///  *  `EDIT_ALL_COMMENTS`
  ///  *  `EDIT_OWN_COMMENTS`
  ///
  /// **Attachments permissions**
  ///
  ///  *  `CREATE_ATTACHMENTS`
  ///  *  `DELETE_ALL_ATTACHMENTS`
  ///  *  `DELETE_OWN_ATTACHMENTS`
  ///
  /// **Time tracking permissions**
  ///
  ///  *  `DELETE_ALL_WORKLOGS`
  ///  *  `DELETE_OWN_WORKLOGS`
  ///  *  `EDIT_ALL_WORKLOGS`
  ///  *  `EDIT_OWN_WORKLOGS`
  ///  *  `WORK_ON_ISSUES`
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PermissionSchemes> getAllPermissionSchemes({String? expand}) async {
    return PermissionSchemes.fromJson(await _client.send(
      'get',
      'rest/api/3/permissionscheme',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Creates a new permission scheme. You can create a permission scheme with
  /// or without defining a set of permission grants.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PermissionScheme> createPermissionScheme(
      {String? expand, required PermissionScheme body}) async {
    return PermissionScheme.fromJson(await _client.send(
      'post',
      'rest/api/3/permissionscheme',
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Returns a permission scheme.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PermissionScheme> getPermissionScheme(
      {required int schemeId, String? expand}) async {
    return PermissionScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/permissionscheme/{schemeId}',
      pathParameters: {
        'schemeId': '$schemeId',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates a permission scheme. Below are some important things to note when
  /// using this resource:
  ///
  ///  *  If a permissions list is present in the request, then it is set in the
  /// permission scheme, overwriting *all existing* grants.
  ///  *  If you want to update only the name and description, then do not send
  /// a permissions list in the request.
  ///  *  Sending an empty list will remove all permission grants from the
  /// permission scheme.
  ///
  /// If you want to add or delete a permission grant instead of updating the
  /// whole list, see
  /// [Create permission grant](#api-rest-api-3-permissionscheme-schemeId-permission-post)
  /// or
  /// [Delete permission scheme entity](#api-rest-api-3-permissionscheme-schemeId-permission-permissionId-delete).
  ///
  /// See
  /// [About permission schemes and grants](../api-group-permission-schemes/#about-permission-schemes-and-grants)
  /// for more details.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PermissionScheme> updatePermissionScheme(
      {required int schemeId,
      String? expand,
      required PermissionScheme body}) async {
    return PermissionScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/permissionscheme/{schemeId}',
      pathParameters: {
        'schemeId': '$schemeId',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a permission scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deletePermissionScheme(int schemeId) async {
    await _client.send(
      'delete',
      'rest/api/3/permissionscheme/{schemeId}',
      pathParameters: {
        'schemeId': '$schemeId',
      },
    );
  }

  /// Returns all permission grants for a permission scheme.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PermissionGrants> getPermissionSchemeGrants(
      {required int schemeId, String? expand}) async {
    return PermissionGrants.fromJson(await _client.send(
      'get',
      'rest/api/3/permissionscheme/{schemeId}/permission',
      pathParameters: {
        'schemeId': '$schemeId',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Creates a permission grant in a permission scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PermissionGrant> createPermissionGrant(
      {required int schemeId,
      String? expand,
      required PermissionGrant body}) async {
    return PermissionGrant.fromJson(await _client.send(
      'post',
      'rest/api/3/permissionscheme/{schemeId}/permission',
      pathParameters: {
        'schemeId': '$schemeId',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Returns a permission grant.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PermissionGrant> getPermissionSchemeGrant(
      {required int schemeId,
      required int permissionId,
      String? expand}) async {
    return PermissionGrant.fromJson(await _client.send(
      'get',
      'rest/api/3/permissionscheme/{schemeId}/permission/{permissionId}',
      pathParameters: {
        'schemeId': '$schemeId',
        'permissionId': '$permissionId',
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Deletes a permission grant from a permission scheme. See
  /// [About permission schemes and grants](../api-group-permission-schemes/#about-permission-schemes-and-grants)
  /// for more details.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deletePermissionSchemeEntity(
      {required int schemeId, required int permissionId}) async {
    await _client.send(
      'delete',
      'rest/api/3/permissionscheme/{schemeId}/permission/{permissionId}',
      pathParameters: {
        'schemeId': '$schemeId',
        'permissionId': '$permissionId',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class PermissionsApi {
  final ApiClient _client;

  PermissionsApi(this._client);

  /// Returns a list of permissions indicating which permissions the user has.
  /// Details of the user's permissions can be obtained in a global, project,
  /// issue or comment context.
  ///
  /// The user is reported as having a project permission:
  ///
  ///  *  in the global context, if the user has the project permission in any
  /// project.
  ///  *  for a project, where the project permission is determined using issue
  /// data, if the user meets the permission's criteria for any issue in the
  /// project. Otherwise, if the user has the project permission in the project.
  ///  *  for an issue, where a project permission is determined using issue
  /// data, if the user has the permission in the issue. Otherwise, if the user
  /// has the project permission in the project containing the issue.
  ///  *  for a comment, where the user has both the permission to browse the
  /// comment and the project permission for the comment's parent issue. Only
  /// the BROWSE_PROJECTS permission is supported. If a `commentId` is provided
  /// whose `permissions` does not equal BROWSE_PROJECTS, a 400 error will be
  /// returned.
  ///
  /// This means that users may be shown as having an issue permission (such as
  /// EDIT_ISSUES) in the global context or a project context but may not have
  /// the permission for any or all issues. For example, if Reporters have the
  /// EDIT_ISSUES permission a user would be shown as having this permission in
  /// the global context or the context of a project, because any user can be a
  /// reporter. However, if they are not the user who reported the issue queried
  /// they would not have EDIT_ISSUES permission for that issue.
  ///
  /// Global permissions are unaffected by context.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<Permissions> getMyPermissions(
      {String? projectKey,
      String? projectId,
      String? issueKey,
      String? issueId,
      String? permissions,
      String? projectUuid,
      String? projectConfigurationUuid,
      String? commentId}) async {
    return Permissions.fromJson(await _client.send(
      'get',
      'rest/api/3/mypermissions',
      queryParameters: {
        if (projectKey != null) 'projectKey': projectKey,
        if (projectId != null) 'projectId': projectId,
        if (issueKey != null) 'issueKey': issueKey,
        if (issueId != null) 'issueId': issueId,
        if (permissions != null) 'permissions': permissions,
        if (projectUuid != null) 'projectUuid': projectUuid,
        if (projectConfigurationUuid != null)
          'projectConfigurationUuid': projectConfigurationUuid,
        if (commentId != null) 'commentId': commentId,
      },
    ));
  }

  /// Returns all permissions, including:
  ///
  ///  *  global permissions.
  ///  *  project permissions.
  ///  *  global permissions added by plugins.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Permissions> getAllPermissions() async {
    return Permissions.fromJson(await _client.send(
      'get',
      'rest/api/3/permissions',
    ));
  }

  /// Returns:
  ///
  ///  *  for a list of global permissions, the global permissions granted to a
  /// user.
  ///  *  for a list of project permissions and lists of projects and issues,
  /// for each project permission a list of the projects and issues a user can
  /// access or manipulate.
  ///
  /// If no account ID is provided, the operation returns details for the logged
  /// in user.
  ///
  /// Note that:
  ///
  ///  *  Invalid project and issue IDs are ignored.
  ///  *  A maximum of 1000 projects and 1000 issues can be checked.
  ///  *  Null values in `globalPermissions`, `projectPermissions`,
  /// `projectPermissions.projects`, and `projectPermissions.issues` are
  /// ignored.
  ///  *  Empty strings in `projectPermissions.permissions` are ignored.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) to check
  /// the permissions for other users, otherwise none. However, Connect apps can
  /// make a call from the app server to the product to obtain permission
  /// details for any user, without admin permission. This Connect app ability
  /// doesn't apply to calls made using AP.request() in a browser.
  Future<BulkPermissionGrants> getBulkPermissions(
      {required BulkPermissionsRequestBean body}) async {
    return BulkPermissionGrants.fromJson(await _client.send(
      'post',
      'rest/api/3/permissions/check',
      body: body.toJson(),
    ));
  }

  /// Returns all the projects where the user is granted a list of project
  /// permissions.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<PermittedProjects> getPermittedProjects(
      {required PermissionsKeysBean body}) async {
    return PermittedProjects.fromJson(await _client.send(
      'post',
      'rest/api/3/permissions/project',
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ProjectAvatarsApi {
  final ApiClient _client;

  ProjectAvatarsApi(this._client);

  /// Sets the avatar displayed for a project.
  ///
  /// Use
  /// [Load project avatar](#api-rest-api-3-project-projectIdOrKey-avatar2-post)
  /// to store avatars against the project, before using this operation to set
  /// the displayed avatar.
  ///
  /// **[Permissions](#permissions) required:** *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg).
  Future<dynamic> updateProjectAvatar(
      {required String projectIdOrKey, required Avatar body}) async {
    return await _client.send(
      'put',
      'rest/api/3/project/{projectIdOrKey}/avatar',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      body: body.toJson(),
    );
  }

  /// Deletes a custom avatar from a project. Note that system avatars cannot be
  /// deleted.
  ///
  /// **[Permissions](#permissions) required:** *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg).
  Future<void> deleteProjectAvatar(
      {required String projectIdOrKey, required int id}) async {
    await _client.send(
      'delete',
      'rest/api/3/project/{projectIdOrKey}/avatar/{id}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'id': '$id',
      },
    );
  }

  /// Loads an avatar for a project.
  ///
  /// Specify the avatar's local file location in the body of the request. Also,
  /// include the following headers:
  ///
  ///  *  `X-Atlassian-Token: no-check` To prevent XSRF protection blocking the
  /// request, for more information see
  /// [Special Headers](#special-request-headers).
  ///  *  `Content-Type: image/image type` Valid image types are JPEG, GIF, or
  /// PNG.
  ///
  /// For example:
  /// `curl --request POST `
  ///
  /// `--user email@example.com:<api_token> `
  ///
  /// `--header 'X-Atlassian-Token: no-check' `
  ///
  /// `--header 'Content-Type: image/< image_type>' `
  ///
  /// `--data-binary "<@/path/to/file/with/your/avatar>" `
  ///
  /// `--url
  /// 'https://your-domain.atlassian.net/rest/api/3/project/{projectIdOrKey}/avatar2'`
  ///
  /// The avatar is cropped to a square. If no crop parameters are specified,
  /// the square originates at the top left of the image. The length of the
  /// square's sides is set to the smaller of the height or width of the image.
  ///
  /// The cropped image is then used to create avatars of 16x16, 24x24, 32x32,
  /// and 48x48 in size.
  ///
  /// After creating the avatar use
  /// [Set project avatar](#api-rest-api-3-project-projectIdOrKey-avatar-put) to
  /// set it as the project's displayed avatar.
  ///
  /// **[Permissions](#permissions) required:** *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg).
  Future<Avatar> createProjectAvatar(
      {required String projectIdOrKey,
      int? x,
      int? y,
      int? size,
      required dynamic body}) async {
    return Avatar.fromJson(await _client.send(
      'post',
      'rest/api/3/project/{projectIdOrKey}/avatar2',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (x != null) 'x': '$x',
        if (y != null) 'y': '$y',
        if (size != null) 'size': '$size',
      },
      body: body,
    ));
  }

  /// Returns all project avatars, grouped by system and custom avatars.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<ProjectAvatars> getAllProjectAvatars(String projectIdOrKey) async {
    return ProjectAvatars.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/avatars',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ProjectCategoriesApi {
  final ApiClient _client;

  ProjectCategoriesApi(this._client);

  /// Returns all project categories.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<List<ProjectCategory>> getAllProjectCategories() async {
    return (await _client.send(
      'get',
      'rest/api/3/projectCategory',
    ) as List<Object?>)
        .map((i) =>
            ProjectCategory.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a project category.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectCategory> createProjectCategory(
      {required ProjectCategory body}) async {
    return ProjectCategory.fromJson(await _client.send(
      'post',
      'rest/api/3/projectCategory',
      body: body.toJson(),
    ));
  }

  /// Returns a project category.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<ProjectCategory> getProjectCategoryById(int id) async {
    return ProjectCategory.fromJson(await _client.send(
      'get',
      'rest/api/3/projectCategory/{id}',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Updates a project category.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<UpdatedProjectCategory> updateProjectCategory(
      {required int id, required ProjectCategory body}) async {
    return UpdatedProjectCategory.fromJson(await _client.send(
      'put',
      'rest/api/3/projectCategory/{id}',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a project category.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> removeProjectCategory(int id) async {
    await _client.send(
      'delete',
      'rest/api/3/projectCategory/{id}',
      pathParameters: {
        'id': '$id',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class ProjectComponentsApi {
  final ApiClient _client;

  ProjectComponentsApi(this._client);

  /// Creates a component. Use components to provide containers for issues
  /// within a project.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project in which the component is created or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectComponent> createComponent(
      {required ProjectComponent body}) async {
    return ProjectComponent.fromJson(await _client.send(
      'post',
      'rest/api/3/component',
      body: body.toJson(),
    ));
  }

  /// Returns a component.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for
  /// project containing the component.
  Future<ProjectComponent> getComponent(String id) async {
    return ProjectComponent.fromJson(await _client.send(
      'get',
      'rest/api/3/component/{id}',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Updates a component. Any fields included in the request are overwritten.
  /// If `leadAccountId` is an empty string ("") the component lead is removed.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the component or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectComponent> updateComponent(
      {required String id, required ProjectComponent body}) async {
    return ProjectComponent.fromJson(await _client.send(
      'put',
      'rest/api/3/component/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a component.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the component or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteComponent(
      {required String id, String? moveIssuesTo}) async {
    await _client.send(
      'delete',
      'rest/api/3/component/{id}',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        if (moveIssuesTo != null) 'moveIssuesTo': moveIssuesTo,
      },
    );
  }

  /// Returns the counts of issues assigned to the component.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<ComponentIssuesCount> getComponentRelatedIssues(String id) async {
    return ComponentIssuesCount.fromJson(await _client.send(
      'get',
      'rest/api/3/component/{id}/relatedIssueCounts',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of all components in a project.
  /// See the
  /// [Get project components](#api-rest-api-3-project-projectIdOrKey-components-get)
  /// resource if you want to get a full list of versions without pagination.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<PageBeanComponentWithIssueCount> getProjectComponentsPaginated(
      {required String projectIdOrKey,
      int? startAt,
      int? maxResults,
      String? orderBy,
      String? query}) async {
    return PageBeanComponentWithIssueCount.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/component',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (orderBy != null) 'orderBy': orderBy,
        if (query != null) 'query': query,
      },
    ));
  }

  /// Returns all components in a project. See the
  /// [Get project components paginated](#api-rest-api-3-project-projectIdOrKey-component-get)
  /// resource if you want to get a full list of components with pagination.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<List<ProjectComponent>> getProjectComponents(
      String projectIdOrKey) async {
    return (await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/components',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ) as List<Object?>)
        .map((i) =>
            ProjectComponent.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }
}

/// Jira Cloud platform REST API documentation

class ProjectEmailApi {
  final ApiClient _client;

  ProjectEmailApi(this._client);

  /// Returns the
  /// [project's sender email address](https://confluence.atlassian.com/x/dolKLg).
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<ProjectEmailAddress> getProjectEmail(int projectId) async {
    return ProjectEmailAddress.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectId}/email',
      pathParameters: {
        'projectId': '$projectId',
      },
    ));
  }

  /// Sets the
  /// [project's sender email address](https://confluence.atlassian.com/x/dolKLg).
  ///
  /// If `emailAddress` is an empty string, the default email address is
  /// restored.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<dynamic> updateProjectEmail(
      {required int projectId, required ProjectEmailAddress body}) async {
    return await _client.send(
      'put',
      'rest/api/3/project/{projectId}/email',
      pathParameters: {
        'projectId': '$projectId',
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class ProjectFeaturesApi {
  final ApiClient _client;

  ProjectFeaturesApi(this._client);

  /// Returns the list of features for a project.
  Future<ContainerForProjectFeatures> getFeaturesForProject(
      String projectIdOrKey) async {
    return ContainerForProjectFeatures.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/features',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ));
  }

  /// Sets the state of a project feature.
  Future<ContainerForProjectFeatures> toggleFeatureForProject(
      {required String projectIdOrKey,
      required String featureKey,
      required ProjectFeatureState body}) async {
    return ContainerForProjectFeatures.fromJson(await _client.send(
      'put',
      'rest/api/3/project/{projectIdOrKey}/features/{featureKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'featureKey': featureKey,
      },
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ProjectKeyAndNameValidationApi {
  final ApiClient _client;

  ProjectKeyAndNameValidationApi(this._client);

  /// Validates a project key by confirming the key is a valid string and not in
  /// use.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<ErrorCollection> validateProjectKey({String? key}) async {
    return ErrorCollection.fromJson(await _client.send(
      'get',
      'rest/api/3/projectvalidate/key',
      queryParameters: {
        if (key != null) 'key': key,
      },
    ));
  }

  /// Validates a project key and, if the key is invalid or in use, generates a
  /// valid random string for the project key.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<String> getValidProjectKey({String? key}) async {
    return await _client.send(
      'get',
      'rest/api/3/projectvalidate/validProjectKey',
      queryParameters: {
        if (key != null) 'key': key,
      },
    ) as String;
  }

  /// Checks that a project name isn't in use. If the name isn't in use, the
  /// passed string is returned. If the name is in use, this operation attempts
  /// to generate a valid project name based on the one supplied, usually by
  /// adding a sequence number. If a valid project name cannot be generated, a
  /// 404 response is returned.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<String> getValidProjectName(String name) async {
    return await _client.send(
      'get',
      'rest/api/3/projectvalidate/validProjectName',
      queryParameters: {
        'name': name,
      },
    ) as String;
  }
}

/// Jira Cloud platform REST API documentation

class ProjectPermissionSchemesApi {
  final ApiClient _client;

  ProjectPermissionSchemesApi(this._client);

  /// Returns the
  /// [issue security scheme](https://confluence.atlassian.com/x/J4lKLg)
  /// associated with the project.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or the
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg).
  Future<SecurityScheme> getProjectIssueSecurityScheme(
      String projectKeyOrId) async {
    return SecurityScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectKeyOrId}/issuesecuritylevelscheme',
      pathParameters: {
        'projectKeyOrId': projectKeyOrId,
      },
    ));
  }

  /// Gets the [permission scheme](https://confluence.atlassian.com/x/yodKLg)
  /// associated with the project.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg).
  Future<PermissionScheme> getAssignedPermissionScheme(
      {required String projectKeyOrId, String? expand}) async {
    return PermissionScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectKeyOrId}/permissionscheme',
      pathParameters: {
        'projectKeyOrId': projectKeyOrId,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Assigns a permission scheme with a project. See
  /// [Managing project permissions](https://confluence.atlassian.com/x/yodKLg)
  /// for more information about permission schemes.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg)
  Future<PermissionScheme> assignPermissionScheme(
      {required String projectKeyOrId,
      String? expand,
      required IdBean body}) async {
    return PermissionScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/project/{projectKeyOrId}/permissionscheme',
      pathParameters: {
        'projectKeyOrId': projectKeyOrId,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Returns all [issue security](https://confluence.atlassian.com/x/J4lKLg)
  /// levels for the project that the user has access to.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) for the
  /// project, however, issue security levels are only returned for
  /// authenticated user with *Set Issue Security*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) for the
  /// project.
  Future<ProjectIssueSecurityLevels> getSecurityLevelsForProject(
      String projectKeyOrId) async {
    return ProjectIssueSecurityLevels.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectKeyOrId}/securitylevel',
      pathParameters: {
        'projectKeyOrId': projectKeyOrId,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ProjectPropertiesApi {
  final ApiClient _client;

  ProjectPropertiesApi(this._client);

  /// Returns all
  /// [project property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties)
  /// keys for the project.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<PropertyKeys> getProjectPropertyKeys(String projectIdOrKey) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/properties',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ));
  }

  /// Returns the value of a
  /// [project property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the property.
  Future<EntityProperty> getProjectProperty(
      {required String projectIdOrKey, required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/properties/{propertyKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'propertyKey': propertyKey,
      },
    ));
  }

  /// Sets the value of the
  /// [project property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties).
  /// You can use project properties to store custom data against the project.
  ///
  /// The value of the request body must be a
  /// [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project in which the property is created.
  Future<dynamic> setProjectProperty(
      {required String projectIdOrKey,
      required String propertyKey,
      required dynamic body}) async {
    return await _client.send(
      'put',
      'rest/api/3/project/{projectIdOrKey}/properties/{propertyKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'propertyKey': propertyKey,
      },
      body: body,
    );
  }

  /// Deletes the
  /// [property](https://developer.atlassian.com/cloud/jira/platform/storing-data-without-a-database/#a-id-jira-entity-properties-a-jira-entity-properties)
  /// from a project.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the property.
  Future<void> deleteProjectProperty(
      {required String projectIdOrKey, required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/project/{projectIdOrKey}/properties/{propertyKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'propertyKey': propertyKey,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class ProjectRoleActorsApi {
  final ApiClient _client;

  ProjectRoleActorsApi(this._client);

  /// Sets the actors for a project role for a project, replacing all existing
  /// actors.
  ///
  /// To add actors to the project without overwriting the existing list, use
  /// [Add actors to project role](#api-rest-api-3-project-projectIdOrKey-role-id-post).
  ///
  /// **[Permissions](#permissions) required:** *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> setActors(
      {required String projectIdOrKey,
      required int id,
      required ProjectRoleActorsUpdateBean body}) async {
    return ProjectRole.fromJson(await _client.send(
      'put',
      'rest/api/3/project/{projectIdOrKey}/role/{id}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Adds actors to a project role for the project.
  ///
  /// To replace all actors for the project, use
  /// [Set actors for project role](#api-rest-api-3-project-projectIdOrKey-role-id-put).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> addActorUsers(
      {required String projectIdOrKey,
      required int id,
      required ActorsMap body}) async {
    return ProjectRole.fromJson(await _client.send(
      'post',
      'rest/api/3/project/{projectIdOrKey}/role/{id}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes actors from a project role for the project.
  ///
  /// To remove default actors from the project role, use
  /// [Delete default actors from project role](#api-rest-api-3-role-id-actors-delete).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteActor(
      {required String projectIdOrKey,
      required int id,
      String? user,
      String? group,
      String? groupId}) async {
    await _client.send(
      'delete',
      'rest/api/3/project/{projectIdOrKey}/role/{id}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'id': '$id',
      },
      queryParameters: {
        if (user != null) 'user': user,
        if (group != null) 'group': group,
        if (groupId != null) 'groupId': groupId,
      },
    );
  }

  /// Returns the [default actors](#api-rest-api-3-resolution-get) for the
  /// project role.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> getProjectRoleActorsForRole(int id) async {
    return ProjectRole.fromJson(await _client.send(
      'get',
      'rest/api/3/role/{id}/actors',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Adds [default actors](#api-rest-api-3-resolution-get) to a role. You may
  /// add groups or users, but you cannot add groups and users in the same
  /// request.
  ///
  /// Changing a project role's default actors does not affect project role
  /// members for projects already created.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> addProjectRoleActorsToRole(
      {required int id, required ActorInputBean body}) async {
    return ProjectRole.fromJson(await _client.send(
      'post',
      'rest/api/3/role/{id}/actors',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the [default actors](#api-rest-api-3-resolution-get) from a
  /// project role. You may delete a group or user, but you cannot delete a
  /// group and a user in the same request.
  ///
  /// Changing a project role's default actors does not affect project role
  /// members for projects already created.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> deleteProjectRoleActorsFromRole(
      {required int id, String? user, String? groupId, String? group}) async {
    return ProjectRole.fromJson(await _client.send(
      'delete',
      'rest/api/3/role/{id}/actors',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (user != null) 'user': user,
        if (groupId != null) 'groupId': groupId,
        if (group != null) 'group': group,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ProjectRolesApi {
  final ApiClient _client;

  ProjectRolesApi(this._client);

  /// Returns a list of
  /// [project roles](https://confluence.atlassian.com/x/3odKLg) for the project
  /// returning the name and self URL for each role.
  ///
  /// Note that all project roles are shared with all projects in Jira Cloud.
  /// See [Get all project roles](#api-rest-api-3-role-get) for more
  /// information.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for any
  /// project on the site or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Map<String, dynamic>> getProjectRoles(String projectIdOrKey) async {
    return await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/role',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ) as Map<String, Object?>;
  }

  /// Returns a project role's details and actors associated with the project.
  /// The list of actors is sorted by display name.
  ///
  /// To check whether a user belongs to a role based on their group
  /// memberships, use [Get user](#api-rest-api-3-user-get) with the `groups`
  /// expand parameter selected. Then check whether the user keys and groups
  /// match with the actors returned for the project.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project or *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> getProjectRole(
      {required String projectIdOrKey,
      required int id,
      bool? excludeInactiveUsers}) async {
    return ProjectRole.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/role/{id}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
        'id': '$id',
      },
      queryParameters: {
        if (excludeInactiveUsers != null)
          'excludeInactiveUsers': '$excludeInactiveUsers',
      },
    ));
  }

  /// Returns all [project roles](https://confluence.atlassian.com/x/3odKLg) and
  /// the details for each role. Note that the list of project roles is common
  /// to all projects.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<List<ProjectRoleDetails>> getProjectRoleDetails(
      {required String projectIdOrKey,
      bool? currentMember,
      bool? excludeConnectAddons}) async {
    return (await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/roledetails',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (currentMember != null) 'currentMember': '$currentMember',
        if (excludeConnectAddons != null)
          'excludeConnectAddons': '$excludeConnectAddons',
      },
    ) as List<Object?>)
        .map((i) =>
            ProjectRoleDetails.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Gets a list of all project roles, complete with project role details and
  /// default actors.
  ///
  /// ### About project roles ###
  ///
  /// [Project roles](https://confluence.atlassian.com/x/3odKLg) are a flexible
  /// way to to associate users and groups with projects. In Jira Cloud, the
  /// list of project roles is shared globally with all projects, but each
  /// project can have a different set of actors associated with it (unlike
  /// groups, which have the same membership throughout all Jira applications).
  ///
  /// Project roles are used in
  /// [permission schemes](#api-rest-api-3-permissionscheme-get),
  /// [email notification schemes](#api-rest-api-3-notificationscheme-get),
  /// [issue security levels](#api-rest-api-3-issuesecurityschemes-get),
  /// [comment visibility](#api-rest-api-3-comment-list-post), and workflow
  /// conditions.
  ///
  /// #### Members and actors ####
  ///
  /// In the Jira REST API, a member of a project role is called an *actor*. An
  /// *actor* is a group or user associated with a project role.
  ///
  /// Actors may be set as
  /// [default members](https://confluence.atlassian.com/x/3odKLg#Managingprojectroles-Specifying'defaultmembers'foraprojectrole)
  /// of the project role or set at the project level:
  ///
  ///  *  Default actors: Users and groups that are assigned to the project role
  /// for all newly created projects. The default actors can be removed at the
  /// project level later if desired.
  ///  *  Actors: Users and groups that are associated with a project role for a
  /// project, which may differ from the default actors. This enables you to
  /// assign a user to different roles in different projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<ProjectRole>> getAllProjectRoles() async {
    return (await _client.send(
      'get',
      'rest/api/3/role',
    ) as List<Object?>)
        .map(
            (i) => ProjectRole.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a new project role with no
  /// [default actors](#api-rest-api-3-resolution-get). You can use the
  /// [Add default actors to project role](#api-rest-api-3-role-id-actors-post)
  /// operation to add default actors to the project role after creating it.
  ///
  /// *Note that although a new project role is available to all projects upon
  /// creation, any default actors that are associated with the project role are
  /// not added to projects that existed prior to the role being created.*<
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> createProjectRole(
      {required CreateUpdateRoleRequestBean body}) async {
    return ProjectRole.fromJson(await _client.send(
      'post',
      'rest/api/3/role',
      body: body.toJson(),
    ));
  }

  /// Gets the project role details and the default actors associated with the
  /// role. The list of default actors is sorted by display name.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> getProjectRoleById(int id) async {
    return ProjectRole.fromJson(await _client.send(
      'get',
      'rest/api/3/role/{id}',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Updates the project role's name and description. You must include both a
  /// name and a description in the request.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> fullyUpdateProjectRole(
      {required int id, required CreateUpdateRoleRequestBean body}) async {
    return ProjectRole.fromJson(await _client.send(
      'put',
      'rest/api/3/role/{id}',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Updates either the project role's name or its description.
  ///
  /// You cannot update both the name and description at the same time using
  /// this operation. If you send a request with a name and a description only
  /// the name is updated.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectRole> partialUpdateProjectRole(
      {required int id, required CreateUpdateRoleRequestBean body}) async {
    return ProjectRole.fromJson(await _client.send(
      'post',
      'rest/api/3/role/{id}',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a project role. You must specify a replacement project role if you
  /// wish to delete a project role that is in use.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteProjectRole({required int id, int? swap}) async {
    await _client.send(
      'delete',
      'rest/api/3/role/{id}',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (swap != null) 'swap': '$swap',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class ProjectTypesApi {
  final ApiClient _client;

  ProjectTypesApi(this._client);

  /// Returns all [project types](https://confluence.atlassian.com/x/Var1Nw),
  /// whether or not the instance has a valid license for each type.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<List<ProjectType>> getAllProjectTypes() async {
    return (await _client.send(
      'get',
      'rest/api/3/project/type',
    ) as List<Object?>)
        .map(
            (i) => ProjectType.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns all [project types](https://confluence.atlassian.com/x/Var1Nw)
  /// with a valid license.
  Future<List<ProjectType>> getAllAccessibleProjectTypes() async {
    return (await _client.send(
      'get',
      'rest/api/3/project/type/accessible',
    ) as List<Object?>)
        .map(
            (i) => ProjectType.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a [project type](https://confluence.atlassian.com/x/Var1Nw).
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<ProjectType> getProjectTypeByKey(String projectTypeKey) async {
    return ProjectType.fromJson(await _client.send(
      'get',
      'rest/api/3/project/type/{projectTypeKey}',
      pathParameters: {
        'projectTypeKey': projectTypeKey,
      },
    ));
  }

  /// Returns a [project type](https://confluence.atlassian.com/x/Var1Nw) if it
  /// is accessible to the user.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<ProjectType> getAccessibleProjectTypeByKey(
      String projectTypeKey) async {
    return ProjectType.fromJson(await _client.send(
      'get',
      'rest/api/3/project/type/{projectTypeKey}/accessible',
      pathParameters: {
        'projectTypeKey': projectTypeKey,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ProjectVersionsApi {
  final ApiClient _client;

  ProjectVersionsApi(this._client);

  /// Returns a [paginated](#pagination) list of all versions in a project. See
  /// the
  /// [Get project versions](#api-rest-api-3-project-projectIdOrKey-versions-get)
  /// resource if you want to get a full list of versions without pagination.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<PageBeanVersion> getProjectVersionsPaginated(
      {required String projectIdOrKey,
      int? startAt,
      int? maxResults,
      String? orderBy,
      String? query,
      String? status,
      String? expand}) async {
    return PageBeanVersion.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/version',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (orderBy != null) 'orderBy': orderBy,
        if (query != null) 'query': query,
        if (status != null) 'status': status,
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns all versions in a project. The response is not paginated. Use
  /// [Get project versions paginated](#api-rest-api-3-project-projectIdOrKey-version-get)
  /// if you want to get the versions in a project with pagination.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<List<Version>> getProjectVersions(
      {required String projectIdOrKey, String? expand}) async {
    return (await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/versions',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ) as List<Object?>)
        .map((i) => Version.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a project version.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project the version is added to.
  Future<Version> createVersion({required Version body}) async {
    return Version.fromJson(await _client.send(
      'post',
      'rest/api/3/version',
      body: body.toJson(),
    ));
  }

  /// Returns a project version.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project containing the version.
  Future<Version> getVersion({required String id, String? expand}) async {
    return Version.fromJson(await _client.send(
      'get',
      'rest/api/3/version/{id}',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates a project version.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that contains the version.
  Future<Version> updateVersion(
      {required String id, required Version body}) async {
    return Version.fromJson(await _client.send(
      'put',
      'rest/api/3/version/{id}',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a project version.
  ///
  /// Deprecated, use
  /// [ Delete and replace version](#api-rest-api-3-version-id-removeAndSwap-post)
  /// that supports swapping version values in custom fields, in addition to the
  /// swapping for `fixVersion` and `affectedVersion` provided in this resource.
  ///
  /// Alternative versions can be provided to update issues that use the deleted
  /// version in `fixVersion` or `affectedVersion`. If alternatives are not
  /// provided, occurrences of `fixVersion` and `affectedVersion` that contain
  /// the deleted version are cleared.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that contains the version.
  Future<void> deleteVersion(
      {required String id,
      String? moveFixIssuesTo,
      String? moveAffectedIssuesTo}) async {
    await _client.send(
      'delete',
      'rest/api/3/version/{id}',
      pathParameters: {
        'id': id,
      },
      queryParameters: {
        if (moveFixIssuesTo != null) 'moveFixIssuesTo': moveFixIssuesTo,
        if (moveAffectedIssuesTo != null)
          'moveAffectedIssuesTo': moveAffectedIssuesTo,
      },
    );
  }

  /// Merges two project versions. The merge is completed by deleting the
  /// version specified in `id` and replacing any occurrences of its ID in
  /// `fixVersion` with the version ID specified in `moveIssuesTo`.
  ///
  /// Consider using
  /// [ Delete and replace version](#api-rest-api-3-version-id-removeAndSwap-post)
  /// instead. This resource supports swapping version values in `fixVersion`,
  /// `affectedVersion`, and custom fields.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that contains the version.
  Future<dynamic> mergeVersions(
      {required String id, required String moveIssuesTo}) async {
    return await _client.send(
      'put',
      'rest/api/3/version/{id}/mergeto/{moveIssuesTo}',
      pathParameters: {
        'id': id,
        'moveIssuesTo': moveIssuesTo,
      },
    );
  }

  /// Modifies the version's sequence within the project, which affects the
  /// display order of the versions in Jira.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects* project
  /// permission for the project that contains the version.
  Future<Version> moveVersion(
      {required String id, required VersionMoveBean body}) async {
    return Version.fromJson(await _client.send(
      'post',
      'rest/api/3/version/{id}/move',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    ));
  }

  /// Returns the following counts for a version:
  ///
  ///  *  Number of issues where the `fixVersion` is set to the version.
  ///  *  Number of issues where the `affectedVersion` is set to the version.
  ///  *  Number of issues where a version custom field is set to the version.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects* project
  /// permission for the project that contains the version.
  Future<VersionIssueCounts> getVersionRelatedIssues(String id) async {
    return VersionIssueCounts.fromJson(await _client.send(
      'get',
      'rest/api/3/version/{id}/relatedIssueCounts',
      pathParameters: {
        'id': id,
      },
    ));
  }

  /// Deletes a project version.
  ///
  /// Alternative versions can be provided to update issues that use the deleted
  /// version in `fixVersion`, `affectedVersion`, or any version picker custom
  /// fields. If alternatives are not provided, occurrences of `fixVersion`,
  /// `affectedVersion`, and any version picker custom field, that contain the
  /// deleted version, are cleared. Any replacement version must be in the same
  /// project as the version being deleted and cannot be the version being
  /// deleted.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project that contains the version.
  Future<dynamic> deleteAndReplaceVersion(
      {required String id, required DeleteAndReplaceVersionBean body}) async {
    return await _client.send(
      'post',
      'rest/api/3/version/{id}/removeAndSwap',
      pathParameters: {
        'id': id,
      },
      body: body.toJson(),
    );
  }

  /// Returns counts of the issues and unresolved issues for the project
  /// version.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects* project
  /// permission for the project that contains the version.
  Future<VersionUnresolvedIssuesCount> getVersionUnresolvedIssues(
      String id) async {
    return VersionUnresolvedIssuesCount.fromJson(await _client.send(
      'get',
      'rest/api/3/version/{id}/unresolvedIssueCount',
      pathParameters: {
        'id': id,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ProjectsApi {
  final ApiClient _client;

  ProjectsApi(this._client);

  /// Returns all projects visible to the user. Deprecated, use
  /// [ Get projects paginated](#api-rest-api-3-project-search-get) that
  /// supports search and pagination.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Projects are returned only where
  /// the user has *Browse Projects* or *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<List<Project>> getAllProjects(
      {String? expand, int? recent, List<String>? properties}) async {
    return (await _client.send(
      'get',
      'rest/api/3/project',
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (recent != null) 'recent': '$recent',
        if (properties != null)
          'properties': properties.map((e) => e).join(','),
      },
    ) as List<Object?>)
        .map((i) => Project.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a project based on a project type template, as shown in the
  /// following table:
  ///
  /// | Project Type Key | Project Template Key |
  /// |--|--|
  /// | `business` |
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-content-management`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-document-approval`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-lead-tracking`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-process-control`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-procurement`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-project-management`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-recruitment`,
  /// `com.atlassian.jira-core-project-templates:jira-core-simplified-task-tracking`
  /// |
  /// | `service_desk` |
  /// `com.atlassian.servicedesk:simplified-it-service-management`,
  /// `com.atlassian.servicedesk:simplified-general-service-desk-it`,
  /// `com.atlassian.servicedesk:simplified-general-service-desk-business`,
  /// `com.atlassian.servicedesk:simplified-external-service-desk`,
  /// `com.atlassian.servicedesk:simplified-hr-service-desk`,
  /// `com.atlassian.servicedesk:simplified-facilities-service-desk`,
  /// `com.atlassian.servicedesk:simplified-legal-service-desk`,
  /// `com.atlassian.servicedesk:simplified-analytics-service-desk`,
  /// `com.atlassian.servicedesk:simplified-marketing-service-desk`,
  /// `com.atlassian.servicedesk:simplified-design-service-desk`,
  /// `com.atlassian.servicedesk:simplified-sales-service-desk`,
  /// `com.atlassian.servicedesk:simplified-finance-service-desk` |
  /// | `software` | `com.pyxis.greenhopper.jira:gh-simplified-agility-kanban`,
  /// `com.pyxis.greenhopper.jira:gh-simplified-agility-scrum`,
  /// `com.pyxis.greenhopper.jira:gh-simplified-basic`,
  /// `com.pyxis.greenhopper.jira:gh-simplified-kanban-classic`,
  /// `com.pyxis.greenhopper.jira:gh-simplified-scrum-classic` |
  /// The project types are available according to the installed Jira features
  /// as follows:
  ///
  ///  *  Jira Core, the default, enables `business` projects.
  ///  *  Jira Service Management enables `service_desk` projects.
  ///  *  Jira Software enables `software` projects.
  ///
  /// To determine which features are installed, go to **Jira settings** >
  /// **Apps** > **Manage apps** and review the System Apps list. To add Jira
  /// Software or Jira Service Management into a JIRA instance, use **Jira
  /// settings** > **Apps** > **Finding new apps**. For more information, see
  /// [ Managing add-ons](https://confluence.atlassian.com/x/S31NLg).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ProjectIdentifiers> createProject(
      {required CreateProjectDetails body}) async {
    return ProjectIdentifiers.fromJson(await _client.send(
      'post',
      'rest/api/3/project',
      body: body.toJson(),
    ));
  }

  /// Returns a list of up to 20 projects recently viewed by the user that are
  /// still visible to the user.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Projects are returned only where
  /// the user has one of:
  ///
  ///  *  *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  ///  *  *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<Project>> getRecent(
      {String? expand, List<StringList>? properties}) async {
    return (await _client.send(
      'get',
      'rest/api/3/project/recent',
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (properties != null)
          'properties': properties.map((e) => '$e').join(','),
      },
    ) as List<Object?>)
        .map((i) => Project.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a [paginated](#pagination) list of projects visible to the user.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** Projects are returned only where
  /// the user has one of:
  ///
  ///  *  *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  ///  *  *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanProject> searchProjects(
      {int? startAt,
      int? maxResults,
      String? orderBy,
      List<int>? id,
      List<String>? keys,
      String? query,
      String? typeKey,
      int? categoryId,
      String? action,
      String? expand,
      List<String>? status,
      List<StringList>? properties,
      String? propertyQuery}) async {
    return PageBeanProject.fromJson(await _client.send(
      'get',
      'rest/api/3/project/search',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (orderBy != null) 'orderBy': orderBy,
        if (id != null) 'id': id.map((e) => '$e').join(','),
        if (keys != null) 'keys': keys.map((e) => e).join(','),
        if (query != null) 'query': query,
        if (typeKey != null) 'typeKey': typeKey,
        if (categoryId != null) 'categoryId': '$categoryId',
        if (action != null) 'action': action,
        if (expand != null) 'expand': expand,
        if (status != null) 'status': status.map((e) => e).join(','),
        if (properties != null)
          'properties': properties.map((e) => '$e').join(','),
        if (propertyQuery != null) 'propertyQuery': propertyQuery,
      },
    ));
  }

  /// Returns the [project details](https://confluence.atlassian.com/x/ahLpNw)
  /// for a project.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<Project> getProject(
      {required String projectIdOrKey,
      String? expand,
      List<String>? properties}) async {
    return Project.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (properties != null)
          'properties': properties.map((e) => e).join(','),
      },
    ));
  }

  /// Updates the [project details](https://confluence.atlassian.com/x/ahLpNw)
  /// of a project.
  ///
  /// All parameters are optional in the body of the request.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Project> updateProject(
      {required String projectIdOrKey,
      String? expand,
      required UpdateProjectDetails body}) async {
    return Project.fromJson(await _client.send(
      'put',
      'rest/api/3/project/{projectIdOrKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a project.
  ///
  /// You can't delete a project if it's archived. To delete an archived
  /// project, restore the project and then delete it. To restore a project, use
  /// the Jira UI.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteProject(
      {required String projectIdOrKey, bool? enableUndo}) async {
    await _client.send(
      'delete',
      'rest/api/3/project/{projectIdOrKey}',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
      queryParameters: {
        if (enableUndo != null) 'enableUndo': '$enableUndo',
      },
    );
  }

  /// Archives a project. You can't delete a project if it's archived. To delete
  /// an archived project, restore the project and then delete it. To restore a
  /// project, use the Jira UI.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> archiveProject(String projectIdOrKey) async {
    return await _client.send(
      'post',
      'rest/api/3/project/{projectIdOrKey}/archive',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    );
  }

  /// Deletes a project asynchronously.
  ///
  /// This operation is:
  ///
  ///  *  transactional, that is, if part of the delete fails the project is not
  /// deleted.
  ///  *  [asynchronous](#async). Follow the `location` link in the response to
  /// determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain subsequent updates.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TaskProgressBeanObject> deleteProjectAsynchronously(
      String projectIdOrKey) async {
    return TaskProgressBeanObject.fromJson(await _client.send(
      'post',
      'rest/api/3/project/{projectIdOrKey}/delete',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ));
  }

  /// Restores a project that has been archived or placed in the Jira recycle
  /// bin.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg)for Company
  /// managed projects.
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project for Team managed projects.
  Future<Project> restore(String projectIdOrKey) async {
    return Project.fromJson(await _client.send(
      'post',
      'rest/api/3/project/{projectIdOrKey}/restore',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ));
  }

  /// Returns the valid statuses for a project. The statuses are grouped by
  /// issue type, as each project has a set of valid issue types and each issue
  /// type has a set of valid statuses.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<List<IssueTypeWithStatus>> getAllStatuses(
      String projectIdOrKey) async {
    return (await _client.send(
      'get',
      'rest/api/3/project/{projectIdOrKey}/statuses',
      pathParameters: {
        'projectIdOrKey': projectIdOrKey,
      },
    ) as List<Object?>)
        .map((i) => IssueTypeWithStatus.fromJson(
            i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Get the issue type hierarchy for a next-gen project.
  ///
  /// The issue type hierarchy for a project consists of:
  ///
  ///  *  *Epic* at level 1 (optional).
  ///  *  One or more issue types at level 0 such as *Story*, *Task*, or *Bug*.
  /// Where the issue type *Epic* is defined, these issue types are used to
  /// break down the content of an epic.
  ///  *  *Subtask* at level -1 (optional). This issue type enables level 0
  /// issue types to be broken down into components. Issues based on a level -1
  /// issue type must have a parent issue.
  ///
  /// **[Permissions](#permissions) required:** *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for the
  /// project.
  Future<ProjectIssueTypeHierarchy> getHierarchy(int projectId) async {
    return ProjectIssueTypeHierarchy.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectId}/hierarchy',
      pathParameters: {
        'projectId': '$projectId',
      },
    ));
  }

  /// Gets a [notification scheme](https://confluence.atlassian.com/x/8YdKLg)
  /// associated with the project. Deprecated, use
  /// [Get notification schemes paginated](#api-rest-api-3-notificationscheme-get)
  /// supporting search and pagination.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg) or
  /// *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg).
  Future<NotificationScheme> getNotificationSchemeForProject(
      {required String projectKeyOrId, String? expand}) async {
    return NotificationScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/project/{projectKeyOrId}/notificationscheme',
      pathParameters: {
        'projectKeyOrId': projectKeyOrId,
      },
      queryParameters: {
        if (expand != null) 'expand': expand,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class ScreenSchemesApi {
  final ApiClient _client;

  ScreenSchemesApi(this._client);

  /// Returns a [paginated](#pagination) list of screen schemes.
  ///
  /// Only screen schemes used in classic projects are returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanScreenScheme> getScreenSchemes(
      {int? startAt,
      int? maxResults,
      List<int>? id,
      String? expand,
      String? queryString,
      String? orderBy}) async {
    return PageBeanScreenScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/screenscheme',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': id.map((e) => '$e').join(','),
        if (expand != null) 'expand': expand,
        if (queryString != null) 'queryString': queryString,
        if (orderBy != null) 'orderBy': orderBy,
      },
    ));
  }

  /// Creates a screen scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ScreenSchemeId> createScreenScheme(
      {required ScreenSchemeDetails body}) async {
    return ScreenSchemeId.fromJson(await _client.send(
      'post',
      'rest/api/3/screenscheme',
      body: body.toJson(),
    ));
  }

  /// Updates a screen scheme. Only screen schemes used in classic projects can
  /// be updated.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> updateScreenScheme(
      {required String screenSchemeId,
      required UpdateScreenSchemeDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/screenscheme/{screenSchemeId}',
      pathParameters: {
        'screenSchemeId': screenSchemeId,
      },
      body: body.toJson(),
    );
  }

  /// Deletes a screen scheme. A screen scheme cannot be deleted if it is used
  /// in an issue type screen scheme.
  ///
  /// Only screens schemes used in classic projects can be deleted.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteScreenScheme(String screenSchemeId) async {
    await _client.send(
      'delete',
      'rest/api/3/screenscheme/{screenSchemeId}',
      pathParameters: {
        'screenSchemeId': screenSchemeId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class ScreenTabFieldsApi {
  final ApiClient _client;

  ScreenTabFieldsApi(this._client);

  /// Returns all fields for a screen tab.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///  *  *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) when the
  /// project key is specified, providing that the screen is associated with the
  /// project through a Screen Scheme and Issue Type Screen Scheme.
  Future<List<ScreenableField>> getAllScreenTabFields(
      {required int screenId, required int tabId, String? projectKey}) async {
    return (await _client.send(
      'get',
      'rest/api/3/screens/{screenId}/tabs/{tabId}/fields',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
      },
      queryParameters: {
        if (projectKey != null) 'projectKey': projectKey,
      },
    ) as List<Object?>)
        .map((i) =>
            ScreenableField.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Adds a field to a screen tab.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ScreenableField> addScreenTabField(
      {required int screenId,
      required int tabId,
      required AddFieldBean body}) async {
    return ScreenableField.fromJson(await _client.send(
      'post',
      'rest/api/3/screens/{screenId}/tabs/{tabId}/fields',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
      },
      body: body.toJson(),
    ));
  }

  /// Removes a field from a screen tab.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> removeScreenTabField(
      {required int screenId, required int tabId, required String id}) async {
    await _client.send(
      'delete',
      'rest/api/3/screens/{screenId}/tabs/{tabId}/fields/{id}',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
        'id': id,
      },
    );
  }

  /// Moves a screen tab field.
  ///
  /// If `after` and `position` are provided in the request, `position` is
  /// ignored.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> moveScreenTabField(
      {required int screenId,
      required int tabId,
      required String id,
      required MoveFieldBean body}) async {
    return await _client.send(
      'post',
      'rest/api/3/screens/{screenId}/tabs/{tabId}/fields/{id}/move',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
        'id': id,
      },
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class ScreenTabsApi {
  final ApiClient _client;

  ScreenTabsApi(this._client);

  /// Returns the list of tabs for a screen.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///  *  *Administer projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) when the
  /// project key is specified, providing that the screen is associated with the
  /// project through a Screen Scheme and Issue Type Screen Scheme.
  Future<List<ScreenableTab>> getAllScreenTabs(
      {required int screenId, String? projectKey}) async {
    return (await _client.send(
      'get',
      'rest/api/3/screens/{screenId}/tabs',
      pathParameters: {
        'screenId': '$screenId',
      },
      queryParameters: {
        if (projectKey != null) 'projectKey': projectKey,
      },
    ) as List<Object?>)
        .map((i) =>
            ScreenableTab.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a tab for a screen.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ScreenableTab> addScreenTab(
      {required int screenId, required ScreenableTab body}) async {
    return ScreenableTab.fromJson(await _client.send(
      'post',
      'rest/api/3/screens/{screenId}/tabs',
      pathParameters: {
        'screenId': '$screenId',
      },
      body: body.toJson(),
    ));
  }

  /// Updates the name of a screen tab.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ScreenableTab> renameScreenTab(
      {required int screenId,
      required int tabId,
      required ScreenableTab body}) async {
    return ScreenableTab.fromJson(await _client.send(
      'put',
      'rest/api/3/screens/{screenId}/tabs/{tabId}',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a screen tab.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteScreenTab(
      {required int screenId, required int tabId}) async {
    await _client.send(
      'delete',
      'rest/api/3/screens/{screenId}/tabs/{tabId}',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
      },
    );
  }

  /// Moves a screen tab.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> moveScreenTab(
      {required int screenId, required int tabId, required int pos}) async {
    return await _client.send(
      'post',
      'rest/api/3/screens/{screenId}/tabs/{tabId}/move/{pos}',
      pathParameters: {
        'screenId': '$screenId',
        'tabId': '$tabId',
        'pos': '$pos',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class ScreensApi {
  final ApiClient _client;

  ScreensApi(this._client);

  /// Returns a [paginated](#pagination) list of the screens a field is used in.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanScreenWithTab> getScreensForField(
      {required String fieldId,
      int? startAt,
      int? maxResults,
      String? expand}) async {
    return PageBeanScreenWithTab.fromJson(await _client.send(
      'get',
      'rest/api/3/field/{fieldId}/screens',
      pathParameters: {
        'fieldId': fieldId,
      },
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Returns a [paginated](#pagination) list of all screens or those specified
  /// by one or more screen IDs.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanScreen> getScreens(
      {int? startAt,
      int? maxResults,
      List<int>? id,
      String? queryString,
      List<String>? scope,
      String? orderBy}) async {
    return PageBeanScreen.fromJson(await _client.send(
      'get',
      'rest/api/3/screens',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (id != null) 'id': id.map((e) => '$e').join(','),
        if (queryString != null) 'queryString': queryString,
        if (scope != null) 'scope': scope.map((e) => e).join(','),
        if (orderBy != null) 'orderBy': orderBy,
      },
    ));
  }

  /// Creates a screen with a default field tab.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Screen> createScreen({required ScreenDetails body}) async {
    return Screen.fromJson(await _client.send(
      'post',
      'rest/api/3/screens',
      body: body.toJson(),
    ));
  }

  /// Adds a field to the default tab of the default screen.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> addFieldToDefaultScreen(String fieldId) async {
    return await _client.send(
      'post',
      'rest/api/3/screens/addToDefault/{fieldId}',
      pathParameters: {
        'fieldId': fieldId,
      },
    );
  }

  /// Updates a screen. Only screens used in classic projects can be updated.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<Screen> updateScreen(
      {required int screenId, required UpdateScreenDetails body}) async {
    return Screen.fromJson(await _client.send(
      'put',
      'rest/api/3/screens/{screenId}',
      pathParameters: {
        'screenId': '$screenId',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a screen. A screen cannot be deleted if it is used in a screen
  /// scheme, workflow, or workflow draft.
  ///
  /// Only screens used in classic projects can be deleted.
  Future<void> deleteScreen(int screenId) async {
    await _client.send(
      'delete',
      'rest/api/3/screens/{screenId}',
      pathParameters: {
        'screenId': '$screenId',
      },
    );
  }

  /// Returns the fields that can be added to a tab on a screen.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<ScreenableField>> getAvailableScreenFields(int screenId) async {
    return (await _client.send(
      'get',
      'rest/api/3/screens/{screenId}/availableFields',
      pathParameters: {
        'screenId': '$screenId',
      },
    ) as List<Object?>)
        .map((i) =>
            ScreenableField.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }
}

/// Jira Cloud platform REST API documentation

class ServerInfoApi {
  final ApiClient _client;

  ServerInfoApi(this._client);

  /// Returns information about the Jira instance.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<ServerInformation> getServerInfo() async {
    return ServerInformation.fromJson(await _client.send(
      'get',
      'rest/api/3/serverInfo',
    ));
  }
}

/// Jira Cloud platform REST API documentation

class StatusApi {
  final ApiClient _client;

  StatusApi(this._client);

  /// Returns a list of the statuses specified by one or more status IDs.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer projects*
  /// [project permission.](https://confluence.atlassian.com/x/yodKLg)
  ///  *  *Administer Jira*
  /// [project permission.](https://confluence.atlassian.com/x/yodKLg)
  Future<List<JiraStatus>> getStatusesById(
      {String? expand, List<String>? id}) async {
    return (await _client.send(
      'get',
      'rest/api/3/statuses',
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (id != null) 'id': id.map((e) => e).join(','),
      },
    ) as List<Object?>)
        .map((i) => JiraStatus.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Updates statuses by ID.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer projects*
  /// [project permission.](https://confluence.atlassian.com/x/yodKLg)
  ///  *  *Administer Jira*
  /// [project permission.](https://confluence.atlassian.com/x/yodKLg)
  Future<dynamic> updateStatuses({required StatusUpdateRequest body}) async {
    return await _client.send(
      'put',
      'rest/api/3/statuses',
      body: body.toJson(),
    );
  }

  /// Creates statuses for a global or project scope.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer projects*
  /// [project permission.](https://confluence.atlassian.com/x/yodKLg)
  ///  *  *Administer Jira*
  /// [project permission.](https://confluence.atlassian.com/x/yodKLg)
  Future<List<JiraStatus>> createStatuses(
      {required StatusCreateRequest body}) async {
    return (await _client.send(
      'post',
      'rest/api/3/statuses',
      body: body.toJson(),
    ) as List<Object?>)
        .map((i) => JiraStatus.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Deletes statuses by ID.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer projects*
  /// [project permission.](https://confluence.atlassian.com/x/yodKLg)
  ///  *  *Administer Jira*
  /// [project permission.](https://confluence.atlassian.com/x/yodKLg)
  Future<dynamic> deleteStatusesById({List<String>? id}) async {
    return await _client.send(
      'delete',
      'rest/api/3/statuses',
      queryParameters: {
        if (id != null) 'id': id.map((e) => e).join(','),
      },
    );
  }

  /// Returns a
  /// [paginated](https://developer.atlassian.com/cloud/jira/platform/rest/v3/intro/#pagination)
  /// list of statuses that match a search on name or project.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer projects*
  /// [project permission.](https://confluence.atlassian.com/x/yodKLg)
  ///  *  *Administer Jira*
  /// [project permission.](https://confluence.atlassian.com/x/yodKLg)
  Future<PageOfStatuses> search(
      {String? expand,
      String? projectId,
      int? startAt,
      int? maxResults,
      String? searchString,
      String? statusCategory}) async {
    return PageOfStatuses.fromJson(await _client.send(
      'get',
      'rest/api/3/statuses/search',
      queryParameters: {
        if (expand != null) 'expand': expand,
        if (projectId != null) 'projectId': projectId,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (searchString != null) 'searchString': searchString,
        if (statusCategory != null) 'statusCategory': statusCategory,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class TasksApi {
  final ApiClient _client;

  TasksApi(this._client);

  /// Returns the status of a [long-running asynchronous task](#async).
  ///
  /// When a task has finished, this operation returns the JSON blob applicable
  /// to the task. See the documentation of the operation that created the task
  /// for details. Task details are not permanently retained. As of September
  /// 2019, details are retained for 14 days although this period may change
  /// without notice.
  ///
  /// **[Permissions](#permissions) required:** either of:
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///  *  Creator of the task.
  Future<TaskProgressBeanObject> getTask(String taskId) async {
    return TaskProgressBeanObject.fromJson(await _client.send(
      'get',
      'rest/api/3/task/{taskId}',
      pathParameters: {
        'taskId': taskId,
      },
    ));
  }

  /// Cancels a task.
  ///
  /// **[Permissions](#permissions) required:** either of:
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///  *  Creator of the task.
  Future<dynamic> cancelTask(String taskId) async {
    return await _client.send(
      'post',
      'rest/api/3/task/{taskId}/cancel',
      pathParameters: {
        'taskId': taskId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class TimeTrackingApi {
  final ApiClient _client;

  TimeTrackingApi(this._client);

  /// Returns the time tracking provider that is currently selected. Note that
  /// if time tracking is disabled, then a successful but empty response is
  /// returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TimeTrackingProvider> getSelectedTimeTrackingImplementation() async {
    return TimeTrackingProvider.fromJson(await _client.send(
      'get',
      'rest/api/3/configuration/timetracking',
    ));
  }

  /// Selects a time tracking provider.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> selectTimeTrackingImplementation(
      {required TimeTrackingProvider body}) async {
    return await _client.send(
      'put',
      'rest/api/3/configuration/timetracking',
      body: body.toJson(),
    );
  }

  /// Returns all time tracking providers. By default, Jira only has one time
  /// tracking provider: *JIRA provided time tracking*. However, you can install
  /// other time tracking providers via apps from the Atlassian Marketplace. For
  /// more information on time tracking providers, see the documentation for the
  /// [ Time Tracking Provider](https://developer.atlassian.com/cloud/jira/platform/modules/time-tracking-provider/)
  /// module.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<TimeTrackingProvider>>
      getAvailableTimeTrackingImplementations() async {
    return (await _client.send(
      'get',
      'rest/api/3/configuration/timetracking/list',
    ) as List<Object?>)
        .map((i) => TimeTrackingProvider.fromJson(
            i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns the time tracking settings. This includes settings such as the
  /// time format, default time unit, and others. For more information, see
  /// [Configuring time tracking](https://confluence.atlassian.com/x/qoXKM).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TimeTrackingConfiguration> getSharedTimeTrackingConfiguration() async {
    return TimeTrackingConfiguration.fromJson(await _client.send(
      'get',
      'rest/api/3/configuration/timetracking/options',
    ));
  }

  /// Sets the time tracking settings.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<TimeTrackingConfiguration> setSharedTimeTrackingConfiguration(
      {required TimeTrackingConfiguration body}) async {
    return TimeTrackingConfiguration.fromJson(await _client.send(
      'put',
      'rest/api/3/configuration/timetracking/options',
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class UIModificationsAppsApi {
  final ApiClient _client;

  UIModificationsAppsApi(this._client);

  /// Gets UI modifications. UI modifications can only be retrieved by Forge
  /// apps.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<PageBeanUiModificationDetails> getUiModifications(
      {int? startAt, int? maxResults, String? expand}) async {
    return PageBeanUiModificationDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/uiModifications',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Creates a UI modification. UI modification can only be created by Forge
  /// apps.
  ///
  /// Each app can define up to 100 UI modifications. Each UI modification can
  /// define up to 1000 contexts.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *None* if the UI modification is created without contexts.
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for one or
  /// more projects, if the UI modification is created with contexts.
  Future<UiModificationIdentifiers> createUiModification(
      {required CreateUiModificationDetails body}) async {
    return UiModificationIdentifiers.fromJson(await _client.send(
      'post',
      'rest/api/3/uiModifications',
      body: body.toJson(),
    ));
  }

  /// Updates a UI modification. UI modification can only be updated by Forge
  /// apps.
  ///
  /// Each UI modification can define up to 1000 contexts.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *None* if the UI modification is created without contexts.
  ///  *  *Browse projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for one or
  /// more projects, if the UI modification is created with contexts.
  Future<dynamic> updateUiModification(
      {required String uiModificationId,
      required UpdateUiModificationDetails body}) async {
    return await _client.send(
      'put',
      'rest/api/3/uiModifications/{uiModificationId}',
      pathParameters: {
        'uiModificationId': uiModificationId,
      },
      body: body.toJson(),
    );
  }

  /// Deletes a UI modification. All the contexts that belong to the UI
  /// modification are deleted too. UI modification can only be deleted by Forge
  /// apps.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<dynamic> deleteUiModification(String uiModificationId) async {
    return await _client.send(
      'delete',
      'rest/api/3/uiModifications/{uiModificationId}',
      pathParameters: {
        'uiModificationId': uiModificationId,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class UserPropertiesApi {
  final ApiClient _client;

  UserPropertiesApi(this._client);

  /// Returns the keys of all properties for a user.
  ///
  /// Note: This operation does not access the
  /// [user properties](https://confluence.atlassian.com/x/8YxjL) created and
  /// maintained in Jira.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to access
  /// the property keys on any user.
  ///  *  Access to Jira, to access the calling user's property keys.
  Future<PropertyKeys> getUserPropertyKeys(
      {String? accountId, String? userKey, String? username}) async {
    return PropertyKeys.fromJson(await _client.send(
      'get',
      'rest/api/3/user/properties',
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (userKey != null) 'userKey': userKey,
        if (username != null) 'username': username,
      },
    ));
  }

  /// Returns the value of a user's property. If no property key is provided
  /// [Get user property keys](#api-rest-api-3-user-properties-get) is called.
  ///
  /// Note: This operation does not access the
  /// [user properties](https://confluence.atlassian.com/x/8YxjL) created and
  /// maintained in Jira.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to get a
  /// property from any user.
  ///  *  Access to Jira, to get a property from the calling user's record.
  Future<EntityProperty> getUserProperty(
      {String? accountId,
      String? userKey,
      String? username,
      required String propertyKey}) async {
    return EntityProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/user/properties/{propertyKey}',
      pathParameters: {
        'propertyKey': propertyKey,
      },
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (userKey != null) 'userKey': userKey,
        if (username != null) 'username': username,
      },
    ));
  }

  /// Sets the value of a user's property. Use this resource to store custom
  /// data against a user.
  ///
  /// Note: This operation does not access the
  /// [user properties](https://confluence.atlassian.com/x/8YxjL) created and
  /// maintained in Jira.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to set a
  /// property on any user.
  ///  *  Access to Jira, to set a property on the calling user's record.
  Future<dynamic> setUserProperty(
      {String? accountId,
      String? userKey,
      String? username,
      required String propertyKey,
      required dynamic body}) async {
    return await _client.send(
      'put',
      'rest/api/3/user/properties/{propertyKey}',
      pathParameters: {
        'propertyKey': propertyKey,
      },
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (userKey != null) 'userKey': userKey,
        if (username != null) 'username': username,
      },
      body: body,
    );
  }

  /// Deletes a property from a user.
  ///
  /// Note: This operation does not access the
  /// [user properties](https://confluence.atlassian.com/x/8YxjL) created and
  /// maintained in Jira.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to delete
  /// a property from any user.
  ///  *  Access to Jira, to delete a property from the calling user's record.
  Future<void> deleteUserProperty(
      {String? accountId,
      String? userKey,
      String? username,
      required String propertyKey}) async {
    await _client.send(
      'delete',
      'rest/api/3/user/properties/{propertyKey}',
      pathParameters: {
        'propertyKey': propertyKey,
      },
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (userKey != null) 'userKey': userKey,
        if (username != null) 'username': username,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class UserSearchApi {
  final ApiClient _client;

  UserSearchApi(this._client);

  /// Returns a list of users who can be assigned issues in one or more
  /// projects. The list may be restricted to users whose attributes match a
  /// string.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that can be assigned issues in the projects. This means
  /// the operation usually returns fewer users than specified in `maxResults`.
  /// To get all the users who can be assigned issues in the projects, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// Privacy controls are applied to the response based on the users'
  /// preferences. This could mean, for example, that the user's email address
  /// is hidden. See the
  /// [Profile visibility overview](https://developer.atlassian.com/cloud/jira/platform/profile-visibility/)
  /// for more details.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<List<User>> findBulkAssignableUsers(
      {String? query,
      String? username,
      String? accountId,
      required String projectKeys,
      int? startAt,
      int? maxResults}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/assignable/multiProjectSearch',
      queryParameters: {
        if (query != null) 'query': query,
        if (username != null) 'username': username,
        if (accountId != null) 'accountId': accountId,
        'projectKeys': projectKeys,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a list of users that can be assigned to an issue. Use this
  /// operation to find the list of users who can be assigned to:
  ///
  ///  *  a new issue, by providing the `projectKeyOrId`.
  ///  *  an updated issue, by providing the `issueKey`.
  ///  *  to an issue during a transition (workflow action), by providing the
  /// `issueKey` and the transition id in `actionDescriptorId`. You can obtain
  /// the IDs of an issue's valid transitions using the `transitions` option in
  /// the `expand` parameter of
  /// [ Get issue](#api-rest-api-3-issue-issueIdOrKey-get).
  ///
  /// In all these cases, you can pass an account ID to determine if a user can
  /// be assigned to an issue. The user is returned in the response if they can
  /// be assigned to the issue or issue transition.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that can be assigned the issue. This means the operation
  /// usually returns fewer users than specified in `maxResults`. To get all the
  /// users who can be assigned the issue, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// Privacy controls are applied to the response based on the users'
  /// preferences. This could mean, for example, that the user's email address
  /// is hidden. See the
  /// [Profile visibility overview](https://developer.atlassian.com/cloud/jira/platform/profile-visibility/)
  /// for more details.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<List<User>> findAssignableUsers(
      {String? query,
      String? sessionId,
      String? username,
      String? accountId,
      String? project,
      String? issueKey,
      int? startAt,
      int? maxResults,
      int? actionDescriptorId,
      bool? recommend}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/assignable/search',
      queryParameters: {
        if (query != null) 'query': query,
        if (sessionId != null) 'sessionId': sessionId,
        if (username != null) 'username': username,
        if (accountId != null) 'accountId': accountId,
        if (project != null) 'project': project,
        if (issueKey != null) 'issueKey': issueKey,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (actionDescriptorId != null)
          'actionDescriptorId': '$actionDescriptorId',
        if (recommend != null) 'recommend': '$recommend',
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a list of users who fulfill these criteria:
  ///
  ///  *  their user attributes match a search string.
  ///  *  they have a set of permissions for a project or issue.
  ///
  /// If no search string is provided, a list of all users with the permissions
  /// is returned.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that match the search string and have permission for the
  /// project or issue. This means the operation usually returns fewer users
  /// than specified in `maxResults`. To get all the users who match the search
  /// string and have permission for the project or issue, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// Privacy controls are applied to the response based on the users'
  /// preferences. This could mean, for example, that the user's email address
  /// is hidden. See the
  /// [Profile visibility overview](https://developer.atlassian.com/cloud/jira/platform/profile-visibility/)
  /// for more details.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to get
  /// users for any project.
  ///  *  *Administer Projects*
  /// [project permission](https://confluence.atlassian.com/x/yodKLg) for a
  /// project, to get users for that project.
  Future<List<User>> findUsersWithAllPermissions(
      {String? query,
      String? username,
      String? accountId,
      required String permissions,
      String? issueKey,
      String? projectKey,
      int? startAt,
      int? maxResults}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/permission/search',
      queryParameters: {
        if (query != null) 'query': query,
        if (username != null) 'username': username,
        if (accountId != null) 'accountId': accountId,
        'permissions': permissions,
        if (issueKey != null) 'issueKey': issueKey,
        if (projectKey != null) 'projectKey': projectKey,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a list of users whose attributes match the query term. The
  /// returned object includes the `html` field where the matched query term is
  /// highlighted with the HTML strong tag. A list of account IDs can be
  /// provided to exclude users from the results.
  ///
  /// This operation takes the users in the range defined by `maxResults`, up to
  /// the thousandth user, and then returns only the users from that range that
  /// match the query term. This means the operation usually returns fewer users
  /// than specified in `maxResults`. To get all the users who match the query
  /// term, use [Get all users](#api-rest-api-3-users-search-get) and filter the
  /// records in your code.
  ///
  /// Privacy controls are applied to the response based on the users'
  /// preferences. This could mean, for example, that the user's email address
  /// is hidden. See the
  /// [Profile visibility overview](https://developer.atlassian.com/cloud/jira/platform/profile-visibility/)
  /// for more details.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Anonymous
  /// calls and calls by users without the required permission return search
  /// results for an exact name match only.
  Future<FoundUsers> findUsersForPicker(
      {required String query,
      int? maxResults,
      bool? showAvatar,
      List<String>? exclude,
      List<String>? excludeAccountIds,
      String? avatarSize,
      bool? excludeConnectUsers}) async {
    return FoundUsers.fromJson(await _client.send(
      'get',
      'rest/api/3/user/picker',
      queryParameters: {
        'query': query,
        if (maxResults != null) 'maxResults': '$maxResults',
        if (showAvatar != null) 'showAvatar': '$showAvatar',
        if (exclude != null) 'exclude': exclude.map((e) => e).join(','),
        if (excludeAccountIds != null)
          'excludeAccountIds': excludeAccountIds.map((e) => e).join(','),
        if (avatarSize != null) 'avatarSize': avatarSize,
        if (excludeConnectUsers != null)
          'excludeConnectUsers': '$excludeConnectUsers',
      },
    ));
  }

  /// Returns a list of users that match the search string and property.
  ///
  /// This operation first applies a filter to match the search string and
  /// property, and then takes the filtered users in the range defined by
  /// `startAt` and `maxResults`, up to the thousandth user. To get all the
  /// users who match the search string and property, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// Privacy controls are applied to the response based on the users'
  /// preferences. This could mean, for example, that the user's email address
  /// is hidden. See the
  /// [Profile visibility overview](https://developer.atlassian.com/cloud/jira/platform/profile-visibility/)
  /// for more details.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Anonymous
  /// calls or calls by users without the required permission return empty
  /// search results.
  Future<List<User>> findUsers(
      {String? query,
      String? username,
      String? accountId,
      int? startAt,
      int? maxResults,
      String? property}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/search',
      queryParameters: {
        if (query != null) 'query': query,
        if (username != null) 'username': username,
        if (accountId != null) 'accountId': accountId,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (property != null) 'property': property,
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Finds users with a structured query and returns a [paginated](#pagination)
  /// list of user details.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that match the structured query. This means the operation
  /// usually returns fewer users than specified in `maxResults`. To get all the
  /// users who match the structured query, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///
  /// The query statements are:
  ///
  ///  *  `is assignee of PROJ` Returns the users that are assignees of at least
  /// one issue in project *PROJ*.
  ///  *  `is assignee of (PROJ-1, PROJ-2)` Returns users that are assignees on
  /// the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is reporter of (PROJ-1, PROJ-2)` Returns users that are reporters on
  /// the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is watcher of (PROJ-1, PROJ-2)` Returns users that are watchers on
  /// the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is voter of (PROJ-1, PROJ-2)` Returns users that are voters on the
  /// issues *PROJ-1* or *PROJ-2*.
  ///  *  `is commenter of (PROJ-1, PROJ-2)` Returns users that have posted a
  /// comment on the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is transitioner of (PROJ-1, PROJ-2)` Returns users that have
  /// performed a transition on issues *PROJ-1* or *PROJ-2*.
  ///  *  `[propertyKey].entity.property.path is "property value"` Returns users
  /// with the entity property value.
  ///
  /// The list of issues can be extended as needed, as in *(PROJ-1, PROJ-2, ...
  /// PROJ-n)*. Statements can be combined using the `AND` and `OR` operators to
  /// form more complex queries. For example:
  ///
  /// `is assignee of PROJ AND [propertyKey].entity.property.path is "property
  /// value"`
  Future<PageBeanUser> findUsersByQuery(
      {required String query, int? startAt, int? maxResults}) async {
    return PageBeanUser.fromJson(await _client.send(
      'get',
      'rest/api/3/user/search/query',
      queryParameters: {
        'query': query,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Finds users with a structured query and returns a [paginated](#pagination)
  /// list of user keys.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that match the structured query. This means the operation
  /// usually returns fewer users than specified in `maxResults`. To get all the
  /// users who match the structured query, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  ///
  /// The query statements are:
  ///
  ///  *  `is assignee of PROJ` Returns the users that are assignees of at least
  /// one issue in project *PROJ*.
  ///  *  `is assignee of (PROJ-1, PROJ-2)` Returns users that are assignees on
  /// the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is reporter of (PROJ-1, PROJ-2)` Returns users that are reporters on
  /// the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is watcher of (PROJ-1, PROJ-2)` Returns users that are watchers on
  /// the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is voter of (PROJ-1, PROJ-2)` Returns users that are voters on the
  /// issues *PROJ-1* or *PROJ-2*.
  ///  *  `is commenter of (PROJ-1, PROJ-2)` Returns users that have posted a
  /// comment on the issues *PROJ-1* or *PROJ-2*.
  ///  *  `is transitioner of (PROJ-1, PROJ-2)` Returns users that have
  /// performed a transition on issues *PROJ-1* or *PROJ-2*.
  ///  *  `[propertyKey].entity.property.path is "property value"` Returns users
  /// with the entity property value.
  ///
  /// The list of issues can be extended as needed, as in *(PROJ-1, PROJ-2, ...
  /// PROJ-n)*. Statements can be combined using the `AND` and `OR` operators to
  /// form more complex queries. For example:
  ///
  /// `is assignee of PROJ AND [propertyKey].entity.property.path is "property
  /// value"`
  Future<PageBeanUserKey> findUserKeysByQuery(
      {required String query, int? startAt, int? maxResults}) async {
    return PageBeanUserKey.fromJson(await _client.send(
      'get',
      'rest/api/3/user/search/query/key',
      queryParameters: {
        'query': query,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Returns a list of users who fulfill these criteria:
  ///
  ///  *  their user attributes match a search string.
  ///  *  they have permission to browse issues.
  ///
  /// Use this resource to find users who can browse:
  ///
  ///  *  an issue, by providing the `issueKey`.
  ///  *  any issue in a project, by providing the `projectKey`.
  ///
  /// This operation takes the users in the range defined by `startAt` and
  /// `maxResults`, up to the thousandth user, and then returns only the users
  /// from that range that match the search string and have permission to browse
  /// issues. This means the operation usually returns fewer users than
  /// specified in `maxResults`. To get all the users who match the search
  /// string and have permission to browse issues, use
  /// [Get all users](#api-rest-api-3-users-search-get) and filter the records
  /// in your code.
  ///
  /// Privacy controls are applied to the response based on the users'
  /// preferences. This could mean, for example, that the user's email address
  /// is hidden. See the
  /// [Profile visibility overview](https://developer.atlassian.com/cloud/jira/platform/profile-visibility/)
  /// for more details.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg). Anonymous
  /// calls and calls by users without the required permission return empty
  /// search results.
  Future<List<User>> findUsersWithBrowsePermission(
      {String? query,
      String? username,
      String? accountId,
      String? issueKey,
      String? projectKey,
      int? startAt,
      int? maxResults}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/viewissue/search',
      queryParameters: {
        if (query != null) 'query': query,
        if (username != null) 'username': username,
        if (accountId != null) 'accountId': accountId,
        if (issueKey != null) 'issueKey': issueKey,
        if (projectKey != null) 'projectKey': projectKey,
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }
}

/// Jira Cloud platform REST API documentation

class UsersApi {
  final ApiClient _client;

  UsersApi(this._client);

  /// Returns a user.
  ///
  /// Privacy controls are applied to the response based on the user's
  /// preferences. This could mean, for example, that the user's email address
  /// is hidden. See the
  /// [Profile visibility overview](https://developer.atlassian.com/cloud/jira/platform/profile-visibility/)
  /// for more details.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<User> getUser(
      {String? accountId,
      String? username,
      String? key,
      String? expand}) async {
    return User.fromJson(await _client.send(
      'get',
      'rest/api/3/user',
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (username != null) 'username': username,
        if (key != null) 'key': key,
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Creates a user. This resource is retained for legacy compatibility. As
  /// soon as a more suitable alternative is available this resource will be
  /// deprecated.
  ///
  /// If the user exists and has access to Jira, the operation returns a 201
  /// status. If the user exists but does not have access to Jira, the operation
  /// returns a 400 status.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<User> createUser({required NewUserDetails body}) async {
    return User.fromJson(await _client.send(
      'post',
      'rest/api/3/user',
      body: body.toJson(),
    ));
  }

  /// Deletes a user. If the operation completes successfully then the user is
  /// removed from Jira's user base. This operation does not delete the user's
  /// Atlassian account.
  ///
  /// **[Permissions](#permissions) required:** Site administration (that is,
  /// membership of the *site-admin*
  /// [group](https://confluence.atlassian.com/x/24xjL)).
  Future<void> removeUser(
      {required String accountId, String? username, String? key}) async {
    await _client.send(
      'delete',
      'rest/api/3/user',
      queryParameters: {
        'accountId': accountId,
        if (username != null) 'username': username,
        if (key != null) 'key': key,
      },
    );
  }

  /// Returns a [paginated](#pagination) list of the users specified by one or
  /// more account IDs.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<PageBeanUser> bulkGetUsers(
      {int? startAt,
      int? maxResults,
      List<String>? username,
      List<String>? key,
      required List<String> accountId}) async {
    return PageBeanUser.fromJson(await _client.send(
      'get',
      'rest/api/3/user/bulk',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (username != null) 'username': username.map((e) => e).join(','),
        if (key != null) 'key': key.map((e) => e).join(','),
        'accountId': accountId.map((e) => e).join(','),
      },
    ));
  }

  /// Returns the account IDs for the users specified in the `key` or `username`
  /// parameters. Note that multiple `key` or `username` parameters can be
  /// specified.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<List<UserMigrationBean>> bulkGetUsersMigration(
      {int? startAt,
      int? maxResults,
      List<String>? username,
      List<String>? key}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/bulk/migration',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (username != null) 'username': username.map((e) => e).join(','),
        if (key != null) 'key': key.map((e) => e).join(','),
      },
    ) as List<Object?>)
        .map((i) =>
            UserMigrationBean.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns the default
  /// [issue table columns](https://confluence.atlassian.com/x/XYdKLg) for the
  /// user. If `accountId` is not passed in the request, the calling user's
  /// details are returned.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLgl), to get
  /// the column details for any user.
  ///  *  Permission to access Jira, to get the calling user's column details.
  Future<List<ColumnItem>> getUserDefaultColumns(
      {String? accountId, String? username}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/columns',
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (username != null) 'username': username,
      },
    ) as List<Object?>)
        .map((i) => ColumnItem.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Sets the default
  /// [ issue table columns](https://confluence.atlassian.com/x/XYdKLg) for the
  /// user. If an account ID is not passed, the calling user's default columns
  /// are set. If no column details are sent, then all default columns are
  /// removed.
  ///
  /// The parameters for this resource are expressed as HTML form data. For
  /// example, in curl:
  ///
  /// `curl -X PUT -d columns=summary -d columns=description
  /// https://your-domain.atlassian.net/rest/api/3/user/columns?accountId=5b10ac8d82e05b22cc7d4ef5'`
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to set the
  /// columns on any user.
  ///  *  Permission to access Jira, to set the calling user's columns.
  Future<dynamic> setUserColumns(
      {String? accountId, required List<String> body}) async {
    return await _client.send(
      'put',
      'rest/api/3/user/columns',
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
      },
      body: body,
    );
  }

  /// Resets the default
  /// [ issue table columns](https://confluence.atlassian.com/x/XYdKLg) for the
  /// user to the system default. If `accountId` is not passed, the calling
  /// user's default columns are reset.
  ///
  /// **[Permissions](#permissions) required:**
  ///
  ///  *  *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg), to set the
  /// columns on any user.
  ///  *  Permission to access Jira, to set the calling user's columns.
  Future<void> resetUserColumns({String? accountId, String? username}) async {
    await _client.send(
      'delete',
      'rest/api/3/user/columns',
      queryParameters: {
        if (accountId != null) 'accountId': accountId,
        if (username != null) 'username': username,
      },
    );
  }

  /// Returns a user's email address. This API is only available to apps
  /// approved by Atlassian, according to these
  /// [guidelines](https://community.developer.atlassian.com/t/guidelines-for-requesting-access-to-email-address/27603).
  Future<UnrestrictedUserEmail> getUserEmail(String accountId) async {
    return UnrestrictedUserEmail.fromJson(await _client.send(
      'get',
      'rest/api/3/user/email',
      queryParameters: {
        'accountId': accountId,
      },
    ));
  }

  /// Returns a user's email address. This API is only available to apps
  /// approved by Atlassian, according to these
  /// [guidelines](https://community.developer.atlassian.com/t/guidelines-for-requesting-access-to-email-address/27603).
  Future<UnrestrictedUserEmail> getUserEmailBulk(List<String> accountId) async {
    return UnrestrictedUserEmail.fromJson(await _client.send(
      'get',
      'rest/api/3/user/email/bulk',
      queryParameters: {
        'accountId': accountId.map((e) => e).join(','),
      },
    ));
  }

  /// Returns the groups to which a user belongs.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<GroupName>> getUserGroups(
      {required String accountId, String? username, String? key}) async {
    return (await _client.send(
      'get',
      'rest/api/3/user/groups',
      queryParameters: {
        'accountId': accountId,
        if (username != null) 'username': username,
        if (key != null) 'key': key,
      },
    ) as List<Object?>)
        .map((i) => GroupName.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a list of all users, including active users, inactive users and
  /// previously deleted users that have an Atlassian account.
  ///
  /// Privacy controls are applied to the response based on the users'
  /// preferences. This could mean, for example, that the user's email address
  /// is hidden. See the
  /// [Profile visibility overview](https://developer.atlassian.com/cloud/jira/platform/profile-visibility/)
  /// for more details.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<User>> getAllUsersDefault({int? startAt, int? maxResults}) async {
    return (await _client.send(
      'get',
      'rest/api/3/users',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a list of all users, including active users, inactive users and
  /// previously deleted users that have an Atlassian account.
  ///
  /// Privacy controls are applied to the response based on the users'
  /// preferences. This could mean, for example, that the user's email address
  /// is hidden. See the
  /// [Profile visibility overview](https://developer.atlassian.com/cloud/jira/platform/profile-visibility/)
  /// for more details.
  ///
  /// **[Permissions](#permissions) required:** *Browse users and groups*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<User>> getAllUsers({int? startAt, int? maxResults}) async {
    return (await _client.send(
      'get',
      'rest/api/3/users/search',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ) as List<Object?>)
        .map((i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }
}

/// Jira Cloud platform REST API documentation

class WebhooksApi {
  final ApiClient _client;

  WebhooksApi(this._client);

  /// Returns a [paginated](#pagination) list of the webhooks registered by the
  /// calling app.
  ///
  /// **[Permissions](#permissions) required:** Only
  /// [Connect](https://developer.atlassian.com/cloud/jira/platform/#connect-apps)
  /// and
  /// [OAuth 2.0](https://developer.atlassian.com/cloud/jira/platform/oauth-2-3lo-apps)
  /// apps can use this operation.
  Future<PageBeanWebhook> getDynamicWebhooksForApp(
      {int? startAt, int? maxResults}) async {
    return PageBeanWebhook.fromJson(await _client.send(
      'get',
      'rest/api/3/webhook',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Registers webhooks.
  ///
  /// **NOTE:** for non-public OAuth apps, webhooks are delivered only if there
  /// is a match between the app owner and the user who registered a dynamic
  /// webhook.
  ///
  /// **[Permissions](#permissions) required:** Only
  /// [Connect](https://developer.atlassian.com/cloud/jira/platform/#connect-apps)
  /// and
  /// [OAuth 2.0](https://developer.atlassian.com/cloud/jira/platform/oauth-2-3lo-apps)
  /// apps can use this operation.
  Future<ContainerForRegisteredWebhooks> registerDynamicWebhooks(
      {required WebhookRegistrationDetails body}) async {
    return ContainerForRegisteredWebhooks.fromJson(await _client.send(
      'post',
      'rest/api/3/webhook',
      body: body.toJson(),
    ));
  }

  /// Removes webhooks by ID. Only webhooks registered by the calling app are
  /// removed. If webhooks created by other apps are specified, they are
  /// ignored.
  ///
  /// **[Permissions](#permissions) required:** Only
  /// [Connect](https://developer.atlassian.com/cloud/jira/platform/#connect-apps)
  /// and
  /// [OAuth 2.0](https://developer.atlassian.com/cloud/jira/platform/oauth-2-3lo-apps)
  /// apps can use this operation.
  Future<void> deleteWebhookById({required ContainerForWebhookIDs body}) async {
    await _client.send(
      'delete',
      'rest/api/3/webhook',
      body: body.toJson(),
    );
  }

  /// Returns webhooks that have recently failed to be delivered to the
  /// requesting app after the maximum number of retries.
  ///
  /// After 72 hours the failure may no longer be returned by this operation.
  ///
  /// The oldest failure is returned first.
  ///
  /// This method uses a cursor-based pagination. To request the next page use
  /// the failure time of the last webhook on the list as the `failedAfter`
  /// value or use the URL provided in `next`.
  ///
  /// **[Permissions](#permissions) required:** Only
  /// [Connect apps](https://developer.atlassian.com/cloud/jira/platform/index/#connect-apps)
  /// can use this operation.
  Future<FailedWebhooks> getFailedWebhooks(
      {int? maxResults, int? after}) async {
    return FailedWebhooks.fromJson(await _client.send(
      'get',
      'rest/api/3/webhook/failed',
      queryParameters: {
        if (maxResults != null) 'maxResults': '$maxResults',
        if (after != null) 'after': '$after',
      },
    ));
  }

  /// Extends the life of webhook. Webhooks registered through the REST API
  /// expire after 30 days. Call this operation to keep them alive.
  ///
  /// Unrecognized webhook IDs (those that are not found or belong to other
  /// apps) are ignored.
  ///
  /// **[Permissions](#permissions) required:** Only
  /// [Connect](https://developer.atlassian.com/cloud/jira/platform/#connect-apps)
  /// and
  /// [OAuth 2.0](https://developer.atlassian.com/cloud/jira/platform/oauth-2-3lo-apps)
  /// apps can use this operation.
  Future<WebhooksExpirationDate> refreshWebhooks(
      {required ContainerForWebhookIDs body}) async {
    return WebhooksExpirationDate.fromJson(await _client.send(
      'put',
      'rest/api/3/webhook/refresh',
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowSchemeDraftsApi {
  final ApiClient _client;

  WorkflowSchemeDraftsApi(this._client);

  /// Create a draft workflow scheme from an active workflow scheme, by copying
  /// the active workflow scheme. Note that an active workflow scheme can only
  /// have one draft workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> createWorkflowSchemeDraftFromParent(int id) async {
    return WorkflowScheme.fromJson(await _client.send(
      'post',
      'rest/api/3/workflowscheme/{id}/createdraft',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Returns the draft workflow scheme for an active workflow scheme. Draft
  /// workflow schemes allow changes to be made to the active workflow schemes:
  /// When an active workflow scheme is updated, a draft copy is created. The
  /// draft is modified, then the changes in the draft are copied back to the
  /// active workflow scheme. See
  /// [Configuring workflow schemes](https://confluence.atlassian.com/x/tohKLg)
  /// for more information.
  /// Note that:
  ///
  ///  *  Only active workflow schemes can have draft workflow schemes.
  ///  *  An active workflow scheme can only have one draft workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> getWorkflowSchemeDraft(int id) async {
    return WorkflowScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/draft',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Updates a draft workflow scheme. If a draft workflow scheme does not exist
  /// for the active workflow scheme, then a draft is created. Note that an
  /// active workflow scheme can only have one draft workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> updateWorkflowSchemeDraft(
      {required int id, required WorkflowScheme body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/draft',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a draft workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteWorkflowSchemeDraft(int id) async {
    await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/draft',
      pathParameters: {
        'id': '$id',
      },
    );
  }

  /// Returns the default workflow for a workflow scheme's draft. The default
  /// workflow is the workflow that is assigned any issue types that have not
  /// been mapped to any other workflow. The default workflow has *All
  /// Unassigned Issue Types* listed in its issue types for the workflow scheme
  /// in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<DefaultWorkflow> getDraftDefaultWorkflow(int id) async {
    return DefaultWorkflow.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/draft/default',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Sets the default workflow for a workflow scheme's draft.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> updateDraftDefaultWorkflow(
      {required int id, required DefaultWorkflow body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/draft/default',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Resets the default workflow for a workflow scheme's draft. That is, the
  /// default workflow is set to Jira's system workflow (the *jira* workflow).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> deleteDraftDefaultWorkflow(int id) async {
    return WorkflowScheme.fromJson(await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/draft/default',
      pathParameters: {
        'id': '$id',
      },
    ));
  }

  /// Returns the issue type-workflow mapping for an issue type in a workflow
  /// scheme's draft.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeWorkflowMapping> getWorkflowSchemeDraftIssueType(
      {required int id, required String issueType}) async {
    return IssueTypeWorkflowMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}',
      pathParameters: {
        'id': '$id',
        'issueType': issueType,
      },
    ));
  }

  /// Sets the workflow for an issue type in a workflow scheme's draft.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> setWorkflowSchemeDraftIssueType(
      {required int id,
      required String issueType,
      required IssueTypeWorkflowMapping body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}',
      pathParameters: {
        'id': '$id',
        'issueType': issueType,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the issue type-workflow mapping for an issue type in a workflow
  /// scheme's draft.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> deleteWorkflowSchemeDraftIssueType(
      {required int id, required String issueType}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}',
      pathParameters: {
        'id': '$id',
        'issueType': issueType,
      },
    ));
  }

  /// Publishes a draft workflow scheme.
  ///
  /// Where the draft workflow includes new workflow statuses for an issue type,
  /// mappings are provided to update issues with the original workflow status
  /// to the new workflow status.
  ///
  /// This operation is [asynchronous](#async). Follow the `location` link in
  /// the response to determine the status of the task and use
  /// [Get task](#api-rest-api-3-task-taskId-get) to obtain updates.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> publishDraftWorkflowScheme(
      {required int id,
      bool? validateOnly,
      required PublishDraftWorkflowScheme body}) async {
    await _client.send(
      'post',
      'rest/api/3/workflowscheme/{id}/draft/publish',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (validateOnly != null) 'validateOnly': '$validateOnly',
      },
      body: body.toJson(),
    );
  }

  /// Returns the workflow-issue type mappings for a workflow scheme's draft.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypesWorkflowMapping> getDraftWorkflow(
      {required int id, String? workflowName}) async {
    return IssueTypesWorkflowMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/draft/workflow',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (workflowName != null) 'workflowName': workflowName,
      },
    ));
  }

  /// Sets the issue types for a workflow in a workflow scheme's draft. The
  /// workflow can also be set as the default workflow for the draft workflow
  /// scheme. Unmapped issues types are mapped to the default workflow.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> updateDraftWorkflowMapping(
      {required int id,
      required String workflowName,
      required IssueTypesWorkflowMapping body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/draft/workflow',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        'workflowName': workflowName,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the workflow-issue type mapping for a workflow in a workflow
  /// scheme's draft.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteDraftWorkflowMapping(
      {required int id, required String workflowName}) async {
    await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/draft/workflow',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        'workflowName': workflowName,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowSchemeProjectAssociationsApi {
  final ApiClient _client;

  WorkflowSchemeProjectAssociationsApi(this._client);

  /// Returns a list of the workflow schemes associated with a list of projects.
  /// Each returned workflow scheme includes a list of the requested projects
  /// associated with it. Any team-managed or non-existent projects in the
  /// request are ignored and no errors are returned.
  ///
  /// If the project is associated with the `Default Workflow Scheme` no ID is
  /// returned. This is because the way the `Default Workflow Scheme` is stored
  /// means it has no ID.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<ContainerOfWorkflowSchemeAssociations>
      getWorkflowSchemeProjectAssociations(List<int> projectId) async {
    return ContainerOfWorkflowSchemeAssociations.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/project',
      queryParameters: {
        'projectId': projectId.map((e) => '$e').join(','),
      },
    ));
  }

  /// Assigns a workflow scheme to a project. This operation is performed only
  /// when there are no issues in the project.
  ///
  /// Workflow schemes can only be assigned to classic projects.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> assignSchemeToProject(
      {required WorkflowSchemeProjectAssociation body}) async {
    return await _client.send(
      'put',
      'rest/api/3/workflowscheme/project',
      body: body.toJson(),
    );
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowSchemesApi {
  final ApiClient _client;

  WorkflowSchemesApi(this._client);

  /// Returns a [paginated](#pagination) list of all workflow schemes, not
  /// including draft workflow schemes.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanWorkflowScheme> getAllWorkflowSchemes(
      {int? startAt, int? maxResults}) async {
    return PageBeanWorkflowScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
      },
    ));
  }

  /// Creates a workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> createWorkflowScheme(
      {required WorkflowScheme body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'post',
      'rest/api/3/workflowscheme',
      body: body.toJson(),
    ));
  }

  /// Returns a workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> getWorkflowScheme(
      {required int id, bool? returnDraftIfExists}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (returnDraftIfExists != null)
          'returnDraftIfExists': '$returnDraftIfExists',
      },
    ));
  }

  /// Updates a workflow scheme, including the name, default workflow, issue
  /// type to project mappings, and more. If the workflow scheme is active (that
  /// is, being used by at least one project), then a draft workflow scheme is
  /// created or updated instead, provided that `updateDraftIfNeeded` is set to
  /// `true`.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> updateWorkflowScheme(
      {required int id, required WorkflowScheme body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a workflow scheme. Note that a workflow scheme cannot be deleted
  /// if it is active (that is, being used by at least one project).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<dynamic> deleteWorkflowScheme(int id) async {
    return await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}',
      pathParameters: {
        'id': '$id',
      },
    );
  }

  /// Returns the default workflow for a workflow scheme. The default workflow
  /// is the workflow that is assigned any issue types that have not been mapped
  /// to any other workflow. The default workflow has *All Unassigned Issue
  /// Types* listed in its issue types for the workflow scheme in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<DefaultWorkflow> getDefaultWorkflow(
      {required int id, bool? returnDraftIfExists}) async {
    return DefaultWorkflow.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/default',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (returnDraftIfExists != null)
          'returnDraftIfExists': '$returnDraftIfExists',
      },
    ));
  }

  /// Sets the default workflow for a workflow scheme.
  ///
  /// Note that active workflow schemes cannot be edited. If the workflow scheme
  /// is active, set `updateDraftIfNeeded` to `true` in the request object and a
  /// draft workflow scheme is created or updated with the new default workflow.
  /// The draft workflow scheme can be published in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> updateDefaultWorkflow(
      {required int id, required DefaultWorkflow body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/default',
      pathParameters: {
        'id': '$id',
      },
      body: body.toJson(),
    ));
  }

  /// Resets the default workflow for a workflow scheme. That is, the default
  /// workflow is set to Jira's system workflow (the *jira* workflow).
  ///
  /// Note that active workflow schemes cannot be edited. If the workflow scheme
  /// is active, set `updateDraftIfNeeded` to `true` and a draft workflow scheme
  /// is created or updated with the default workflow reset. The draft workflow
  /// scheme can be published in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> deleteDefaultWorkflow(
      {required int id, bool? updateDraftIfNeeded}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/default',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (updateDraftIfNeeded != null)
          'updateDraftIfNeeded': '$updateDraftIfNeeded',
      },
    ));
  }

  /// Returns the issue type-workflow mapping for an issue type in a workflow
  /// scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypeWorkflowMapping> getWorkflowSchemeIssueType(
      {required int id,
      required String issueType,
      bool? returnDraftIfExists}) async {
    return IssueTypeWorkflowMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/issuetype/{issueType}',
      pathParameters: {
        'id': '$id',
        'issueType': issueType,
      },
      queryParameters: {
        if (returnDraftIfExists != null)
          'returnDraftIfExists': '$returnDraftIfExists',
      },
    ));
  }

  /// Sets the workflow for an issue type in a workflow scheme.
  ///
  /// Note that active workflow schemes cannot be edited. If the workflow scheme
  /// is active, set `updateDraftIfNeeded` to `true` in the request body and a
  /// draft workflow scheme is created or updated with the new issue
  /// type-workflow mapping. The draft workflow scheme can be published in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> setWorkflowSchemeIssueType(
      {required int id,
      required String issueType,
      required IssueTypeWorkflowMapping body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/issuetype/{issueType}',
      pathParameters: {
        'id': '$id',
        'issueType': issueType,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the issue type-workflow mapping for an issue type in a workflow
  /// scheme.
  ///
  /// Note that active workflow schemes cannot be edited. If the workflow scheme
  /// is active, set `updateDraftIfNeeded` to `true` and a draft workflow scheme
  /// is created or updated with the issue type-workflow mapping deleted. The
  /// draft workflow scheme can be published in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> deleteWorkflowSchemeIssueType(
      {required int id,
      required String issueType,
      bool? updateDraftIfNeeded}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/issuetype/{issueType}',
      pathParameters: {
        'id': '$id',
        'issueType': issueType,
      },
      queryParameters: {
        if (updateDraftIfNeeded != null)
          'updateDraftIfNeeded': '$updateDraftIfNeeded',
      },
    ));
  }

  /// Returns the workflow-issue type mappings for a workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<IssueTypesWorkflowMapping> getWorkflow(
      {required int id,
      String? workflowName,
      bool? returnDraftIfExists}) async {
    return IssueTypesWorkflowMapping.fromJson(await _client.send(
      'get',
      'rest/api/3/workflowscheme/{id}/workflow',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        if (workflowName != null) 'workflowName': workflowName,
        if (returnDraftIfExists != null)
          'returnDraftIfExists': '$returnDraftIfExists',
      },
    ));
  }

  /// Sets the issue types for a workflow in a workflow scheme. The workflow can
  /// also be set as the default workflow for the workflow scheme. Unmapped
  /// issues types are mapped to the default workflow.
  ///
  /// Note that active workflow schemes cannot be edited. If the workflow scheme
  /// is active, set `updateDraftIfNeeded` to `true` in the request body and a
  /// draft workflow scheme is created or updated with the new workflow-issue
  /// types mappings. The draft workflow scheme can be published in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowScheme> updateWorkflowMapping(
      {required int id,
      required String workflowName,
      required IssueTypesWorkflowMapping body}) async {
    return WorkflowScheme.fromJson(await _client.send(
      'put',
      'rest/api/3/workflowscheme/{id}/workflow',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        'workflowName': workflowName,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes the workflow-issue type mapping for a workflow in a workflow
  /// scheme.
  ///
  /// Note that active workflow schemes cannot be edited. If the workflow scheme
  /// is active, set `updateDraftIfNeeded` to `true` and a draft workflow scheme
  /// is created or updated with the workflow-issue type mapping deleted. The
  /// draft workflow scheme can be published in Jira.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteWorkflowMapping(
      {required int id,
      required String workflowName,
      bool? updateDraftIfNeeded}) async {
    await _client.send(
      'delete',
      'rest/api/3/workflowscheme/{id}/workflow',
      pathParameters: {
        'id': '$id',
      },
      queryParameters: {
        'workflowName': workflowName,
        if (updateDraftIfNeeded != null)
          'updateDraftIfNeeded': '$updateDraftIfNeeded',
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowStatusCategoriesApi {
  final ApiClient _client;

  WorkflowStatusCategoriesApi(this._client);

  /// Returns a list of all status categories.
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<List<StatusCategory>> getStatusCategories() async {
    return (await _client.send(
      'get',
      'rest/api/3/statuscategory',
    ) as List<Object?>)
        .map((i) =>
            StatusCategory.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a status category. Status categories provided a mechanism for
  /// categorizing [statuses](#api-rest-api-3-status-idOrName-get).
  ///
  /// **[Permissions](#permissions) required:** Permission to access Jira.
  Future<StatusCategory> getStatusCategory(String idOrKey) async {
    return StatusCategory.fromJson(await _client.send(
      'get',
      'rest/api/3/statuscategory/{idOrKey}',
      pathParameters: {
        'idOrKey': idOrKey,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowStatusesApi {
  final ApiClient _client;

  WorkflowStatusesApi(this._client);

  /// Returns a list of all statuses associated with active workflows.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// **[Permissions](#permissions) required:** None.
  Future<List<StatusDetails>> getStatuses() async {
    return (await _client.send(
      'get',
      'rest/api/3/status',
    ) as List<Object?>)
        .map((i) =>
            StatusDetails.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Returns a status. The status must be associated with an active workflow to
  /// be returned.
  ///
  /// If a name is used on more than one status, only the status found first is
  /// returned. Therefore, identifying the status by its ID may be preferable.
  ///
  /// This operation can be accessed anonymously.
  ///
  /// [Permissions](#permissions) required: None.
  Future<StatusDetails> getStatus(String idOrName) async {
    return StatusDetails.fromJson(await _client.send(
      'get',
      'rest/api/3/status/{idOrName}',
      pathParameters: {
        'idOrName': idOrName,
      },
    ));
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowTransitionPropertiesApi {
  final ApiClient _client;

  WorkflowTransitionPropertiesApi(this._client);

  /// Returns the properties on a workflow transition. Transition properties are
  /// used to change the behavior of a transition. For more information, see
  /// [Transition properties](https://confluence.atlassian.com/x/zIhKLg#Advancedworkflowconfiguration-transitionproperties)
  /// and [Workflow properties](https://confluence.atlassian.com/x/JYlKLg).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowTransitionProperty> getWorkflowTransitionProperties(
      {required int transitionId,
      bool? includeReservedKeys,
      String? key,
      required String workflowName,
      String? workflowMode}) async {
    return WorkflowTransitionProperty.fromJson(await _client.send(
      'get',
      'rest/api/3/workflow/transitions/{transitionId}/properties',
      pathParameters: {
        'transitionId': '$transitionId',
      },
      queryParameters: {
        if (includeReservedKeys != null)
          'includeReservedKeys': '$includeReservedKeys',
        if (key != null) 'key': key,
        'workflowName': workflowName,
        if (workflowMode != null) 'workflowMode': workflowMode,
      },
    ));
  }

  /// Updates a workflow transition by changing the property value. Trying to
  /// update a property that does not exist results in a new property being
  /// added to the transition. Transition properties are used to change the
  /// behavior of a transition. For more information, see
  /// [Transition properties](https://confluence.atlassian.com/x/zIhKLg#Advancedworkflowconfiguration-transitionproperties)
  /// and [Workflow properties](https://confluence.atlassian.com/x/JYlKLg).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowTransitionProperty> updateWorkflowTransitionProperty(
      {required int transitionId,
      required String key,
      required String workflowName,
      String? workflowMode,
      required WorkflowTransitionProperty body}) async {
    return WorkflowTransitionProperty.fromJson(await _client.send(
      'put',
      'rest/api/3/workflow/transitions/{transitionId}/properties',
      pathParameters: {
        'transitionId': '$transitionId',
      },
      queryParameters: {
        'key': key,
        'workflowName': workflowName,
        if (workflowMode != null) 'workflowMode': workflowMode,
      },
      body: body.toJson(),
    ));
  }

  /// Adds a property to a workflow transition. Transition properties are used
  /// to change the behavior of a transition. For more information, see
  /// [Transition properties](https://confluence.atlassian.com/x/zIhKLg#Advancedworkflowconfiguration-transitionproperties)
  /// and [Workflow properties](https://confluence.atlassian.com/x/JYlKLg).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowTransitionProperty> createWorkflowTransitionProperty(
      {required int transitionId,
      required String key,
      required String workflowName,
      String? workflowMode,
      required WorkflowTransitionProperty body}) async {
    return WorkflowTransitionProperty.fromJson(await _client.send(
      'post',
      'rest/api/3/workflow/transitions/{transitionId}/properties',
      pathParameters: {
        'transitionId': '$transitionId',
      },
      queryParameters: {
        'key': key,
        'workflowName': workflowName,
        if (workflowMode != null) 'workflowMode': workflowMode,
      },
      body: body.toJson(),
    ));
  }

  /// Deletes a property from a workflow transition. Transition properties are
  /// used to change the behavior of a transition. For more information, see
  /// [Transition properties](https://confluence.atlassian.com/x/zIhKLg#Advancedworkflowconfiguration-transitionproperties)
  /// and [Workflow properties](https://confluence.atlassian.com/x/JYlKLg).
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteWorkflowTransitionProperty(
      {required int transitionId,
      required String key,
      required String workflowName,
      String? workflowMode}) async {
    await _client.send(
      'delete',
      'rest/api/3/workflow/transitions/{transitionId}/properties',
      pathParameters: {
        'transitionId': '$transitionId',
      },
      queryParameters: {
        'key': key,
        'workflowName': workflowName,
        if (workflowMode != null) 'workflowMode': workflowMode,
      },
    );
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowTransitionRulesApi {
  final ApiClient _client;

  WorkflowTransitionRulesApi(this._client);

  /// Returns a [paginated](#pagination) list of workflows with transition
  /// rules. The workflows can be filtered to return only those containing
  /// workflow transition rules:
  ///
  ///  *  of one or more transition rule types, such as
  /// [workflow post functions](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-post-function/).
  ///  *  matching one or more transition rule keys.
  ///
  /// Only workflows containing transition rules created by the calling
  /// [Connect](https://developer.atlassian.com/cloud/jira/platform/index/#connect-apps)
  /// or
  /// [Forge](https://developer.atlassian.com/cloud/jira/platform/index/#forge-apps)
  /// app are returned.
  ///
  /// Due to server-side optimizations, workflows with an empty list of rules
  /// may be returned; these workflows can be ignored.
  ///
  /// **[Permissions](#permissions) required:** Only
  /// [Connect](https://developer.atlassian.com/cloud/jira/platform/index/#connect-apps)
  /// or
  /// [Forge](https://developer.atlassian.com/cloud/jira/platform/index/#forge-apps)
  /// apps can use this operation.
  Future<PageBeanWorkflowTransitionRules>
      getWorkflowTransitionRuleConfigurations(
          {int? startAt,
          int? maxResults,
          required List<String> types,
          List<String>? keys,
          List<String>? workflowNames,
          List<String>? withTags,
          bool? draft,
          String? expand}) async {
    return PageBeanWorkflowTransitionRules.fromJson(await _client.send(
      'get',
      'rest/api/3/workflow/rule/config',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        'types': types.map((e) => e).join(','),
        if (keys != null) 'keys': keys.map((e) => e).join(','),
        if (workflowNames != null)
          'workflowNames': workflowNames.map((e) => e).join(','),
        if (withTags != null) 'withTags': withTags.map((e) => e).join(','),
        if (draft != null) 'draft': '$draft',
        if (expand != null) 'expand': expand,
      },
    ));
  }

  /// Updates configuration of workflow transition rules. The following rule
  /// types are supported:
  ///
  ///  *
  /// [post functions](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-post-function/)
  ///  *
  /// [conditions](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-condition/)
  ///  *
  /// [validators](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-validator/)
  ///
  /// Only rules created by the calling Connect app can be updated.
  ///
  /// To assist with app migration, this operation can be used to:
  ///
  ///  *  Disable a rule.
  ///  *  Add a `tag`. Use this to filter rules in the
  /// [Get workflow transition rule configurations](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-workflow-transition-rules/#api-rest-api-3-workflow-rule-config-get).
  ///
  /// Rules are enabled if the `disabled` parameter is not provided.
  ///
  /// **[Permissions](#permissions) required:** Only Connect apps can use this
  /// operation.
  Future<WorkflowTransitionRulesUpdateErrors>
      updateWorkflowTransitionRuleConfigurations(
          {required WorkflowTransitionRulesUpdate body}) async {
    return WorkflowTransitionRulesUpdateErrors.fromJson(await _client.send(
      'put',
      'rest/api/3/workflow/rule/config',
      body: body.toJson(),
    ));
  }

  /// Deletes workflow transition rules from one or more workflows. These rule
  /// types are supported:
  ///
  ///  *
  /// [post functions](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-post-function/)
  ///  *
  /// [conditions](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-condition/)
  ///  *
  /// [validators](https://developer.atlassian.com/cloud/jira/platform/modules/workflow-validator/)
  ///
  /// Only rules created by the calling Connect app can be deleted.
  ///
  /// **[Permissions](#permissions) required:** Only Connect apps can use this
  /// operation.
  Future<WorkflowTransitionRulesUpdateErrors>
      deleteWorkflowTransitionRuleConfigurations(
          {required WorkflowsWithTransitionRulesDetails body}) async {
    return WorkflowTransitionRulesUpdateErrors.fromJson(await _client.send(
      'put',
      'rest/api/3/workflow/rule/config/delete',
      body: body.toJson(),
    ));
  }
}

/// Jira Cloud platform REST API documentation

class WorkflowsApi {
  final ApiClient _client;

  WorkflowsApi(this._client);

  /// Returns all workflows in Jira or a workflow. Deprecated, use
  /// [Get workflows paginated](#api-rest-api-3-workflow-search-get).
  ///
  /// If the `workflowName` parameter is specified, the workflow is returned as
  /// an object (not in an array). Otherwise, an array of workflow objects is
  /// returned.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<List<DeprecatedWorkflow>> getAllWorkflows(
      {String? workflowName}) async {
    return (await _client.send(
      'get',
      'rest/api/3/workflow',
      queryParameters: {
        if (workflowName != null) 'workflowName': workflowName,
      },
    ) as List<Object?>)
        .map((i) =>
            DeprecatedWorkflow.fromJson(i as Map<String, Object?>? ?? const {}))
        .toList();
  }

  /// Creates a workflow. You can define transition rules using the shapes
  /// detailed in the following sections. If no transitional rules are specified
  /// the default system transition rules are used.
  ///
  /// #### Conditions ####
  ///
  /// Conditions enable workflow rules that govern whether a transition can
  /// execute.
  ///
  /// ##### Always false condition #####
  ///
  /// A condition that always fails.
  ///
  ///     {
  ///        "type": "AlwaysFalseCondition"
  ///      }
  ///
  /// ##### Block transition until approval #####
  ///
  /// A condition that blocks issue transition if there is a pending approval.
  ///
  ///     {
  ///        "type": "BlockInProgressApprovalCondition"
  ///      }
  ///
  /// ##### Compare number custom field condition #####
  ///
  /// A condition that allows transition if a comparison between a number custom
  /// field and a value is true.
  ///
  ///     {
  ///        "type": "CompareNumberCFCondition",
  ///        "configuration": {
  ///          "comparator": "=",
  ///          "fieldId": "customfield_10029",
  ///          "fieldValue": 2
  ///        }
  ///      }
  ///
  ///  *  `comparator` One of the supported comparator: `=`, `>`, and `<`.
  ///  *  `fieldId` The custom numeric field ID. Allowed field types:
  ///
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:float`
  ///      *  `com.pyxis.greenhopper.jira:jsw-story-points`
  ///  *  `fieldValue` The value for comparison.
  ///
  /// ##### Hide from user condition #####
  ///
  /// A condition that hides a transition from users. The transition can only be
  /// triggered from a workflow function or REST API operation.
  ///
  ///     {
  ///        "type": "RemoteOnlyCondition"
  ///      }
  ///
  /// ##### Only assignee condition #####
  ///
  /// A condition that allows only the assignee to execute a transition.
  ///
  ///     {
  ///        "type": "AllowOnlyAssignee"
  ///      }
  ///
  /// ##### Only Bamboo notifications workflow condition #####
  ///
  /// A condition that makes the transition available only to Bamboo build
  /// notifications.
  ///
  ///     {
  ///        "type": "OnlyBambooNotificationsCondition"
  ///      }
  ///
  /// ##### Only reporter condition #####
  ///
  /// A condition that allows only the reporter to execute a transition.
  ///
  ///     {
  ///        "type": "AllowOnlyReporter"
  ///      }
  ///
  /// ##### Permission condition #####
  ///
  /// A condition that allows only users with a permission to execute a
  /// transition.
  ///
  ///     {
  ///        "type": "PermissionCondition",
  ///        "configuration": {
  ///            "permissionKey": "BROWSE_PROJECTS"
  ///        }
  ///      }
  ///
  ///  *  `permissionKey` The permission required to perform the transition.
  /// Allowed values:
  /// [built-in](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-permission-schemes/#built-in-permissions)
  /// or app defined permissions.
  ///
  /// ##### Previous status condition #####
  ///
  /// A condition that allows a transition based on whether an issue has or has
  /// not transitioned through a status.
  ///
  ///     {
  ///        "type": "PreviousStatusCondition",
  ///        "configuration": {
  ///          "ignoreLoopTransitions": true,
  ///          "includeCurrentStatus": true,
  ///          "mostRecentStatusOnly": true,
  ///          "reverseCondition": true,
  ///          "previousStatus": {
  ///            "id": "5"
  ///          }
  ///        }
  ///      }
  ///
  /// By default this condition allows the transition if the status, as defined
  /// by its ID in the `previousStatus` object, matches any previous issue
  /// status, unless:
  ///
  ///  *  `ignoreLoopTransitions` is `true`, then loop transitions (from and to
  /// the same status) are ignored.
  ///  *  `includeCurrentStatus` is `true`, then the current issue status is
  /// also checked.
  ///  *  `mostRecentStatusOnly` is `true`, then only the issue's preceding
  /// status (the one immediately before the current status) is checked.
  ///  *  `reverseCondition` is `true`, then the status must not be present.
  ///
  /// ##### Separation of duties condition #####
  ///
  /// A condition that prevents a user to perform the transition, if the user
  /// has already performed a transition on the issue.
  ///
  ///     {
  ///        "type": "SeparationOfDutiesCondition",
  ///        "configuration": {
  ///          "fromStatus": {
  ///            "id": "5"
  ///          },
  ///          "toStatus": {
  ///            "id": "6"
  ///          }
  ///        }
  ///      }
  ///
  ///  *  `fromStatus` OPTIONAL. An object containing the ID of the source
  /// status of the transition that is blocked. If omitted any transition to
  /// `toStatus` is blocked.
  ///  *  `toStatus` An object containing the ID of the target status of the
  /// transition that is blocked.
  ///
  /// ##### Subtask blocking condition #####
  ///
  /// A condition that blocks transition on a parent issue if any of its
  /// subtasks are in any of one or more statuses.
  ///
  ///     {
  ///        "type": "SubTaskBlockingCondition",
  ///        "configuration": {
  ///          "statuses": [
  ///            {
  ///              "id": "1"
  ///            },
  ///            {
  ///              "id": "3"
  ///            }
  ///          ]
  ///        }
  ///      }
  ///
  ///  *  `statuses` A list of objects containing status IDs.
  ///
  /// ##### User is in any group condition #####
  ///
  /// A condition that allows users belonging to any group from a list of groups
  /// to execute a transition.
  ///
  ///     {
  ///        "type": "UserInAnyGroupCondition",
  ///        "configuration": {
  ///          "groups": [
  ///            "administrators",
  ///            "atlassian-addons-admin"
  ///          ]
  ///        }
  ///      }
  ///
  ///  *  `groups` A list of group names.
  ///
  /// ##### User is in any project role condition #####
  ///
  /// A condition that allows only users with at least one project roles from a
  /// list of project roles to execute a transition.
  ///
  ///     {
  ///        "type": "InAnyProjectRoleCondition",
  ///        "configuration": {
  ///          "projectRoles": [
  ///            {
  ///              "id": "10002"
  ///            },
  ///            {
  ///              "id": "10003"
  ///            },
  ///            {
  ///              "id": "10012"
  ///            },
  ///            {
  ///              "id": "10013"
  ///            }
  ///          ]
  ///        }
  ///      }
  ///
  ///  *  `projectRoles` A list of objects containing project role IDs.
  ///
  /// ##### User is in custom field condition #####
  ///
  /// A condition that allows only users listed in a given custom field to
  /// execute the transition.
  ///
  ///     {
  ///        "type": "UserIsInCustomFieldCondition",
  ///        "configuration": {
  ///          "allowUserInField": false,
  ///          "fieldId": "customfield_10010"
  ///        }
  ///      }
  ///
  ///  *  `allowUserInField` If `true` only a user who is listed in `fieldId`
  /// can perform the transition, otherwise, only a user who is not listed in
  /// `fieldId` can perform the transition.
  ///  *  `fieldId` The ID of the field containing the list of users.
  ///
  /// ##### User is in group condition #####
  ///
  /// A condition that allows users belonging to a group to execute a
  /// transition.
  ///
  ///     {
  ///        "type": "UserInGroupCondition",
  ///        "configuration": {
  ///          "group": "administrators"
  ///        }
  ///      }
  ///
  ///  *  `group` The name of the group.
  ///
  /// ##### User is in group custom field condition #####
  ///
  /// A condition that allows users belonging to a group specified in a custom
  /// field to execute a transition.
  ///
  ///     {
  ///        "type": "InGroupCFCondition",
  ///        "configuration": {
  ///          "fieldId": "customfield_10012"
  ///        }
  ///      }
  ///
  ///  *  `fieldId` The ID of the field. Allowed field types:
  ///
  ///      *
  /// `com.atlassian.jira.plugin.system.customfieldtypes:multigrouppicker`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:grouppicker`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:select`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:multiselect`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons`
  ///      *
  /// `com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes`
  ///      *  `com.pyxis.greenhopper.jira:gh-epic-status`
  ///
  /// ##### User is in project role condition #####
  ///
  /// A condition that allows users with a project role to execute a transition.
  ///
  ///     {
  ///        "type": "InProjectRoleCondition",
  ///        "configuration": {
  ///          "projectRole": {
  ///            "id": "10002"
  ///          }
  ///        }
  ///      }
  ///
  ///  *  `projectRole` An object containing the ID of a project role.
  ///
  /// ##### Value field condition #####
  ///
  /// A conditions that allows a transition to execute if the value of a field
  /// is equal to a constant value or simply set.
  ///
  ///     {
  ///        "type": "ValueFieldCondition",
  ///        "configuration": {
  ///          "fieldId": "assignee",
  ///          "fieldValue":
  /// "qm:6e1ecee6-8e64-4db6-8c85-916bb3275f51:54b56885-2bd2-4381-8239-78263442520f",
  ///          "comparisonType": "NUMBER",
  ///          "comparator": "="
  ///        }
  ///      }
  ///
  ///  *  `fieldId` The ID of a field used in the comparison.
  ///  *  `fieldValue` The expected value of the field.
  ///  *  `comparisonType` The type of the comparison. Allowed values: `STRING`,
  /// `NUMBER`, `DATE`, `DATE_WITHOUT_TIME`, or `OPTIONID`.
  ///  *  `comparator` One of the supported comparator: `>`, `>=`, `=`, `<=`,
  /// `<`, `!=`.
  ///
  /// **Notes:**
  ///
  ///  *  If you choose the comparison type `STRING`, only `=` and `!=` are
  /// valid options.
  ///  *  You may leave `fieldValue` empty when comparison type is `!=` to
  /// indicate that a value is required in the field.
  ///  *  For date fields without time format values as `yyyy-MM-dd`, and for
  /// those with time as `yyyy-MM-dd HH:mm`. For example, for July 16 2021 use
  /// `2021-07-16`, for 8:05 AM use `2021-07-16 08:05`, and for 4 PM:
  /// `2021-07-16 16:00`.
  ///
  /// #### Validators ####
  ///
  /// Validators check that any input made to the transition is valid before the
  /// transition is performed.
  ///
  /// ##### Date field validator #####
  ///
  /// A validator that compares two dates.
  ///
  ///     {
  ///        "type": "DateFieldValidator",
  ///        "configuration": {
  ///            "comparator": ">",
  ///            "date1": "updated",
  ///            "date2": "created",
  ///            "expression": "1d",
  ///            "includeTime": true
  ///          }
  ///      }
  ///
  ///  *  `comparator` One of the supported comparator: `>`, `>=`, `=`, `<=`,
  /// `<`, or `!=`.
  ///  *  `date1` The date field to validate. Allowed field types:
  ///
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:datepicker`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:datetime`
  ///      *  `com.atlassian.jpo:jpo-custom-field-baseline-end`
  ///      *  `com.atlassian.jpo:jpo-custom-field-baseline-start`
  ///      *  `duedate`
  ///      *  `created`
  ///      *  `updated`
  ///      *  `resolutiondate`
  ///  *  `date2` The second date field. Required, if `expression` is not
  /// passed. Allowed field types:
  ///
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:datepicker`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:datetime`
  ///      *  `com.atlassian.jpo:jpo-custom-field-baseline-end`
  ///      *  `com.atlassian.jpo:jpo-custom-field-baseline-start`
  ///      *  `duedate`
  ///      *  `created`
  ///      *  `updated`
  ///      *  `resolutiondate`
  ///  *  `expression` An expression specifying an offset. Required, if `date2`
  /// is not passed. Offsets are built with a number, with `-` as prefix for the
  /// past, and one of these time units: `d` for day, `w` for week, `m` for
  /// month, or `y` for year. For example, -2d means two days into the past and
  /// 1w means one week into the future. The `now` keyword enables a comparison
  /// with the current date.
  ///  *  `includeTime` If `true`, then the time part of the data is included
  /// for the comparison. If the field doesn't have a time part, 00:00:00 is
  /// used.
  ///
  /// ##### Windows date validator #####
  ///
  /// A validator that checks that a date falls on or after a reference date and
  /// before or on the reference date plus a number of days.
  ///
  ///     {
  ///        "type": "WindowsDateValidator",
  ///        "configuration": {
  ///            "date1": "customfield_10009",
  ///            "date2": "created",
  ///            "windowsDays": 5
  ///          }
  ///      }
  ///
  ///  *  `date1` The date field to validate. Allowed field types:
  ///
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:datepicker`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:datetime`
  ///      *  `com.atlassian.jpo:jpo-custom-field-baseline-end`
  ///      *  `com.atlassian.jpo:jpo-custom-field-baseline-start`
  ///      *  `duedate`
  ///      *  `created`
  ///      *  `updated`
  ///      *  `resolutiondate`
  ///  *  `date2` The reference date. Allowed field types:
  ///
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:datepicker`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:datetime`
  ///      *  `com.atlassian.jpo:jpo-custom-field-baseline-end`
  ///      *  `com.atlassian.jpo:jpo-custom-field-baseline-start`
  ///      *  `duedate`
  ///      *  `created`
  ///      *  `updated`
  ///      *  `resolutiondate`
  ///  *  `windowsDays` A positive integer indicating a number of days.
  ///
  /// ##### Field required validator #####
  ///
  /// A validator that checks fields are not empty. By default, if a field is
  /// not included in the current context it's ignored and not validated.
  ///
  ///     {
  ///          "type": "FieldRequiredValidator",
  ///          "configuration": {
  ///              "ignoreContext": true,
  ///              "errorMessage": "Hey",
  ///              "fieldIds": [
  ///                  "versions",
  ///                  "customfield_10037",
  ///                  "customfield_10003"
  ///              ]
  ///          }
  ///      }
  ///
  ///  *  `ignoreContext` If `true`, then the context is ignored and all the
  /// fields are validated.
  ///  *  `errorMessage` OPTIONAL. The error message displayed when one or more
  /// fields are empty. A default error message is shown if an error message is
  /// not provided.
  ///  *  `fieldIds` The list of fields to validate.
  ///
  /// ##### Field changed validator #####
  ///
  /// A validator that checks that a field value is changed. However, this
  /// validation can be ignored for users from a list of groups.
  ///
  ///     {
  ///          "type": "FieldChangedValidator",
  ///          "configuration": {
  ///              "fieldId": "comment",
  ///              "errorMessage": "Hey",
  ///              "exemptedGroups": [
  ///                  "administrators",
  ///                  "atlassian-addons-admin"
  ///              ]
  ///          }
  ///      }
  ///
  ///  *  `fieldId` The ID of a field.
  ///  *  `errorMessage` OPTIONAL. The error message displayed if the field is
  /// not changed. A default error message is shown if the error message is not
  /// provided.
  ///  *  `exemptedGroups` OPTIONAL. The list of groups.
  ///
  /// ##### Field has single value validator #####
  ///
  /// A validator that checks that a multi-select field has only one value.
  /// Optionally, the validation can ignore values copied from subtasks.
  ///
  ///     {
  ///          "type": "FieldHasSingleValueValidator",
  ///          "configuration": {
  ///              "fieldId": "attachment,
  ///              "excludeSubtasks": true
  ///          }
  ///      }
  ///
  ///  *  `fieldId` The ID of a field.
  ///  *  `excludeSubtasks` If `true`, then values copied from subtasks are
  /// ignored.
  ///
  /// ##### Parent status validator #####
  ///
  /// A validator that checks the status of the parent issue of a subtask. Ìf
  /// the issue is not a subtask, no validation is performed.
  ///
  ///     {
  ///          "type": "ParentStatusValidator",
  ///          "configuration": {
  ///              "parentStatuses": [
  ///                  {
  ///                    "id":"1"
  ///                  },
  ///                  {
  ///                    "id":"2"
  ///                  }
  ///              ]
  ///          }
  ///      }
  ///
  ///  *  `parentStatus` The list of required parent issue statuses.
  ///
  /// ##### Permission validator #####
  ///
  /// A validator that checks the user has a permission.
  ///
  ///     {
  ///        "type": "PermissionValidator",
  ///        "configuration": {
  ///            "permissionKey": "ADMINISTER_PROJECTS"
  ///        }
  ///      }
  ///
  ///  *  `permissionKey` The permission required to perform the transition.
  /// Allowed values:
  /// [built-in](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-permission-schemes/#built-in-permissions)
  /// or app defined permissions.
  ///
  /// ##### Previous status validator #####
  ///
  /// A validator that checks if the issue has held a status.
  ///
  ///     {
  ///        "type": "PreviousStatusValidator",
  ///        "configuration": {
  ///            "mostRecentStatusOnly": false,
  ///            "previousStatus": {
  ///                "id": "15"
  ///            }
  ///        }
  ///      }
  ///
  ///  *  `mostRecentStatusOnly` If `true`, then only the issue's preceding
  /// status (the one immediately before the current status) is checked.
  ///  *  `previousStatus` An object containing the ID of an issue status.
  ///
  /// ##### Regular expression validator #####
  ///
  /// A validator that checks the content of a field against a regular
  /// expression.
  ///
  ///     {
  ///        "type": "RegexpFieldValidator",
  ///        "configuration": {
  ///            "regExp": "[0-9]",
  ///            "fieldId": "customfield_10029"
  ///        }
  ///      }
  ///
  ///  *  `regExp`A regular expression.
  ///  *  `fieldId` The ID of a field. Allowed field types:
  ///
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:select`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:multiselect`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons`
  ///      *
  /// `com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:textarea`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:textfield`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:url`
  ///      *  `com.atlassian.jira.plugin.system.customfieldtypes:float`
  ///      *  `com.pyxis.greenhopper.jira:jsw-story-points`
  ///      *  `com.pyxis.greenhopper.jira:gh-epic-status`
  ///      *  `description`
  ///      *  `summary`
  ///
  /// ##### User permission validator #####
  ///
  /// A validator that checks if a user has a permission. Obsolete. You may
  /// encounter this validator when getting transition rules and can pass it
  /// when updating or creating rules, for example, when you want to duplicate
  /// the rules from a workflow on a new workflow.
  ///
  ///     {
  ///          "type": "UserPermissionValidator",
  ///          "configuration": {
  ///              "permissionKey": "BROWSE_PROJECTS",
  ///              "nullAllowed": false,
  ///              "username": "TestUser"
  ///          }
  ///      }
  ///
  ///  *  `permissionKey` The permission to be validated. Allowed values:
  /// [built-in](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-permission-schemes/#built-in-permissions)
  /// or app defined permissions.
  ///  *  `nullAllowed` If `true`, allows the transition when `username` is
  /// empty.
  ///  *  `username` The username to validate against the `permissionKey`.
  ///
  /// #### Post functions ####
  ///
  /// Post functions carry out any additional processing required after a Jira
  /// workflow transition is executed.
  ///
  /// ##### Fire issue event function #####
  ///
  /// A post function that fires an event that is processed by the listeners.
  ///
  ///     {
  ///        "type": "FireIssueEventFunction",
  ///        "configuration": {
  ///          "event": {
  ///            "id":"1"
  ///          }
  ///        }
  ///      }
  ///
  /// **Note:** If provided, this post function overrides the default
  /// `FireIssueEventFunction`. Can be included once in a transition.
  ///
  ///  *  `event` An object containing the ID of the issue event.
  ///
  /// ##### Update issue status #####
  ///
  /// A post function that sets issue status to the linked status of the
  /// destination workflow status.
  ///
  ///     {
  ///        "type": "UpdateIssueStatusFunction"
  ///      }
  ///
  /// **Note:** This post function is a default function in global and directed
  /// transitions. It can only be added to the initial transition and can only
  /// be added once.
  ///
  /// ##### Create comment #####
  ///
  /// A post function that adds a comment entered during the transition to an
  /// issue.
  ///
  ///     {
  ///        "type": "CreateCommentFunction"
  ///      }
  ///
  /// **Note:** This post function is a default function in global and directed
  /// transitions. It can only be added to the initial transition and can only
  /// be added once.
  ///
  /// ##### Store issue #####
  ///
  /// A post function that stores updates to an issue.
  ///
  ///     {
  ///        "type": "IssueStoreFunction"
  ///      }
  ///
  /// **Note:** This post function can only be added to the initial transition
  /// and can only be added once.
  ///
  /// ##### Assign to current user function #####
  ///
  /// A post function that assigns the issue to the current user if the current
  /// user has the `ASSIGNABLE_USER` permission.
  ///
  ///     {
  ///          "type": "AssignToCurrentUserFunction"
  ///      }
  ///
  /// **Note:** This post function can be included once in a transition.
  ///
  /// ##### Assign to lead function #####
  ///
  /// A post function that assigns the issue to the project or component lead
  /// developer.
  ///
  ///     {
  ///          "type": "AssignToLeadFunction"
  ///      }
  ///
  /// **Note:** This post function can be included once in a transition.
  ///
  /// ##### Assign to reporter function #####
  ///
  /// A post function that assigns the issue to the reporter.
  ///
  ///     {
  ///          "type": "AssignToReporterFunction"
  ///      }
  ///
  /// **Note:** This post function can be included once in a transition.
  ///
  /// ##### Clear field value function #####
  ///
  /// A post function that clears the value from a field.
  ///
  ///     {
  ///        "type": "ClearFieldValuePostFunction",
  ///        "configuration": {
  ///          "fieldId": "assignee"
  ///        }
  ///      }
  ///
  ///  *  `fieldId` The ID of the field.
  ///
  /// ##### Copy value from other field function #####
  ///
  /// A post function that copies the value of one field to another, either
  /// within an issue or from parent to subtask.
  ///
  ///     {
  ///        "type": "CopyValueFromOtherFieldPostFunction",
  ///        "configuration": {
  ///          "sourceFieldId": "assignee",
  ///          "destinationFieldId": "creator",
  ///          "copyType": "same"
  ///        }
  ///      }
  ///
  ///  *  `sourceFieldId` The ID of the source field.
  ///  *  `destinationFieldId` The ID of the destination field.
  ///  *  `copyType` Use `same` to copy the value from a field inside the issue,
  /// or `parent` to copy the value from the parent issue.
  ///
  /// ##### Create Crucible review workflow function #####
  ///
  /// A post function that creates a Crucible review for all unreviewed code for
  /// the issue.
  ///
  ///     {
  ///          "type": "CreateCrucibleReviewWorkflowFunction"
  ///      }
  ///
  /// **Note:** This post function can be included once in a transition.
  ///
  /// ##### Set issue security level based on user's project role function #####
  ///
  /// A post function that sets the issue's security level if the current user
  /// has a project role.
  ///
  ///     {
  ///        "type": "SetIssueSecurityFromRoleFunction",
  ///        "configuration": {
  ///          "projectRole": {
  ///              "id":"10002"
  ///          },
  ///          "issueSecurityLevel": {
  ///              "id":"10000"
  ///          }
  ///        }
  ///      }
  ///
  ///  *  `projectRole` An object containing the ID of the project role.
  ///  *  `issueSecurityLevel` OPTIONAL. The object containing the ID of the
  /// security level. If not passed, then the security level is set to `none`.
  ///
  /// ##### Trigger a webhook function #####
  ///
  /// A post function that triggers a webhook.
  ///
  ///     {
  ///        "type": "TriggerWebhookFunction",
  ///        "configuration": {
  ///          "webhook": {
  ///            "id": "1"
  ///          }
  ///        }
  ///      }
  ///
  ///  *  `webhook` An object containing the ID of the webhook listener to
  /// trigger.
  ///
  /// ##### Update issue custom field function #####
  ///
  /// A post function that updates the content of an issue custom field.
  ///
  ///     {
  ///        "type": "UpdateIssueCustomFieldPostFunction",
  ///        "configuration": {
  ///          "mode": "append",
  ///          "fieldId": "customfield_10003",
  ///          "fieldValue": "yikes"
  ///        }
  ///      }
  ///
  ///  *  `mode` Use `replace` to override the field content with `fieldValue`
  /// or `append` to add `fieldValue` to the end of the field content.
  ///  *  `fieldId` The ID of the field.
  ///  *  `fieldValue` The update content.
  ///
  /// ##### Update issue field function #####
  ///
  /// A post function that updates a simple issue field.
  ///
  ///     {
  ///        "type": "UpdateIssueFieldFunction",
  ///        "configuration": {
  ///          "fieldId": "assignee",
  ///          "fieldValue": "5f0c277e70b8a90025a00776"
  ///        }
  ///      }
  ///
  ///  *  `fieldId` The ID of the field. Allowed field types:
  ///
  ///      *  `assignee`
  ///      *  `description`
  ///      *  `environment`
  ///      *  `priority`
  ///      *  `resolution`
  ///      *  `summary`
  ///      *  `timeoriginalestimate`
  ///      *  `timeestimate`
  ///      *  `timespent`
  ///  *  `fieldValue` The update value.
  ///  *  If the `fieldId` is `assignee`, the `fieldValue` should be one of
  /// these values:
  ///
  ///      *  an account ID.
  ///      *  `automatic`.
  ///      *  a blank string, which sets the value to `unassigned`.
  ///
  /// #### Connect rules ####
  ///
  /// Connect rules are conditions, validators, and post functions of a
  /// transition that are registered by Connect apps. To create a rule
  /// registered by the app, the app must be enabled and the rule's module must
  /// exist.
  ///
  ///     {
  ///        "type": "appKey__moduleKey",
  ///        "configuration": {
  ///          "value":"{"isValid":"true"}"
  ///        }
  ///      }
  ///
  ///  *  `type` A Connect rule key in a form of `appKey__moduleKey`.
  ///  *  `value` The stringified JSON configuration of a Connect rule.
  ///
  /// #### Forge rules ####
  ///
  /// Forge transition rules are not yet supported.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<WorkflowIDs> createWorkflow(
      {required CreateWorkflowDetails body}) async {
    return WorkflowIDs.fromJson(await _client.send(
      'post',
      'rest/api/3/workflow',
      body: body.toJson(),
    ));
  }

  /// Returns a [paginated](#pagination) list of published classic workflows.
  /// When workflow names are specified, details of those workflows are
  /// returned. Otherwise, all published classic workflows are returned.
  ///
  /// This operation does not return next-gen workflows.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<PageBeanWorkflow> getWorkflowsPaginated(
      {int? startAt,
      int? maxResults,
      List<String>? workflowName,
      String? expand,
      String? queryString,
      String? orderBy,
      bool? isActive}) async {
    return PageBeanWorkflow.fromJson(await _client.send(
      'get',
      'rest/api/3/workflow/search',
      queryParameters: {
        if (startAt != null) 'startAt': '$startAt',
        if (maxResults != null) 'maxResults': '$maxResults',
        if (workflowName != null)
          'workflowName': workflowName.map((e) => e).join(','),
        if (expand != null) 'expand': expand,
        if (queryString != null) 'queryString': queryString,
        if (orderBy != null) 'orderBy': orderBy,
        if (isActive != null) 'isActive': '$isActive',
      },
    ));
  }

  /// Deletes a workflow.
  ///
  /// The workflow cannot be deleted if it is:
  ///
  ///  *  an active workflow.
  ///  *  a system workflow.
  ///  *  associated with any workflow scheme.
  ///  *  associated with any draft workflow scheme.
  ///
  /// **[Permissions](#permissions) required:** *Administer Jira*
  /// [global permission](https://confluence.atlassian.com/x/x4dKLg).
  Future<void> deleteInactiveWorkflow(String entityId) async {
    await _client.send(
      'delete',
      'rest/api/3/workflow/{entityId}',
      pathParameters: {
        'entityId': entityId,
      },
    );
  }
}

class ActorInputBean {
  /// The name of the group to add as a default actor. This parameter cannot be
  /// used with the `groupId` parameter. As a group's name can change,use of
  /// `groupId` is recommended. This parameter accepts a comma-separated list.
  /// For example, `"group":["project-admin", "jira-developers"]`.
  final List<String> group;

  /// The ID of the group to add as a default actor. This parameter cannot be
  /// used with the `group` parameter This parameter accepts a comma-separated
  /// list. For example,
  /// `"groupId":["77f6ab39-e755-4570-a6ae-2d7a8df0bcb8", "0c011f85-69ed-49c4-a801-3b18d0f771bc"]`.
  final List<String> groupId;

  /// The account IDs of the users to add as default actors. This parameter
  /// accepts a comma-separated list. For example,
  /// `"user":["5b10a2844c20165700ede21g", "5b109f2e9729b51b54dc274d"]`.
  final List<String> user;

  ActorInputBean(
      {List<String>? group, List<String>? groupId, List<String>? user})
      : group = group ?? [],
        groupId = groupId ?? [],
        user = user ?? [];

  factory ActorInputBean.fromJson(Map<String, Object?> json) {
    return ActorInputBean(
      group: (json[r'group'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      groupId: (json[r'groupId'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      user: (json[r'user'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var group = this.group;
    var groupId = this.groupId;
    var user = this.user;

    final json = <String, Object?>{};
    json[r'group'] = group;
    json[r'groupId'] = groupId;
    json[r'user'] = user;
    return json;
  }

  ActorInputBean copyWith(
      {List<String>? group, List<String>? groupId, List<String>? user}) {
    return ActorInputBean(
      group: group ?? this.group,
      groupId: groupId ?? this.groupId,
      user: user ?? this.user,
    );
  }
}

class ActorsMap {
  /// The name of the group to add. This parameter cannot be used with the
  /// `groupId` parameter. As a group's name can change, use of `groupId` is
  /// recommended.
  final List<String> group;

  /// The ID of the group to add. This parameter cannot be used with the `group`
  /// parameter.
  final List<String> groupId;

  /// The user account ID of the user to add.
  final List<String> user;

  ActorsMap({List<String>? group, List<String>? groupId, List<String>? user})
      : group = group ?? [],
        groupId = groupId ?? [],
        user = user ?? [];

  factory ActorsMap.fromJson(Map<String, Object?> json) {
    return ActorsMap(
      group: (json[r'group'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      groupId: (json[r'groupId'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      user: (json[r'user'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var group = this.group;
    var groupId = this.groupId;
    var user = this.user;

    final json = <String, Object?>{};
    json[r'group'] = group;
    json[r'groupId'] = groupId;
    json[r'user'] = user;
    return json;
  }

  ActorsMap copyWith(
      {List<String>? group, List<String>? groupId, List<String>? user}) {
    return ActorsMap(
      group: group ?? this.group,
      groupId: groupId ?? this.groupId,
      user: user ?? this.user,
    );
  }
}

class AddFieldBean {
  /// The ID of the field to add.
  final String fieldId;

  AddFieldBean({required this.fieldId});

  factory AddFieldBean.fromJson(Map<String, Object?> json) {
    return AddFieldBean(
      fieldId: json[r'fieldId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var fieldId = this.fieldId;

    final json = <String, Object?>{};
    json[r'fieldId'] = fieldId;
    return json;
  }

  AddFieldBean copyWith({String? fieldId}) {
    return AddFieldBean(
      fieldId: fieldId ?? this.fieldId,
    );
  }
}

class AddGroupBean {
  /// The name of the group.
  final String name;

  AddGroupBean({required this.name});

  factory AddGroupBean.fromJson(Map<String, Object?> json) {
    return AddGroupBean(
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;

    final json = <String, Object?>{};
    json[r'name'] = name;
    return json;
  }

  AddGroupBean copyWith({String? name}) {
    return AddGroupBean(
      name: name ?? this.name,
    );
  }
}

/// Details of notifications which should be added to the notification scheme.
class AddNotificationsDetails {
  /// The list of notifications which should be added to the notification
  /// scheme.
  final List<NotificationSchemeEventDetails> notificationSchemeEvents;

  AddNotificationsDetails({required this.notificationSchemeEvents});

  factory AddNotificationsDetails.fromJson(Map<String, Object?> json) {
    return AddNotificationsDetails(
      notificationSchemeEvents:
          (json[r'notificationSchemeEvents'] as List<Object?>?)
                  ?.map((i) => NotificationSchemeEventDetails.fromJson(
                      i as Map<String, Object?>? ?? const {}))
                  .toList() ??
              [],
    );
  }

  Map<String, Object?> toJson() {
    var notificationSchemeEvents = this.notificationSchemeEvents;

    final json = <String, Object?>{};
    json[r'notificationSchemeEvents'] =
        notificationSchemeEvents.map((i) => i.toJson()).toList();
    return json;
  }

  AddNotificationsDetails copyWith(
      {List<NotificationSchemeEventDetails>? notificationSchemeEvents}) {
    return AddNotificationsDetails(
      notificationSchemeEvents:
          notificationSchemeEvents ?? this.notificationSchemeEvents,
    );
  }
}

class AddSecuritySchemeLevelsRequestBean {
  /// The list of scheme levels which should be added to the security scheme.
  final List<SecuritySchemeLevelBean> levels;

  AddSecuritySchemeLevelsRequestBean({List<SecuritySchemeLevelBean>? levels})
      : levels = levels ?? [];

  factory AddSecuritySchemeLevelsRequestBean.fromJson(
      Map<String, Object?> json) {
    return AddSecuritySchemeLevelsRequestBean(
      levels: (json[r'levels'] as List<Object?>?)
              ?.map((i) => SecuritySchemeLevelBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var levels = this.levels;

    final json = <String, Object?>{};
    json[r'levels'] = levels.map((i) => i.toJson()).toList();
    return json;
  }

  AddSecuritySchemeLevelsRequestBean copyWith(
      {List<SecuritySchemeLevelBean>? levels}) {
    return AddSecuritySchemeLevelsRequestBean(
      levels: levels ?? this.levels,
    );
  }
}

/// Announcement banner configuration.
class AnnouncementBannerConfiguration {
  /// Hash of the banner data. The client detects updates by comparing hash IDs.
  final String? hashId;

  /// Flag indicating if the announcement banner can be dismissed by the user.
  final bool isDismissible;

  /// Flag indicating if the announcement banner is enabled or not.
  final bool isEnabled;

  /// The text on the announcement banner.
  final String? message;

  /// Visibility of the announcement banner.
  final AnnouncementBannerConfigurationVisibility? visibility;

  AnnouncementBannerConfiguration(
      {this.hashId,
      bool? isDismissible,
      bool? isEnabled,
      this.message,
      this.visibility})
      : isDismissible = isDismissible ?? false,
        isEnabled = isEnabled ?? false;

  factory AnnouncementBannerConfiguration.fromJson(Map<String, Object?> json) {
    return AnnouncementBannerConfiguration(
      hashId: json[r'hashId'] as String?,
      isDismissible: json[r'isDismissible'] as bool? ?? false,
      isEnabled: json[r'isEnabled'] as bool? ?? false,
      message: json[r'message'] as String?,
      visibility: json[r'visibility'] != null
          ? AnnouncementBannerConfigurationVisibility.fromValue(
              json[r'visibility']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var hashId = this.hashId;
    var isDismissible = this.isDismissible;
    var isEnabled = this.isEnabled;
    var message = this.message;
    var visibility = this.visibility;

    final json = <String, Object?>{};
    if (hashId != null) {
      json[r'hashId'] = hashId;
    }
    json[r'isDismissible'] = isDismissible;
    json[r'isEnabled'] = isEnabled;
    if (message != null) {
      json[r'message'] = message;
    }
    if (visibility != null) {
      json[r'visibility'] = visibility.value;
    }
    return json;
  }

  AnnouncementBannerConfiguration copyWith(
      {String? hashId,
      bool? isDismissible,
      bool? isEnabled,
      String? message,
      AnnouncementBannerConfigurationVisibility? visibility}) {
    return AnnouncementBannerConfiguration(
      hashId: hashId ?? this.hashId,
      isDismissible: isDismissible ?? this.isDismissible,
      isEnabled: isEnabled ?? this.isEnabled,
      message: message ?? this.message,
      visibility: visibility ?? this.visibility,
    );
  }
}

class AnnouncementBannerConfigurationVisibility {
  static const public = AnnouncementBannerConfigurationVisibility._('PUBLIC');
  static const private = AnnouncementBannerConfigurationVisibility._('PRIVATE');

  static const values = [
    public,
    private,
  ];
  final String value;

  const AnnouncementBannerConfigurationVisibility._(this.value);

  static AnnouncementBannerConfigurationVisibility fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => AnnouncementBannerConfigurationVisibility._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Configuration of the announcement banner.
class AnnouncementBannerConfigurationUpdate {
  /// Flag indicating if the announcement banner can be dismissed by the user.
  final bool isDismissible;

  /// Flag indicating if the announcement banner is enabled or not.
  final bool isEnabled;

  /// The text on the announcement banner.
  final String? message;

  /// Visibility of the announcement banner. Can be public or private.
  final String? visibility;

  AnnouncementBannerConfigurationUpdate(
      {bool? isDismissible, bool? isEnabled, this.message, this.visibility})
      : isDismissible = isDismissible ?? false,
        isEnabled = isEnabled ?? false;

  factory AnnouncementBannerConfigurationUpdate.fromJson(
      Map<String, Object?> json) {
    return AnnouncementBannerConfigurationUpdate(
      isDismissible: json[r'isDismissible'] as bool? ?? false,
      isEnabled: json[r'isEnabled'] as bool? ?? false,
      message: json[r'message'] as String?,
      visibility: json[r'visibility'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var isDismissible = this.isDismissible;
    var isEnabled = this.isEnabled;
    var message = this.message;
    var visibility = this.visibility;

    final json = <String, Object?>{};
    json[r'isDismissible'] = isDismissible;
    json[r'isEnabled'] = isEnabled;
    if (message != null) {
      json[r'message'] = message;
    }
    if (visibility != null) {
      json[r'visibility'] = visibility;
    }
    return json;
  }

  AnnouncementBannerConfigurationUpdate copyWith(
      {bool? isDismissible,
      bool? isEnabled,
      String? message,
      String? visibility}) {
    return AnnouncementBannerConfigurationUpdate(
      isDismissible: isDismissible ?? this.isDismissible,
      isEnabled: isEnabled ?? this.isEnabled,
      message: message ?? this.message,
      visibility: visibility ?? this.visibility,
    );
  }
}

/// A workflow transition rule.
class AppWorkflowTransitionRule {
  final RuleConfiguration configuration;

  /// The ID of the transition rule.
  final String id;

  /// The key of the rule, as defined in the Connect or the Forge app
  /// descriptor.
  final String key;
  final WorkflowTransition? transition;

  AppWorkflowTransitionRule(
      {required this.configuration,
      required this.id,
      required this.key,
      this.transition});

  factory AppWorkflowTransitionRule.fromJson(Map<String, Object?> json) {
    return AppWorkflowTransitionRule(
      configuration: RuleConfiguration.fromJson(
          json[r'configuration'] as Map<String, Object?>? ?? const {}),
      id: json[r'id'] as String? ?? '',
      key: json[r'key'] as String? ?? '',
      transition: json[r'transition'] != null
          ? WorkflowTransition.fromJson(
              json[r'transition']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var configuration = this.configuration;
    var id = this.id;
    var key = this.key;
    var transition = this.transition;

    final json = <String, Object?>{};
    json[r'configuration'] = configuration.toJson();
    json[r'id'] = id;
    json[r'key'] = key;
    if (transition != null) {
      json[r'transition'] = transition.toJson();
    }
    return json;
  }

  AppWorkflowTransitionRule copyWith(
      {RuleConfiguration? configuration,
      String? id,
      String? key,
      WorkflowTransition? transition}) {
    return AppWorkflowTransitionRule(
      configuration: configuration ?? this.configuration,
      id: id ?? this.id,
      key: key ?? this.key,
      transition: transition ?? this.transition,
    );
  }
}

/// The application the linked item is in.
class Application {
  /// The name of the application. Used in conjunction with the (remote) object
  /// icon title to display a tooltip for the link's icon. The tooltip takes the
  /// format "[application name] icon title". Blank items are excluded from the
  /// tooltip title. If both items are blank, the icon tooltop displays as "Web
  /// Link". Grouping and sorting of links may place links without an
  /// application name last.
  final String? name;

  /// The name-spaced type of the application, used by registered rendering
  /// apps.
  final String? type;

  Application({this.name, this.type});

  factory Application.fromJson(Map<String, Object?> json) {
    return Application(
      name: json[r'name'] as String?,
      type: json[r'type'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var name = this.name;
    var type = this.type;

    final json = <String, Object?>{};
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type;
    }
    return json;
  }

  Application copyWith({String? name, String? type}) {
    return Application(
      name: name ?? this.name,
      type: type ?? this.type,
    );
  }
}

/// Details of an application property.
class ApplicationProperty {
  /// The allowed values, if applicable.
  final List<String> allowedValues;

  /// The default value of the application property.
  final String? defaultValue;

  /// The description of the application property.
  final String? desc;
  final String? example;

  /// The ID of the application property. The ID and key are the same.
  final String? id;

  /// The key of the application property. The ID and key are the same.
  final String? key;

  /// The name of the application property.
  final String? name;

  /// The data type of the application property.
  final String? type;

  /// The new value.
  final String? value;

  ApplicationProperty(
      {List<String>? allowedValues,
      this.defaultValue,
      this.desc,
      this.example,
      this.id,
      this.key,
      this.name,
      this.type,
      this.value})
      : allowedValues = allowedValues ?? [];

  factory ApplicationProperty.fromJson(Map<String, Object?> json) {
    return ApplicationProperty(
      allowedValues: (json[r'allowedValues'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      defaultValue: json[r'defaultValue'] as String?,
      desc: json[r'desc'] as String?,
      example: json[r'example'] as String?,
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      type: json[r'type'] as String?,
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var allowedValues = this.allowedValues;
    var defaultValue = this.defaultValue;
    var desc = this.desc;
    var example = this.example;
    var id = this.id;
    var key = this.key;
    var name = this.name;
    var type = this.type;
    var value = this.value;

    final json = <String, Object?>{};
    json[r'allowedValues'] = allowedValues;
    if (defaultValue != null) {
      json[r'defaultValue'] = defaultValue;
    }
    if (desc != null) {
      json[r'desc'] = desc;
    }
    if (example != null) {
      json[r'example'] = example;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  ApplicationProperty copyWith(
      {List<String>? allowedValues,
      String? defaultValue,
      String? desc,
      String? example,
      String? id,
      String? key,
      String? name,
      String? type,
      String? value}) {
    return ApplicationProperty(
      allowedValues: allowedValues ?? this.allowedValues,
      defaultValue: defaultValue ?? this.defaultValue,
      desc: desc ?? this.desc,
      example: example ?? this.example,
      id: id ?? this.id,
      key: key ?? this.key,
      name: name ?? this.name,
      type: type ?? this.type,
      value: value ?? this.value,
    );
  }
}

/// Details of an application role.
class ApplicationRole {
  /// The groups that are granted default access for this application role. As a
  /// group's name can change, use of `defaultGroupsDetails` is recommended to
  /// identify a groups.
  final List<String> defaultGroups;

  /// The groups that are granted default access for this application role.
  final List<GroupName> defaultGroupsDetails;

  /// Deprecated.
  final bool defined;

  /// The groups associated with the application role.
  final List<GroupName> groupDetails;

  /// The groups associated with the application role. As a group's name can
  /// change, use of `groupDetails` is recommended to identify a groups.
  final List<String> groups;
  final bool hasUnlimitedSeats;

  /// The key of the application role.
  final String? key;

  /// The display name of the application role.
  final String? name;

  /// The maximum count of users on your license.
  final int? numberOfSeats;

  /// Indicates if the application role belongs to Jira platform (`jira-core`).
  final bool platform;

  /// The count of users remaining on your license.
  final int? remainingSeats;

  /// Determines whether this application role should be selected by default on
  /// user creation.
  final bool selectedByDefault;

  /// The number of users counting against your license.
  final int? userCount;

  /// The [type of users](https://confluence.atlassian.com/x/lRW3Ng) being
  /// counted against your license.
  final String? userCountDescription;

  ApplicationRole(
      {List<String>? defaultGroups,
      List<GroupName>? defaultGroupsDetails,
      bool? defined,
      List<GroupName>? groupDetails,
      List<String>? groups,
      bool? hasUnlimitedSeats,
      this.key,
      this.name,
      this.numberOfSeats,
      bool? platform,
      this.remainingSeats,
      bool? selectedByDefault,
      this.userCount,
      this.userCountDescription})
      : defaultGroups = defaultGroups ?? [],
        defaultGroupsDetails = defaultGroupsDetails ?? [],
        defined = defined ?? false,
        groupDetails = groupDetails ?? [],
        groups = groups ?? [],
        hasUnlimitedSeats = hasUnlimitedSeats ?? false,
        platform = platform ?? false,
        selectedByDefault = selectedByDefault ?? false;

  factory ApplicationRole.fromJson(Map<String, Object?> json) {
    return ApplicationRole(
      defaultGroups: (json[r'defaultGroups'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      defaultGroupsDetails: (json[r'defaultGroupsDetails'] as List<Object?>?)
              ?.map((i) =>
                  GroupName.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      defined: json[r'defined'] as bool? ?? false,
      groupDetails: (json[r'groupDetails'] as List<Object?>?)
              ?.map((i) =>
                  GroupName.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      groups: (json[r'groups'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      hasUnlimitedSeats: json[r'hasUnlimitedSeats'] as bool? ?? false,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      numberOfSeats: (json[r'numberOfSeats'] as num?)?.toInt(),
      platform: json[r'platform'] as bool? ?? false,
      remainingSeats: (json[r'remainingSeats'] as num?)?.toInt(),
      selectedByDefault: json[r'selectedByDefault'] as bool? ?? false,
      userCount: (json[r'userCount'] as num?)?.toInt(),
      userCountDescription: json[r'userCountDescription'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var defaultGroups = this.defaultGroups;
    var defaultGroupsDetails = this.defaultGroupsDetails;
    var defined = this.defined;
    var groupDetails = this.groupDetails;
    var groups = this.groups;
    var hasUnlimitedSeats = this.hasUnlimitedSeats;
    var key = this.key;
    var name = this.name;
    var numberOfSeats = this.numberOfSeats;
    var platform = this.platform;
    var remainingSeats = this.remainingSeats;
    var selectedByDefault = this.selectedByDefault;
    var userCount = this.userCount;
    var userCountDescription = this.userCountDescription;

    final json = <String, Object?>{};
    json[r'defaultGroups'] = defaultGroups;
    json[r'defaultGroupsDetails'] =
        defaultGroupsDetails.map((i) => i.toJson()).toList();
    json[r'defined'] = defined;
    json[r'groupDetails'] = groupDetails.map((i) => i.toJson()).toList();
    json[r'groups'] = groups;
    json[r'hasUnlimitedSeats'] = hasUnlimitedSeats;
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (numberOfSeats != null) {
      json[r'numberOfSeats'] = numberOfSeats;
    }
    json[r'platform'] = platform;
    if (remainingSeats != null) {
      json[r'remainingSeats'] = remainingSeats;
    }
    json[r'selectedByDefault'] = selectedByDefault;
    if (userCount != null) {
      json[r'userCount'] = userCount;
    }
    if (userCountDescription != null) {
      json[r'userCountDescription'] = userCountDescription;
    }
    return json;
  }

  ApplicationRole copyWith(
      {List<String>? defaultGroups,
      List<GroupName>? defaultGroupsDetails,
      bool? defined,
      List<GroupName>? groupDetails,
      List<String>? groups,
      bool? hasUnlimitedSeats,
      String? key,
      String? name,
      int? numberOfSeats,
      bool? platform,
      int? remainingSeats,
      bool? selectedByDefault,
      int? userCount,
      String? userCountDescription}) {
    return ApplicationRole(
      defaultGroups: defaultGroups ?? this.defaultGroups,
      defaultGroupsDetails: defaultGroupsDetails ?? this.defaultGroupsDetails,
      defined: defined ?? this.defined,
      groupDetails: groupDetails ?? this.groupDetails,
      groups: groups ?? this.groups,
      hasUnlimitedSeats: hasUnlimitedSeats ?? this.hasUnlimitedSeats,
      key: key ?? this.key,
      name: name ?? this.name,
      numberOfSeats: numberOfSeats ?? this.numberOfSeats,
      platform: platform ?? this.platform,
      remainingSeats: remainingSeats ?? this.remainingSeats,
      selectedByDefault: selectedByDefault ?? this.selectedByDefault,
      userCount: userCount ?? this.userCount,
      userCountDescription: userCountDescription ?? this.userCountDescription,
    );
  }
}

/// Details of a field configuration to issue type mappings.
class AssociateFieldConfigurationsWithIssueTypesRequest {
  /// Field configuration to issue type mappings.
  final List<FieldConfigurationToIssueTypeMapping> mappings;

  AssociateFieldConfigurationsWithIssueTypesRequest({required this.mappings});

  factory AssociateFieldConfigurationsWithIssueTypesRequest.fromJson(
      Map<String, Object?> json) {
    return AssociateFieldConfigurationsWithIssueTypesRequest(
      mappings: (json[r'mappings'] as List<Object?>?)
              ?.map((i) => FieldConfigurationToIssueTypeMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var mappings = this.mappings;

    final json = <String, Object?>{};
    json[r'mappings'] = mappings.map((i) => i.toJson()).toList();
    return json;
  }

  AssociateFieldConfigurationsWithIssueTypesRequest copyWith(
      {List<FieldConfigurationToIssueTypeMapping>? mappings}) {
    return AssociateFieldConfigurationsWithIssueTypesRequest(
      mappings: mappings ?? this.mappings,
    );
  }
}

/// Issue security scheme, project, and remapping details.
class AssociateSecuritySchemeWithProjectDetails {
  /// The list of scheme levels which should be remapped to new levels of the
  /// issue security scheme.
  final List<OldToNewSecurityLevelMappingsBean> oldToNewSecurityLevelMappings;

  /// The ID of the project.
  final String projectId;

  /// The ID of the issue security scheme. Providing null will clear the
  /// association with the issue security scheme.
  final String schemeId;

  AssociateSecuritySchemeWithProjectDetails(
      {List<OldToNewSecurityLevelMappingsBean>? oldToNewSecurityLevelMappings,
      required this.projectId,
      required this.schemeId})
      : oldToNewSecurityLevelMappings = oldToNewSecurityLevelMappings ?? [];

  factory AssociateSecuritySchemeWithProjectDetails.fromJson(
      Map<String, Object?> json) {
    return AssociateSecuritySchemeWithProjectDetails(
      oldToNewSecurityLevelMappings:
          (json[r'oldToNewSecurityLevelMappings'] as List<Object?>?)
                  ?.map((i) => OldToNewSecurityLevelMappingsBean.fromJson(
                      i as Map<String, Object?>? ?? const {}))
                  .toList() ??
              [],
      projectId: json[r'projectId'] as String? ?? '',
      schemeId: json[r'schemeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var oldToNewSecurityLevelMappings = this.oldToNewSecurityLevelMappings;
    var projectId = this.projectId;
    var schemeId = this.schemeId;

    final json = <String, Object?>{};
    json[r'oldToNewSecurityLevelMappings'] =
        oldToNewSecurityLevelMappings.map((i) => i.toJson()).toList();
    json[r'projectId'] = projectId;
    json[r'schemeId'] = schemeId;
    return json;
  }

  AssociateSecuritySchemeWithProjectDetails copyWith(
      {List<OldToNewSecurityLevelMappingsBean>? oldToNewSecurityLevelMappings,
      String? projectId,
      String? schemeId}) {
    return AssociateSecuritySchemeWithProjectDetails(
      oldToNewSecurityLevelMappings:
          oldToNewSecurityLevelMappings ?? this.oldToNewSecurityLevelMappings,
      projectId: projectId ?? this.projectId,
      schemeId: schemeId ?? this.schemeId,
    );
  }
}

/// Details of an item associated with the changed record.
class AssociatedItemBean {
  /// The ID of the associated record.
  final String? id;

  /// The name of the associated record.
  final String? name;

  /// The ID of the associated parent record.
  final String? parentId;

  /// The name of the associated parent record.
  final String? parentName;

  /// The type of the associated record.
  final String? typeName;

  AssociatedItemBean(
      {this.id, this.name, this.parentId, this.parentName, this.typeName});

  factory AssociatedItemBean.fromJson(Map<String, Object?> json) {
    return AssociatedItemBean(
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      parentId: json[r'parentId'] as String?,
      parentName: json[r'parentName'] as String?,
      typeName: json[r'typeName'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var parentId = this.parentId;
    var parentName = this.parentName;
    var typeName = this.typeName;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (parentId != null) {
      json[r'parentId'] = parentId;
    }
    if (parentName != null) {
      json[r'parentName'] = parentName;
    }
    if (typeName != null) {
      json[r'typeName'] = typeName;
    }
    return json;
  }

  AssociatedItemBean copyWith(
      {String? id,
      String? name,
      String? parentId,
      String? parentName,
      String? typeName}) {
    return AssociatedItemBean(
      id: id ?? this.id,
      name: name ?? this.name,
      parentId: parentId ?? this.parentId,
      parentName: parentName ?? this.parentName,
      typeName: typeName ?? this.typeName,
    );
  }
}

/// Details about an attachment.
class Attachment {
  /// Details of the user who added the attachment.
  final UserDetails? author;

  /// The content of the attachment.
  final String? content;

  /// The datetime the attachment was created.
  final DateTime? created;

  /// The file name of the attachment.
  final String? filename;

  /// The ID of the attachment.
  final String? id;

  /// The MIME type of the attachment.
  final String? mimeType;

  /// The URL of the attachment details response.
  final String? self;

  /// The size of the attachment.
  final int? size;

  /// The URL of a thumbnail representing the attachment.
  final String? thumbnail;

  Attachment(
      {this.author,
      this.content,
      this.created,
      this.filename,
      this.id,
      this.mimeType,
      this.self,
      this.size,
      this.thumbnail});

  factory Attachment.fromJson(Map<String, Object?> json) {
    return Attachment(
      author: json[r'author'] != null
          ? UserDetails.fromJson(json[r'author']! as Map<String, Object?>)
          : null,
      content: json[r'content'] as String?,
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      filename: json[r'filename'] as String?,
      id: json[r'id'] as String?,
      mimeType: json[r'mimeType'] as String?,
      self: json[r'self'] as String?,
      size: (json[r'size'] as num?)?.toInt(),
      thumbnail: json[r'thumbnail'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var author = this.author;
    var content = this.content;
    var created = this.created;
    var filename = this.filename;
    var id = this.id;
    var mimeType = this.mimeType;
    var self = this.self;
    var size = this.size;
    var thumbnail = this.thumbnail;

    final json = <String, Object?>{};
    if (author != null) {
      json[r'author'] = author.toJson();
    }
    if (content != null) {
      json[r'content'] = content;
    }
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    if (filename != null) {
      json[r'filename'] = filename;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (mimeType != null) {
      json[r'mimeType'] = mimeType;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (size != null) {
      json[r'size'] = size;
    }
    if (thumbnail != null) {
      json[r'thumbnail'] = thumbnail;
    }
    return json;
  }

  Attachment copyWith(
      {UserDetails? author,
      String? content,
      DateTime? created,
      String? filename,
      String? id,
      String? mimeType,
      String? self,
      int? size,
      String? thumbnail}) {
    return Attachment(
      author: author ?? this.author,
      content: content ?? this.content,
      created: created ?? this.created,
      filename: filename ?? this.filename,
      id: id ?? this.id,
      mimeType: mimeType ?? this.mimeType,
      self: self ?? this.self,
      size: size ?? this.size,
      thumbnail: thumbnail ?? this.thumbnail,
    );
  }
}

class AttachmentArchive {
  final List<AttachmentArchiveEntry> entries;
  final bool moreAvailable;
  final int? totalEntryCount;
  final int? totalNumberOfEntriesAvailable;

  AttachmentArchive(
      {List<AttachmentArchiveEntry>? entries,
      bool? moreAvailable,
      this.totalEntryCount,
      this.totalNumberOfEntriesAvailable})
      : entries = entries ?? [],
        moreAvailable = moreAvailable ?? false;

  factory AttachmentArchive.fromJson(Map<String, Object?> json) {
    return AttachmentArchive(
      entries: (json[r'entries'] as List<Object?>?)
              ?.map((i) => AttachmentArchiveEntry.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      moreAvailable: json[r'moreAvailable'] as bool? ?? false,
      totalEntryCount: (json[r'totalEntryCount'] as num?)?.toInt(),
      totalNumberOfEntriesAvailable:
          (json[r'totalNumberOfEntriesAvailable'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var entries = this.entries;
    var moreAvailable = this.moreAvailable;
    var totalEntryCount = this.totalEntryCount;
    var totalNumberOfEntriesAvailable = this.totalNumberOfEntriesAvailable;

    final json = <String, Object?>{};
    json[r'entries'] = entries.map((i) => i.toJson()).toList();
    json[r'moreAvailable'] = moreAvailable;
    if (totalEntryCount != null) {
      json[r'totalEntryCount'] = totalEntryCount;
    }
    if (totalNumberOfEntriesAvailable != null) {
      json[r'totalNumberOfEntriesAvailable'] = totalNumberOfEntriesAvailable;
    }
    return json;
  }

  AttachmentArchive copyWith(
      {List<AttachmentArchiveEntry>? entries,
      bool? moreAvailable,
      int? totalEntryCount,
      int? totalNumberOfEntriesAvailable}) {
    return AttachmentArchive(
      entries: entries ?? this.entries,
      moreAvailable: moreAvailable ?? this.moreAvailable,
      totalEntryCount: totalEntryCount ?? this.totalEntryCount,
      totalNumberOfEntriesAvailable:
          totalNumberOfEntriesAvailable ?? this.totalNumberOfEntriesAvailable,
    );
  }
}

class AttachmentArchiveEntry {
  final String? abbreviatedName;
  final int? entryIndex;
  final String? mediaType;
  final String? name;
  final int? size;

  AttachmentArchiveEntry(
      {this.abbreviatedName,
      this.entryIndex,
      this.mediaType,
      this.name,
      this.size});

  factory AttachmentArchiveEntry.fromJson(Map<String, Object?> json) {
    return AttachmentArchiveEntry(
      abbreviatedName: json[r'abbreviatedName'] as String?,
      entryIndex: (json[r'entryIndex'] as num?)?.toInt(),
      mediaType: json[r'mediaType'] as String?,
      name: json[r'name'] as String?,
      size: (json[r'size'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var abbreviatedName = this.abbreviatedName;
    var entryIndex = this.entryIndex;
    var mediaType = this.mediaType;
    var name = this.name;
    var size = this.size;

    final json = <String, Object?>{};
    if (abbreviatedName != null) {
      json[r'abbreviatedName'] = abbreviatedName;
    }
    if (entryIndex != null) {
      json[r'entryIndex'] = entryIndex;
    }
    if (mediaType != null) {
      json[r'mediaType'] = mediaType;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (size != null) {
      json[r'size'] = size;
    }
    return json;
  }

  AttachmentArchiveEntry copyWith(
      {String? abbreviatedName,
      int? entryIndex,
      String? mediaType,
      String? name,
      int? size}) {
    return AttachmentArchiveEntry(
      abbreviatedName: abbreviatedName ?? this.abbreviatedName,
      entryIndex: entryIndex ?? this.entryIndex,
      mediaType: mediaType ?? this.mediaType,
      name: name ?? this.name,
      size: size ?? this.size,
    );
  }
}

class AttachmentArchiveImpl {
  /// The list of the items included in the archive.
  final List<AttachmentArchiveEntry> entries;

  /// The number of items in the archive.
  final int? totalEntryCount;

  AttachmentArchiveImpl(
      {List<AttachmentArchiveEntry>? entries, this.totalEntryCount})
      : entries = entries ?? [];

  factory AttachmentArchiveImpl.fromJson(Map<String, Object?> json) {
    return AttachmentArchiveImpl(
      entries: (json[r'entries'] as List<Object?>?)
              ?.map((i) => AttachmentArchiveEntry.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      totalEntryCount: (json[r'totalEntryCount'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var entries = this.entries;
    var totalEntryCount = this.totalEntryCount;

    final json = <String, Object?>{};
    json[r'entries'] = entries.map((i) => i.toJson()).toList();
    if (totalEntryCount != null) {
      json[r'totalEntryCount'] = totalEntryCount;
    }
    return json;
  }

  AttachmentArchiveImpl copyWith(
      {List<AttachmentArchiveEntry>? entries, int? totalEntryCount}) {
    return AttachmentArchiveImpl(
      entries: entries ?? this.entries,
      totalEntryCount: totalEntryCount ?? this.totalEntryCount,
    );
  }
}

/// Metadata for an item in an attachment archive.
class AttachmentArchiveItemReadable {
  /// The position of the item within the archive.
  final int? index;

  /// The label for the archive item.
  final String? label;

  /// The MIME type of the archive item.
  final String? mediaType;

  /// The path of the archive item.
  final String? path;

  /// The size of the archive item.
  final String? size;

  AttachmentArchiveItemReadable(
      {this.index, this.label, this.mediaType, this.path, this.size});

  factory AttachmentArchiveItemReadable.fromJson(Map<String, Object?> json) {
    return AttachmentArchiveItemReadable(
      index: (json[r'index'] as num?)?.toInt(),
      label: json[r'label'] as String?,
      mediaType: json[r'mediaType'] as String?,
      path: json[r'path'] as String?,
      size: json[r'size'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var index = this.index;
    var label = this.label;
    var mediaType = this.mediaType;
    var path = this.path;
    var size = this.size;

    final json = <String, Object?>{};
    if (index != null) {
      json[r'index'] = index;
    }
    if (label != null) {
      json[r'label'] = label;
    }
    if (mediaType != null) {
      json[r'mediaType'] = mediaType;
    }
    if (path != null) {
      json[r'path'] = path;
    }
    if (size != null) {
      json[r'size'] = size;
    }
    return json;
  }

  AttachmentArchiveItemReadable copyWith(
      {int? index,
      String? label,
      String? mediaType,
      String? path,
      String? size}) {
    return AttachmentArchiveItemReadable(
      index: index ?? this.index,
      label: label ?? this.label,
      mediaType: mediaType ?? this.mediaType,
      path: path ?? this.path,
      size: size ?? this.size,
    );
  }
}

/// Metadata for an archive (for example a zip) and its contents.
class AttachmentArchiveMetadataReadable {
  /// The list of the items included in the archive.
  final List<AttachmentArchiveItemReadable> entries;

  /// The ID of the attachment.
  final int? id;

  /// The MIME type of the attachment.
  final String? mediaType;

  /// The name of the archive file.
  final String? name;

  /// The number of items included in the archive.
  final int? totalEntryCount;

  AttachmentArchiveMetadataReadable(
      {List<AttachmentArchiveItemReadable>? entries,
      this.id,
      this.mediaType,
      this.name,
      this.totalEntryCount})
      : entries = entries ?? [];

  factory AttachmentArchiveMetadataReadable.fromJson(
      Map<String, Object?> json) {
    return AttachmentArchiveMetadataReadable(
      entries: (json[r'entries'] as List<Object?>?)
              ?.map((i) => AttachmentArchiveItemReadable.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      id: (json[r'id'] as num?)?.toInt(),
      mediaType: json[r'mediaType'] as String?,
      name: json[r'name'] as String?,
      totalEntryCount: (json[r'totalEntryCount'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var entries = this.entries;
    var id = this.id;
    var mediaType = this.mediaType;
    var name = this.name;
    var totalEntryCount = this.totalEntryCount;

    final json = <String, Object?>{};
    json[r'entries'] = entries.map((i) => i.toJson()).toList();
    if (id != null) {
      json[r'id'] = id;
    }
    if (mediaType != null) {
      json[r'mediaType'] = mediaType;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (totalEntryCount != null) {
      json[r'totalEntryCount'] = totalEntryCount;
    }
    return json;
  }

  AttachmentArchiveMetadataReadable copyWith(
      {List<AttachmentArchiveItemReadable>? entries,
      int? id,
      String? mediaType,
      String? name,
      int? totalEntryCount}) {
    return AttachmentArchiveMetadataReadable(
      entries: entries ?? this.entries,
      id: id ?? this.id,
      mediaType: mediaType ?? this.mediaType,
      name: name ?? this.name,
      totalEntryCount: totalEntryCount ?? this.totalEntryCount,
    );
  }
}

/// Metadata for an issue attachment.
class AttachmentMetadata {
  /// Details of the user who attached the file.
  final User? author;

  /// The URL of the attachment.
  final String? content;

  /// The datetime the attachment was created.
  final DateTime? created;

  /// The name of the attachment file.
  final String? filename;

  /// The ID of the attachment.
  final int? id;

  /// The MIME type of the attachment.
  final String? mimeType;

  /// Additional properties of the attachment.
  final Map<String, dynamic>? properties;

  /// The URL of the attachment metadata details.
  final String? self;

  /// The size of the attachment.
  final int? size;

  /// The URL of a thumbnail representing the attachment.
  final String? thumbnail;

  AttachmentMetadata(
      {this.author,
      this.content,
      this.created,
      this.filename,
      this.id,
      this.mimeType,
      this.properties,
      this.self,
      this.size,
      this.thumbnail});

  factory AttachmentMetadata.fromJson(Map<String, Object?> json) {
    return AttachmentMetadata(
      author: json[r'author'] != null
          ? User.fromJson(json[r'author']! as Map<String, Object?>)
          : null,
      content: json[r'content'] as String?,
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      filename: json[r'filename'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      mimeType: json[r'mimeType'] as String?,
      properties: json[r'properties'] as Map<String, Object?>?,
      self: json[r'self'] as String?,
      size: (json[r'size'] as num?)?.toInt(),
      thumbnail: json[r'thumbnail'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var author = this.author;
    var content = this.content;
    var created = this.created;
    var filename = this.filename;
    var id = this.id;
    var mimeType = this.mimeType;
    var properties = this.properties;
    var self = this.self;
    var size = this.size;
    var thumbnail = this.thumbnail;

    final json = <String, Object?>{};
    if (author != null) {
      json[r'author'] = author.toJson();
    }
    if (content != null) {
      json[r'content'] = content;
    }
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    if (filename != null) {
      json[r'filename'] = filename;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (mimeType != null) {
      json[r'mimeType'] = mimeType;
    }
    if (properties != null) {
      json[r'properties'] = properties;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (size != null) {
      json[r'size'] = size;
    }
    if (thumbnail != null) {
      json[r'thumbnail'] = thumbnail;
    }
    return json;
  }

  AttachmentMetadata copyWith(
      {User? author,
      String? content,
      DateTime? created,
      String? filename,
      int? id,
      String? mimeType,
      Map<String, dynamic>? properties,
      String? self,
      int? size,
      String? thumbnail}) {
    return AttachmentMetadata(
      author: author ?? this.author,
      content: content ?? this.content,
      created: created ?? this.created,
      filename: filename ?? this.filename,
      id: id ?? this.id,
      mimeType: mimeType ?? this.mimeType,
      properties: properties ?? this.properties,
      self: self ?? this.self,
      size: size ?? this.size,
      thumbnail: thumbnail ?? this.thumbnail,
    );
  }
}

/// Details of the instance's attachment settings.
class AttachmentSettings {
  /// Whether the ability to add attachments is enabled.
  final bool enabled;

  /// The maximum size of attachments permitted, in bytes.
  final int? uploadLimit;

  AttachmentSettings({bool? enabled, this.uploadLimit})
      : enabled = enabled ?? false;

  factory AttachmentSettings.fromJson(Map<String, Object?> json) {
    return AttachmentSettings(
      enabled: json[r'enabled'] as bool? ?? false,
      uploadLimit: (json[r'uploadLimit'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var enabled = this.enabled;
    var uploadLimit = this.uploadLimit;

    final json = <String, Object?>{};
    json[r'enabled'] = enabled;
    if (uploadLimit != null) {
      json[r'uploadLimit'] = uploadLimit;
    }
    return json;
  }

  AttachmentSettings copyWith({bool? enabled, int? uploadLimit}) {
    return AttachmentSettings(
      enabled: enabled ?? this.enabled,
      uploadLimit: uploadLimit ?? this.uploadLimit,
    );
  }
}

/// An audit record.
class AuditRecordBean {
  /// The list of items associated with the changed record.
  final List<AssociatedItemBean> associatedItems;

  /// Deprecated, use `authorAccountId` instead. The key of the user who created
  /// the audit record.
  final String? authorKey;

  /// The category of the audit record. For a list of these categories, see the
  /// help article
  /// [Auditing in Jira applications](https://confluence.atlassian.com/x/noXKM).
  final String? category;

  /// The list of values changed in the record event.
  final List<ChangedValueBean> changedValues;

  /// The date and time on which the audit record was created.
  final DateTime? created;

  /// The description of the audit record.
  final String? description;

  /// The event the audit record originated from.
  final String? eventSource;

  /// The ID of the audit record.
  final int? id;
  final AssociatedItemBean? objectItem;

  /// The URL of the computer where the creation of the audit record was
  /// initiated.
  final String? remoteAddress;

  /// The summary of the audit record.
  final String? summary;

  AuditRecordBean(
      {List<AssociatedItemBean>? associatedItems,
      this.authorKey,
      this.category,
      List<ChangedValueBean>? changedValues,
      this.created,
      this.description,
      this.eventSource,
      this.id,
      this.objectItem,
      this.remoteAddress,
      this.summary})
      : associatedItems = associatedItems ?? [],
        changedValues = changedValues ?? [];

  factory AuditRecordBean.fromJson(Map<String, Object?> json) {
    return AuditRecordBean(
      associatedItems: (json[r'associatedItems'] as List<Object?>?)
              ?.map((i) => AssociatedItemBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      authorKey: json[r'authorKey'] as String?,
      category: json[r'category'] as String?,
      changedValues: (json[r'changedValues'] as List<Object?>?)
              ?.map((i) => ChangedValueBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      description: json[r'description'] as String?,
      eventSource: json[r'eventSource'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      objectItem: json[r'objectItem'] != null
          ? AssociatedItemBean.fromJson(
              json[r'objectItem']! as Map<String, Object?>)
          : null,
      remoteAddress: json[r'remoteAddress'] as String?,
      summary: json[r'summary'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var associatedItems = this.associatedItems;
    var authorKey = this.authorKey;
    var category = this.category;
    var changedValues = this.changedValues;
    var created = this.created;
    var description = this.description;
    var eventSource = this.eventSource;
    var id = this.id;
    var objectItem = this.objectItem;
    var remoteAddress = this.remoteAddress;
    var summary = this.summary;

    final json = <String, Object?>{};
    json[r'associatedItems'] = associatedItems.map((i) => i.toJson()).toList();
    if (authorKey != null) {
      json[r'authorKey'] = authorKey;
    }
    if (category != null) {
      json[r'category'] = category;
    }
    json[r'changedValues'] = changedValues.map((i) => i.toJson()).toList();
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (eventSource != null) {
      json[r'eventSource'] = eventSource;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (objectItem != null) {
      json[r'objectItem'] = objectItem.toJson();
    }
    if (remoteAddress != null) {
      json[r'remoteAddress'] = remoteAddress;
    }
    if (summary != null) {
      json[r'summary'] = summary;
    }
    return json;
  }

  AuditRecordBean copyWith(
      {List<AssociatedItemBean>? associatedItems,
      String? authorKey,
      String? category,
      List<ChangedValueBean>? changedValues,
      DateTime? created,
      String? description,
      String? eventSource,
      int? id,
      AssociatedItemBean? objectItem,
      String? remoteAddress,
      String? summary}) {
    return AuditRecordBean(
      associatedItems: associatedItems ?? this.associatedItems,
      authorKey: authorKey ?? this.authorKey,
      category: category ?? this.category,
      changedValues: changedValues ?? this.changedValues,
      created: created ?? this.created,
      description: description ?? this.description,
      eventSource: eventSource ?? this.eventSource,
      id: id ?? this.id,
      objectItem: objectItem ?? this.objectItem,
      remoteAddress: remoteAddress ?? this.remoteAddress,
      summary: summary ?? this.summary,
    );
  }
}

/// Container for a list of audit records.
class AuditRecords {
  /// The requested or default limit on the number of audit items to be
  /// returned.
  final int? limit;

  /// The number of audit items skipped before the first item in this list.
  final int? offset;

  /// The list of audit items.
  final List<AuditRecordBean> records;

  /// The total number of audit items returned.
  final int? total;

  AuditRecords(
      {this.limit, this.offset, List<AuditRecordBean>? records, this.total})
      : records = records ?? [];

  factory AuditRecords.fromJson(Map<String, Object?> json) {
    return AuditRecords(
      limit: (json[r'limit'] as num?)?.toInt(),
      offset: (json[r'offset'] as num?)?.toInt(),
      records: (json[r'records'] as List<Object?>?)
              ?.map((i) => AuditRecordBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var limit = this.limit;
    var offset = this.offset;
    var records = this.records;
    var total = this.total;

    final json = <String, Object?>{};
    if (limit != null) {
      json[r'limit'] = limit;
    }
    if (offset != null) {
      json[r'offset'] = offset;
    }
    json[r'records'] = records.map((i) => i.toJson()).toList();
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  AuditRecords copyWith(
      {int? limit, int? offset, List<AuditRecordBean>? records, int? total}) {
    return AuditRecords(
      limit: limit ?? this.limit,
      offset: offset ?? this.offset,
      records: records ?? this.records,
      total: total ?? this.total,
    );
  }
}

/// A field auto-complete suggestion.
class AutoCompleteSuggestion {
  /// The display name of a suggested item. If `fieldValue` or `predicateValue`
  /// are provided, the matching text is highlighted with the HTML bold tag.
  final String? displayName;

  /// The value of a suggested item.
  final String? value;

  AutoCompleteSuggestion({this.displayName, this.value});

  factory AutoCompleteSuggestion.fromJson(Map<String, Object?> json) {
    return AutoCompleteSuggestion(
      displayName: json[r'displayName'] as String?,
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var displayName = this.displayName;
    var value = this.value;

    final json = <String, Object?>{};
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  AutoCompleteSuggestion copyWith({String? displayName, String? value}) {
    return AutoCompleteSuggestion(
      displayName: displayName ?? this.displayName,
      value: value ?? this.value,
    );
  }
}

/// The results from a JQL query.
class AutoCompleteSuggestions {
  /// The list of suggested item.
  final List<AutoCompleteSuggestion> results;

  AutoCompleteSuggestions({List<AutoCompleteSuggestion>? results})
      : results = results ?? [];

  factory AutoCompleteSuggestions.fromJson(Map<String, Object?> json) {
    return AutoCompleteSuggestions(
      results: (json[r'results'] as List<Object?>?)
              ?.map((i) => AutoCompleteSuggestion.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var results = this.results;

    final json = <String, Object?>{};
    json[r'results'] = results.map((i) => i.toJson()).toList();
    return json;
  }

  AutoCompleteSuggestions copyWith({List<AutoCompleteSuggestion>? results}) {
    return AutoCompleteSuggestions(
      results: results ?? this.results,
    );
  }
}

/// The details of the available dashboard gadget.
class AvailableDashboardGadget {
  /// The module key of the gadget type.
  final String? moduleKey;

  /// The title of the gadget.
  final String title;

  /// The URI of the gadget type.
  final String? uri;

  AvailableDashboardGadget({this.moduleKey, required this.title, this.uri});

  factory AvailableDashboardGadget.fromJson(Map<String, Object?> json) {
    return AvailableDashboardGadget(
      moduleKey: json[r'moduleKey'] as String?,
      title: json[r'title'] as String? ?? '',
      uri: json[r'uri'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var moduleKey = this.moduleKey;
    var title = this.title;
    var uri = this.uri;

    final json = <String, Object?>{};
    if (moduleKey != null) {
      json[r'moduleKey'] = moduleKey;
    }
    json[r'title'] = title;
    if (uri != null) {
      json[r'uri'] = uri;
    }
    return json;
  }

  AvailableDashboardGadget copyWith(
      {String? moduleKey, String? title, String? uri}) {
    return AvailableDashboardGadget(
      moduleKey: moduleKey ?? this.moduleKey,
      title: title ?? this.title,
      uri: uri ?? this.uri,
    );
  }
}

/// The list of available gadgets.
class AvailableDashboardGadgetsResponse {
  /// The list of available gadgets.
  final List<AvailableDashboardGadget> gadgets;

  AvailableDashboardGadgetsResponse({required this.gadgets});

  factory AvailableDashboardGadgetsResponse.fromJson(
      Map<String, Object?> json) {
    return AvailableDashboardGadgetsResponse(
      gadgets: (json[r'gadgets'] as List<Object?>?)
              ?.map((i) => AvailableDashboardGadget.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var gadgets = this.gadgets;

    final json = <String, Object?>{};
    json[r'gadgets'] = gadgets.map((i) => i.toJson()).toList();
    return json;
  }

  AvailableDashboardGadgetsResponse copyWith(
      {List<AvailableDashboardGadget>? gadgets}) {
    return AvailableDashboardGadgetsResponse(
      gadgets: gadgets ?? this.gadgets,
    );
  }
}

/// Details of an avatar.
class Avatar {
  /// The file name of the avatar icon. Returned for system avatars.
  final String? fileName;

  /// The ID of the avatar.
  final String id;

  /// Whether the avatar can be deleted.
  final bool isDeletable;

  /// Whether the avatar is used in Jira. For example, shown as a project's
  /// avatar.
  final bool isSelected;

  /// Whether the avatar is a system avatar.
  final bool isSystemAvatar;

  /// The owner of the avatar. For a system avatar the owner is null (and
  /// nothing is returned). For non-system avatars this is the appropriate
  /// identifier, such as the ID for a project or the account ID for a user.
  final String? owner;

  /// The list of avatar icon URLs.
  final Map<String, dynamic>? urls;

  Avatar(
      {this.fileName,
      required this.id,
      bool? isDeletable,
      bool? isSelected,
      bool? isSystemAvatar,
      this.owner,
      this.urls})
      : isDeletable = isDeletable ?? false,
        isSelected = isSelected ?? false,
        isSystemAvatar = isSystemAvatar ?? false;

  factory Avatar.fromJson(Map<String, Object?> json) {
    return Avatar(
      fileName: json[r'fileName'] as String?,
      id: json[r'id'] as String? ?? '',
      isDeletable: json[r'isDeletable'] as bool? ?? false,
      isSelected: json[r'isSelected'] as bool? ?? false,
      isSystemAvatar: json[r'isSystemAvatar'] as bool? ?? false,
      owner: json[r'owner'] as String?,
      urls: json[r'urls'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var fileName = this.fileName;
    var id = this.id;
    var isDeletable = this.isDeletable;
    var isSelected = this.isSelected;
    var isSystemAvatar = this.isSystemAvatar;
    var owner = this.owner;
    var urls = this.urls;

    final json = <String, Object?>{};
    if (fileName != null) {
      json[r'fileName'] = fileName;
    }
    json[r'id'] = id;
    json[r'isDeletable'] = isDeletable;
    json[r'isSelected'] = isSelected;
    json[r'isSystemAvatar'] = isSystemAvatar;
    if (owner != null) {
      json[r'owner'] = owner;
    }
    if (urls != null) {
      json[r'urls'] = urls;
    }
    return json;
  }

  Avatar copyWith(
      {String? fileName,
      String? id,
      bool? isDeletable,
      bool? isSelected,
      bool? isSystemAvatar,
      String? owner,
      Map<String, dynamic>? urls}) {
    return Avatar(
      fileName: fileName ?? this.fileName,
      id: id ?? this.id,
      isDeletable: isDeletable ?? this.isDeletable,
      isSelected: isSelected ?? this.isSelected,
      isSystemAvatar: isSystemAvatar ?? this.isSystemAvatar,
      owner: owner ?? this.owner,
      urls: urls ?? this.urls,
    );
  }
}

class AvatarUrlsBean {
  /// The URL of the item's 16x16 pixel avatar.
  final String? $16X16;

  /// The URL of the item's 24x24 pixel avatar.
  final String? $24X24;

  /// The URL of the item's 32x32 pixel avatar.
  final String? $32X32;

  /// The URL of the item's 48x48 pixel avatar.
  final String? $48X48;

  AvatarUrlsBean({this.$16X16, this.$24X24, this.$32X32, this.$48X48});

  factory AvatarUrlsBean.fromJson(Map<String, Object?> json) {
    return AvatarUrlsBean(
      $16X16: json[r'16x16'] as String?,
      $24X24: json[r'24x24'] as String?,
      $32X32: json[r'32x32'] as String?,
      $48X48: json[r'48x48'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var $16X16 = this.$16X16;
    var $24X24 = this.$24X24;
    var $32X32 = this.$32X32;
    var $48X48 = this.$48X48;

    final json = <String, Object?>{};
    if ($16X16 != null) {
      json[r'16x16'] = $16X16;
    }
    if ($24X24 != null) {
      json[r'24x24'] = $24X24;
    }
    if ($32X32 != null) {
      json[r'32x32'] = $32X32;
    }
    if ($48X48 != null) {
      json[r'48x48'] = $48X48;
    }
    return json;
  }

  AvatarUrlsBean copyWith(
      {String? $16X16, String? $24X24, String? $32X32, String? $48X48}) {
    return AvatarUrlsBean(
      $16X16: $16X16 ?? this.$16X16,
      $24X24: $24X24 ?? this.$24X24,
      $32X32: $32X32 ?? this.$32X32,
      $48X48: $48X48 ?? this.$48X48,
    );
  }
}

/// Details about system and custom avatars.
class Avatars {
  /// Custom avatars list.
  final List<Avatar> custom;

  /// System avatars list.
  final List<Avatar> system;

  Avatars({List<Avatar>? custom, List<Avatar>? system})
      : custom = custom ?? [],
        system = system ?? [];

  factory Avatars.fromJson(Map<String, Object?> json) {
    return Avatars(
      custom: (json[r'custom'] as List<Object?>?)
              ?.map((i) =>
                  Avatar.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      system: (json[r'system'] as List<Object?>?)
              ?.map((i) =>
                  Avatar.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var custom = this.custom;
    var system = this.system;

    final json = <String, Object?>{};
    json[r'custom'] = custom.map((i) => i.toJson()).toList();
    json[r'system'] = system.map((i) => i.toJson()).toList();
    return json;
  }

  Avatars copyWith({List<Avatar>? custom, List<Avatar>? system}) {
    return Avatars(
      custom: custom ?? this.custom,
      system: system ?? this.system,
    );
  }
}

/// Details of the options to create for a custom field.
class BulkCustomFieldOptionCreateRequest {
  /// Details of options to create.
  final List<CustomFieldOptionCreate> options;

  BulkCustomFieldOptionCreateRequest({List<CustomFieldOptionCreate>? options})
      : options = options ?? [];

  factory BulkCustomFieldOptionCreateRequest.fromJson(
      Map<String, Object?> json) {
    return BulkCustomFieldOptionCreateRequest(
      options: (json[r'options'] as List<Object?>?)
              ?.map((i) => CustomFieldOptionCreate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var options = this.options;

    final json = <String, Object?>{};
    json[r'options'] = options.map((i) => i.toJson()).toList();
    return json;
  }

  BulkCustomFieldOptionCreateRequest copyWith(
      {List<CustomFieldOptionCreate>? options}) {
    return BulkCustomFieldOptionCreateRequest(
      options: options ?? this.options,
    );
  }
}

/// Details of the options to update for a custom field.
class BulkCustomFieldOptionUpdateRequest {
  /// Details of the options to update.
  final List<CustomFieldOptionUpdate> options;

  BulkCustomFieldOptionUpdateRequest({List<CustomFieldOptionUpdate>? options})
      : options = options ?? [];

  factory BulkCustomFieldOptionUpdateRequest.fromJson(
      Map<String, Object?> json) {
    return BulkCustomFieldOptionUpdateRequest(
      options: (json[r'options'] as List<Object?>?)
              ?.map((i) => CustomFieldOptionUpdate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var options = this.options;

    final json = <String, Object?>{};
    json[r'options'] = options.map((i) => i.toJson()).toList();
    return json;
  }

  BulkCustomFieldOptionUpdateRequest copyWith(
      {List<CustomFieldOptionUpdate>? options}) {
    return BulkCustomFieldOptionUpdateRequest(
      options: options ?? this.options,
    );
  }
}

/// A container for the watch status of a list of issues.
class BulkIssueIsWatching {
  /// The map of issue ID to boolean watch status.
  final Map<String, dynamic>? issuesIsWatching;

  BulkIssueIsWatching({this.issuesIsWatching});

  factory BulkIssueIsWatching.fromJson(Map<String, Object?> json) {
    return BulkIssueIsWatching(
      issuesIsWatching: json[r'issuesIsWatching'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var issuesIsWatching = this.issuesIsWatching;

    final json = <String, Object?>{};
    if (issuesIsWatching != null) {
      json[r'issuesIsWatching'] = issuesIsWatching;
    }
    return json;
  }

  BulkIssueIsWatching copyWith({Map<String, dynamic>? issuesIsWatching}) {
    return BulkIssueIsWatching(
      issuesIsWatching: issuesIsWatching ?? this.issuesIsWatching,
    );
  }
}

/// Bulk issue property update request details.
class BulkIssuePropertyUpdateRequest {
  /// EXPERIMENTAL. The Jira expression to calculate the value of the property.
  /// The value of the expression must be an object that can be converted to
  /// JSON, such as a number, boolean, string, list, or map. The context
  /// variables available to the expression are `issue` and `user`. Issues for
  /// which the expression returns a value whose JSON representation is longer
  /// than 32768 characters are ignored.
  final String? expression;

  /// The bulk operation filter.
  final IssueFilterForBulkPropertySet? filter;

  /// The value of the property. The value must be a
  /// [valid](https://tools.ietf.org/html/rfc4627), non-empty JSON blob. The
  /// maximum length is 32768 characters.
  final dynamic value;

  BulkIssuePropertyUpdateRequest({this.expression, this.filter, this.value});

  factory BulkIssuePropertyUpdateRequest.fromJson(Map<String, Object?> json) {
    return BulkIssuePropertyUpdateRequest(
      expression: json[r'expression'] as String?,
      filter: json[r'filter'] != null
          ? IssueFilterForBulkPropertySet.fromJson(
              json[r'filter']! as Map<String, Object?>)
          : null,
      value: json[r'value'],
    );
  }

  Map<String, Object?> toJson() {
    var expression = this.expression;
    var filter = this.filter;
    var value = this.value;

    final json = <String, Object?>{};
    if (expression != null) {
      json[r'expression'] = expression;
    }
    if (filter != null) {
      json[r'filter'] = filter.toJson();
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  BulkIssuePropertyUpdateRequest copyWith(
      {String? expression,
      IssueFilterForBulkPropertySet? filter,
      dynamic value}) {
    return BulkIssuePropertyUpdateRequest(
      expression: expression ?? this.expression,
      filter: filter ?? this.filter,
      value: value ?? this.value,
    );
  }
}

class BulkOperationErrorResult {
  final ErrorCollection? elementErrors;
  final int? failedElementNumber;
  final int? status;

  BulkOperationErrorResult(
      {this.elementErrors, this.failedElementNumber, this.status});

  factory BulkOperationErrorResult.fromJson(Map<String, Object?> json) {
    return BulkOperationErrorResult(
      elementErrors: json[r'elementErrors'] != null
          ? ErrorCollection.fromJson(
              json[r'elementErrors']! as Map<String, Object?>)
          : null,
      failedElementNumber: (json[r'failedElementNumber'] as num?)?.toInt(),
      status: (json[r'status'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var elementErrors = this.elementErrors;
    var failedElementNumber = this.failedElementNumber;
    var status = this.status;

    final json = <String, Object?>{};
    if (elementErrors != null) {
      json[r'elementErrors'] = elementErrors.toJson();
    }
    if (failedElementNumber != null) {
      json[r'failedElementNumber'] = failedElementNumber;
    }
    if (status != null) {
      json[r'status'] = status;
    }
    return json;
  }

  BulkOperationErrorResult copyWith(
      {ErrorCollection? elementErrors, int? failedElementNumber, int? status}) {
    return BulkOperationErrorResult(
      elementErrors: elementErrors ?? this.elementErrors,
      failedElementNumber: failedElementNumber ?? this.failedElementNumber,
      status: status ?? this.status,
    );
  }
}

/// Details of global and project permissions granted to the user.
class BulkPermissionGrants {
  /// List of permissions granted to the user.
  final List<String> globalPermissions;

  /// List of project permissions and the projects and issues those permissions
  /// provide access to.
  final List<BulkProjectPermissionGrants> projectPermissions;

  BulkPermissionGrants(
      {required this.globalPermissions, required this.projectPermissions});

  factory BulkPermissionGrants.fromJson(Map<String, Object?> json) {
    return BulkPermissionGrants(
      globalPermissions: (json[r'globalPermissions'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      projectPermissions: (json[r'projectPermissions'] as List<Object?>?)
              ?.map((i) => BulkProjectPermissionGrants.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var globalPermissions = this.globalPermissions;
    var projectPermissions = this.projectPermissions;

    final json = <String, Object?>{};
    json[r'globalPermissions'] = globalPermissions;
    json[r'projectPermissions'] =
        projectPermissions.map((i) => i.toJson()).toList();
    return json;
  }

  BulkPermissionGrants copyWith(
      {List<String>? globalPermissions,
      List<BulkProjectPermissionGrants>? projectPermissions}) {
    return BulkPermissionGrants(
      globalPermissions: globalPermissions ?? this.globalPermissions,
      projectPermissions: projectPermissions ?? this.projectPermissions,
    );
  }
}

/// Details of global permissions to look up and project permissions with
/// associated projects and issues to look up.
class BulkPermissionsRequestBean {
  /// The account ID of a user.
  final String? accountId;

  /// Global permissions to look up.
  final List<String> globalPermissions;

  /// Project permissions with associated projects and issues to look up.
  final List<BulkProjectPermissions> projectPermissions;

  BulkPermissionsRequestBean(
      {this.accountId,
      List<String>? globalPermissions,
      List<BulkProjectPermissions>? projectPermissions})
      : globalPermissions = globalPermissions ?? [],
        projectPermissions = projectPermissions ?? [];

  factory BulkPermissionsRequestBean.fromJson(Map<String, Object?> json) {
    return BulkPermissionsRequestBean(
      accountId: json[r'accountId'] as String?,
      globalPermissions: (json[r'globalPermissions'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      projectPermissions: (json[r'projectPermissions'] as List<Object?>?)
              ?.map((i) => BulkProjectPermissions.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var globalPermissions = this.globalPermissions;
    var projectPermissions = this.projectPermissions;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    json[r'globalPermissions'] = globalPermissions;
    json[r'projectPermissions'] =
        projectPermissions.map((i) => i.toJson()).toList();
    return json;
  }

  BulkPermissionsRequestBean copyWith(
      {String? accountId,
      List<String>? globalPermissions,
      List<BulkProjectPermissions>? projectPermissions}) {
    return BulkPermissionsRequestBean(
      accountId: accountId ?? this.accountId,
      globalPermissions: globalPermissions ?? this.globalPermissions,
      projectPermissions: projectPermissions ?? this.projectPermissions,
    );
  }
}

/// List of project permissions and the projects and issues those permissions
/// grant access to.
class BulkProjectPermissionGrants {
  /// IDs of the issues the user has the permission for.
  final List<int> issues;

  /// A project permission,
  final String permission;

  /// IDs of the projects the user has the permission for.
  final List<int> projects;

  BulkProjectPermissionGrants(
      {required this.issues, required this.permission, required this.projects});

  factory BulkProjectPermissionGrants.fromJson(Map<String, Object?> json) {
    return BulkProjectPermissionGrants(
      issues: (json[r'issues'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      permission: json[r'permission'] as String? ?? '',
      projects: (json[r'projects'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issues = this.issues;
    var permission = this.permission;
    var projects = this.projects;

    final json = <String, Object?>{};
    json[r'issues'] = issues;
    json[r'permission'] = permission;
    json[r'projects'] = projects;
    return json;
  }

  BulkProjectPermissionGrants copyWith(
      {List<int>? issues, String? permission, List<int>? projects}) {
    return BulkProjectPermissionGrants(
      issues: issues ?? this.issues,
      permission: permission ?? this.permission,
      projects: projects ?? this.projects,
    );
  }
}

/// Details of project permissions and associated issues and projects to look
/// up.
class BulkProjectPermissions {
  /// List of issue IDs.
  final List<int> issues;

  /// List of project permissions.
  final List<String> permissions;

  /// List of project IDs.
  final List<int> projects;

  BulkProjectPermissions(
      {List<int>? issues, required this.permissions, List<int>? projects})
      : issues = issues ?? [],
        projects = projects ?? [];

  factory BulkProjectPermissions.fromJson(Map<String, Object?> json) {
    return BulkProjectPermissions(
      issues: (json[r'issues'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      permissions: (json[r'permissions'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      projects: (json[r'projects'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issues = this.issues;
    var permissions = this.permissions;
    var projects = this.projects;

    final json = <String, Object?>{};
    json[r'issues'] = issues;
    json[r'permissions'] = permissions;
    json[r'projects'] = projects;
    return json;
  }

  BulkProjectPermissions copyWith(
      {List<int>? issues, List<String>? permissions, List<int>? projects}) {
    return BulkProjectPermissions(
      issues: issues ?? this.issues,
      permissions: permissions ?? this.permissions,
      projects: projects ?? this.projects,
    );
  }
}

/// A change item.
class ChangeDetails {
  /// The name of the field changed.
  final String? field;

  /// The ID of the field changed.
  final String? fieldId;

  /// The type of the field changed.
  final String? fieldtype;

  /// The details of the original value.
  final String? from;

  /// The details of the original value as a string.
  final String? fromString;

  /// The details of the new value.
  final String? to;

  /// The details of the new value as a string.
  final String? toString$;

  ChangeDetails(
      {this.field,
      this.fieldId,
      this.fieldtype,
      this.from,
      this.fromString,
      this.to,
      this.toString$});

  factory ChangeDetails.fromJson(Map<String, Object?> json) {
    return ChangeDetails(
      field: json[r'field'] as String?,
      fieldId: json[r'fieldId'] as String?,
      fieldtype: json[r'fieldtype'] as String?,
      from: json[r'from'] as String?,
      fromString: json[r'fromString'] as String?,
      to: json[r'to'] as String?,
      toString$: json[r'toString'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var field = this.field;
    var fieldId = this.fieldId;
    var fieldtype = this.fieldtype;
    var from = this.from;
    var fromString = this.fromString;
    var to = this.to;
    var toString$ = this.toString$;

    final json = <String, Object?>{};
    if (field != null) {
      json[r'field'] = field;
    }
    if (fieldId != null) {
      json[r'fieldId'] = fieldId;
    }
    if (fieldtype != null) {
      json[r'fieldtype'] = fieldtype;
    }
    if (from != null) {
      json[r'from'] = from;
    }
    if (fromString != null) {
      json[r'fromString'] = fromString;
    }
    if (to != null) {
      json[r'to'] = to;
    }
    if (toString$ != null) {
      json[r'toString'] = toString$;
    }
    return json;
  }

  ChangeDetails copyWith(
      {String? field,
      String? fieldId,
      String? fieldtype,
      String? from,
      String? fromString,
      String? to,
      String? toString$}) {
    return ChangeDetails(
      field: field ?? this.field,
      fieldId: fieldId ?? this.fieldId,
      fieldtype: fieldtype ?? this.fieldtype,
      from: from ?? this.from,
      fromString: fromString ?? this.fromString,
      to: to ?? this.to,
      toString$: toString$ ?? this.toString$,
    );
  }
}

/// The account ID of the new owner.
class ChangeFilterOwner {
  /// The account ID of the new owner.
  final String accountId;

  ChangeFilterOwner({required this.accountId});

  factory ChangeFilterOwner.fromJson(Map<String, Object?> json) {
    return ChangeFilterOwner(
      accountId: json[r'accountId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;

    final json = <String, Object?>{};
    json[r'accountId'] = accountId;
    return json;
  }

  ChangeFilterOwner copyWith({String? accountId}) {
    return ChangeFilterOwner(
      accountId: accountId ?? this.accountId,
    );
  }
}

/// Details of names changed in the record event.
class ChangedValueBean {
  /// The value of the field before the change.
  final String? changedFrom;

  /// The value of the field after the change.
  final String? changedTo;

  /// The name of the field changed.
  final String? fieldName;

  ChangedValueBean({this.changedFrom, this.changedTo, this.fieldName});

  factory ChangedValueBean.fromJson(Map<String, Object?> json) {
    return ChangedValueBean(
      changedFrom: json[r'changedFrom'] as String?,
      changedTo: json[r'changedTo'] as String?,
      fieldName: json[r'fieldName'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var changedFrom = this.changedFrom;
    var changedTo = this.changedTo;
    var fieldName = this.fieldName;

    final json = <String, Object?>{};
    if (changedFrom != null) {
      json[r'changedFrom'] = changedFrom;
    }
    if (changedTo != null) {
      json[r'changedTo'] = changedTo;
    }
    if (fieldName != null) {
      json[r'fieldName'] = fieldName;
    }
    return json;
  }

  ChangedValueBean copyWith(
      {String? changedFrom, String? changedTo, String? fieldName}) {
    return ChangedValueBean(
      changedFrom: changedFrom ?? this.changedFrom,
      changedTo: changedTo ?? this.changedTo,
      fieldName: fieldName ?? this.fieldName,
    );
  }
}

/// Details of a changed worklog.
class ChangedWorklog {
  /// Details of properties associated with the change.
  final List<EntityProperty> properties;

  /// The datetime of the change.
  final int? updatedTime;

  /// The ID of the worklog.
  final int? worklogId;

  ChangedWorklog(
      {List<EntityProperty>? properties, this.updatedTime, this.worklogId})
      : properties = properties ?? [];

  factory ChangedWorklog.fromJson(Map<String, Object?> json) {
    return ChangedWorklog(
      properties: (json[r'properties'] as List<Object?>?)
              ?.map((i) => EntityProperty.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      updatedTime: (json[r'updatedTime'] as num?)?.toInt(),
      worklogId: (json[r'worklogId'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var properties = this.properties;
    var updatedTime = this.updatedTime;
    var worklogId = this.worklogId;

    final json = <String, Object?>{};
    json[r'properties'] = properties.map((i) => i.toJson()).toList();
    if (updatedTime != null) {
      json[r'updatedTime'] = updatedTime;
    }
    if (worklogId != null) {
      json[r'worklogId'] = worklogId;
    }
    return json;
  }

  ChangedWorklog copyWith(
      {List<EntityProperty>? properties, int? updatedTime, int? worklogId}) {
    return ChangedWorklog(
      properties: properties ?? this.properties,
      updatedTime: updatedTime ?? this.updatedTime,
      worklogId: worklogId ?? this.worklogId,
    );
  }
}

/// List of changed worklogs.
class ChangedWorklogs {
  final bool lastPage;

  /// The URL of the next list of changed worklogs.
  final String? nextPage;

  /// The URL of this changed worklogs list.
  final String? self;

  /// The datetime of the first worklog item in the list.
  final int? since;

  /// The datetime of the last worklog item in the list.
  final int? until;

  /// Changed worklog list.
  final List<ChangedWorklog> values;

  ChangedWorklogs(
      {bool? lastPage,
      this.nextPage,
      this.self,
      this.since,
      this.until,
      List<ChangedWorklog>? values})
      : lastPage = lastPage ?? false,
        values = values ?? [];

  factory ChangedWorklogs.fromJson(Map<String, Object?> json) {
    return ChangedWorklogs(
      lastPage: json[r'lastPage'] as bool? ?? false,
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      since: (json[r'since'] as num?)?.toInt(),
      until: (json[r'until'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => ChangedWorklog.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var lastPage = this.lastPage;
    var nextPage = this.nextPage;
    var self = this.self;
    var since = this.since;
    var until = this.until;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'lastPage'] = lastPage;
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (since != null) {
      json[r'since'] = since;
    }
    if (until != null) {
      json[r'until'] = until;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  ChangedWorklogs copyWith(
      {bool? lastPage,
      String? nextPage,
      String? self,
      int? since,
      int? until,
      List<ChangedWorklog>? values}) {
    return ChangedWorklogs(
      lastPage: lastPage ?? this.lastPage,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      since: since ?? this.since,
      until: until ?? this.until,
      values: values ?? this.values,
    );
  }
}

/// A log of changes made to issue fields. Changelogs related to workflow
/// associations are currently being deprecated.
class Changelog {
  /// The user who made the change.
  final UserDetails? author;

  /// The date on which the change took place.
  final DateTime? created;

  /// The history metadata associated with the changed.
  final HistoryMetadata? historyMetadata;

  /// The ID of the changelog.
  final String? id;

  /// The list of items changed.
  final List<ChangeDetails> items;

  Changelog(
      {this.author,
      this.created,
      this.historyMetadata,
      this.id,
      List<ChangeDetails>? items})
      : items = items ?? [];

  factory Changelog.fromJson(Map<String, Object?> json) {
    return Changelog(
      author: json[r'author'] != null
          ? UserDetails.fromJson(json[r'author']! as Map<String, Object?>)
          : null,
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      historyMetadata: json[r'historyMetadata'] != null
          ? HistoryMetadata.fromJson(
              json[r'historyMetadata']! as Map<String, Object?>)
          : null,
      id: json[r'id'] as String?,
      items: (json[r'items'] as List<Object?>?)
              ?.map((i) => ChangeDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var author = this.author;
    var created = this.created;
    var historyMetadata = this.historyMetadata;
    var id = this.id;
    var items = this.items;

    final json = <String, Object?>{};
    if (author != null) {
      json[r'author'] = author.toJson();
    }
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    if (historyMetadata != null) {
      json[r'historyMetadata'] = historyMetadata.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'items'] = items.map((i) => i.toJson()).toList();
    return json;
  }

  Changelog copyWith(
      {UserDetails? author,
      DateTime? created,
      HistoryMetadata? historyMetadata,
      String? id,
      List<ChangeDetails>? items}) {
    return Changelog(
      author: author ?? this.author,
      created: created ?? this.created,
      historyMetadata: historyMetadata ?? this.historyMetadata,
      id: id ?? this.id,
      items: items ?? this.items,
    );
  }
}

/// Details of an issue navigator column item.
class ColumnItem {
  /// The issue navigator column label.
  final String? label;

  /// The issue navigator column value.
  final String? value;

  ColumnItem({this.label, this.value});

  factory ColumnItem.fromJson(Map<String, Object?> json) {
    return ColumnItem(
      label: json[r'label'] as String?,
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var label = this.label;
    var value = this.value;

    final json = <String, Object?>{};
    if (label != null) {
      json[r'label'] = label;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  ColumnItem copyWith({String? label, String? value}) {
    return ColumnItem(
      label: label ?? this.label,
      value: value ?? this.value,
    );
  }
}

/// A comment.
class Comment {
  /// The ID of the user who created the comment.
  final UserDetails? author;

  /// The comment text in
  /// [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/).
  final dynamic body;

  /// The date and time at which the comment was created.
  final DateTime? created;

  /// The ID of the comment.
  final String? id;

  /// Whether the comment was added from an email sent by a person who is not
  /// part of the issue. See
  /// [Allow external emails to be added as comments on issues](https://support.atlassian.com/jira-service-management-cloud/docs/allow-external-emails-to-be-added-as-comments-on-issues/)for
  /// information on setting up this feature.
  final bool jsdAuthorCanSeeRequest;

  /// Whether the comment is visible in Jira Service Desk. Defaults to true when
  /// comments are created in the Jira Cloud Platform. This includes when the
  /// site doesn't use Jira Service Desk or the project isn't a Jira Service
  /// Desk project and, therefore, there is no Jira Service Desk for the issue
  /// to be visible on. To create a comment with its visibility in Jira Service
  /// Desk set to false, use the Jira Service Desk REST API
  /// [Create request comment](https://developer.atlassian.com/cloud/jira/service-desk/rest/#api-rest-servicedeskapi-request-issueIdOrKey-comment-post)
  /// operation.
  final bool jsdPublic;

  /// A list of comment properties. Optional on create and update.
  final List<EntityProperty> properties;

  /// The rendered version of the comment.
  final String? renderedBody;

  /// The URL of the comment.
  final String? self;

  /// The ID of the user who updated the comment last.
  final UserDetails? updateAuthor;

  /// The date and time at which the comment was updated last.
  final DateTime? updated;

  /// The group or role to which this comment is visible. Optional on create and
  /// update.
  final Visibility? visibility;

  Comment(
      {this.author,
      this.body,
      this.created,
      this.id,
      bool? jsdAuthorCanSeeRequest,
      bool? jsdPublic,
      List<EntityProperty>? properties,
      this.renderedBody,
      this.self,
      this.updateAuthor,
      this.updated,
      this.visibility})
      : jsdAuthorCanSeeRequest = jsdAuthorCanSeeRequest ?? false,
        jsdPublic = jsdPublic ?? false,
        properties = properties ?? [];

  factory Comment.fromJson(Map<String, Object?> json) {
    return Comment(
      author: json[r'author'] != null
          ? UserDetails.fromJson(json[r'author']! as Map<String, Object?>)
          : null,
      body: json[r'body'],
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      id: json[r'id'] as String?,
      jsdAuthorCanSeeRequest: json[r'jsdAuthorCanSeeRequest'] as bool? ?? false,
      jsdPublic: json[r'jsdPublic'] as bool? ?? false,
      properties: (json[r'properties'] as List<Object?>?)
              ?.map((i) => EntityProperty.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      renderedBody: json[r'renderedBody'] as String?,
      self: json[r'self'] as String?,
      updateAuthor: json[r'updateAuthor'] != null
          ? UserDetails.fromJson(json[r'updateAuthor']! as Map<String, Object?>)
          : null,
      updated: DateTime.tryParse(json[r'updated'] as String? ?? ''),
      visibility: json[r'visibility'] != null
          ? Visibility.fromJson(json[r'visibility']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var author = this.author;
    var body = this.body;
    var created = this.created;
    var id = this.id;
    var jsdAuthorCanSeeRequest = this.jsdAuthorCanSeeRequest;
    var jsdPublic = this.jsdPublic;
    var properties = this.properties;
    var renderedBody = this.renderedBody;
    var self = this.self;
    var updateAuthor = this.updateAuthor;
    var updated = this.updated;
    var visibility = this.visibility;

    final json = <String, Object?>{};
    if (author != null) {
      json[r'author'] = author.toJson();
    }
    if (body != null) {
      json[r'body'] = body;
    }
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'jsdAuthorCanSeeRequest'] = jsdAuthorCanSeeRequest;
    json[r'jsdPublic'] = jsdPublic;
    json[r'properties'] = properties.map((i) => i.toJson()).toList();
    if (renderedBody != null) {
      json[r'renderedBody'] = renderedBody;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (updateAuthor != null) {
      json[r'updateAuthor'] = updateAuthor.toJson();
    }
    if (updated != null) {
      json[r'updated'] = updated.toIso8601String();
    }
    if (visibility != null) {
      json[r'visibility'] = visibility.toJson();
    }
    return json;
  }

  Comment copyWith(
      {UserDetails? author,
      dynamic body,
      DateTime? created,
      String? id,
      bool? jsdAuthorCanSeeRequest,
      bool? jsdPublic,
      List<EntityProperty>? properties,
      String? renderedBody,
      String? self,
      UserDetails? updateAuthor,
      DateTime? updated,
      Visibility? visibility}) {
    return Comment(
      author: author ?? this.author,
      body: body ?? this.body,
      created: created ?? this.created,
      id: id ?? this.id,
      jsdAuthorCanSeeRequest:
          jsdAuthorCanSeeRequest ?? this.jsdAuthorCanSeeRequest,
      jsdPublic: jsdPublic ?? this.jsdPublic,
      properties: properties ?? this.properties,
      renderedBody: renderedBody ?? this.renderedBody,
      self: self ?? this.self,
      updateAuthor: updateAuthor ?? this.updateAuthor,
      updated: updated ?? this.updated,
      visibility: visibility ?? this.visibility,
    );
  }
}

/// Count of issues assigned to a component.
class ComponentIssuesCount {
  /// The count of issues assigned to a component.
  final int? issueCount;

  /// The URL for this count of issues for a component.
  final String? self;

  ComponentIssuesCount({this.issueCount, this.self});

  factory ComponentIssuesCount.fromJson(Map<String, Object?> json) {
    return ComponentIssuesCount(
      issueCount: (json[r'issueCount'] as num?)?.toInt(),
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var issueCount = this.issueCount;
    var self = this.self;

    final json = <String, Object?>{};
    if (issueCount != null) {
      json[r'issueCount'] = issueCount;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  ComponentIssuesCount copyWith({int? issueCount, String? self}) {
    return ComponentIssuesCount(
      issueCount: issueCount ?? this.issueCount,
      self: self ?? this.self,
    );
  }
}

/// Details about a component with a count of the issues it contains.
class ComponentWithIssueCount {
  /// The details of the user associated with `assigneeType`, if any. See
  /// `realAssignee` for details of the user assigned to issues created with
  /// this component.
  final User? assignee;

  /// The nominal user type used to determine the assignee for issues created
  /// with this component. See `realAssigneeType` for details on how the type of
  /// the user, and hence the user, assigned to issues is determined. Takes the
  /// following values:
  ///
  ///  *  `PROJECT_LEAD` the assignee to any issues created with this component
  /// is nominally the lead for the project the component is in.
  ///  *  `COMPONENT_LEAD` the assignee to any issues created with this
  /// component is nominally the lead for the component.
  ///  *  `UNASSIGNED` an assignee is not set for issues created with this
  /// component.
  ///  *  `PROJECT_DEFAULT` the assignee to any issues created with this
  /// component is nominally the default assignee for the project that the
  /// component is in.
  final ComponentWithIssueCountAssigneeType? assigneeType;

  /// The description for the component.
  final String? description;

  /// The unique identifier for the component.
  final String? id;

  /// Whether a user is associated with `assigneeType`. For example, if the
  /// `assigneeType` is set to `COMPONENT_LEAD` but the component lead is not
  /// set, then `false` is returned.
  final bool isAssigneeTypeValid;

  /// Count of issues for the component.
  final int? issueCount;

  /// The user details for the component's lead user.
  final User? lead;

  /// The name for the component.
  final String? name;

  /// The key of the project to which the component is assigned.
  final String? project;

  /// Not used.
  final int? projectId;

  /// The user assigned to issues created with this component, when
  /// `assigneeType` does not identify a valid assignee.
  final User? realAssignee;

  /// The type of the assignee that is assigned to issues created with this
  /// component, when an assignee cannot be set from the `assigneeType`. For
  /// example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead
  /// is set. This property is set to one of the following values:
  ///
  ///  *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project
  /// lead has permission to be assigned issues in the project that the
  /// component is in.
  ///  *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the
  /// component lead has permission to be assigned issues in the project that
  /// the component is in.
  ///  *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is
  /// configured to allow unassigned issues.
  ///  *  `PROJECT_DEFAULT` when none of the preceding cases are true.
  final ComponentWithIssueCountRealAssigneeType? realAssigneeType;

  /// The URL for this count of the issues contained in the component.
  final String? self;

  ComponentWithIssueCount(
      {this.assignee,
      this.assigneeType,
      this.description,
      this.id,
      bool? isAssigneeTypeValid,
      this.issueCount,
      this.lead,
      this.name,
      this.project,
      this.projectId,
      this.realAssignee,
      this.realAssigneeType,
      this.self})
      : isAssigneeTypeValid = isAssigneeTypeValid ?? false;

  factory ComponentWithIssueCount.fromJson(Map<String, Object?> json) {
    return ComponentWithIssueCount(
      assignee: json[r'assignee'] != null
          ? User.fromJson(json[r'assignee']! as Map<String, Object?>)
          : null,
      assigneeType: json[r'assigneeType'] != null
          ? ComponentWithIssueCountAssigneeType.fromValue(
              json[r'assigneeType']! as String)
          : null,
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      isAssigneeTypeValid: json[r'isAssigneeTypeValid'] as bool? ?? false,
      issueCount: (json[r'issueCount'] as num?)?.toInt(),
      lead: json[r'lead'] != null
          ? User.fromJson(json[r'lead']! as Map<String, Object?>)
          : null,
      name: json[r'name'] as String?,
      project: json[r'project'] as String?,
      projectId: (json[r'projectId'] as num?)?.toInt(),
      realAssignee: json[r'realAssignee'] != null
          ? User.fromJson(json[r'realAssignee']! as Map<String, Object?>)
          : null,
      realAssigneeType: json[r'realAssigneeType'] != null
          ? ComponentWithIssueCountRealAssigneeType.fromValue(
              json[r'realAssigneeType']! as String)
          : null,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var assignee = this.assignee;
    var assigneeType = this.assigneeType;
    var description = this.description;
    var id = this.id;
    var isAssigneeTypeValid = this.isAssigneeTypeValid;
    var issueCount = this.issueCount;
    var lead = this.lead;
    var name = this.name;
    var project = this.project;
    var projectId = this.projectId;
    var realAssignee = this.realAssignee;
    var realAssigneeType = this.realAssigneeType;
    var self = this.self;

    final json = <String, Object?>{};
    if (assignee != null) {
      json[r'assignee'] = assignee.toJson();
    }
    if (assigneeType != null) {
      json[r'assigneeType'] = assigneeType.value;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'isAssigneeTypeValid'] = isAssigneeTypeValid;
    if (issueCount != null) {
      json[r'issueCount'] = issueCount;
    }
    if (lead != null) {
      json[r'lead'] = lead.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (project != null) {
      json[r'project'] = project;
    }
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    if (realAssignee != null) {
      json[r'realAssignee'] = realAssignee.toJson();
    }
    if (realAssigneeType != null) {
      json[r'realAssigneeType'] = realAssigneeType.value;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  ComponentWithIssueCount copyWith(
      {User? assignee,
      ComponentWithIssueCountAssigneeType? assigneeType,
      String? description,
      String? id,
      bool? isAssigneeTypeValid,
      int? issueCount,
      User? lead,
      String? name,
      String? project,
      int? projectId,
      User? realAssignee,
      ComponentWithIssueCountRealAssigneeType? realAssigneeType,
      String? self}) {
    return ComponentWithIssueCount(
      assignee: assignee ?? this.assignee,
      assigneeType: assigneeType ?? this.assigneeType,
      description: description ?? this.description,
      id: id ?? this.id,
      isAssigneeTypeValid: isAssigneeTypeValid ?? this.isAssigneeTypeValid,
      issueCount: issueCount ?? this.issueCount,
      lead: lead ?? this.lead,
      name: name ?? this.name,
      project: project ?? this.project,
      projectId: projectId ?? this.projectId,
      realAssignee: realAssignee ?? this.realAssignee,
      realAssigneeType: realAssigneeType ?? this.realAssigneeType,
      self: self ?? this.self,
    );
  }
}

class ComponentWithIssueCountAssigneeType {
  static const projectDefault =
      ComponentWithIssueCountAssigneeType._('PROJECT_DEFAULT');
  static const componentLead =
      ComponentWithIssueCountAssigneeType._('COMPONENT_LEAD');
  static const projectLead =
      ComponentWithIssueCountAssigneeType._('PROJECT_LEAD');
  static const unassigned = ComponentWithIssueCountAssigneeType._('UNASSIGNED');

  static const values = [
    projectDefault,
    componentLead,
    projectLead,
    unassigned,
  ];
  final String value;

  const ComponentWithIssueCountAssigneeType._(this.value);

  static ComponentWithIssueCountAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ComponentWithIssueCountAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ComponentWithIssueCountRealAssigneeType {
  static const projectDefault =
      ComponentWithIssueCountRealAssigneeType._('PROJECT_DEFAULT');
  static const componentLead =
      ComponentWithIssueCountRealAssigneeType._('COMPONENT_LEAD');
  static const projectLead =
      ComponentWithIssueCountRealAssigneeType._('PROJECT_LEAD');
  static const unassigned =
      ComponentWithIssueCountRealAssigneeType._('UNASSIGNED');

  static const values = [
    projectDefault,
    componentLead,
    projectLead,
    unassigned,
  ];
  final String value;

  const ComponentWithIssueCountRealAssigneeType._(this.value);

  static ComponentWithIssueCountRealAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ComponentWithIssueCountRealAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A JQL query clause that consists of nested clauses. For example, `(labels in
/// (urgent, blocker) OR lastCommentedBy = currentUser()). Note that, where
/// nesting is not defined, the parser nests JQL clauses based on the operator
/// precedence. For example, "A OR B AND C" is parsed as "(A OR B) AND C". See
/// Setting the precedence of operators for more information about precedence in
/// JQL queries.`
class CompoundClause {
  /// The list of nested clauses.
  final List<JqlQueryClause> clauses;

  /// The operator between the clauses.
  final CompoundClauseOperator operator$;

  CompoundClause({required this.clauses, required this.operator$});

  factory CompoundClause.fromJson(Map<String, Object?> json) {
    return CompoundClause(
      clauses: (json[r'clauses'] as List<Object?>?)
              ?.map((i) => JqlQueryClause.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      operator$:
          CompoundClauseOperator.fromValue(json[r'operator'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var clauses = this.clauses;
    var operator$ = this.operator$;

    final json = <String, Object?>{};
    json[r'clauses'] = clauses.map((i) => i.toJson()).toList();
    json[r'operator'] = operator$.value;
    return json;
  }

  CompoundClause copyWith(
      {List<JqlQueryClause>? clauses, CompoundClauseOperator? operator$}) {
    return CompoundClause(
      clauses: clauses ?? this.clauses,
      operator$: operator$ ?? this.operator$,
    );
  }
}

class CompoundClauseOperator {
  static const and = CompoundClauseOperator._('and');
  static const or = CompoundClauseOperator._('or');
  static const not = CompoundClauseOperator._('not');

  static const values = [
    and,
    or,
    not,
  ];
  final String value;

  const CompoundClauseOperator._(this.value);

  static CompoundClauseOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CompoundClauseOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about the configuration of Jira.
class Configuration {
  /// Whether the ability to add attachments to issues is enabled.
  final bool attachmentsEnabled;

  /// Whether the ability to link issues is enabled.
  final bool issueLinkingEnabled;

  /// Whether the ability to create subtasks for issues is enabled.
  final bool subTasksEnabled;

  /// The configuration of time tracking.
  final TimeTrackingConfiguration? timeTrackingConfiguration;

  /// Whether the ability to track time is enabled. This property is deprecated.
  final bool timeTrackingEnabled;

  /// Whether the ability to create unassigned issues is enabled. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  final bool unassignedIssuesAllowed;

  /// Whether the ability for users to vote on issues is enabled. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  final bool votingEnabled;

  /// Whether the ability for users to watch issues is enabled. See
  /// [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM)
  /// for details.
  final bool watchingEnabled;

  Configuration(
      {bool? attachmentsEnabled,
      bool? issueLinkingEnabled,
      bool? subTasksEnabled,
      this.timeTrackingConfiguration,
      bool? timeTrackingEnabled,
      bool? unassignedIssuesAllowed,
      bool? votingEnabled,
      bool? watchingEnabled})
      : attachmentsEnabled = attachmentsEnabled ?? false,
        issueLinkingEnabled = issueLinkingEnabled ?? false,
        subTasksEnabled = subTasksEnabled ?? false,
        timeTrackingEnabled = timeTrackingEnabled ?? false,
        unassignedIssuesAllowed = unassignedIssuesAllowed ?? false,
        votingEnabled = votingEnabled ?? false,
        watchingEnabled = watchingEnabled ?? false;

  factory Configuration.fromJson(Map<String, Object?> json) {
    return Configuration(
      attachmentsEnabled: json[r'attachmentsEnabled'] as bool? ?? false,
      issueLinkingEnabled: json[r'issueLinkingEnabled'] as bool? ?? false,
      subTasksEnabled: json[r'subTasksEnabled'] as bool? ?? false,
      timeTrackingConfiguration: json[r'timeTrackingConfiguration'] != null
          ? TimeTrackingConfiguration.fromJson(
              json[r'timeTrackingConfiguration']! as Map<String, Object?>)
          : null,
      timeTrackingEnabled: json[r'timeTrackingEnabled'] as bool? ?? false,
      unassignedIssuesAllowed:
          json[r'unassignedIssuesAllowed'] as bool? ?? false,
      votingEnabled: json[r'votingEnabled'] as bool? ?? false,
      watchingEnabled: json[r'watchingEnabled'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var attachmentsEnabled = this.attachmentsEnabled;
    var issueLinkingEnabled = this.issueLinkingEnabled;
    var subTasksEnabled = this.subTasksEnabled;
    var timeTrackingConfiguration = this.timeTrackingConfiguration;
    var timeTrackingEnabled = this.timeTrackingEnabled;
    var unassignedIssuesAllowed = this.unassignedIssuesAllowed;
    var votingEnabled = this.votingEnabled;
    var watchingEnabled = this.watchingEnabled;

    final json = <String, Object?>{};
    json[r'attachmentsEnabled'] = attachmentsEnabled;
    json[r'issueLinkingEnabled'] = issueLinkingEnabled;
    json[r'subTasksEnabled'] = subTasksEnabled;
    if (timeTrackingConfiguration != null) {
      json[r'timeTrackingConfiguration'] = timeTrackingConfiguration.toJson();
    }
    json[r'timeTrackingEnabled'] = timeTrackingEnabled;
    json[r'unassignedIssuesAllowed'] = unassignedIssuesAllowed;
    json[r'votingEnabled'] = votingEnabled;
    json[r'watchingEnabled'] = watchingEnabled;
    return json;
  }

  Configuration copyWith(
      {bool? attachmentsEnabled,
      bool? issueLinkingEnabled,
      bool? subTasksEnabled,
      TimeTrackingConfiguration? timeTrackingConfiguration,
      bool? timeTrackingEnabled,
      bool? unassignedIssuesAllowed,
      bool? votingEnabled,
      bool? watchingEnabled}) {
    return Configuration(
      attachmentsEnabled: attachmentsEnabled ?? this.attachmentsEnabled,
      issueLinkingEnabled: issueLinkingEnabled ?? this.issueLinkingEnabled,
      subTasksEnabled: subTasksEnabled ?? this.subTasksEnabled,
      timeTrackingConfiguration:
          timeTrackingConfiguration ?? this.timeTrackingConfiguration,
      timeTrackingEnabled: timeTrackingEnabled ?? this.timeTrackingEnabled,
      unassignedIssuesAllowed:
          unassignedIssuesAllowed ?? this.unassignedIssuesAllowed,
      votingEnabled: votingEnabled ?? this.votingEnabled,
      watchingEnabled: watchingEnabled ?? this.watchingEnabled,
    );
  }
}

/// A list of custom field details.
class ConnectCustomFieldValue {
  /// The type of custom field.
  final ConnectCustomFieldValueType type;

  /// The custom field ID.
  final int fieldId;

  /// The issue ID.
  final int issueId;

  /// The value of number type custom field when `_type` is `NumberIssueField`.
  final num? number;

  /// The value of single select and multiselect custom field type when `_type`
  /// is `SingleSelectIssueField` or `MultiSelectIssueField`.
  final String? optionId;

  /// The value of richText type custom field when `_type` is
  /// `RichTextIssueField`.
  final String? richText;

  /// The value of string type custom field when `_type` is `StringIssueField`.
  final String? string;

  /// The value of of text custom field type when `_type` is `TextIssueField`.
  final String? text;

  ConnectCustomFieldValue(
      {required this.type,
      required this.fieldId,
      required this.issueId,
      this.number,
      this.optionId,
      this.richText,
      this.string,
      this.text});

  factory ConnectCustomFieldValue.fromJson(Map<String, Object?> json) {
    return ConnectCustomFieldValue(
      type: ConnectCustomFieldValueType.fromValue(
          json[r'_type'] as String? ?? ''),
      fieldId: (json[r'fieldID'] as num?)?.toInt() ?? 0,
      issueId: (json[r'issueID'] as num?)?.toInt() ?? 0,
      number: json[r'number'] as num?,
      optionId: json[r'optionID'] as String?,
      richText: json[r'richText'] as String?,
      string: json[r'string'] as String?,
      text: json[r'text'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var fieldId = this.fieldId;
    var issueId = this.issueId;
    var number = this.number;
    var optionId = this.optionId;
    var richText = this.richText;
    var string = this.string;
    var text = this.text;

    final json = <String, Object?>{};
    json[r'_type'] = type.value;
    json[r'fieldID'] = fieldId;
    json[r'issueID'] = issueId;
    if (number != null) {
      json[r'number'] = number;
    }
    if (optionId != null) {
      json[r'optionID'] = optionId;
    }
    if (richText != null) {
      json[r'richText'] = richText;
    }
    if (string != null) {
      json[r'string'] = string;
    }
    if (text != null) {
      json[r'text'] = text;
    }
    return json;
  }

  ConnectCustomFieldValue copyWith(
      {ConnectCustomFieldValueType? type,
      int? fieldId,
      int? issueId,
      num? number,
      String? optionId,
      String? richText,
      String? string,
      String? text}) {
    return ConnectCustomFieldValue(
      type: type ?? this.type,
      fieldId: fieldId ?? this.fieldId,
      issueId: issueId ?? this.issueId,
      number: number ?? this.number,
      optionId: optionId ?? this.optionId,
      richText: richText ?? this.richText,
      string: string ?? this.string,
      text: text ?? this.text,
    );
  }
}

class ConnectCustomFieldValueType {
  static const stringIssueField =
      ConnectCustomFieldValueType._('StringIssueField');
  static const numberIssueField =
      ConnectCustomFieldValueType._('NumberIssueField');
  static const richTextIssueField =
      ConnectCustomFieldValueType._('RichTextIssueField');
  static const singleSelectIssueField =
      ConnectCustomFieldValueType._('SingleSelectIssueField');
  static const multiSelectIssueField =
      ConnectCustomFieldValueType._('MultiSelectIssueField');
  static const textIssueField = ConnectCustomFieldValueType._('TextIssueField');

  static const values = [
    stringIssueField,
    numberIssueField,
    richTextIssueField,
    singleSelectIssueField,
    multiSelectIssueField,
    textIssueField,
  ];
  final String value;

  const ConnectCustomFieldValueType._(this.value);

  static ConnectCustomFieldValueType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ConnectCustomFieldValueType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of updates for a custom field.
class ConnectCustomFieldValues {
  /// The list of custom field update details.
  final List<ConnectCustomFieldValue> updateValueList;

  ConnectCustomFieldValues({List<ConnectCustomFieldValue>? updateValueList})
      : updateValueList = updateValueList ?? [];

  factory ConnectCustomFieldValues.fromJson(Map<String, Object?> json) {
    return ConnectCustomFieldValues(
      updateValueList: (json[r'updateValueList'] as List<Object?>?)
              ?.map((i) => ConnectCustomFieldValue.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var updateValueList = this.updateValueList;

    final json = <String, Object?>{};
    json[r'updateValueList'] = updateValueList.map((i) => i.toJson()).toList();
    return json;
  }

  ConnectCustomFieldValues copyWith(
      {List<ConnectCustomFieldValue>? updateValueList}) {
    return ConnectCustomFieldValues(
      updateValueList: updateValueList ?? this.updateValueList,
    );
  }
}

/// A
/// [Connect module](https://developer.atlassian.com/cloud/jira/platform/about-jira-modules/)
/// in the same format as in the
/// [app descriptor](https://developer.atlassian.com/cloud/jira/platform/app-descriptor/).
class ConnectModule {
  ConnectModule();

  factory ConnectModule.fromJson(Map<String, Object?> json) {
    return ConnectModule();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class ConnectModules {
  /// A list of app modules in the same format as the `modules` property in the
  /// [app descriptor](https://developer.atlassian.com/cloud/jira/platform/app-descriptor/).
  final List<ConnectModule> modules;

  ConnectModules({required this.modules});

  factory ConnectModules.fromJson(Map<String, Object?> json) {
    return ConnectModules(
      modules: (json[r'modules'] as List<Object?>?)
              ?.map((i) => ConnectModule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var modules = this.modules;

    final json = <String, Object?>{};
    json[r'modules'] = modules.map((i) => i.toJson()).toList();
    return json;
  }

  ConnectModules copyWith({List<ConnectModule>? modules}) {
    return ConnectModules(
      modules: modules ?? this.modules,
    );
  }
}

/// A workflow transition rule.
class ConnectWorkflowTransitionRule {
  final RuleConfiguration configuration;

  /// The ID of the transition rule.
  final String id;

  /// The key of the rule, as defined in the Connect app descriptor.
  final String key;
  final WorkflowTransition? transition;

  ConnectWorkflowTransitionRule(
      {required this.configuration,
      required this.id,
      required this.key,
      this.transition});

  factory ConnectWorkflowTransitionRule.fromJson(Map<String, Object?> json) {
    return ConnectWorkflowTransitionRule(
      configuration: RuleConfiguration.fromJson(
          json[r'configuration'] as Map<String, Object?>? ?? const {}),
      id: json[r'id'] as String? ?? '',
      key: json[r'key'] as String? ?? '',
      transition: json[r'transition'] != null
          ? WorkflowTransition.fromJson(
              json[r'transition']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var configuration = this.configuration;
    var id = this.id;
    var key = this.key;
    var transition = this.transition;

    final json = <String, Object?>{};
    json[r'configuration'] = configuration.toJson();
    json[r'id'] = id;
    json[r'key'] = key;
    if (transition != null) {
      json[r'transition'] = transition.toJson();
    }
    return json;
  }

  ConnectWorkflowTransitionRule copyWith(
      {RuleConfiguration? configuration,
      String? id,
      String? key,
      WorkflowTransition? transition}) {
    return ConnectWorkflowTransitionRule(
      configuration: configuration ?? this.configuration,
      id: id ?? this.id,
      key: key ?? this.key,
      transition: transition ?? this.transition,
    );
  }
}

/// The list of features on a project.
class ContainerForProjectFeatures {
  /// The project features.
  final List<ProjectFeature> features;

  ContainerForProjectFeatures({List<ProjectFeature>? features})
      : features = features ?? [];

  factory ContainerForProjectFeatures.fromJson(Map<String, Object?> json) {
    return ContainerForProjectFeatures(
      features: (json[r'features'] as List<Object?>?)
              ?.map((i) => ProjectFeature.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var features = this.features;

    final json = <String, Object?>{};
    json[r'features'] = features.map((i) => i.toJson()).toList();
    return json;
  }

  ContainerForProjectFeatures copyWith({List<ProjectFeature>? features}) {
    return ContainerForProjectFeatures(
      features: features ?? this.features,
    );
  }
}

/// Container for a list of registered webhooks. Webhook details are returned in
/// the same order as the request.
class ContainerForRegisteredWebhooks {
  /// A list of registered webhooks.
  final List<RegisteredWebhook> webhookRegistrationResult;

  ContainerForRegisteredWebhooks(
      {List<RegisteredWebhook>? webhookRegistrationResult})
      : webhookRegistrationResult = webhookRegistrationResult ?? [];

  factory ContainerForRegisteredWebhooks.fromJson(Map<String, Object?> json) {
    return ContainerForRegisteredWebhooks(
      webhookRegistrationResult:
          (json[r'webhookRegistrationResult'] as List<Object?>?)
                  ?.map((i) => RegisteredWebhook.fromJson(
                      i as Map<String, Object?>? ?? const {}))
                  .toList() ??
              [],
    );
  }

  Map<String, Object?> toJson() {
    var webhookRegistrationResult = this.webhookRegistrationResult;

    final json = <String, Object?>{};
    json[r'webhookRegistrationResult'] =
        webhookRegistrationResult.map((i) => i.toJson()).toList();
    return json;
  }

  ContainerForRegisteredWebhooks copyWith(
      {List<RegisteredWebhook>? webhookRegistrationResult}) {
    return ContainerForRegisteredWebhooks(
      webhookRegistrationResult:
          webhookRegistrationResult ?? this.webhookRegistrationResult,
    );
  }
}

/// Container for a list of webhook IDs.
class ContainerForWebhookIDs {
  /// A list of webhook IDs.
  final List<int> webhookIds;

  ContainerForWebhookIDs({required this.webhookIds});

  factory ContainerForWebhookIDs.fromJson(Map<String, Object?> json) {
    return ContainerForWebhookIDs(
      webhookIds: (json[r'webhookIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var webhookIds = this.webhookIds;

    final json = <String, Object?>{};
    json[r'webhookIds'] = webhookIds;
    return json;
  }

  ContainerForWebhookIDs copyWith({List<int>? webhookIds}) {
    return ContainerForWebhookIDs(
      webhookIds: webhookIds ?? this.webhookIds,
    );
  }
}

/// A container for a list of workflow schemes together with the projects they
/// are associated with.
class ContainerOfWorkflowSchemeAssociations {
  /// A list of workflow schemes together with projects they are associated
  /// with.
  final List<WorkflowSchemeAssociations> values;

  ContainerOfWorkflowSchemeAssociations({required this.values});

  factory ContainerOfWorkflowSchemeAssociations.fromJson(
      Map<String, Object?> json) {
    return ContainerOfWorkflowSchemeAssociations(
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => WorkflowSchemeAssociations.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var values = this.values;

    final json = <String, Object?>{};
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  ContainerOfWorkflowSchemeAssociations copyWith(
      {List<WorkflowSchemeAssociations>? values}) {
    return ContainerOfWorkflowSchemeAssociations(
      values: values ?? this.values,
    );
  }
}

/// A context.
class Context {
  /// The ID of the context.
  final int? id;

  /// The name of the context.
  final String? name;

  /// The scope of the context.
  final Scope? scope;

  Context({this.id, this.name, this.scope});

  factory Context.fromJson(Map<String, Object?> json) {
    return Context(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var scope = this.scope;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    return json;
  }

  Context copyWith({int? id, String? name, Scope? scope}) {
    return Context(
      id: id ?? this.id,
      name: name ?? this.name,
      scope: scope ?? this.scope,
    );
  }
}

/// The project and issue type mapping with a matching custom field context.
class ContextForProjectAndIssueType {
  /// The ID of the custom field context.
  final String contextId;

  /// The ID of the issue type.
  final String issueTypeId;

  /// The ID of the project.
  final String projectId;

  ContextForProjectAndIssueType(
      {required this.contextId,
      required this.issueTypeId,
      required this.projectId});

  factory ContextForProjectAndIssueType.fromJson(Map<String, Object?> json) {
    return ContextForProjectAndIssueType(
      contextId: json[r'contextId'] as String? ?? '',
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
      projectId: json[r'projectId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var issueTypeId = this.issueTypeId;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'issueTypeId'] = issueTypeId;
    json[r'projectId'] = projectId;
    return json;
  }

  ContextForProjectAndIssueType copyWith(
      {String? contextId, String? issueTypeId, String? projectId}) {
    return ContextForProjectAndIssueType(
      contextId: contextId ?? this.contextId,
      issueTypeId: issueTypeId ?? this.issueTypeId,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// Details of the contextual configuration for a custom field.
class ContextualConfiguration {
  /// The field configuration.
  final dynamic configuration;

  /// The ID of the field context the configuration is associated with.
  final String fieldContextId;

  /// The ID of the configuration.
  final String id;

  /// The field value schema.
  final dynamic schema;

  ContextualConfiguration(
      {this.configuration,
      required this.fieldContextId,
      required this.id,
      this.schema});

  factory ContextualConfiguration.fromJson(Map<String, Object?> json) {
    return ContextualConfiguration(
      configuration: json[r'configuration'],
      fieldContextId: json[r'fieldContextId'] as String? ?? '',
      id: json[r'id'] as String? ?? '',
      schema: json[r'schema'],
    );
  }

  Map<String, Object?> toJson() {
    var configuration = this.configuration;
    var fieldContextId = this.fieldContextId;
    var id = this.id;
    var schema = this.schema;

    final json = <String, Object?>{};
    if (configuration != null) {
      json[r'configuration'] = configuration;
    }
    json[r'fieldContextId'] = fieldContextId;
    json[r'id'] = id;
    if (schema != null) {
      json[r'schema'] = schema;
    }
    return json;
  }

  ContextualConfiguration copyWith(
      {dynamic configuration,
      String? fieldContextId,
      String? id,
      dynamic schema}) {
    return ContextualConfiguration(
      configuration: configuration ?? this.configuration,
      fieldContextId: fieldContextId ?? this.fieldContextId,
      id: id ?? this.id,
      schema: schema ?? this.schema,
    );
  }
}

/// The converted JQL queries.
class ConvertedJQLQueries {
  /// List of queries containing user information that could not be mapped to an
  /// existing user
  final List<JQLQueryWithUnknownUsers> queriesWithUnknownUsers;

  /// The list of converted query strings with account IDs in place of user
  /// identifiers.
  final List<String> queryStrings;

  ConvertedJQLQueries(
      {List<JQLQueryWithUnknownUsers>? queriesWithUnknownUsers,
      List<String>? queryStrings})
      : queriesWithUnknownUsers = queriesWithUnknownUsers ?? [],
        queryStrings = queryStrings ?? [];

  factory ConvertedJQLQueries.fromJson(Map<String, Object?> json) {
    return ConvertedJQLQueries(
      queriesWithUnknownUsers:
          (json[r'queriesWithUnknownUsers'] as List<Object?>?)
                  ?.map((i) => JQLQueryWithUnknownUsers.fromJson(
                      i as Map<String, Object?>? ?? const {}))
                  .toList() ??
              [],
      queryStrings: (json[r'queryStrings'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var queriesWithUnknownUsers = this.queriesWithUnknownUsers;
    var queryStrings = this.queryStrings;

    final json = <String, Object?>{};
    json[r'queriesWithUnknownUsers'] =
        queriesWithUnknownUsers.map((i) => i.toJson()).toList();
    json[r'queryStrings'] = queryStrings;
    return json;
  }

  ConvertedJQLQueries copyWith(
      {List<JQLQueryWithUnknownUsers>? queriesWithUnknownUsers,
      List<String>? queryStrings}) {
    return ConvertedJQLQueries(
      queriesWithUnknownUsers:
          queriesWithUnknownUsers ?? this.queriesWithUnknownUsers,
      queryStrings: queryStrings ?? this.queryStrings,
    );
  }
}

/// The details of a created custom field context.
class CreateCustomFieldContext {
  /// The description of the context.
  final String? description;

  /// The ID of the context.
  final String? id;

  /// The list of issue types IDs for the context. If the list is empty, the
  /// context refers to all issue types.
  final List<String> issueTypeIds;

  /// The name of the context.
  final String name;

  /// The list of project IDs associated with the context. If the list is empty,
  /// the context is global.
  final List<String> projectIds;

  CreateCustomFieldContext(
      {this.description,
      this.id,
      List<String>? issueTypeIds,
      required this.name,
      List<String>? projectIds})
      : issueTypeIds = issueTypeIds ?? [],
        projectIds = projectIds ?? [];

  factory CreateCustomFieldContext.fromJson(Map<String, Object?> json) {
    return CreateCustomFieldContext(
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      issueTypeIds: (json[r'issueTypeIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      name: json[r'name'] as String? ?? '',
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var issueTypeIds = this.issueTypeIds;
    var name = this.name;
    var projectIds = this.projectIds;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'issueTypeIds'] = issueTypeIds;
    json[r'name'] = name;
    json[r'projectIds'] = projectIds;
    return json;
  }

  CreateCustomFieldContext copyWith(
      {String? description,
      String? id,
      List<String>? issueTypeIds,
      String? name,
      List<String>? projectIds}) {
    return CreateCustomFieldContext(
      description: description ?? this.description,
      id: id ?? this.id,
      issueTypeIds: issueTypeIds ?? this.issueTypeIds,
      name: name ?? this.name,
      projectIds: projectIds ?? this.projectIds,
    );
  }
}

/// Issue security scheme and it's details
class CreateIssueSecuritySchemeDetails {
  /// The description of the issue security scheme.
  final String? description;

  /// The list of scheme levels which should be added to the security scheme.
  final List<SecuritySchemeLevelBean> levels;

  /// The name of the issue security scheme. Must be unique (case-insensitive).
  final String name;

  CreateIssueSecuritySchemeDetails(
      {this.description,
      List<SecuritySchemeLevelBean>? levels,
      required this.name})
      : levels = levels ?? [];

  factory CreateIssueSecuritySchemeDetails.fromJson(Map<String, Object?> json) {
    return CreateIssueSecuritySchemeDetails(
      description: json[r'description'] as String?,
      levels: (json[r'levels'] as List<Object?>?)
              ?.map((i) => SecuritySchemeLevelBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var levels = this.levels;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'levels'] = levels.map((i) => i.toJson()).toList();
    json[r'name'] = name;
    return json;
  }

  CreateIssueSecuritySchemeDetails copyWith(
      {String? description,
      List<SecuritySchemeLevelBean>? levels,
      String? name}) {
    return CreateIssueSecuritySchemeDetails(
      description: description ?? this.description,
      levels: levels ?? this.levels,
      name: name ?? this.name,
    );
  }
}

/// Details of an notification scheme.
class CreateNotificationSchemeDetails {
  /// The description of the notification scheme.
  final String? description;

  /// The name of the notification scheme. Must be unique (case-insensitive).
  final String name;

  /// The list of notifications which should be added to the notification
  /// scheme.
  final List<NotificationSchemeEventDetails> notificationSchemeEvents;

  CreateNotificationSchemeDetails(
      {this.description,
      required this.name,
      List<NotificationSchemeEventDetails>? notificationSchemeEvents})
      : notificationSchemeEvents = notificationSchemeEvents ?? [];

  factory CreateNotificationSchemeDetails.fromJson(Map<String, Object?> json) {
    return CreateNotificationSchemeDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String? ?? '',
      notificationSchemeEvents:
          (json[r'notificationSchemeEvents'] as List<Object?>?)
                  ?.map((i) => NotificationSchemeEventDetails.fromJson(
                      i as Map<String, Object?>? ?? const {}))
                  .toList() ??
              [],
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;
    var notificationSchemeEvents = this.notificationSchemeEvents;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'name'] = name;
    json[r'notificationSchemeEvents'] =
        notificationSchemeEvents.map((i) => i.toJson()).toList();
    return json;
  }

  CreateNotificationSchemeDetails copyWith(
      {String? description,
      String? name,
      List<NotificationSchemeEventDetails>? notificationSchemeEvents}) {
    return CreateNotificationSchemeDetails(
      description: description ?? this.description,
      name: name ?? this.name,
      notificationSchemeEvents:
          notificationSchemeEvents ?? this.notificationSchemeEvents,
    );
  }
}

/// Details of an issue priority.
class CreatePriorityDetails {
  /// The description of the priority.
  final String? description;

  /// The URL of an icon for the priority. Accepted protocols are HTTP and
  /// HTTPS. Built in icons can also be used.
  final CreatePriorityDetailsIconUrl? iconUrl;

  /// The name of the priority. Must be unique.
  final String name;

  /// The status color of the priority in 3-digit or 6-digit hexadecimal format.
  final String statusColor;

  CreatePriorityDetails(
      {this.description,
      this.iconUrl,
      required this.name,
      required this.statusColor});

  factory CreatePriorityDetails.fromJson(Map<String, Object?> json) {
    return CreatePriorityDetails(
      description: json[r'description'] as String?,
      iconUrl: json[r'iconUrl'] != null
          ? CreatePriorityDetailsIconUrl.fromValue(json[r'iconUrl']! as String)
          : null,
      name: json[r'name'] as String? ?? '',
      statusColor: json[r'statusColor'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var iconUrl = this.iconUrl;
    var name = this.name;
    var statusColor = this.statusColor;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (iconUrl != null) {
      json[r'iconUrl'] = iconUrl.value;
    }
    json[r'name'] = name;
    json[r'statusColor'] = statusColor;
    return json;
  }

  CreatePriorityDetails copyWith(
      {String? description,
      CreatePriorityDetailsIconUrl? iconUrl,
      String? name,
      String? statusColor}) {
    return CreatePriorityDetails(
      description: description ?? this.description,
      iconUrl: iconUrl ?? this.iconUrl,
      name: name ?? this.name,
      statusColor: statusColor ?? this.statusColor,
    );
  }
}

class CreatePriorityDetailsIconUrl {
  static const imagesIconsPrioritiesBlockerPng =
      CreatePriorityDetailsIconUrl._('/images/icons/priorities/blocker.png');
  static const imagesIconsPrioritiesCriticalPng =
      CreatePriorityDetailsIconUrl._('/images/icons/priorities/critical.png');
  static const imagesIconsPrioritiesHighPng =
      CreatePriorityDetailsIconUrl._('/images/icons/priorities/high.png');
  static const imagesIconsPrioritiesHighestPng =
      CreatePriorityDetailsIconUrl._('/images/icons/priorities/highest.png');
  static const imagesIconsPrioritiesLowPng =
      CreatePriorityDetailsIconUrl._('/images/icons/priorities/low.png');
  static const imagesIconsPrioritiesLowestPng =
      CreatePriorityDetailsIconUrl._('/images/icons/priorities/lowest.png');
  static const imagesIconsPrioritiesMajorPng =
      CreatePriorityDetailsIconUrl._('/images/icons/priorities/major.png');
  static const imagesIconsPrioritiesMediumPng =
      CreatePriorityDetailsIconUrl._('/images/icons/priorities/medium.png');
  static const imagesIconsPrioritiesMinorPng =
      CreatePriorityDetailsIconUrl._('/images/icons/priorities/minor.png');
  static const imagesIconsPrioritiesTrivialPng =
      CreatePriorityDetailsIconUrl._('/images/icons/priorities/trivial.png');

  static const values = [
    imagesIconsPrioritiesBlockerPng,
    imagesIconsPrioritiesCriticalPng,
    imagesIconsPrioritiesHighPng,
    imagesIconsPrioritiesHighestPng,
    imagesIconsPrioritiesLowPng,
    imagesIconsPrioritiesLowestPng,
    imagesIconsPrioritiesMajorPng,
    imagesIconsPrioritiesMediumPng,
    imagesIconsPrioritiesMinorPng,
    imagesIconsPrioritiesTrivialPng,
  ];
  final String value;

  const CreatePriorityDetailsIconUrl._(this.value);

  static CreatePriorityDetailsIconUrl fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CreatePriorityDetailsIconUrl._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about the project.
class CreateProjectDetails {
  /// The default assignee when creating issues for this project.
  final CreateProjectDetailsAssigneeType? assigneeType;

  /// An integer value for the project's avatar.
  final int? avatarId;

  /// The ID of the project's category. A complete list of category IDs is found
  /// using the
  /// [Get all project categories](#api-rest-api-3-projectCategory-get)
  /// operation.
  final int? categoryId;

  /// A brief description of the project.
  final String? description;

  /// The ID of the field configuration scheme for the project. Use the
  /// [Get all field configuration schemes](#api-rest-api-3-fieldconfigurationscheme-get)
  /// operation to get a list of field configuration scheme IDs. If you specify
  /// the field configuration scheme you cannot specify the project template
  /// key.
  final int? fieldConfigurationScheme;

  /// The ID of the issue security scheme for the project, which enables you to
  /// control who can and cannot view issues. Use the
  /// [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get)
  /// resource to get all issue security scheme IDs.
  final int? issueSecurityScheme;

  /// The ID of the issue type scheme for the project. Use the
  /// [Get all issue type schemes](#api-rest-api-3-issuetypescheme-get)
  /// operation to get a list of issue type scheme IDs. If you specify the issue
  /// type scheme you cannot specify the project template key.
  final int? issueTypeScheme;

  /// The ID of the issue type screen scheme for the project. Use the
  /// [Get all issue type screen schemes](#api-rest-api-3-issuetypescreenscheme-get)
  /// operation to get a list of issue type screen scheme IDs. If you specify
  /// the issue type screen scheme you cannot specify the project template key.
  final int? issueTypeScreenScheme;

  /// Project keys must be unique and start with an uppercase letter followed by
  /// one or more uppercase alphanumeric characters. The maximum length is 10
  /// characters.
  final String key;

  /// This parameter is deprecated because of privacy changes. Use
  /// `leadAccountId` instead. See the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details. The user name of the project lead. Either `lead` or
  /// `leadAccountId` must be set when creating a project. Cannot be provided
  /// with `leadAccountId`.
  final String? lead;

  /// The account ID of the project lead. Either `lead` or `leadAccountId` must
  /// be set when creating a project. Cannot be provided with `lead`.
  final String? leadAccountId;

  /// The name of the project.
  final String name;

  /// The ID of the notification scheme for the project. Use the
  /// [Get notification schemes](#api-rest-api-3-notificationscheme-get)
  /// resource to get a list of notification scheme IDs.
  final int? notificationScheme;

  /// The ID of the permission scheme for the project. Use the
  /// [Get all permission schemes](#api-rest-api-3-permissionscheme-get)
  /// resource to see a list of all permission scheme IDs.
  final int? permissionScheme;

  /// A predefined configuration for a project. The type of the
  /// `projectTemplateKey` must match with the type of the `projectTypeKey`.
  final CreateProjectDetailsProjectTemplateKey? projectTemplateKey;

  /// The
  /// [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes),
  /// which defines the application-specific feature set. If you don't specify
  /// the project template you have to specify the project type.
  final CreateProjectDetailsProjectTypeKey? projectTypeKey;

  /// A link to information about this project, such as project documentation
  final String? url;

  /// The ID of the workflow scheme for the project. Use the
  /// [Get all workflow schemes](#api-rest-api-3-workflowscheme-get) operation
  /// to get a list of workflow scheme IDs. If you specify the workflow scheme
  /// you cannot specify the project template key.
  final int? workflowScheme;

  CreateProjectDetails(
      {this.assigneeType,
      this.avatarId,
      this.categoryId,
      this.description,
      this.fieldConfigurationScheme,
      this.issueSecurityScheme,
      this.issueTypeScheme,
      this.issueTypeScreenScheme,
      required this.key,
      this.lead,
      this.leadAccountId,
      required this.name,
      this.notificationScheme,
      this.permissionScheme,
      this.projectTemplateKey,
      this.projectTypeKey,
      this.url,
      this.workflowScheme});

  factory CreateProjectDetails.fromJson(Map<String, Object?> json) {
    return CreateProjectDetails(
      assigneeType: json[r'assigneeType'] != null
          ? CreateProjectDetailsAssigneeType.fromValue(
              json[r'assigneeType']! as String)
          : null,
      avatarId: (json[r'avatarId'] as num?)?.toInt(),
      categoryId: (json[r'categoryId'] as num?)?.toInt(),
      description: json[r'description'] as String?,
      fieldConfigurationScheme:
          (json[r'fieldConfigurationScheme'] as num?)?.toInt(),
      issueSecurityScheme: (json[r'issueSecurityScheme'] as num?)?.toInt(),
      issueTypeScheme: (json[r'issueTypeScheme'] as num?)?.toInt(),
      issueTypeScreenScheme: (json[r'issueTypeScreenScheme'] as num?)?.toInt(),
      key: json[r'key'] as String? ?? '',
      lead: json[r'lead'] as String?,
      leadAccountId: json[r'leadAccountId'] as String?,
      name: json[r'name'] as String? ?? '',
      notificationScheme: (json[r'notificationScheme'] as num?)?.toInt(),
      permissionScheme: (json[r'permissionScheme'] as num?)?.toInt(),
      projectTemplateKey: json[r'projectTemplateKey'] != null
          ? CreateProjectDetailsProjectTemplateKey.fromValue(
              json[r'projectTemplateKey']! as String)
          : null,
      projectTypeKey: json[r'projectTypeKey'] != null
          ? CreateProjectDetailsProjectTypeKey.fromValue(
              json[r'projectTypeKey']! as String)
          : null,
      url: json[r'url'] as String?,
      workflowScheme: (json[r'workflowScheme'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var assigneeType = this.assigneeType;
    var avatarId = this.avatarId;
    var categoryId = this.categoryId;
    var description = this.description;
    var fieldConfigurationScheme = this.fieldConfigurationScheme;
    var issueSecurityScheme = this.issueSecurityScheme;
    var issueTypeScheme = this.issueTypeScheme;
    var issueTypeScreenScheme = this.issueTypeScreenScheme;
    var key = this.key;
    var lead = this.lead;
    var leadAccountId = this.leadAccountId;
    var name = this.name;
    var notificationScheme = this.notificationScheme;
    var permissionScheme = this.permissionScheme;
    var projectTemplateKey = this.projectTemplateKey;
    var projectTypeKey = this.projectTypeKey;
    var url = this.url;
    var workflowScheme = this.workflowScheme;

    final json = <String, Object?>{};
    if (assigneeType != null) {
      json[r'assigneeType'] = assigneeType.value;
    }
    if (avatarId != null) {
      json[r'avatarId'] = avatarId;
    }
    if (categoryId != null) {
      json[r'categoryId'] = categoryId;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (fieldConfigurationScheme != null) {
      json[r'fieldConfigurationScheme'] = fieldConfigurationScheme;
    }
    if (issueSecurityScheme != null) {
      json[r'issueSecurityScheme'] = issueSecurityScheme;
    }
    if (issueTypeScheme != null) {
      json[r'issueTypeScheme'] = issueTypeScheme;
    }
    if (issueTypeScreenScheme != null) {
      json[r'issueTypeScreenScheme'] = issueTypeScreenScheme;
    }
    json[r'key'] = key;
    if (lead != null) {
      json[r'lead'] = lead;
    }
    if (leadAccountId != null) {
      json[r'leadAccountId'] = leadAccountId;
    }
    json[r'name'] = name;
    if (notificationScheme != null) {
      json[r'notificationScheme'] = notificationScheme;
    }
    if (permissionScheme != null) {
      json[r'permissionScheme'] = permissionScheme;
    }
    if (projectTemplateKey != null) {
      json[r'projectTemplateKey'] = projectTemplateKey.value;
    }
    if (projectTypeKey != null) {
      json[r'projectTypeKey'] = projectTypeKey.value;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    if (workflowScheme != null) {
      json[r'workflowScheme'] = workflowScheme;
    }
    return json;
  }

  CreateProjectDetails copyWith(
      {CreateProjectDetailsAssigneeType? assigneeType,
      int? avatarId,
      int? categoryId,
      String? description,
      int? fieldConfigurationScheme,
      int? issueSecurityScheme,
      int? issueTypeScheme,
      int? issueTypeScreenScheme,
      String? key,
      String? lead,
      String? leadAccountId,
      String? name,
      int? notificationScheme,
      int? permissionScheme,
      CreateProjectDetailsProjectTemplateKey? projectTemplateKey,
      CreateProjectDetailsProjectTypeKey? projectTypeKey,
      String? url,
      int? workflowScheme}) {
    return CreateProjectDetails(
      assigneeType: assigneeType ?? this.assigneeType,
      avatarId: avatarId ?? this.avatarId,
      categoryId: categoryId ?? this.categoryId,
      description: description ?? this.description,
      fieldConfigurationScheme:
          fieldConfigurationScheme ?? this.fieldConfigurationScheme,
      issueSecurityScheme: issueSecurityScheme ?? this.issueSecurityScheme,
      issueTypeScheme: issueTypeScheme ?? this.issueTypeScheme,
      issueTypeScreenScheme:
          issueTypeScreenScheme ?? this.issueTypeScreenScheme,
      key: key ?? this.key,
      lead: lead ?? this.lead,
      leadAccountId: leadAccountId ?? this.leadAccountId,
      name: name ?? this.name,
      notificationScheme: notificationScheme ?? this.notificationScheme,
      permissionScheme: permissionScheme ?? this.permissionScheme,
      projectTemplateKey: projectTemplateKey ?? this.projectTemplateKey,
      projectTypeKey: projectTypeKey ?? this.projectTypeKey,
      url: url ?? this.url,
      workflowScheme: workflowScheme ?? this.workflowScheme,
    );
  }
}

class CreateProjectDetailsAssigneeType {
  static const projectLead = CreateProjectDetailsAssigneeType._('PROJECT_LEAD');
  static const unassigned = CreateProjectDetailsAssigneeType._('UNASSIGNED');

  static const values = [
    projectLead,
    unassigned,
  ];
  final String value;

  const CreateProjectDetailsAssigneeType._(this.value);

  static CreateProjectDetailsAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CreateProjectDetailsAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class CreateProjectDetailsProjectTemplateKey {
  static const comPyxisGreenhopperJiraGhSimplifiedAgilityKanban =
      CreateProjectDetailsProjectTemplateKey._(
          'com.pyxis.greenhopper.jira:gh-simplified-agility-kanban');
  static const comPyxisGreenhopperJiraGhSimplifiedAgilityScrum =
      CreateProjectDetailsProjectTemplateKey._(
          'com.pyxis.greenhopper.jira:gh-simplified-agility-scrum');
  static const comPyxisGreenhopperJiraGhSimplifiedBasic =
      CreateProjectDetailsProjectTemplateKey._(
          'com.pyxis.greenhopper.jira:gh-simplified-basic');
  static const comPyxisGreenhopperJiraGhSimplifiedKanbanClassic =
      CreateProjectDetailsProjectTemplateKey._(
          'com.pyxis.greenhopper.jira:gh-simplified-kanban-classic');
  static const comPyxisGreenhopperJiraGhSimplifiedScrumClassic =
      CreateProjectDetailsProjectTemplateKey._(
          'com.pyxis.greenhopper.jira:gh-simplified-scrum-classic');
  static const comPyxisGreenhopperJiraGhCrossTeamTemplate =
      CreateProjectDetailsProjectTemplateKey._(
          'com.pyxis.greenhopper.jira:gh-cross-team-template');
  static const comAtlassianServicedeskSimplifiedItServiceManagement =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-it-service-management');
  static const comAtlassianServicedeskSimplifiedGeneralServiceDesk =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-general-service-desk');
  static const comAtlassianServicedeskSimplifiedGeneralServiceDeskIt =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-general-service-desk-it');
  static const comAtlassianServicedeskSimplifiedGeneralServiceDeskBusiness =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-general-service-desk-business');
  static const comAtlassianServicedeskSimplifiedInternalServiceDesk =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-internal-service-desk');
  static const comAtlassianServicedeskSimplifiedExternalServiceDesk =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-external-service-desk');
  static const comAtlassianServicedeskSimplifiedHrServiceDesk =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-hr-service-desk');
  static const comAtlassianServicedeskSimplifiedFacilitiesServiceDesk =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-facilities-service-desk');
  static const comAtlassianServicedeskSimplifiedLegalServiceDesk =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-legal-service-desk');
  static const comAtlassianServicedeskSimplifiedMarketingServiceDesk =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-marketing-service-desk');
  static const comAtlassianServicedeskSimplifiedFinanceServiceDesk =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-finance-service-desk');
  static const comAtlassianServicedeskSimplifiedAnalyticsServiceDesk =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-analytics-service-desk');
  static const comAtlassianServicedeskSimplifiedDesignServiceDesk =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-design-service-desk');
  static const comAtlassianServicedeskSimplifiedSalesServiceDesk =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-sales-service-desk');
  static const comAtlassianServicedeskSimplifiedHalpServiceDesk =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-halp-service-desk');
  static const comAtlassianServicedeskSimplifiedBlankProjectIt =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-blank-project-it');
  static const comAtlassianServicedeskSimplifiedBlankProjectBusiness =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.servicedesk:simplified-blank-project-business');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedContentManagement =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-content-management');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedDocumentApproval =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-document-approval');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedLeadTracking =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-lead-tracking');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProcessControl =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-process-control');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProcurement =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-procurement');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProjectManagement =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-project-management');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedRecruitment =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-recruitment');
  static const comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedTask =
      CreateProjectDetailsProjectTemplateKey._(
          'com.atlassian.jira-core-project-templates:jira-core-simplified-task-');

  static const values = [
    comPyxisGreenhopperJiraGhSimplifiedAgilityKanban,
    comPyxisGreenhopperJiraGhSimplifiedAgilityScrum,
    comPyxisGreenhopperJiraGhSimplifiedBasic,
    comPyxisGreenhopperJiraGhSimplifiedKanbanClassic,
    comPyxisGreenhopperJiraGhSimplifiedScrumClassic,
    comPyxisGreenhopperJiraGhCrossTeamTemplate,
    comAtlassianServicedeskSimplifiedItServiceManagement,
    comAtlassianServicedeskSimplifiedGeneralServiceDesk,
    comAtlassianServicedeskSimplifiedGeneralServiceDeskIt,
    comAtlassianServicedeskSimplifiedGeneralServiceDeskBusiness,
    comAtlassianServicedeskSimplifiedInternalServiceDesk,
    comAtlassianServicedeskSimplifiedExternalServiceDesk,
    comAtlassianServicedeskSimplifiedHrServiceDesk,
    comAtlassianServicedeskSimplifiedFacilitiesServiceDesk,
    comAtlassianServicedeskSimplifiedLegalServiceDesk,
    comAtlassianServicedeskSimplifiedMarketingServiceDesk,
    comAtlassianServicedeskSimplifiedFinanceServiceDesk,
    comAtlassianServicedeskSimplifiedAnalyticsServiceDesk,
    comAtlassianServicedeskSimplifiedDesignServiceDesk,
    comAtlassianServicedeskSimplifiedSalesServiceDesk,
    comAtlassianServicedeskSimplifiedHalpServiceDesk,
    comAtlassianServicedeskSimplifiedBlankProjectIt,
    comAtlassianServicedeskSimplifiedBlankProjectBusiness,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedContentManagement,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedDocumentApproval,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedLeadTracking,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProcessControl,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProcurement,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedProjectManagement,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedRecruitment,
    comAtlassianJiraCoreProjectTemplatesJiraCoreSimplifiedTask,
  ];
  final String value;

  const CreateProjectDetailsProjectTemplateKey._(this.value);

  static CreateProjectDetailsProjectTemplateKey fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CreateProjectDetailsProjectTemplateKey._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class CreateProjectDetailsProjectTypeKey {
  static const software = CreateProjectDetailsProjectTypeKey._('software');
  static const serviceDesk =
      CreateProjectDetailsProjectTypeKey._('service_desk');
  static const business = CreateProjectDetailsProjectTypeKey._('business');

  static const values = [
    software,
    serviceDesk,
    business,
  ];
  final String value;

  const CreateProjectDetailsProjectTypeKey._(this.value);

  static CreateProjectDetailsProjectTypeKey fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CreateProjectDetailsProjectTypeKey._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of an issue resolution.
class CreateResolutionDetails {
  /// The description of the resolution.
  final String? description;

  /// The name of the resolution. Must be unique (case-insensitive).
  final String name;

  CreateResolutionDetails({this.description, required this.name});

  factory CreateResolutionDetails.fromJson(Map<String, Object?> json) {
    return CreateResolutionDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'name'] = name;
    return json;
  }

  CreateResolutionDetails copyWith({String? description, String? name}) {
    return CreateResolutionDetails(
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// The details of a UI modification.
class CreateUiModificationDetails {
  /// List of contexts of the UI modification. The maximum number of contexts is
  /// 1000.
  final List<UiModificationContextDetails> contexts;

  /// The data of the UI modification. The maximum size of the data is 50000
  /// characters.
  final String? data;

  /// The description of the UI modification. The maximum length is 255
  /// characters.
  final String? description;

  /// The name of the UI modification. The maximum length is 255 characters.
  final String name;

  CreateUiModificationDetails(
      {List<UiModificationContextDetails>? contexts,
      this.data,
      this.description,
      required this.name})
      : contexts = contexts ?? [];

  factory CreateUiModificationDetails.fromJson(Map<String, Object?> json) {
    return CreateUiModificationDetails(
      contexts: (json[r'contexts'] as List<Object?>?)
              ?.map((i) => UiModificationContextDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      data: json[r'data'] as String?,
      description: json[r'description'] as String?,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contexts = this.contexts;
    var data = this.data;
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    json[r'contexts'] = contexts.map((i) => i.toJson()).toList();
    if (data != null) {
      json[r'data'] = data;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'name'] = name;
    return json;
  }

  CreateUiModificationDetails copyWith(
      {List<UiModificationContextDetails>? contexts,
      String? data,
      String? description,
      String? name}) {
    return CreateUiModificationDetails(
      contexts: contexts ?? this.contexts,
      data: data ?? this.data,
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

class CreateUpdateRoleRequestBean {
  /// A description of the project role. Required when fully updating a project
  /// role. Optional when creating or partially updating a project role.
  final String? description;

  /// The name of the project role. Must be unique. Cannot begin or end with
  /// whitespace. The maximum length is 255 characters. Required when creating a
  /// project role. Optional when partially updating a project role.
  final String? name;

  CreateUpdateRoleRequestBean({this.description, this.name});

  factory CreateUpdateRoleRequestBean.fromJson(Map<String, Object?> json) {
    return CreateUpdateRoleRequestBean(
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  CreateUpdateRoleRequestBean copyWith({String? description, String? name}) {
    return CreateUpdateRoleRequestBean(
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// A workflow transition condition.
class CreateWorkflowCondition {
  /// The list of workflow conditions.
  final List<CreateWorkflowCondition> conditions;

  /// EXPERIMENTAL. The configuration of the transition rule.
  final Map<String, dynamic>? configuration;

  /// The compound condition operator.
  final CreateWorkflowConditionOperator? operator$;

  /// The type of the transition rule.
  final String? type;

  CreateWorkflowCondition(
      {List<CreateWorkflowCondition>? conditions,
      this.configuration,
      this.operator$,
      this.type})
      : conditions = conditions ?? [];

  factory CreateWorkflowCondition.fromJson(Map<String, Object?> json) {
    return CreateWorkflowCondition(
      conditions: (json[r'conditions'] as List<Object?>?)
              ?.map((i) => CreateWorkflowCondition.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      configuration: json[r'configuration'] as Map<String, Object?>?,
      operator$: json[r'operator'] != null
          ? CreateWorkflowConditionOperator.fromValue(
              json[r'operator']! as String)
          : null,
      type: json[r'type'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var conditions = this.conditions;
    var configuration = this.configuration;
    var operator$ = this.operator$;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'conditions'] = conditions.map((i) => i.toJson()).toList();
    if (configuration != null) {
      json[r'configuration'] = configuration;
    }
    if (operator$ != null) {
      json[r'operator'] = operator$.value;
    }
    if (type != null) {
      json[r'type'] = type;
    }
    return json;
  }

  CreateWorkflowCondition copyWith(
      {List<CreateWorkflowCondition>? conditions,
      Map<String, dynamic>? configuration,
      CreateWorkflowConditionOperator? operator$,
      String? type}) {
    return CreateWorkflowCondition(
      conditions: conditions ?? this.conditions,
      configuration: configuration ?? this.configuration,
      operator$: operator$ ?? this.operator$,
      type: type ?? this.type,
    );
  }
}

class CreateWorkflowConditionOperator {
  static const and = CreateWorkflowConditionOperator._('AND');
  static const or = CreateWorkflowConditionOperator._('OR');

  static const values = [
    and,
    or,
  ];
  final String value;

  const CreateWorkflowConditionOperator._(this.value);

  static CreateWorkflowConditionOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CreateWorkflowConditionOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The details of a workflow.
class CreateWorkflowDetails {
  /// The description of the workflow. The maximum length is 1000 characters.
  final String? description;

  /// The name of the workflow. The name must be unique. The maximum length is
  /// 255 characters. Characters can be separated by a whitespace but the name
  /// cannot start or end with a whitespace.
  final String name;

  /// The statuses of the workflow. Any status that does not include a
  /// transition is added to the workflow without a transition.
  final List<CreateWorkflowStatusDetails> statuses;

  /// The transitions of the workflow. For the request to be valid, these
  /// transitions must:
  ///
  ///  *  include one *initial* transition.
  ///  *  not use the same name for a *global* and *directed* transition.
  ///  *  have a unique name for each *global* transition.
  ///  *  have a unique 'to' status for each *global* transition.
  ///  *  have unique names for each transition from a status.
  ///  *  not have a 'from' status on *initial* and *global* transitions.
  ///  *  have a 'from' status on *directed* transitions.
  ///
  /// All the transition statuses must be included in `statuses`.
  final List<CreateWorkflowTransitionDetails> transitions;

  CreateWorkflowDetails(
      {this.description,
      required this.name,
      required this.statuses,
      required this.transitions});

  factory CreateWorkflowDetails.fromJson(Map<String, Object?> json) {
    return CreateWorkflowDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String? ?? '',
      statuses: (json[r'statuses'] as List<Object?>?)
              ?.map((i) => CreateWorkflowStatusDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      transitions: (json[r'transitions'] as List<Object?>?)
              ?.map((i) => CreateWorkflowTransitionDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;
    var statuses = this.statuses;
    var transitions = this.transitions;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'name'] = name;
    json[r'statuses'] = statuses.map((i) => i.toJson()).toList();
    json[r'transitions'] = transitions.map((i) => i.toJson()).toList();
    return json;
  }

  CreateWorkflowDetails copyWith(
      {String? description,
      String? name,
      List<CreateWorkflowStatusDetails>? statuses,
      List<CreateWorkflowTransitionDetails>? transitions}) {
    return CreateWorkflowDetails(
      description: description ?? this.description,
      name: name ?? this.name,
      statuses: statuses ?? this.statuses,
      transitions: transitions ?? this.transitions,
    );
  }
}

/// The details of a transition status.
class CreateWorkflowStatusDetails {
  /// The ID of the status.
  final String id;

  /// The properties of the status.
  final Map<String, dynamic>? properties;

  CreateWorkflowStatusDetails({required this.id, this.properties});

  factory CreateWorkflowStatusDetails.fromJson(Map<String, Object?> json) {
    return CreateWorkflowStatusDetails(
      id: json[r'id'] as String? ?? '',
      properties: json[r'properties'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var properties = this.properties;

    final json = <String, Object?>{};
    json[r'id'] = id;
    if (properties != null) {
      json[r'properties'] = properties;
    }
    return json;
  }

  CreateWorkflowStatusDetails copyWith(
      {String? id, Map<String, dynamic>? properties}) {
    return CreateWorkflowStatusDetails(
      id: id ?? this.id,
      properties: properties ?? this.properties,
    );
  }
}

/// The details of a workflow transition.
class CreateWorkflowTransitionDetails {
  /// The description of the transition. The maximum length is 1000 characters.
  final String? description;

  /// The statuses the transition can start from.
  final List<String> from;

  /// The name of the transition. The maximum length is 60 characters.
  final String name;

  /// The properties of the transition.
  final Map<String, dynamic>? properties;

  /// The rules of the transition.
  final CreateWorkflowTransitionRulesDetails? rules;

  /// The screen of the transition.
  final CreateWorkflowTransitionScreenDetails? screen;

  /// The status the transition goes to.
  final String to;

  /// The type of the transition.
  final CreateWorkflowTransitionDetailsType type;

  CreateWorkflowTransitionDetails(
      {this.description,
      List<String>? from,
      required this.name,
      this.properties,
      this.rules,
      this.screen,
      required this.to,
      required this.type})
      : from = from ?? [];

  factory CreateWorkflowTransitionDetails.fromJson(Map<String, Object?> json) {
    return CreateWorkflowTransitionDetails(
      description: json[r'description'] as String?,
      from: (json[r'from'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      name: json[r'name'] as String? ?? '',
      properties: json[r'properties'] as Map<String, Object?>?,
      rules: json[r'rules'] != null
          ? CreateWorkflowTransitionRulesDetails.fromJson(
              json[r'rules']! as Map<String, Object?>)
          : null,
      screen: json[r'screen'] != null
          ? CreateWorkflowTransitionScreenDetails.fromJson(
              json[r'screen']! as Map<String, Object?>)
          : null,
      to: json[r'to'] as String? ?? '',
      type: CreateWorkflowTransitionDetailsType.fromValue(
          json[r'type'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var from = this.from;
    var name = this.name;
    var properties = this.properties;
    var rules = this.rules;
    var screen = this.screen;
    var to = this.to;
    var type = this.type;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'from'] = from;
    json[r'name'] = name;
    if (properties != null) {
      json[r'properties'] = properties;
    }
    if (rules != null) {
      json[r'rules'] = rules.toJson();
    }
    if (screen != null) {
      json[r'screen'] = screen.toJson();
    }
    json[r'to'] = to;
    json[r'type'] = type.value;
    return json;
  }

  CreateWorkflowTransitionDetails copyWith(
      {String? description,
      List<String>? from,
      String? name,
      Map<String, dynamic>? properties,
      CreateWorkflowTransitionRulesDetails? rules,
      CreateWorkflowTransitionScreenDetails? screen,
      String? to,
      CreateWorkflowTransitionDetailsType? type}) {
    return CreateWorkflowTransitionDetails(
      description: description ?? this.description,
      from: from ?? this.from,
      name: name ?? this.name,
      properties: properties ?? this.properties,
      rules: rules ?? this.rules,
      screen: screen ?? this.screen,
      to: to ?? this.to,
      type: type ?? this.type,
    );
  }
}

class CreateWorkflowTransitionDetailsType {
  static const global = CreateWorkflowTransitionDetailsType._('global');
  static const initial = CreateWorkflowTransitionDetailsType._('initial');
  static const directed = CreateWorkflowTransitionDetailsType._('directed');

  static const values = [
    global,
    initial,
    directed,
  ];
  final String value;

  const CreateWorkflowTransitionDetailsType._(this.value);

  static CreateWorkflowTransitionDetailsType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CreateWorkflowTransitionDetailsType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A workflow transition rule.
class CreateWorkflowTransitionRule {
  /// EXPERIMENTAL. The configuration of the transition rule.
  final Map<String, dynamic>? configuration;

  /// The type of the transition rule.
  final String type;

  CreateWorkflowTransitionRule({this.configuration, required this.type});

  factory CreateWorkflowTransitionRule.fromJson(Map<String, Object?> json) {
    return CreateWorkflowTransitionRule(
      configuration: json[r'configuration'] as Map<String, Object?>?,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var configuration = this.configuration;
    var type = this.type;

    final json = <String, Object?>{};
    if (configuration != null) {
      json[r'configuration'] = configuration;
    }
    json[r'type'] = type;
    return json;
  }

  CreateWorkflowTransitionRule copyWith(
      {Map<String, dynamic>? configuration, String? type}) {
    return CreateWorkflowTransitionRule(
      configuration: configuration ?? this.configuration,
      type: type ?? this.type,
    );
  }
}

/// The details of a workflow transition rules.
class CreateWorkflowTransitionRulesDetails {
  /// The workflow conditions.
  final CreateWorkflowCondition? conditions;

  /// The workflow post functions.
  ///
  /// **Note:** The default post functions are always added to the *initial*
  /// transition, as in:
  ///
  ///     "postFunctions": [
  ///         {
  ///             "type": "IssueCreateFunction"
  ///         },
  ///         {
  ///             "type": "IssueReindexFunction"
  ///         },
  ///         {
  ///             "type": "FireIssueEventFunction",
  ///             "configuration": {
  ///                 "event": {
  ///                     "id": "1",
  ///                     "name": "issue_created"
  ///                 }
  ///             }
  ///         }
  ///     ]
  ///
  /// **Note:** The default post functions are always added to the *global* and
  /// *directed* transitions, as in:
  ///
  ///     "postFunctions": [
  ///         {
  ///             "type": "UpdateIssueStatusFunction"
  ///         },
  ///         {
  ///             "type": "CreateCommentFunction"
  ///         },
  ///         {
  ///             "type": "GenerateChangeHistoryFunction"
  ///         },
  ///         {
  ///             "type": "IssueReindexFunction"
  ///         },
  ///         {
  ///             "type": "FireIssueEventFunction",
  ///             "configuration": {
  ///                 "event": {
  ///                     "id": "13",
  ///                     "name": "issue_generic"
  ///                 }
  ///             }
  ///         }
  ///     ]
  final List<CreateWorkflowTransitionRule> postFunctions;

  /// The workflow validators.
  ///
  /// **Note:** The default permission validator is always added to the
  /// *initial* transition, as in:
  ///
  ///     "validators": [
  ///         {
  ///             "type": "PermissionValidator",
  ///             "configuration": {
  ///                 "permissionKey": "CREATE_ISSUES"
  ///             }
  ///         }
  ///     ]
  final List<CreateWorkflowTransitionRule> validators;

  CreateWorkflowTransitionRulesDetails(
      {this.conditions,
      List<CreateWorkflowTransitionRule>? postFunctions,
      List<CreateWorkflowTransitionRule>? validators})
      : postFunctions = postFunctions ?? [],
        validators = validators ?? [];

  factory CreateWorkflowTransitionRulesDetails.fromJson(
      Map<String, Object?> json) {
    return CreateWorkflowTransitionRulesDetails(
      conditions: json[r'conditions'] != null
          ? CreateWorkflowCondition.fromJson(
              json[r'conditions']! as Map<String, Object?>)
          : null,
      postFunctions: (json[r'postFunctions'] as List<Object?>?)
              ?.map((i) => CreateWorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      validators: (json[r'validators'] as List<Object?>?)
              ?.map((i) => CreateWorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var conditions = this.conditions;
    var postFunctions = this.postFunctions;
    var validators = this.validators;

    final json = <String, Object?>{};
    if (conditions != null) {
      json[r'conditions'] = conditions.toJson();
    }
    json[r'postFunctions'] = postFunctions.map((i) => i.toJson()).toList();
    json[r'validators'] = validators.map((i) => i.toJson()).toList();
    return json;
  }

  CreateWorkflowTransitionRulesDetails copyWith(
      {CreateWorkflowCondition? conditions,
      List<CreateWorkflowTransitionRule>? postFunctions,
      List<CreateWorkflowTransitionRule>? validators}) {
    return CreateWorkflowTransitionRulesDetails(
      conditions: conditions ?? this.conditions,
      postFunctions: postFunctions ?? this.postFunctions,
      validators: validators ?? this.validators,
    );
  }
}

/// The details of a transition screen.
class CreateWorkflowTransitionScreenDetails {
  /// The ID of the screen.
  final String id;

  CreateWorkflowTransitionScreenDetails({required this.id});

  factory CreateWorkflowTransitionScreenDetails.fromJson(
      Map<String, Object?> json) {
    return CreateWorkflowTransitionScreenDetails(
      id: json[r'id'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  CreateWorkflowTransitionScreenDetails copyWith({String? id}) {
    return CreateWorkflowTransitionScreenDetails(
      id: id ?? this.id,
    );
  }
}

/// Details about a created issue or subtask.
class CreatedIssue {
  /// The ID of the created issue or subtask.
  final String? id;

  /// The key of the created issue or subtask.
  final String? key;

  /// The URL of the created issue or subtask.
  final String? self;

  /// The response code and messages related to any requested transition.
  final NestedResponse? transition;

  /// The response code and messages related to any requested watchers.
  final NestedResponse? watchers;

  CreatedIssue({this.id, this.key, this.self, this.transition, this.watchers});

  factory CreatedIssue.fromJson(Map<String, Object?> json) {
    return CreatedIssue(
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      self: json[r'self'] as String?,
      transition: json[r'transition'] != null
          ? NestedResponse.fromJson(
              json[r'transition']! as Map<String, Object?>)
          : null,
      watchers: json[r'watchers'] != null
          ? NestedResponse.fromJson(json[r'watchers']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;
    var self = this.self;
    var transition = this.transition;
    var watchers = this.watchers;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (transition != null) {
      json[r'transition'] = transition.toJson();
    }
    if (watchers != null) {
      json[r'watchers'] = watchers.toJson();
    }
    return json;
  }

  CreatedIssue copyWith(
      {String? id,
      String? key,
      String? self,
      NestedResponse? transition,
      NestedResponse? watchers}) {
    return CreatedIssue(
      id: id ?? this.id,
      key: key ?? this.key,
      self: self ?? this.self,
      transition: transition ?? this.transition,
      watchers: watchers ?? this.watchers,
    );
  }
}

/// Details about the issues created and the errors for requests that failed.
class CreatedIssues {
  /// Error details for failed issue creation requests.
  final List<BulkOperationErrorResult> errors;

  /// Details of the issues created.
  final List<CreatedIssue> issues;

  CreatedIssues(
      {List<BulkOperationErrorResult>? errors, List<CreatedIssue>? issues})
      : errors = errors ?? [],
        issues = issues ?? [];

  factory CreatedIssues.fromJson(Map<String, Object?> json) {
    return CreatedIssues(
      errors: (json[r'errors'] as List<Object?>?)
              ?.map((i) => BulkOperationErrorResult.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      issues: (json[r'issues'] as List<Object?>?)
              ?.map((i) =>
                  CreatedIssue.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var errors = this.errors;
    var issues = this.issues;

    final json = <String, Object?>{};
    json[r'errors'] = errors.map((i) => i.toJson()).toList();
    json[r'issues'] = issues.map((i) => i.toJson()).toList();
    return json;
  }

  CreatedIssues copyWith(
      {List<BulkOperationErrorResult>? errors, List<CreatedIssue>? issues}) {
    return CreatedIssues(
      errors: errors ?? this.errors,
      issues: issues ?? this.issues,
    );
  }
}

class CustomContextVariable {
  /// Type of custom context variable.
  final String type;

  CustomContextVariable({required this.type});

  factory CustomContextVariable.fromJson(Map<String, Object?> json) {
    return CustomContextVariable(
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;

    final json = <String, Object?>{};
    json[r'type'] = type;
    return json;
  }

  CustomContextVariable copyWith({String? type}) {
    return CustomContextVariable(
      type: type ?? this.type,
    );
  }
}

/// Details of configurations for a custom field.
class CustomFieldConfigurations {
  /// The list of custom field configuration details.
  final List<ContextualConfiguration> configurations;

  CustomFieldConfigurations({required this.configurations});

  factory CustomFieldConfigurations.fromJson(Map<String, Object?> json) {
    return CustomFieldConfigurations(
      configurations: (json[r'configurations'] as List<Object?>?)
              ?.map((i) => ContextualConfiguration.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var configurations = this.configurations;

    final json = <String, Object?>{};
    json[r'configurations'] = configurations.map((i) => i.toJson()).toList();
    return json;
  }

  CustomFieldConfigurations copyWith(
      {List<ContextualConfiguration>? configurations}) {
    return CustomFieldConfigurations(
      configurations: configurations ?? this.configurations,
    );
  }
}

/// The details of a custom field context.
class CustomFieldContext {
  /// The description of the context.
  final String description;

  /// The ID of the context.
  final String id;

  /// Whether the context apply to all issue types.
  final bool isAnyIssueType;

  /// Whether the context is global.
  final bool isGlobalContext;

  /// The name of the context.
  final String name;

  CustomFieldContext(
      {required this.description,
      required this.id,
      required this.isAnyIssueType,
      required this.isGlobalContext,
      required this.name});

  factory CustomFieldContext.fromJson(Map<String, Object?> json) {
    return CustomFieldContext(
      description: json[r'description'] as String? ?? '',
      id: json[r'id'] as String? ?? '',
      isAnyIssueType: json[r'isAnyIssueType'] as bool? ?? false,
      isGlobalContext: json[r'isGlobalContext'] as bool? ?? false,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var isAnyIssueType = this.isAnyIssueType;
    var isGlobalContext = this.isGlobalContext;
    var name = this.name;

    final json = <String, Object?>{};
    json[r'description'] = description;
    json[r'id'] = id;
    json[r'isAnyIssueType'] = isAnyIssueType;
    json[r'isGlobalContext'] = isGlobalContext;
    json[r'name'] = name;
    return json;
  }

  CustomFieldContext copyWith(
      {String? description,
      String? id,
      bool? isAnyIssueType,
      bool? isGlobalContext,
      String? name}) {
    return CustomFieldContext(
      description: description ?? this.description,
      id: id ?? this.id,
      isAnyIssueType: isAnyIssueType ?? this.isAnyIssueType,
      isGlobalContext: isGlobalContext ?? this.isGlobalContext,
      name: name ?? this.name,
    );
  }
}

class CustomFieldContextDefaultValue {
  CustomFieldContextDefaultValue();

  factory CustomFieldContextDefaultValue.fromJson(Map<String, Object?> json) {
    return CustomFieldContextDefaultValue();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// The default value for a cascading select custom field.
class CustomFieldContextDefaultValueCascadingOption {
  /// The ID of the default cascading option.
  final String? cascadingOptionId;

  /// The ID of the context.
  final String contextId;

  /// The ID of the default option.
  final String optionId;
  final String type;

  CustomFieldContextDefaultValueCascadingOption(
      {this.cascadingOptionId,
      required this.contextId,
      required this.optionId,
      required this.type});

  factory CustomFieldContextDefaultValueCascadingOption.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueCascadingOption(
      cascadingOptionId: json[r'cascadingOptionId'] as String?,
      contextId: json[r'contextId'] as String? ?? '',
      optionId: json[r'optionId'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var cascadingOptionId = this.cascadingOptionId;
    var contextId = this.contextId;
    var optionId = this.optionId;
    var type = this.type;

    final json = <String, Object?>{};
    if (cascadingOptionId != null) {
      json[r'cascadingOptionId'] = cascadingOptionId;
    }
    json[r'contextId'] = contextId;
    json[r'optionId'] = optionId;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueCascadingOption copyWith(
      {String? cascadingOptionId,
      String? contextId,
      String? optionId,
      String? type}) {
    return CustomFieldContextDefaultValueCascadingOption(
      cascadingOptionId: cascadingOptionId ?? this.cascadingOptionId,
      contextId: contextId ?? this.contextId,
      optionId: optionId ?? this.optionId,
      type: type ?? this.type,
    );
  }
}

/// The default value for a Date custom field.
class CustomFieldContextDefaultValueDate {
  /// The default date in ISO format. Ignored if `useCurrent` is true.
  final String? date;
  final String type;

  /// Whether to use the current date.
  final bool useCurrent;

  CustomFieldContextDefaultValueDate(
      {this.date, required this.type, bool? useCurrent})
      : useCurrent = useCurrent ?? false;

  factory CustomFieldContextDefaultValueDate.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueDate(
      date: json[r'date'] as String?,
      type: json[r'type'] as String? ?? '',
      useCurrent: json[r'useCurrent'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var date = this.date;
    var type = this.type;
    var useCurrent = this.useCurrent;

    final json = <String, Object?>{};
    if (date != null) {
      json[r'date'] = date;
    }
    json[r'type'] = type;
    json[r'useCurrent'] = useCurrent;
    return json;
  }

  CustomFieldContextDefaultValueDate copyWith(
      {String? date, String? type, bool? useCurrent}) {
    return CustomFieldContextDefaultValueDate(
      date: date ?? this.date,
      type: type ?? this.type,
      useCurrent: useCurrent ?? this.useCurrent,
    );
  }
}

/// The default value for a date time custom field.
class CustomFieldContextDefaultValueDateTime {
  /// The default date-time in ISO format. Ignored if `useCurrent` is true.
  final String? dateTime;
  final String type;

  /// Whether to use the current date.
  final bool useCurrent;

  CustomFieldContextDefaultValueDateTime(
      {this.dateTime, required this.type, bool? useCurrent})
      : useCurrent = useCurrent ?? false;

  factory CustomFieldContextDefaultValueDateTime.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueDateTime(
      dateTime: json[r'dateTime'] as String?,
      type: json[r'type'] as String? ?? '',
      useCurrent: json[r'useCurrent'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var dateTime = this.dateTime;
    var type = this.type;
    var useCurrent = this.useCurrent;

    final json = <String, Object?>{};
    if (dateTime != null) {
      json[r'dateTime'] = dateTime;
    }
    json[r'type'] = type;
    json[r'useCurrent'] = useCurrent;
    return json;
  }

  CustomFieldContextDefaultValueDateTime copyWith(
      {String? dateTime, String? type, bool? useCurrent}) {
    return CustomFieldContextDefaultValueDateTime(
      dateTime: dateTime ?? this.dateTime,
      type: type ?? this.type,
      useCurrent: useCurrent ?? this.useCurrent,
    );
  }
}

/// Default value for a float (number) custom field.
class CustomFieldContextDefaultValueFloat {
  /// The default floating-point number.
  final num number;
  final String type;

  CustomFieldContextDefaultValueFloat(
      {required this.number, required this.type});

  factory CustomFieldContextDefaultValueFloat.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueFloat(
      number: json[r'number'] as num? ?? 0,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var number = this.number;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'number'] = number;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueFloat copyWith({num? number, String? type}) {
    return CustomFieldContextDefaultValueFloat(
      number: number ?? this.number,
      type: type ?? this.type,
    );
  }
}

/// The default value for a Forge date time custom field.
class CustomFieldContextDefaultValueForgeDateTimeField {
  /// The ID of the context.
  final String contextId;

  /// The default date-time in ISO format. Ignored if `useCurrent` is true.
  final String? dateTime;
  final String type;

  /// Whether to use the current date.
  final bool useCurrent;

  CustomFieldContextDefaultValueForgeDateTimeField(
      {required this.contextId,
      this.dateTime,
      required this.type,
      bool? useCurrent})
      : useCurrent = useCurrent ?? false;

  factory CustomFieldContextDefaultValueForgeDateTimeField.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueForgeDateTimeField(
      contextId: json[r'contextId'] as String? ?? '',
      dateTime: json[r'dateTime'] as String?,
      type: json[r'type'] as String? ?? '',
      useCurrent: json[r'useCurrent'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var dateTime = this.dateTime;
    var type = this.type;
    var useCurrent = this.useCurrent;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    if (dateTime != null) {
      json[r'dateTime'] = dateTime;
    }
    json[r'type'] = type;
    json[r'useCurrent'] = useCurrent;
    return json;
  }

  CustomFieldContextDefaultValueForgeDateTimeField copyWith(
      {String? contextId, String? dateTime, String? type, bool? useCurrent}) {
    return CustomFieldContextDefaultValueForgeDateTimeField(
      contextId: contextId ?? this.contextId,
      dateTime: dateTime ?? this.dateTime,
      type: type ?? this.type,
      useCurrent: useCurrent ?? this.useCurrent,
    );
  }
}

/// The default value for a Forge group custom field.
class CustomFieldContextDefaultValueForgeGroupField {
  /// The ID of the context.
  final String contextId;

  /// The ID of the the default group.
  final String groupId;
  final String type;

  CustomFieldContextDefaultValueForgeGroupField(
      {required this.contextId, required this.groupId, required this.type});

  factory CustomFieldContextDefaultValueForgeGroupField.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueForgeGroupField(
      contextId: json[r'contextId'] as String? ?? '',
      groupId: json[r'groupId'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var groupId = this.groupId;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'groupId'] = groupId;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueForgeGroupField copyWith(
      {String? contextId, String? groupId, String? type}) {
    return CustomFieldContextDefaultValueForgeGroupField(
      contextId: contextId ?? this.contextId,
      groupId: groupId ?? this.groupId,
      type: type ?? this.type,
    );
  }
}

/// The default value for a Forge collection of groups custom field.
class CustomFieldContextDefaultValueForgeMultiGroupField {
  /// The ID of the context.
  final String contextId;

  /// The IDs of the default groups.
  final List<String> groupIds;
  final String type;

  CustomFieldContextDefaultValueForgeMultiGroupField(
      {required this.contextId, required this.groupIds, required this.type});

  factory CustomFieldContextDefaultValueForgeMultiGroupField.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueForgeMultiGroupField(
      contextId: json[r'contextId'] as String? ?? '',
      groupIds: (json[r'groupIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var groupIds = this.groupIds;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'groupIds'] = groupIds;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueForgeMultiGroupField copyWith(
      {String? contextId, List<String>? groupIds, String? type}) {
    return CustomFieldContextDefaultValueForgeMultiGroupField(
      contextId: contextId ?? this.contextId,
      groupIds: groupIds ?? this.groupIds,
      type: type ?? this.type,
    );
  }
}

/// The default text for a Forge collection of strings custom field.
class CustomFieldContextDefaultValueForgeMultiStringField {
  final String type;

  /// List of string values. The maximum length for a value is 254 characters.
  final List<String> values;

  CustomFieldContextDefaultValueForgeMultiStringField(
      {required this.type, List<String>? values})
      : values = values ?? [];

  factory CustomFieldContextDefaultValueForgeMultiStringField.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueForgeMultiStringField(
      type: json[r'type'] as String? ?? '',
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'type'] = type;
    json[r'values'] = values;
    return json;
  }

  CustomFieldContextDefaultValueForgeMultiStringField copyWith(
      {String? type, List<String>? values}) {
    return CustomFieldContextDefaultValueForgeMultiStringField(
      type: type ?? this.type,
      values: values ?? this.values,
    );
  }
}

/// Defaults for a Forge collection of users custom field.
class CustomFieldContextDefaultValueForgeMultiUserField {
  /// The IDs of the default users.
  final List<String> accountIds;

  /// The ID of the context.
  final String contextId;
  final String type;

  CustomFieldContextDefaultValueForgeMultiUserField(
      {required this.accountIds, required this.contextId, required this.type});

  factory CustomFieldContextDefaultValueForgeMultiUserField.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueForgeMultiUserField(
      accountIds: (json[r'accountIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      contextId: json[r'contextId'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var accountIds = this.accountIds;
    var contextId = this.contextId;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'accountIds'] = accountIds;
    json[r'contextId'] = contextId;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueForgeMultiUserField copyWith(
      {List<String>? accountIds, String? contextId, String? type}) {
    return CustomFieldContextDefaultValueForgeMultiUserField(
      accountIds: accountIds ?? this.accountIds,
      contextId: contextId ?? this.contextId,
      type: type ?? this.type,
    );
  }
}

/// Default value for a Forge number custom field.
class CustomFieldContextDefaultValueForgeNumberField {
  /// The ID of the context.
  final String contextId;

  /// The default floating-point number.
  final num number;
  final String type;

  CustomFieldContextDefaultValueForgeNumberField(
      {required this.contextId, required this.number, required this.type});

  factory CustomFieldContextDefaultValueForgeNumberField.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueForgeNumberField(
      contextId: json[r'contextId'] as String? ?? '',
      number: json[r'number'] as num? ?? 0,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var number = this.number;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'number'] = number;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueForgeNumberField copyWith(
      {String? contextId, num? number, String? type}) {
    return CustomFieldContextDefaultValueForgeNumberField(
      contextId: contextId ?? this.contextId,
      number: number ?? this.number,
      type: type ?? this.type,
    );
  }
}

/// The default value for a Forge object custom field.
class CustomFieldContextDefaultValueForgeObjectField {
  /// The default JSON object.
  final Map<String, dynamic>? object;
  final String type;

  CustomFieldContextDefaultValueForgeObjectField(
      {this.object, required this.type});

  factory CustomFieldContextDefaultValueForgeObjectField.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueForgeObjectField(
      object: json[r'object'] as Map<String, Object?>?,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var object = this.object;
    var type = this.type;

    final json = <String, Object?>{};
    if (object != null) {
      json[r'object'] = object;
    }
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueForgeObjectField copyWith(
      {Map<String, dynamic>? object, String? type}) {
    return CustomFieldContextDefaultValueForgeObjectField(
      object: object ?? this.object,
      type: type ?? this.type,
    );
  }
}

/// The default text for a Forge string custom field.
class CustomFieldContextDefaultValueForgeStringField {
  /// The ID of the context.
  final String contextId;

  /// The default text. The maximum length is 254 characters.
  final String? text;
  final String type;

  CustomFieldContextDefaultValueForgeStringField(
      {required this.contextId, this.text, required this.type});

  factory CustomFieldContextDefaultValueForgeStringField.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueForgeStringField(
      contextId: json[r'contextId'] as String? ?? '',
      text: json[r'text'] as String?,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var text = this.text;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    if (text != null) {
      json[r'text'] = text;
    }
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueForgeStringField copyWith(
      {String? contextId, String? text, String? type}) {
    return CustomFieldContextDefaultValueForgeStringField(
      contextId: contextId ?? this.contextId,
      text: text ?? this.text,
      type: type ?? this.type,
    );
  }
}

/// Defaults for a Forge user custom field.
class CustomFieldContextDefaultValueForgeUserField {
  /// The ID of the default user.
  final String accountId;

  /// The ID of the context.
  final String contextId;
  final String type;
  final UserFilter userFilter;

  CustomFieldContextDefaultValueForgeUserField(
      {required this.accountId,
      required this.contextId,
      required this.type,
      required this.userFilter});

  factory CustomFieldContextDefaultValueForgeUserField.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueForgeUserField(
      accountId: json[r'accountId'] as String? ?? '',
      contextId: json[r'contextId'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
      userFilter: UserFilter.fromJson(
          json[r'userFilter'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var contextId = this.contextId;
    var type = this.type;
    var userFilter = this.userFilter;

    final json = <String, Object?>{};
    json[r'accountId'] = accountId;
    json[r'contextId'] = contextId;
    json[r'type'] = type;
    json[r'userFilter'] = userFilter.toJson();
    return json;
  }

  CustomFieldContextDefaultValueForgeUserField copyWith(
      {String? accountId,
      String? contextId,
      String? type,
      UserFilter? userFilter}) {
    return CustomFieldContextDefaultValueForgeUserField(
      accountId: accountId ?? this.accountId,
      contextId: contextId ?? this.contextId,
      type: type ?? this.type,
      userFilter: userFilter ?? this.userFilter,
    );
  }
}

/// Default value for a labels custom field.
class CustomFieldContextDefaultValueLabels {
  /// The default labels value.
  final List<String> labels;
  final String type;

  CustomFieldContextDefaultValueLabels(
      {required this.labels, required this.type});

  factory CustomFieldContextDefaultValueLabels.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueLabels(
      labels: (json[r'labels'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var labels = this.labels;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'labels'] = labels;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueLabels copyWith(
      {List<String>? labels, String? type}) {
    return CustomFieldContextDefaultValueLabels(
      labels: labels ?? this.labels,
      type: type ?? this.type,
    );
  }
}

/// The default value for a User Picker (multiple) custom field.
class CustomFieldContextDefaultValueMultiUserPicker {
  /// The IDs of the default users.
  final List<String> accountIds;

  /// The ID of the context.
  final String contextId;
  final String type;

  CustomFieldContextDefaultValueMultiUserPicker(
      {required this.accountIds, required this.contextId, required this.type});

  factory CustomFieldContextDefaultValueMultiUserPicker.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueMultiUserPicker(
      accountIds: (json[r'accountIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      contextId: json[r'contextId'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var accountIds = this.accountIds;
    var contextId = this.contextId;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'accountIds'] = accountIds;
    json[r'contextId'] = contextId;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueMultiUserPicker copyWith(
      {List<String>? accountIds, String? contextId, String? type}) {
    return CustomFieldContextDefaultValueMultiUserPicker(
      accountIds: accountIds ?? this.accountIds,
      contextId: contextId ?? this.contextId,
      type: type ?? this.type,
    );
  }
}

/// The default value for a multiple group picker custom field.
class CustomFieldContextDefaultValueMultipleGroupPicker {
  /// The ID of the context.
  final String contextId;

  /// The IDs of the default groups.
  final List<String> groupIds;
  final String type;

  CustomFieldContextDefaultValueMultipleGroupPicker(
      {required this.contextId, required this.groupIds, required this.type});

  factory CustomFieldContextDefaultValueMultipleGroupPicker.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueMultipleGroupPicker(
      contextId: json[r'contextId'] as String? ?? '',
      groupIds: (json[r'groupIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var groupIds = this.groupIds;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'groupIds'] = groupIds;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueMultipleGroupPicker copyWith(
      {String? contextId, List<String>? groupIds, String? type}) {
    return CustomFieldContextDefaultValueMultipleGroupPicker(
      contextId: contextId ?? this.contextId,
      groupIds: groupIds ?? this.groupIds,
      type: type ?? this.type,
    );
  }
}

/// The default value for a multi-select custom field.
class CustomFieldContextDefaultValueMultipleOption {
  /// The ID of the context.
  final String contextId;

  /// The list of IDs of the default options.
  final List<String> optionIds;
  final String type;

  CustomFieldContextDefaultValueMultipleOption(
      {required this.contextId, required this.optionIds, required this.type});

  factory CustomFieldContextDefaultValueMultipleOption.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueMultipleOption(
      contextId: json[r'contextId'] as String? ?? '',
      optionIds: (json[r'optionIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var optionIds = this.optionIds;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'optionIds'] = optionIds;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueMultipleOption copyWith(
      {String? contextId, List<String>? optionIds, String? type}) {
    return CustomFieldContextDefaultValueMultipleOption(
      contextId: contextId ?? this.contextId,
      optionIds: optionIds ?? this.optionIds,
      type: type ?? this.type,
    );
  }
}

/// The default value for a multiple version picker custom field.
class CustomFieldContextDefaultValueMultipleVersionPicker {
  final String type;

  /// The IDs of the default versions.
  final List<String> versionIds;

  /// The order the pickable versions are displayed in. If not provided, the
  /// released-first order is used. Available version orders are
  /// `"releasedFirst"` and `"unreleasedFirst"`.
  final String? versionOrder;

  CustomFieldContextDefaultValueMultipleVersionPicker(
      {required this.type, required this.versionIds, this.versionOrder});

  factory CustomFieldContextDefaultValueMultipleVersionPicker.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueMultipleVersionPicker(
      type: json[r'type'] as String? ?? '',
      versionIds: (json[r'versionIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      versionOrder: json[r'versionOrder'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var versionIds = this.versionIds;
    var versionOrder = this.versionOrder;

    final json = <String, Object?>{};
    json[r'type'] = type;
    json[r'versionIds'] = versionIds;
    if (versionOrder != null) {
      json[r'versionOrder'] = versionOrder;
    }
    return json;
  }

  CustomFieldContextDefaultValueMultipleVersionPicker copyWith(
      {String? type, List<String>? versionIds, String? versionOrder}) {
    return CustomFieldContextDefaultValueMultipleVersionPicker(
      type: type ?? this.type,
      versionIds: versionIds ?? this.versionIds,
      versionOrder: versionOrder ?? this.versionOrder,
    );
  }
}

/// The default value for a project custom field.
class CustomFieldContextDefaultValueProject {
  /// The ID of the context.
  final String contextId;

  /// The ID of the default project.
  final String projectId;
  final String type;

  CustomFieldContextDefaultValueProject(
      {required this.contextId, required this.projectId, required this.type});

  factory CustomFieldContextDefaultValueProject.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueProject(
      contextId: json[r'contextId'] as String? ?? '',
      projectId: json[r'projectId'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var projectId = this.projectId;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'projectId'] = projectId;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueProject copyWith(
      {String? contextId, String? projectId, String? type}) {
    return CustomFieldContextDefaultValueProject(
      contextId: contextId ?? this.contextId,
      projectId: projectId ?? this.projectId,
      type: type ?? this.type,
    );
  }
}

/// The default text for a read only custom field.
class CustomFieldContextDefaultValueReadOnly {
  /// The default text. The maximum length is 255 characters.
  final String? text;
  final String type;

  CustomFieldContextDefaultValueReadOnly({this.text, required this.type});

  factory CustomFieldContextDefaultValueReadOnly.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueReadOnly(
      text: json[r'text'] as String?,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var text = this.text;
    var type = this.type;

    final json = <String, Object?>{};
    if (text != null) {
      json[r'text'] = text;
    }
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueReadOnly copyWith(
      {String? text, String? type}) {
    return CustomFieldContextDefaultValueReadOnly(
      text: text ?? this.text,
      type: type ?? this.type,
    );
  }
}

/// The default value for a group picker custom field.
class CustomFieldContextDefaultValueSingleGroupPicker {
  /// The ID of the context.
  final String contextId;

  /// The ID of the the default group.
  final String groupId;
  final String type;

  CustomFieldContextDefaultValueSingleGroupPicker(
      {required this.contextId, required this.groupId, required this.type});

  factory CustomFieldContextDefaultValueSingleGroupPicker.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueSingleGroupPicker(
      contextId: json[r'contextId'] as String? ?? '',
      groupId: json[r'groupId'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var groupId = this.groupId;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'groupId'] = groupId;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueSingleGroupPicker copyWith(
      {String? contextId, String? groupId, String? type}) {
    return CustomFieldContextDefaultValueSingleGroupPicker(
      contextId: contextId ?? this.contextId,
      groupId: groupId ?? this.groupId,
      type: type ?? this.type,
    );
  }
}

/// The default value for a single select custom field.
class CustomFieldContextDefaultValueSingleOption {
  /// The ID of the context.
  final String contextId;

  /// The ID of the default option.
  final String optionId;
  final String type;

  CustomFieldContextDefaultValueSingleOption(
      {required this.contextId, required this.optionId, required this.type});

  factory CustomFieldContextDefaultValueSingleOption.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueSingleOption(
      contextId: json[r'contextId'] as String? ?? '',
      optionId: json[r'optionId'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var optionId = this.optionId;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'optionId'] = optionId;
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueSingleOption copyWith(
      {String? contextId, String? optionId, String? type}) {
    return CustomFieldContextDefaultValueSingleOption(
      contextId: contextId ?? this.contextId,
      optionId: optionId ?? this.optionId,
      type: type ?? this.type,
    );
  }
}

/// The default value for a version picker custom field.
class CustomFieldContextDefaultValueSingleVersionPicker {
  final String type;

  /// The ID of the default version.
  final String versionId;

  /// The order the pickable versions are displayed in. If not provided, the
  /// released-first order is used. Available version orders are
  /// `"releasedFirst"` and `"unreleasedFirst"`.
  final String? versionOrder;

  CustomFieldContextDefaultValueSingleVersionPicker(
      {required this.type, required this.versionId, this.versionOrder});

  factory CustomFieldContextDefaultValueSingleVersionPicker.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueSingleVersionPicker(
      type: json[r'type'] as String? ?? '',
      versionId: json[r'versionId'] as String? ?? '',
      versionOrder: json[r'versionOrder'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var versionId = this.versionId;
    var versionOrder = this.versionOrder;

    final json = <String, Object?>{};
    json[r'type'] = type;
    json[r'versionId'] = versionId;
    if (versionOrder != null) {
      json[r'versionOrder'] = versionOrder;
    }
    return json;
  }

  CustomFieldContextDefaultValueSingleVersionPicker copyWith(
      {String? type, String? versionId, String? versionOrder}) {
    return CustomFieldContextDefaultValueSingleVersionPicker(
      type: type ?? this.type,
      versionId: versionId ?? this.versionId,
      versionOrder: versionOrder ?? this.versionOrder,
    );
  }
}

/// The default text for a text area custom field.
class CustomFieldContextDefaultValueTextArea {
  /// The default text. The maximum length is 32767 characters.
  final String? text;
  final String type;

  CustomFieldContextDefaultValueTextArea({this.text, required this.type});

  factory CustomFieldContextDefaultValueTextArea.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueTextArea(
      text: json[r'text'] as String?,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var text = this.text;
    var type = this.type;

    final json = <String, Object?>{};
    if (text != null) {
      json[r'text'] = text;
    }
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueTextArea copyWith(
      {String? text, String? type}) {
    return CustomFieldContextDefaultValueTextArea(
      text: text ?? this.text,
      type: type ?? this.type,
    );
  }
}

/// The default text for a text custom field.
class CustomFieldContextDefaultValueTextField {
  /// The default text. The maximum length is 254 characters.
  final String? text;
  final String type;

  CustomFieldContextDefaultValueTextField({this.text, required this.type});

  factory CustomFieldContextDefaultValueTextField.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueTextField(
      text: json[r'text'] as String?,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var text = this.text;
    var type = this.type;

    final json = <String, Object?>{};
    if (text != null) {
      json[r'text'] = text;
    }
    json[r'type'] = type;
    return json;
  }

  CustomFieldContextDefaultValueTextField copyWith(
      {String? text, String? type}) {
    return CustomFieldContextDefaultValueTextField(
      text: text ?? this.text,
      type: type ?? this.type,
    );
  }
}

/// The default value for a URL custom field.
class CustomFieldContextDefaultValueURL {
  /// The ID of the context.
  final String contextId;
  final String type;

  /// The default URL.
  final String url;

  CustomFieldContextDefaultValueURL(
      {required this.contextId, required this.type, required this.url});

  factory CustomFieldContextDefaultValueURL.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueURL(
      contextId: json[r'contextId'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
      url: json[r'url'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var type = this.type;
    var url = this.url;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'type'] = type;
    json[r'url'] = url;
    return json;
  }

  CustomFieldContextDefaultValueURL copyWith(
      {String? contextId, String? type, String? url}) {
    return CustomFieldContextDefaultValueURL(
      contextId: contextId ?? this.contextId,
      type: type ?? this.type,
      url: url ?? this.url,
    );
  }
}

/// Default values to update.
class CustomFieldContextDefaultValueUpdate {
  final List<CustomFieldContextDefaultValue> defaultValues;

  CustomFieldContextDefaultValueUpdate(
      {List<CustomFieldContextDefaultValue>? defaultValues})
      : defaultValues = defaultValues ?? [];

  factory CustomFieldContextDefaultValueUpdate.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextDefaultValueUpdate(
      defaultValues: (json[r'defaultValues'] as List<Object?>?)
              ?.map((i) => CustomFieldContextDefaultValue.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var defaultValues = this.defaultValues;

    final json = <String, Object?>{};
    json[r'defaultValues'] = defaultValues.map((i) => i.toJson()).toList();
    return json;
  }

  CustomFieldContextDefaultValueUpdate copyWith(
      {List<CustomFieldContextDefaultValue>? defaultValues}) {
    return CustomFieldContextDefaultValueUpdate(
      defaultValues: defaultValues ?? this.defaultValues,
    );
  }
}

/// Details of the custom field options for a context.
class CustomFieldContextOption {
  /// Whether the option is disabled.
  final bool disabled;

  /// The ID of the custom field option.
  final String id;

  /// For cascading options, the ID of the custom field option containing the
  /// cascading option.
  final String? optionId;

  /// The value of the custom field option.
  final String value;

  CustomFieldContextOption(
      {required this.disabled,
      required this.id,
      this.optionId,
      required this.value});

  factory CustomFieldContextOption.fromJson(Map<String, Object?> json) {
    return CustomFieldContextOption(
      disabled: json[r'disabled'] as bool? ?? false,
      id: json[r'id'] as String? ?? '',
      optionId: json[r'optionId'] as String?,
      value: json[r'value'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var disabled = this.disabled;
    var id = this.id;
    var optionId = this.optionId;
    var value = this.value;

    final json = <String, Object?>{};
    json[r'disabled'] = disabled;
    json[r'id'] = id;
    if (optionId != null) {
      json[r'optionId'] = optionId;
    }
    json[r'value'] = value;
    return json;
  }

  CustomFieldContextOption copyWith(
      {bool? disabled, String? id, String? optionId, String? value}) {
    return CustomFieldContextOption(
      disabled: disabled ?? this.disabled,
      id: id ?? this.id,
      optionId: optionId ?? this.optionId,
      value: value ?? this.value,
    );
  }
}

/// Details of a context to project association.
class CustomFieldContextProjectMapping {
  /// The ID of the context.
  final String contextId;

  /// Whether context is global.
  final bool isGlobalContext;

  /// The ID of the project.
  final String? projectId;

  CustomFieldContextProjectMapping(
      {required this.contextId, bool? isGlobalContext, this.projectId})
      : isGlobalContext = isGlobalContext ?? false;

  factory CustomFieldContextProjectMapping.fromJson(Map<String, Object?> json) {
    return CustomFieldContextProjectMapping(
      contextId: json[r'contextId'] as String? ?? '',
      isGlobalContext: json[r'isGlobalContext'] as bool? ?? false,
      projectId: json[r'projectId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var isGlobalContext = this.isGlobalContext;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'isGlobalContext'] = isGlobalContext;
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    return json;
  }

  CustomFieldContextProjectMapping copyWith(
      {String? contextId, bool? isGlobalContext, String? projectId}) {
    return CustomFieldContextProjectMapping(
      contextId: contextId ?? this.contextId,
      isGlobalContext: isGlobalContext ?? this.isGlobalContext,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// Defaults for a User Picker (single) custom field.
class CustomFieldContextSingleUserPickerDefaults {
  /// The ID of the default user.
  final String accountId;

  /// The ID of the context.
  final String contextId;
  final String type;
  final UserFilter userFilter;

  CustomFieldContextSingleUserPickerDefaults(
      {required this.accountId,
      required this.contextId,
      required this.type,
      required this.userFilter});

  factory CustomFieldContextSingleUserPickerDefaults.fromJson(
      Map<String, Object?> json) {
    return CustomFieldContextSingleUserPickerDefaults(
      accountId: json[r'accountId'] as String? ?? '',
      contextId: json[r'contextId'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
      userFilter: UserFilter.fromJson(
          json[r'userFilter'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var contextId = this.contextId;
    var type = this.type;
    var userFilter = this.userFilter;

    final json = <String, Object?>{};
    json[r'accountId'] = accountId;
    json[r'contextId'] = contextId;
    json[r'type'] = type;
    json[r'userFilter'] = userFilter.toJson();
    return json;
  }

  CustomFieldContextSingleUserPickerDefaults copyWith(
      {String? accountId,
      String? contextId,
      String? type,
      UserFilter? userFilter}) {
    return CustomFieldContextSingleUserPickerDefaults(
      accountId: accountId ?? this.accountId,
      contextId: contextId ?? this.contextId,
      type: type ?? this.type,
      userFilter: userFilter ?? this.userFilter,
    );
  }
}

/// Details of a custom field context.
class CustomFieldContextUpdateDetails {
  /// The description of the custom field context. The maximum length is 255
  /// characters.
  final String? description;

  /// The name of the custom field context. The name must be unique. The maximum
  /// length is 255 characters.
  final String? name;

  CustomFieldContextUpdateDetails({this.description, this.name});

  factory CustomFieldContextUpdateDetails.fromJson(Map<String, Object?> json) {
    return CustomFieldContextUpdateDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  CustomFieldContextUpdateDetails copyWith(
      {String? description, String? name}) {
    return CustomFieldContextUpdateDetails(
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// A list of custom field options for a context.
class CustomFieldCreatedContextOptionsList {
  /// The created custom field options.
  final List<CustomFieldContextOption> options;

  CustomFieldCreatedContextOptionsList(
      {List<CustomFieldContextOption>? options})
      : options = options ?? [];

  factory CustomFieldCreatedContextOptionsList.fromJson(
      Map<String, Object?> json) {
    return CustomFieldCreatedContextOptionsList(
      options: (json[r'options'] as List<Object?>?)
              ?.map((i) => CustomFieldContextOption.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var options = this.options;

    final json = <String, Object?>{};
    json[r'options'] = options.map((i) => i.toJson()).toList();
    return json;
  }

  CustomFieldCreatedContextOptionsList copyWith(
      {List<CustomFieldContextOption>? options}) {
    return CustomFieldCreatedContextOptionsList(
      options: options ?? this.options,
    );
  }
}

class CustomFieldDefinitionJsonBean {
  /// The description of the custom field, which is displayed in Jira.
  final String? description;

  /// The name of the custom field, which is displayed in Jira. This is not the
  /// unique identifier.
  final String name;

  /// The searcher defines the way the field is searched in Jira. For example,
  /// *com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher*.
  /// The search UI (basic search and JQL search) will display different
  /// operations and values for the field, based on the field searcher. You must
  /// specify a searcher that is valid for the field type, as listed below
  /// (abbreviated values shown):
  ///
  ///  *  `cascadingselect`: `cascadingselectsearcher`
  ///  *  `datepicker`: `daterange`
  ///  *  `datetime`: `datetimerange`
  ///  *  `float`: `exactnumber` or `numberrange`
  ///  *  `grouppicker`: `grouppickersearcher`
  ///  *  `importid`: `exactnumber` or `numberrange`
  ///  *  `labels`: `labelsearcher`
  ///  *  `multicheckboxes`: `multiselectsearcher`
  ///  *  `multigrouppicker`: `multiselectsearcher`
  ///  *  `multiselect`: `multiselectsearcher`
  ///  *  `multiuserpicker`: `userpickergroupsearcher`
  ///  *  `multiversion`: `versionsearcher`
  ///  *  `project`: `projectsearcher`
  ///  *  `radiobuttons`: `multiselectsearcher`
  ///  *  `readonlyfield`: `textsearcher`
  ///  *  `select`: `multiselectsearcher`
  ///  *  `textarea`: `textsearcher`
  ///  *  `textfield`: `textsearcher`
  ///  *  `url`: `exacttextsearcher`
  ///  *  `userpicker`: `userpickergroupsearcher`
  ///  *  `version`: `versionsearcher`
  ///
  /// If no searcher is provided, the field isn't searchable. However,
  /// [Forge custom fields](https://developer.atlassian.com/platform/forge/manifest-reference/modules/#jira-custom-field-type--beta-)
  /// have a searcher set automatically, so are always searchable.
  final CustomFieldDefinitionJsonBeanSearcherKey? searcherKey;

  /// The type of the custom field. These built-in custom field types are
  /// available:
  ///
  ///  *  `cascadingselect`: Enables values to be selected from two levels of
  /// select lists (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:cascadingselect`)
  ///  *  `datepicker`: Stores a date using a picker control (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:datepicker`)
  ///  *  `datetime`: Stores a date with a time component (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:datetime`)
  ///  *  `float`: Stores and validates a numeric (floating point) input (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:float`)
  ///  *  `grouppicker`: Stores a user group using a picker control (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:grouppicker`)
  ///  *  `importid`: A read-only field that stores the ID the issue had in the
  /// system it was imported from (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:importid`)
  ///  *  `labels`: Stores labels (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:labels`)
  ///  *  `multicheckboxes`: Stores multiple values using checkboxes (value: ``)
  ///  *  `multigrouppicker`: Stores multiple user groups using a picker control
  /// (value: ``)
  ///  *  `multiselect`: Stores multiple values using a select list (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes`)
  ///  *  `multiuserpicker`: Stores multiple users using a picker control
  /// (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:multigrouppicker`)
  ///  *  `multiversion`: Stores multiple versions from the versions available
  /// in a project using a picker control (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:multiversion`)
  ///  *  `project`: Stores a project from a list of projects that the user is
  /// permitted to view (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:project`)
  ///  *  `radiobuttons`: Stores a value using radio buttons (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons`)
  ///  *  `readonlyfield`: Stores a read-only text value, which can only be
  /// populated via the API (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:readonlyfield`)
  ///  *  `select`: Stores a value from a configurable list of options (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:select`)
  ///  *  `textarea`: Stores a long text string using a multiline text area
  /// (value: `com.atlassian.jira.plugin.system.customfieldtypes:textarea`)
  ///  *  `textfield`: Stores a text string using a single-line text box (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:textfield`)
  ///  *  `url`: Stores a URL (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:url`)
  ///  *  `userpicker`: Stores a user using a picker control (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:userpicker`)
  ///  *  `version`: Stores a version using a picker control (value:
  /// `com.atlassian.jira.plugin.system.customfieldtypes:version`)
  ///
  /// To create a field based on a
  /// [Forge custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/#jira-custom-field-type--beta-),
  /// use the ID of the Forge custom field type as the value. For example,
  /// `ari:cloud:ecosystem::extension/e62f20a2-4b61-4dbe-bfb9-9a88b5e3ac84/548c5df1-24aa-4f7c-bbbb-3038d947cb05/static/my-cf-type-key`.
  final String type;

  CustomFieldDefinitionJsonBean(
      {this.description,
      required this.name,
      this.searcherKey,
      required this.type});

  factory CustomFieldDefinitionJsonBean.fromJson(Map<String, Object?> json) {
    return CustomFieldDefinitionJsonBean(
      description: json[r'description'] as String?,
      name: json[r'name'] as String? ?? '',
      searcherKey: json[r'searcherKey'] != null
          ? CustomFieldDefinitionJsonBeanSearcherKey.fromValue(
              json[r'searcherKey']! as String)
          : null,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;
    var searcherKey = this.searcherKey;
    var type = this.type;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'name'] = name;
    if (searcherKey != null) {
      json[r'searcherKey'] = searcherKey.value;
    }
    json[r'type'] = type;
    return json;
  }

  CustomFieldDefinitionJsonBean copyWith(
      {String? description,
      String? name,
      CustomFieldDefinitionJsonBeanSearcherKey? searcherKey,
      String? type}) {
    return CustomFieldDefinitionJsonBean(
      description: description ?? this.description,
      name: name ?? this.name,
      searcherKey: searcherKey ?? this.searcherKey,
      type: type ?? this.type,
    );
  }
}

class CustomFieldDefinitionJsonBeanSearcherKey {
  static const comAtlassianJiraPluginSystemCustomfieldtypesCascadingselectsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:cascadingselectsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesDaterange =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:daterange');
  static const comAtlassianJiraPluginSystemCustomfieldtypesDatetimerange =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:datetimerange');
  static const comAtlassianJiraPluginSystemCustomfieldtypesExactnumber =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:exactnumber');
  static const comAtlassianJiraPluginSystemCustomfieldtypesExacttextsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:exacttextsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesGrouppickersearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesLabelsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:labelsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesMultiselectsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesNumberrange =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:numberrange');
  static const comAtlassianJiraPluginSystemCustomfieldtypesProjectsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:projectsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesTextsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:textsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesUserpickergroupsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:userpickergroupsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesVersionsearcher =
      CustomFieldDefinitionJsonBeanSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:versionsearcher');

  static const values = [
    comAtlassianJiraPluginSystemCustomfieldtypesCascadingselectsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesDaterange,
    comAtlassianJiraPluginSystemCustomfieldtypesDatetimerange,
    comAtlassianJiraPluginSystemCustomfieldtypesExactnumber,
    comAtlassianJiraPluginSystemCustomfieldtypesExacttextsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesGrouppickersearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesLabelsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesMultiselectsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesNumberrange,
    comAtlassianJiraPluginSystemCustomfieldtypesProjectsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesTextsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesUserpickergroupsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesVersionsearcher,
  ];
  final String value;

  const CustomFieldDefinitionJsonBeanSearcherKey._(this.value);

  static CustomFieldDefinitionJsonBeanSearcherKey fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => CustomFieldDefinitionJsonBeanSearcherKey._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of a custom option for a field.
class CustomFieldOption {
  /// The URL of these custom field option details.
  final String? self;

  /// The value of the custom field option.
  final String? value;

  CustomFieldOption({this.self, this.value});

  factory CustomFieldOption.fromJson(Map<String, Object?> json) {
    return CustomFieldOption(
      self: json[r'self'] as String?,
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var self = this.self;
    var value = this.value;

    final json = <String, Object?>{};
    if (self != null) {
      json[r'self'] = self;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  CustomFieldOption copyWith({String? self, String? value}) {
    return CustomFieldOption(
      self: self ?? this.self,
      value: value ?? this.value,
    );
  }
}

/// Details of a custom field option to create.
class CustomFieldOptionCreate {
  /// Whether the option is disabled.
  final bool disabled;

  /// For cascading options, the ID of the custom field object containing the
  /// cascading option.
  final String? optionId;

  /// The value of the custom field option.
  final String value;

  CustomFieldOptionCreate({bool? disabled, this.optionId, required this.value})
      : disabled = disabled ?? false;

  factory CustomFieldOptionCreate.fromJson(Map<String, Object?> json) {
    return CustomFieldOptionCreate(
      disabled: json[r'disabled'] as bool? ?? false,
      optionId: json[r'optionId'] as String?,
      value: json[r'value'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var disabled = this.disabled;
    var optionId = this.optionId;
    var value = this.value;

    final json = <String, Object?>{};
    json[r'disabled'] = disabled;
    if (optionId != null) {
      json[r'optionId'] = optionId;
    }
    json[r'value'] = value;
    return json;
  }

  CustomFieldOptionCreate copyWith(
      {bool? disabled, String? optionId, String? value}) {
    return CustomFieldOptionCreate(
      disabled: disabled ?? this.disabled,
      optionId: optionId ?? this.optionId,
      value: value ?? this.value,
    );
  }
}

/// Details of a custom field option for a context.
class CustomFieldOptionUpdate {
  /// Whether the option is disabled.
  final bool disabled;

  /// The ID of the custom field option.
  final String id;

  /// The value of the custom field option.
  final String? value;

  CustomFieldOptionUpdate({bool? disabled, required this.id, this.value})
      : disabled = disabled ?? false;

  factory CustomFieldOptionUpdate.fromJson(Map<String, Object?> json) {
    return CustomFieldOptionUpdate(
      disabled: json[r'disabled'] as bool? ?? false,
      id: json[r'id'] as String? ?? '',
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var disabled = this.disabled;
    var id = this.id;
    var value = this.value;

    final json = <String, Object?>{};
    json[r'disabled'] = disabled;
    json[r'id'] = id;
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  CustomFieldOptionUpdate copyWith(
      {bool? disabled, String? id, String? value}) {
    return CustomFieldOptionUpdate(
      disabled: disabled ?? this.disabled,
      id: id ?? this.id,
      value: value ?? this.value,
    );
  }
}

/// Details about the replacement for a deleted version.
class CustomFieldReplacement {
  /// The ID of the custom field in which to replace the version number.
  final int? customFieldId;

  /// The version number to use as a replacement for the deleted version.
  final int? moveTo;

  CustomFieldReplacement({this.customFieldId, this.moveTo});

  factory CustomFieldReplacement.fromJson(Map<String, Object?> json) {
    return CustomFieldReplacement(
      customFieldId: (json[r'customFieldId'] as num?)?.toInt(),
      moveTo: (json[r'moveTo'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var customFieldId = this.customFieldId;
    var moveTo = this.moveTo;

    final json = <String, Object?>{};
    if (customFieldId != null) {
      json[r'customFieldId'] = customFieldId;
    }
    if (moveTo != null) {
      json[r'moveTo'] = moveTo;
    }
    return json;
  }

  CustomFieldReplacement copyWith({int? customFieldId, int? moveTo}) {
    return CustomFieldReplacement(
      customFieldId: customFieldId ?? this.customFieldId,
      moveTo: moveTo ?? this.moveTo,
    );
  }
}

/// A list of custom field options for a context.
class CustomFieldUpdatedContextOptionsList {
  /// The updated custom field options.
  final List<CustomFieldOptionUpdate> options;

  CustomFieldUpdatedContextOptionsList({List<CustomFieldOptionUpdate>? options})
      : options = options ?? [];

  factory CustomFieldUpdatedContextOptionsList.fromJson(
      Map<String, Object?> json) {
    return CustomFieldUpdatedContextOptionsList(
      options: (json[r'options'] as List<Object?>?)
              ?.map((i) => CustomFieldOptionUpdate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var options = this.options;

    final json = <String, Object?>{};
    json[r'options'] = options.map((i) => i.toJson()).toList();
    return json;
  }

  CustomFieldUpdatedContextOptionsList copyWith(
      {List<CustomFieldOptionUpdate>? options}) {
    return CustomFieldUpdatedContextOptionsList(
      options: options ?? this.options,
    );
  }
}

/// A list of issue IDs and the value to update a custom field to.
class CustomFieldValueUpdate {
  /// The list of issue IDs.
  final List<int> issueIds;

  /// The value for the custom field. The value must be compatible with the
  /// [custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#data-types)
  /// as follows:
  ///
  ///  *  `string` the value must be a string.
  ///  *  `number` the value must be a number.
  ///  *  `datetime` the value must be a string that represents a date in the
  /// ISO format or the simplified extended ISO format. For example,
  /// `"2023-01-18T12:00:00-03:00"` or `"2023-01-18T12:00:00.000Z"`. However,
  /// the milliseconds part is ignored.
  ///  *  `user` the value must be an object that contains the `accountId`
  /// field.
  ///  *  `group` the value must be an object that contains the group `name` or
  /// `groupId` field. Because group names can change, we recommend using
  /// `groupId`.
  ///
  /// A list of appropriate values must be provided if the field is of the
  /// `list`
  /// [collection type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#collection-types).
  final dynamic value;

  CustomFieldValueUpdate({required this.issueIds, required this.value});

  factory CustomFieldValueUpdate.fromJson(Map<String, Object?> json) {
    return CustomFieldValueUpdate(
      issueIds: (json[r'issueIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      value: json[r'value'],
    );
  }

  Map<String, Object?> toJson() {
    var issueIds = this.issueIds;
    var value = this.value;

    final json = <String, Object?>{};
    json[r'issueIds'] = issueIds;
    json[r'value'] = value;
    return json;
  }

  CustomFieldValueUpdate copyWith({List<int>? issueIds, dynamic value}) {
    return CustomFieldValueUpdate(
      issueIds: issueIds ?? this.issueIds,
      value: value ?? this.value,
    );
  }
}

/// Details of updates for a custom field.
class CustomFieldValueUpdateDetails {
  /// The list of custom field update details.
  final List<CustomFieldValueUpdate> updates;

  CustomFieldValueUpdateDetails({List<CustomFieldValueUpdate>? updates})
      : updates = updates ?? [];

  factory CustomFieldValueUpdateDetails.fromJson(Map<String, Object?> json) {
    return CustomFieldValueUpdateDetails(
      updates: (json[r'updates'] as List<Object?>?)
              ?.map((i) => CustomFieldValueUpdate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var updates = this.updates;

    final json = <String, Object?>{};
    json[r'updates'] = updates.map((i) => i.toJson()).toList();
    return json;
  }

  CustomFieldValueUpdateDetails copyWith(
      {List<CustomFieldValueUpdate>? updates}) {
    return CustomFieldValueUpdateDetails(
      updates: updates ?? this.updates,
    );
  }
}

/// Details of a dashboard.
class Dashboard {
  /// The automatic refresh interval for the dashboard in milliseconds.
  final int? automaticRefreshMs;
  final String? description;

  /// The details of any edit share permissions for the dashboard.
  final List<SharePermission> editPermissions;

  /// The ID of the dashboard.
  final String? id;

  /// Whether the dashboard is selected as a favorite by the user.
  final bool isFavourite;

  /// Whether the current user has permission to edit the dashboard.
  final bool isWritable;

  /// The name of the dashboard.
  final String? name;

  /// The owner of the dashboard.
  final UserBean? owner;

  /// The number of users who have this dashboard as a favorite.
  final int? popularity;

  /// The rank of this dashboard.
  final int? rank;

  /// The URL of these dashboard details.
  final String? self;

  /// The details of any view share permissions for the dashboard.
  final List<SharePermission> sharePermissions;

  /// Whether the current dashboard is system dashboard.
  final bool systemDashboard;

  /// The URL of the dashboard.
  final String? view;

  Dashboard(
      {this.automaticRefreshMs,
      this.description,
      List<SharePermission>? editPermissions,
      this.id,
      bool? isFavourite,
      bool? isWritable,
      this.name,
      this.owner,
      this.popularity,
      this.rank,
      this.self,
      List<SharePermission>? sharePermissions,
      bool? systemDashboard,
      this.view})
      : editPermissions = editPermissions ?? [],
        isFavourite = isFavourite ?? false,
        isWritable = isWritable ?? false,
        sharePermissions = sharePermissions ?? [],
        systemDashboard = systemDashboard ?? false;

  factory Dashboard.fromJson(Map<String, Object?> json) {
    return Dashboard(
      automaticRefreshMs: (json[r'automaticRefreshMs'] as num?)?.toInt(),
      description: json[r'description'] as String?,
      editPermissions: (json[r'editPermissions'] as List<Object?>?)
              ?.map((i) => SharePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      id: json[r'id'] as String?,
      isFavourite: json[r'isFavourite'] as bool? ?? false,
      isWritable: json[r'isWritable'] as bool? ?? false,
      name: json[r'name'] as String?,
      owner: json[r'owner'] != null
          ? UserBean.fromJson(json[r'owner']! as Map<String, Object?>)
          : null,
      popularity: (json[r'popularity'] as num?)?.toInt(),
      rank: (json[r'rank'] as num?)?.toInt(),
      self: json[r'self'] as String?,
      sharePermissions: (json[r'sharePermissions'] as List<Object?>?)
              ?.map((i) => SharePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      systemDashboard: json[r'systemDashboard'] as bool? ?? false,
      view: json[r'view'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var automaticRefreshMs = this.automaticRefreshMs;
    var description = this.description;
    var editPermissions = this.editPermissions;
    var id = this.id;
    var isFavourite = this.isFavourite;
    var isWritable = this.isWritable;
    var name = this.name;
    var owner = this.owner;
    var popularity = this.popularity;
    var rank = this.rank;
    var self = this.self;
    var sharePermissions = this.sharePermissions;
    var systemDashboard = this.systemDashboard;
    var view = this.view;

    final json = <String, Object?>{};
    if (automaticRefreshMs != null) {
      json[r'automaticRefreshMs'] = automaticRefreshMs;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'editPermissions'] = editPermissions.map((i) => i.toJson()).toList();
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'isFavourite'] = isFavourite;
    json[r'isWritable'] = isWritable;
    if (name != null) {
      json[r'name'] = name;
    }
    if (owner != null) {
      json[r'owner'] = owner.toJson();
    }
    if (popularity != null) {
      json[r'popularity'] = popularity;
    }
    if (rank != null) {
      json[r'rank'] = rank;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'sharePermissions'] =
        sharePermissions.map((i) => i.toJson()).toList();
    json[r'systemDashboard'] = systemDashboard;
    if (view != null) {
      json[r'view'] = view;
    }
    return json;
  }

  Dashboard copyWith(
      {int? automaticRefreshMs,
      String? description,
      List<SharePermission>? editPermissions,
      String? id,
      bool? isFavourite,
      bool? isWritable,
      String? name,
      UserBean? owner,
      int? popularity,
      int? rank,
      String? self,
      List<SharePermission>? sharePermissions,
      bool? systemDashboard,
      String? view}) {
    return Dashboard(
      automaticRefreshMs: automaticRefreshMs ?? this.automaticRefreshMs,
      description: description ?? this.description,
      editPermissions: editPermissions ?? this.editPermissions,
      id: id ?? this.id,
      isFavourite: isFavourite ?? this.isFavourite,
      isWritable: isWritable ?? this.isWritable,
      name: name ?? this.name,
      owner: owner ?? this.owner,
      popularity: popularity ?? this.popularity,
      rank: rank ?? this.rank,
      self: self ?? this.self,
      sharePermissions: sharePermissions ?? this.sharePermissions,
      systemDashboard: systemDashboard ?? this.systemDashboard,
      view: view ?? this.view,
    );
  }
}

/// Details of a dashboard.
class DashboardDetails {
  /// The description of the dashboard.
  final String? description;

  /// The edit permissions for the dashboard.
  final List<SharePermission> editPermissions;

  /// The name of the dashboard.
  final String name;

  /// The share permissions for the dashboard.
  final List<SharePermission> sharePermissions;

  DashboardDetails(
      {this.description,
      required this.editPermissions,
      required this.name,
      required this.sharePermissions});

  factory DashboardDetails.fromJson(Map<String, Object?> json) {
    return DashboardDetails(
      description: json[r'description'] as String?,
      editPermissions: (json[r'editPermissions'] as List<Object?>?)
              ?.map((i) => SharePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      name: json[r'name'] as String? ?? '',
      sharePermissions: (json[r'sharePermissions'] as List<Object?>?)
              ?.map((i) => SharePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var editPermissions = this.editPermissions;
    var name = this.name;
    var sharePermissions = this.sharePermissions;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'editPermissions'] = editPermissions.map((i) => i.toJson()).toList();
    json[r'name'] = name;
    json[r'sharePermissions'] =
        sharePermissions.map((i) => i.toJson()).toList();
    return json;
  }

  DashboardDetails copyWith(
      {String? description,
      List<SharePermission>? editPermissions,
      String? name,
      List<SharePermission>? sharePermissions}) {
    return DashboardDetails(
      description: description ?? this.description,
      editPermissions: editPermissions ?? this.editPermissions,
      name: name ?? this.name,
      sharePermissions: sharePermissions ?? this.sharePermissions,
    );
  }
}

/// Details of a gadget.
class DashboardGadget {
  /// The color of the gadget. Should be one of `blue`, `red`, `yellow`,
  /// `green`, `cyan`, `purple`, `gray`, or `white`.
  final DashboardGadgetColor color;

  /// The ID of the gadget instance.
  final int id;

  /// The module key of the gadget type.
  final String? moduleKey;

  /// The position of the gadget.
  final DashboardGadgetPosition position;

  /// The title of the gadget.
  final String title;

  /// The URI of the gadget type.
  final String? uri;

  DashboardGadget(
      {required this.color,
      required this.id,
      this.moduleKey,
      required this.position,
      required this.title,
      this.uri});

  factory DashboardGadget.fromJson(Map<String, Object?> json) {
    return DashboardGadget(
      color: DashboardGadgetColor.fromValue(json[r'color'] as String? ?? ''),
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      moduleKey: json[r'moduleKey'] as String?,
      position: DashboardGadgetPosition.fromJson(
          json[r'position'] as Map<String, Object?>? ?? const {}),
      title: json[r'title'] as String? ?? '',
      uri: json[r'uri'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var color = this.color;
    var id = this.id;
    var moduleKey = this.moduleKey;
    var position = this.position;
    var title = this.title;
    var uri = this.uri;

    final json = <String, Object?>{};
    json[r'color'] = color.value;
    json[r'id'] = id;
    if (moduleKey != null) {
      json[r'moduleKey'] = moduleKey;
    }
    json[r'position'] = position.toJson();
    json[r'title'] = title;
    if (uri != null) {
      json[r'uri'] = uri;
    }
    return json;
  }

  DashboardGadget copyWith(
      {DashboardGadgetColor? color,
      int? id,
      String? moduleKey,
      DashboardGadgetPosition? position,
      String? title,
      String? uri}) {
    return DashboardGadget(
      color: color ?? this.color,
      id: id ?? this.id,
      moduleKey: moduleKey ?? this.moduleKey,
      position: position ?? this.position,
      title: title ?? this.title,
      uri: uri ?? this.uri,
    );
  }
}

class DashboardGadgetColor {
  static const blue = DashboardGadgetColor._('blue');
  static const red = DashboardGadgetColor._('red');
  static const yellow = DashboardGadgetColor._('yellow');
  static const green = DashboardGadgetColor._('green');
  static const cyan = DashboardGadgetColor._('cyan');
  static const purple = DashboardGadgetColor._('purple');
  static const gray = DashboardGadgetColor._('gray');
  static const white = DashboardGadgetColor._('white');

  static const values = [
    blue,
    red,
    yellow,
    green,
    cyan,
    purple,
    gray,
    white,
  ];
  final String value;

  const DashboardGadgetColor._(this.value);

  static DashboardGadgetColor fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => DashboardGadgetColor._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of a gadget position.
class DashboardGadgetPosition {
  final int theColumnPositionOfTheGadget;
  final int theRowPositionOfTheGadget;

  DashboardGadgetPosition(
      {required this.theColumnPositionOfTheGadget,
      required this.theRowPositionOfTheGadget});

  factory DashboardGadgetPosition.fromJson(Map<String, Object?> json) {
    return DashboardGadgetPosition(
      theColumnPositionOfTheGadget:
          (json[r'The column position of the gadget.'] as num?)?.toInt() ?? 0,
      theRowPositionOfTheGadget:
          (json[r'The row position of the gadget.'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var theColumnPositionOfTheGadget = this.theColumnPositionOfTheGadget;
    var theRowPositionOfTheGadget = this.theRowPositionOfTheGadget;

    final json = <String, Object?>{};
    json[r'The column position of the gadget.'] = theColumnPositionOfTheGadget;
    json[r'The row position of the gadget.'] = theRowPositionOfTheGadget;
    return json;
  }

  DashboardGadgetPosition copyWith(
      {int? theColumnPositionOfTheGadget, int? theRowPositionOfTheGadget}) {
    return DashboardGadgetPosition(
      theColumnPositionOfTheGadget:
          theColumnPositionOfTheGadget ?? this.theColumnPositionOfTheGadget,
      theRowPositionOfTheGadget:
          theRowPositionOfTheGadget ?? this.theRowPositionOfTheGadget,
    );
  }
}

/// The list of gadgets on the dashboard.
class DashboardGadgetResponse {
  /// The list of gadgets.
  final List<DashboardGadget> gadgets;

  DashboardGadgetResponse({required this.gadgets});

  factory DashboardGadgetResponse.fromJson(Map<String, Object?> json) {
    return DashboardGadgetResponse(
      gadgets: (json[r'gadgets'] as List<Object?>?)
              ?.map((i) => DashboardGadget.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var gadgets = this.gadgets;

    final json = <String, Object?>{};
    json[r'gadgets'] = gadgets.map((i) => i.toJson()).toList();
    return json;
  }

  DashboardGadgetResponse copyWith({List<DashboardGadget>? gadgets}) {
    return DashboardGadgetResponse(
      gadgets: gadgets ?? this.gadgets,
    );
  }
}

/// Details of the settings for a dashboard gadget.
class DashboardGadgetSettings {
  /// The color of the gadget. Should be one of `blue`, `red`, `yellow`,
  /// `green`, `cyan`, `purple`, `gray`, or `white`.
  final String? color;

  /// Whether to ignore the validation of module key and URI. For example, when
  /// a gadget is created that is a part of an application that isn't installed.
  final bool ignoreUriAndModuleKeyValidation;

  /// The module key of the gadget type. Can't be provided with `uri`.
  final String? moduleKey;

  /// The position of the gadget. When the gadget is placed into the position,
  /// other gadgets in the same column are moved down to accommodate it.
  final DashboardGadgetPosition? position;

  /// The title of the gadget.
  final String? title;

  /// The URI of the gadget type. Can't be provided with `moduleKey`.
  final String? uri;

  DashboardGadgetSettings(
      {this.color,
      bool? ignoreUriAndModuleKeyValidation,
      this.moduleKey,
      this.position,
      this.title,
      this.uri})
      : ignoreUriAndModuleKeyValidation =
            ignoreUriAndModuleKeyValidation ?? false;

  factory DashboardGadgetSettings.fromJson(Map<String, Object?> json) {
    return DashboardGadgetSettings(
      color: json[r'color'] as String?,
      ignoreUriAndModuleKeyValidation:
          json[r'ignoreUriAndModuleKeyValidation'] as bool? ?? false,
      moduleKey: json[r'moduleKey'] as String?,
      position: json[r'position'] != null
          ? DashboardGadgetPosition.fromJson(
              json[r'position']! as Map<String, Object?>)
          : null,
      title: json[r'title'] as String?,
      uri: json[r'uri'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var color = this.color;
    var ignoreUriAndModuleKeyValidation = this.ignoreUriAndModuleKeyValidation;
    var moduleKey = this.moduleKey;
    var position = this.position;
    var title = this.title;
    var uri = this.uri;

    final json = <String, Object?>{};
    if (color != null) {
      json[r'color'] = color;
    }
    json[r'ignoreUriAndModuleKeyValidation'] = ignoreUriAndModuleKeyValidation;
    if (moduleKey != null) {
      json[r'moduleKey'] = moduleKey;
    }
    if (position != null) {
      json[r'position'] = position.toJson();
    }
    if (title != null) {
      json[r'title'] = title;
    }
    if (uri != null) {
      json[r'uri'] = uri;
    }
    return json;
  }

  DashboardGadgetSettings copyWith(
      {String? color,
      bool? ignoreUriAndModuleKeyValidation,
      String? moduleKey,
      DashboardGadgetPosition? position,
      String? title,
      String? uri}) {
    return DashboardGadgetSettings(
      color: color ?? this.color,
      ignoreUriAndModuleKeyValidation: ignoreUriAndModuleKeyValidation ??
          this.ignoreUriAndModuleKeyValidation,
      moduleKey: moduleKey ?? this.moduleKey,
      position: position ?? this.position,
      title: title ?? this.title,
      uri: uri ?? this.uri,
    );
  }
}

/// The details of the gadget to update.
class DashboardGadgetUpdateRequest {
  /// The color of the gadget. Should be one of `blue`, `red`, `yellow`,
  /// `green`, `cyan`, `purple`, `gray`, or `white`.
  final String? color;

  /// The position of the gadget.
  final DashboardGadgetPosition? position;

  /// The title of the gadget.
  final String? title;

  DashboardGadgetUpdateRequest({this.color, this.position, this.title});

  factory DashboardGadgetUpdateRequest.fromJson(Map<String, Object?> json) {
    return DashboardGadgetUpdateRequest(
      color: json[r'color'] as String?,
      position: json[r'position'] != null
          ? DashboardGadgetPosition.fromJson(
              json[r'position']! as Map<String, Object?>)
          : null,
      title: json[r'title'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var color = this.color;
    var position = this.position;
    var title = this.title;

    final json = <String, Object?>{};
    if (color != null) {
      json[r'color'] = color;
    }
    if (position != null) {
      json[r'position'] = position.toJson();
    }
    if (title != null) {
      json[r'title'] = title;
    }
    return json;
  }

  DashboardGadgetUpdateRequest copyWith(
      {String? color, DashboardGadgetPosition? position, String? title}) {
    return DashboardGadgetUpdateRequest(
      color: color ?? this.color,
      position: position ?? this.position,
      title: title ?? this.title,
    );
  }
}

/// Details of scheme and new default level.
class DefaultLevelValue {
  /// The ID of the issue security level to set as default for the specified
  /// scheme. Providing null will reset the default level.
  final String defaultLevelId;

  /// The ID of the issue security scheme to set default level for.
  final String issueSecuritySchemeId;

  DefaultLevelValue(
      {required this.defaultLevelId, required this.issueSecuritySchemeId});

  factory DefaultLevelValue.fromJson(Map<String, Object?> json) {
    return DefaultLevelValue(
      defaultLevelId: json[r'defaultLevelId'] as String? ?? '',
      issueSecuritySchemeId: json[r'issueSecuritySchemeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var defaultLevelId = this.defaultLevelId;
    var issueSecuritySchemeId = this.issueSecuritySchemeId;

    final json = <String, Object?>{};
    json[r'defaultLevelId'] = defaultLevelId;
    json[r'issueSecuritySchemeId'] = issueSecuritySchemeId;
    return json;
  }

  DefaultLevelValue copyWith(
      {String? defaultLevelId, String? issueSecuritySchemeId}) {
    return DefaultLevelValue(
      defaultLevelId: defaultLevelId ?? this.defaultLevelId,
      issueSecuritySchemeId:
          issueSecuritySchemeId ?? this.issueSecuritySchemeId,
    );
  }
}

/// Details of the scope of the default sharing for new filters and dashboards.
class DefaultShareScope {
  /// The scope of the default sharing for new filters and dashboards:
  ///
  ///  *  `AUTHENTICATED` Shared with all logged-in users.
  ///  *  `GLOBAL` Shared with all logged-in users. This shows as
  /// `AUTHENTICATED` in the response.
  ///  *  `PRIVATE` Not shared with any users.
  final DefaultShareScopeScope scope;

  DefaultShareScope({required this.scope});

  factory DefaultShareScope.fromJson(Map<String, Object?> json) {
    return DefaultShareScope(
      scope: DefaultShareScopeScope.fromValue(json[r'scope'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var scope = this.scope;

    final json = <String, Object?>{};
    json[r'scope'] = scope.value;
    return json;
  }

  DefaultShareScope copyWith({DefaultShareScopeScope? scope}) {
    return DefaultShareScope(
      scope: scope ?? this.scope,
    );
  }
}

class DefaultShareScopeScope {
  static const global = DefaultShareScopeScope._('GLOBAL');
  static const authenticated = DefaultShareScopeScope._('AUTHENTICATED');
  static const private = DefaultShareScopeScope._('PRIVATE');

  static const values = [
    global,
    authenticated,
    private,
  ];
  final String value;

  const DefaultShareScopeScope._(this.value);

  static DefaultShareScopeScope fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => DefaultShareScopeScope._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about the default workflow.
class DefaultWorkflow {
  /// Whether a draft workflow scheme is created or updated when updating an
  /// active workflow scheme. The draft is updated with the new default
  /// workflow. Defaults to `false`.
  final bool updateDraftIfNeeded;

  /// The name of the workflow to set as the default workflow.
  final String workflow;

  DefaultWorkflow({bool? updateDraftIfNeeded, required this.workflow})
      : updateDraftIfNeeded = updateDraftIfNeeded ?? false;

  factory DefaultWorkflow.fromJson(Map<String, Object?> json) {
    return DefaultWorkflow(
      updateDraftIfNeeded: json[r'updateDraftIfNeeded'] as bool? ?? false,
      workflow: json[r'workflow'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var updateDraftIfNeeded = this.updateDraftIfNeeded;
    var workflow = this.workflow;

    final json = <String, Object?>{};
    json[r'updateDraftIfNeeded'] = updateDraftIfNeeded;
    json[r'workflow'] = workflow;
    return json;
  }

  DefaultWorkflow copyWith({bool? updateDraftIfNeeded, String? workflow}) {
    return DefaultWorkflow(
      updateDraftIfNeeded: updateDraftIfNeeded ?? this.updateDraftIfNeeded,
      workflow: workflow ?? this.workflow,
    );
  }
}

class DeleteAndReplaceVersionBean {
  /// An array of custom field IDs (`customFieldId`) and version IDs (`moveTo`)
  /// to update when the fields contain the deleted version.
  final List<CustomFieldReplacement> customFieldReplacementList;

  /// The ID of the version to update `affectedVersion` to when the field
  /// contains the deleted version.
  final int? moveAffectedIssuesTo;

  /// The ID of the version to update `fixVersion` to when the field contains
  /// the deleted version.
  final int? moveFixIssuesTo;

  DeleteAndReplaceVersionBean(
      {List<CustomFieldReplacement>? customFieldReplacementList,
      this.moveAffectedIssuesTo,
      this.moveFixIssuesTo})
      : customFieldReplacementList = customFieldReplacementList ?? [];

  factory DeleteAndReplaceVersionBean.fromJson(Map<String, Object?> json) {
    return DeleteAndReplaceVersionBean(
      customFieldReplacementList:
          (json[r'customFieldReplacementList'] as List<Object?>?)
                  ?.map((i) => CustomFieldReplacement.fromJson(
                      i as Map<String, Object?>? ?? const {}))
                  .toList() ??
              [],
      moveAffectedIssuesTo: (json[r'moveAffectedIssuesTo'] as num?)?.toInt(),
      moveFixIssuesTo: (json[r'moveFixIssuesTo'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var customFieldReplacementList = this.customFieldReplacementList;
    var moveAffectedIssuesTo = this.moveAffectedIssuesTo;
    var moveFixIssuesTo = this.moveFixIssuesTo;

    final json = <String, Object?>{};
    json[r'customFieldReplacementList'] =
        customFieldReplacementList.map((i) => i.toJson()).toList();
    if (moveAffectedIssuesTo != null) {
      json[r'moveAffectedIssuesTo'] = moveAffectedIssuesTo;
    }
    if (moveFixIssuesTo != null) {
      json[r'moveFixIssuesTo'] = moveFixIssuesTo;
    }
    return json;
  }

  DeleteAndReplaceVersionBean copyWith(
      {List<CustomFieldReplacement>? customFieldReplacementList,
      int? moveAffectedIssuesTo,
      int? moveFixIssuesTo}) {
    return DeleteAndReplaceVersionBean(
      customFieldReplacementList:
          customFieldReplacementList ?? this.customFieldReplacementList,
      moveAffectedIssuesTo: moveAffectedIssuesTo ?? this.moveAffectedIssuesTo,
      moveFixIssuesTo: moveFixIssuesTo ?? this.moveFixIssuesTo,
    );
  }
}

/// Details about a workflow.
class DeprecatedWorkflow {
  final bool default$;

  /// The description of the workflow.
  final String? description;

  /// The datetime the workflow was last modified.
  final String? lastModifiedDate;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? lastModifiedUser;

  /// The account ID of the user that last modified the workflow.
  final String? lastModifiedUserAccountId;

  /// The name of the workflow.
  final String? name;

  /// The scope where this workflow applies
  final Scope? scope;

  /// The number of steps included in the workflow.
  final int? steps;

  DeprecatedWorkflow(
      {bool? default$,
      this.description,
      this.lastModifiedDate,
      this.lastModifiedUser,
      this.lastModifiedUserAccountId,
      this.name,
      this.scope,
      this.steps})
      : default$ = default$ ?? false;

  factory DeprecatedWorkflow.fromJson(Map<String, Object?> json) {
    return DeprecatedWorkflow(
      default$: json[r'default'] as bool? ?? false,
      description: json[r'description'] as String?,
      lastModifiedDate: json[r'lastModifiedDate'] as String?,
      lastModifiedUser: json[r'lastModifiedUser'] as String?,
      lastModifiedUserAccountId: json[r'lastModifiedUserAccountId'] as String?,
      name: json[r'name'] as String?,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      steps: (json[r'steps'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var default$ = this.default$;
    var description = this.description;
    var lastModifiedDate = this.lastModifiedDate;
    var lastModifiedUser = this.lastModifiedUser;
    var lastModifiedUserAccountId = this.lastModifiedUserAccountId;
    var name = this.name;
    var scope = this.scope;
    var steps = this.steps;

    final json = <String, Object?>{};
    json[r'default'] = default$;
    if (description != null) {
      json[r'description'] = description;
    }
    if (lastModifiedDate != null) {
      json[r'lastModifiedDate'] = lastModifiedDate;
    }
    if (lastModifiedUser != null) {
      json[r'lastModifiedUser'] = lastModifiedUser;
    }
    if (lastModifiedUserAccountId != null) {
      json[r'lastModifiedUserAccountId'] = lastModifiedUserAccountId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (steps != null) {
      json[r'steps'] = steps;
    }
    return json;
  }

  DeprecatedWorkflow copyWith(
      {bool? default$,
      String? description,
      String? lastModifiedDate,
      String? lastModifiedUser,
      String? lastModifiedUserAccountId,
      String? name,
      Scope? scope,
      int? steps}) {
    return DeprecatedWorkflow(
      default$: default$ ?? this.default$,
      description: description ?? this.description,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      lastModifiedUser: lastModifiedUser ?? this.lastModifiedUser,
      lastModifiedUserAccountId:
          lastModifiedUserAccountId ?? this.lastModifiedUserAccountId,
      name: name ?? this.name,
      scope: scope ?? this.scope,
      steps: steps ?? this.steps,
    );
  }
}

/// An entity property, for more information see
/// [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/).
class EntityProperty {
  /// The key of the property. Required on create and update.
  final String? key;

  /// The value of the property. Required on create and update.
  final dynamic value;

  EntityProperty({this.key, this.value});

  factory EntityProperty.fromJson(Map<String, Object?> json) {
    return EntityProperty(
      key: json[r'key'] as String?,
      value: json[r'value'],
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var value = this.value;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  EntityProperty copyWith({String? key, dynamic value}) {
    return EntityProperty(
      key: key ?? this.key,
      value: value ?? this.value,
    );
  }
}

class EntityPropertyDetails {
  /// The entity property ID.
  final num entityId;

  /// The entity property key.
  final String key;

  /// The new value of the entity property.
  final String value;

  EntityPropertyDetails(
      {required this.entityId, required this.key, required this.value});

  factory EntityPropertyDetails.fromJson(Map<String, Object?> json) {
    return EntityPropertyDetails(
      entityId: json[r'entityId'] as num? ?? 0,
      key: json[r'key'] as String? ?? '',
      value: json[r'value'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var entityId = this.entityId;
    var key = this.key;
    var value = this.value;

    final json = <String, Object?>{};
    json[r'entityId'] = entityId;
    json[r'key'] = key;
    json[r'value'] = value;
    return json;
  }

  EntityPropertyDetails copyWith({num? entityId, String? key, String? value}) {
    return EntityPropertyDetails(
      entityId: entityId ?? this.entityId,
      key: key ?? this.key,
      value: value ?? this.value,
    );
  }
}

/// Error messages from an operation.
class ErrorCollection {
  /// The list of error messages produced by this operation. For example, "input
  /// parameter 'key' must be provided"
  final List<String> errorMessages;

  /// The list of errors by parameter returned by the operation. For
  /// example,"projectKey": "Project keys must start with an uppercase letter,
  /// followed by one or more uppercase alphanumeric characters."
  final Map<String, dynamic>? errors;
  final int? status;

  ErrorCollection({List<String>? errorMessages, this.errors, this.status})
      : errorMessages = errorMessages ?? [];

  factory ErrorCollection.fromJson(Map<String, Object?> json) {
    return ErrorCollection(
      errorMessages: (json[r'errorMessages'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      errors: json[r'errors'] as Map<String, Object?>?,
      status: (json[r'status'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var errorMessages = this.errorMessages;
    var errors = this.errors;
    var status = this.status;

    final json = <String, Object?>{};
    json[r'errorMessages'] = errorMessages;
    if (errors != null) {
      json[r'errors'] = errors;
    }
    if (status != null) {
      json[r'status'] = status;
    }
    return json;
  }

  ErrorCollection copyWith(
      {List<String>? errorMessages,
      Map<String, dynamic>? errors,
      int? status}) {
    return ErrorCollection(
      errorMessages: errorMessages ?? this.errorMessages,
      errors: errors ?? this.errors,
      status: status ?? this.status,
    );
  }
}

class ErrorMessage {
  /// The error message.
  final String message;

  ErrorMessage({required this.message});

  factory ErrorMessage.fromJson(Map<String, Object?> json) {
    return ErrorMessage(
      message: json[r'message'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var message = this.message;

    final json = <String, Object?>{};
    json[r'message'] = message;
    return json;
  }

  ErrorMessage copyWith({String? message}) {
    return ErrorMessage(
      message: message ?? this.message,
    );
  }
}

/// Details about a notification associated with an event.
class EventNotification {
  /// The email address.
  final String? emailAddress;

  /// Expand options that include additional event notification details in the
  /// response.
  final String? expand;

  /// The custom user or group field.
  final FieldDetails? field;

  /// The specified group.
  final GroupName? group;

  /// The ID of the notification.
  final int? id;

  /// Identifies the recipients of the notification.
  final EventNotificationNotificationType? notificationType;

  /// As a group's name can change, use of `recipient` is recommended. The
  /// identifier associated with the `notificationType` value that defines the
  /// receiver of the notification, where the receiver isn't implied by
  /// `notificationType` value. So, when `notificationType` is:
  ///
  ///  *  `User` The `parameter` is the user account ID.
  ///  *  `Group` The `parameter` is the group name.
  ///  *  `ProjectRole` The `parameter` is the project role ID.
  ///  *  `UserCustomField` The `parameter` is the ID of the custom field.
  ///  *  `GroupCustomField` The `parameter` is the ID of the custom field.
  final String? parameter;

  /// The specified project role.
  final ProjectRole? projectRole;

  /// The identifier associated with the `notificationType` value that defines
  /// the receiver of the notification, where the receiver isn't implied by the
  /// `notificationType` value. So, when `notificationType` is:
  ///
  ///  *  `User`, `recipient` is the user account ID.
  ///  *  `Group`, `recipient` is the group ID.
  ///  *  `ProjectRole`, `recipient` is the project role ID.
  ///  *  `UserCustomField`, `recipient` is the ID of the custom field.
  ///  *  `GroupCustomField`, `recipient` is the ID of the custom field.
  final String? recipient;

  /// The specified user.
  final UserDetails? user;

  EventNotification(
      {this.emailAddress,
      this.expand,
      this.field,
      this.group,
      this.id,
      this.notificationType,
      this.parameter,
      this.projectRole,
      this.recipient,
      this.user});

  factory EventNotification.fromJson(Map<String, Object?> json) {
    return EventNotification(
      emailAddress: json[r'emailAddress'] as String?,
      expand: json[r'expand'] as String?,
      field: json[r'field'] != null
          ? FieldDetails.fromJson(json[r'field']! as Map<String, Object?>)
          : null,
      group: json[r'group'] != null
          ? GroupName.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
      id: (json[r'id'] as num?)?.toInt(),
      notificationType: json[r'notificationType'] != null
          ? EventNotificationNotificationType.fromValue(
              json[r'notificationType']! as String)
          : null,
      parameter: json[r'parameter'] as String?,
      projectRole: json[r'projectRole'] != null
          ? ProjectRole.fromJson(json[r'projectRole']! as Map<String, Object?>)
          : null,
      recipient: json[r'recipient'] as String?,
      user: json[r'user'] != null
          ? UserDetails.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var emailAddress = this.emailAddress;
    var expand = this.expand;
    var field = this.field;
    var group = this.group;
    var id = this.id;
    var notificationType = this.notificationType;
    var parameter = this.parameter;
    var projectRole = this.projectRole;
    var recipient = this.recipient;
    var user = this.user;

    final json = <String, Object?>{};
    if (emailAddress != null) {
      json[r'emailAddress'] = emailAddress;
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (field != null) {
      json[r'field'] = field.toJson();
    }
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (notificationType != null) {
      json[r'notificationType'] = notificationType.value;
    }
    if (parameter != null) {
      json[r'parameter'] = parameter;
    }
    if (projectRole != null) {
      json[r'projectRole'] = projectRole.toJson();
    }
    if (recipient != null) {
      json[r'recipient'] = recipient;
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  EventNotification copyWith(
      {String? emailAddress,
      String? expand,
      FieldDetails? field,
      GroupName? group,
      int? id,
      EventNotificationNotificationType? notificationType,
      String? parameter,
      ProjectRole? projectRole,
      String? recipient,
      UserDetails? user}) {
    return EventNotification(
      emailAddress: emailAddress ?? this.emailAddress,
      expand: expand ?? this.expand,
      field: field ?? this.field,
      group: group ?? this.group,
      id: id ?? this.id,
      notificationType: notificationType ?? this.notificationType,
      parameter: parameter ?? this.parameter,
      projectRole: projectRole ?? this.projectRole,
      recipient: recipient ?? this.recipient,
      user: user ?? this.user,
    );
  }
}

class EventNotificationNotificationType {
  static const currentAssignee =
      EventNotificationNotificationType._('CurrentAssignee');
  static const reporter = EventNotificationNotificationType._('Reporter');
  static const currentUser = EventNotificationNotificationType._('CurrentUser');
  static const projectLead = EventNotificationNotificationType._('ProjectLead');
  static const componentLead =
      EventNotificationNotificationType._('ComponentLead');
  static const user = EventNotificationNotificationType._('User');
  static const group = EventNotificationNotificationType._('Group');
  static const projectRole = EventNotificationNotificationType._('ProjectRole');
  static const emailAddress =
      EventNotificationNotificationType._('EmailAddress');
  static const allWatchers = EventNotificationNotificationType._('AllWatchers');
  static const userCustomField =
      EventNotificationNotificationType._('UserCustomField');
  static const groupCustomField =
      EventNotificationNotificationType._('GroupCustomField');

  static const values = [
    currentAssignee,
    reporter,
    currentUser,
    projectLead,
    componentLead,
    user,
    group,
    projectRole,
    emailAddress,
    allWatchers,
    userCustomField,
    groupCustomField,
  ];
  final String value;

  const EventNotificationNotificationType._(this.value);

  static EventNotificationNotificationType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => EventNotificationNotificationType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about a failed webhook.
class FailedWebhook {
  /// The webhook body.
  final String? body;

  /// The time the webhook was added to the list of failed webhooks (that is,
  /// the time of the last failed retry).
  final int failureTime;

  /// The webhook ID, as sent in the `X-Atlassian-Webhook-Identifier` header
  /// with the webhook.
  final String id;

  /// The original webhook destination.
  final String url;

  FailedWebhook(
      {this.body,
      required this.failureTime,
      required this.id,
      required this.url});

  factory FailedWebhook.fromJson(Map<String, Object?> json) {
    return FailedWebhook(
      body: json[r'body'] as String?,
      failureTime: (json[r'failureTime'] as num?)?.toInt() ?? 0,
      id: json[r'id'] as String? ?? '',
      url: json[r'url'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var body = this.body;
    var failureTime = this.failureTime;
    var id = this.id;
    var url = this.url;

    final json = <String, Object?>{};
    if (body != null) {
      json[r'body'] = body;
    }
    json[r'failureTime'] = failureTime;
    json[r'id'] = id;
    json[r'url'] = url;
    return json;
  }

  FailedWebhook copyWith(
      {String? body, int? failureTime, String? id, String? url}) {
    return FailedWebhook(
      body: body ?? this.body,
      failureTime: failureTime ?? this.failureTime,
      id: id ?? this.id,
      url: url ?? this.url,
    );
  }
}

/// A page of failed webhooks.
class FailedWebhooks {
  /// The maximum number of items on the page. If the list of values is shorter
  /// than this number, then there are no more pages.
  final int maxResults;

  /// The URL to the next page of results. Present only if the request returned
  /// at least one result.The next page may be empty at the time of receiving
  /// the response, but new failed webhooks may appear in time. You can save the
  /// URL to the next page and query for new results periodically (for example,
  /// every hour).
  final String? next;

  /// The list of webhooks.
  final List<FailedWebhook> values;

  FailedWebhooks({required this.maxResults, this.next, required this.values});

  factory FailedWebhooks.fromJson(Map<String, Object?> json) {
    return FailedWebhooks(
      maxResults: (json[r'maxResults'] as num?)?.toInt() ?? 0,
      next: json[r'next'] as String?,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FailedWebhook.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var maxResults = this.maxResults;
    var next = this.next;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'maxResults'] = maxResults;
    if (next != null) {
      json[r'next'] = next;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  FailedWebhooks copyWith(
      {int? maxResults, String? next, List<FailedWebhook>? values}) {
    return FailedWebhooks(
      maxResults: maxResults ?? this.maxResults,
      next: next ?? this.next,
      values: values ?? this.values,
    );
  }
}

/// Details of a field.
class Field {
  /// Number of contexts where the field is used.
  final int? contextsCount;

  /// The description of the field.
  final String? description;

  /// The ID of the field.
  final String id;

  /// Whether the field is locked.
  final bool isLocked;

  /// Whether the field is shown on screen or not.
  final bool isUnscreenable;

  /// The key of the field.
  final String? key;
  final FieldLastUsed? lastUsed;

  /// The name of the field.
  final String name;

  /// Number of projects where the field is used.
  final int? projectsCount;
  final JsonTypeBean schema;

  /// Number of screens where the field is used.
  final int? screensCount;

  /// The searcher key of the field. Returned for custom fields.
  final String? searcherKey;

  Field(
      {this.contextsCount,
      this.description,
      required this.id,
      bool? isLocked,
      bool? isUnscreenable,
      this.key,
      this.lastUsed,
      required this.name,
      this.projectsCount,
      required this.schema,
      this.screensCount,
      this.searcherKey})
      : isLocked = isLocked ?? false,
        isUnscreenable = isUnscreenable ?? false;

  factory Field.fromJson(Map<String, Object?> json) {
    return Field(
      contextsCount: (json[r'contextsCount'] as num?)?.toInt(),
      description: json[r'description'] as String?,
      id: json[r'id'] as String? ?? '',
      isLocked: json[r'isLocked'] as bool? ?? false,
      isUnscreenable: json[r'isUnscreenable'] as bool? ?? false,
      key: json[r'key'] as String?,
      lastUsed: json[r'lastUsed'] != null
          ? FieldLastUsed.fromJson(json[r'lastUsed']! as Map<String, Object?>)
          : null,
      name: json[r'name'] as String? ?? '',
      projectsCount: (json[r'projectsCount'] as num?)?.toInt(),
      schema: JsonTypeBean.fromJson(
          json[r'schema'] as Map<String, Object?>? ?? const {}),
      screensCount: (json[r'screensCount'] as num?)?.toInt(),
      searcherKey: json[r'searcherKey'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var contextsCount = this.contextsCount;
    var description = this.description;
    var id = this.id;
    var isLocked = this.isLocked;
    var isUnscreenable = this.isUnscreenable;
    var key = this.key;
    var lastUsed = this.lastUsed;
    var name = this.name;
    var projectsCount = this.projectsCount;
    var schema = this.schema;
    var screensCount = this.screensCount;
    var searcherKey = this.searcherKey;

    final json = <String, Object?>{};
    if (contextsCount != null) {
      json[r'contextsCount'] = contextsCount;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'id'] = id;
    json[r'isLocked'] = isLocked;
    json[r'isUnscreenable'] = isUnscreenable;
    if (key != null) {
      json[r'key'] = key;
    }
    if (lastUsed != null) {
      json[r'lastUsed'] = lastUsed.toJson();
    }
    json[r'name'] = name;
    if (projectsCount != null) {
      json[r'projectsCount'] = projectsCount;
    }
    json[r'schema'] = schema.toJson();
    if (screensCount != null) {
      json[r'screensCount'] = screensCount;
    }
    if (searcherKey != null) {
      json[r'searcherKey'] = searcherKey;
    }
    return json;
  }

  Field copyWith(
      {int? contextsCount,
      String? description,
      String? id,
      bool? isLocked,
      bool? isUnscreenable,
      String? key,
      FieldLastUsed? lastUsed,
      String? name,
      int? projectsCount,
      JsonTypeBean? schema,
      int? screensCount,
      String? searcherKey}) {
    return Field(
      contextsCount: contextsCount ?? this.contextsCount,
      description: description ?? this.description,
      id: id ?? this.id,
      isLocked: isLocked ?? this.isLocked,
      isUnscreenable: isUnscreenable ?? this.isUnscreenable,
      key: key ?? this.key,
      lastUsed: lastUsed ?? this.lastUsed,
      name: name ?? this.name,
      projectsCount: projectsCount ?? this.projectsCount,
      schema: schema ?? this.schema,
      screensCount: screensCount ?? this.screensCount,
      searcherKey: searcherKey ?? this.searcherKey,
    );
  }
}

/// A clause that asserts whether a field was changed. For example, `status
/// CHANGED AFTER startOfMonth(-1M)`.See
/// [CHANGED](https://confluence.atlassian.com/x/dgiiLQ#Advancedsearching-operatorsreference-CHANGEDCHANGED)
/// for more information about the CHANGED operator.
class FieldChangedClause {
  final JqlQueryField field;

  /// The operator applied to the field.
  final FieldChangedClauseOperator operator$;

  /// The list of time predicates.
  final List<JqlQueryClauseTimePredicate> predicates;

  FieldChangedClause(
      {required this.field, required this.operator$, required this.predicates});

  factory FieldChangedClause.fromJson(Map<String, Object?> json) {
    return FieldChangedClause(
      field: JqlQueryField.fromJson(
          json[r'field'] as Map<String, Object?>? ?? const {}),
      operator$: FieldChangedClauseOperator.fromValue(
          json[r'operator'] as String? ?? ''),
      predicates: (json[r'predicates'] as List<Object?>?)
              ?.map((i) => JqlQueryClauseTimePredicate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var field = this.field;
    var operator$ = this.operator$;
    var predicates = this.predicates;

    final json = <String, Object?>{};
    json[r'field'] = field.toJson();
    json[r'operator'] = operator$.value;
    json[r'predicates'] = predicates.map((i) => i.toJson()).toList();
    return json;
  }

  FieldChangedClause copyWith(
      {JqlQueryField? field,
      FieldChangedClauseOperator? operator$,
      List<JqlQueryClauseTimePredicate>? predicates}) {
    return FieldChangedClause(
      field: field ?? this.field,
      operator$: operator$ ?? this.operator$,
      predicates: predicates ?? this.predicates,
    );
  }
}

class FieldChangedClauseOperator {
  static const changed = FieldChangedClauseOperator._('changed');

  static const values = [
    changed,
  ];
  final String value;

  const FieldChangedClauseOperator._(this.value);

  static FieldChangedClauseOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldChangedClauseOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of a field configuration.
class FieldConfiguration {
  /// The description of the field configuration.
  final String description;

  /// The ID of the field configuration.
  final int id;

  /// Whether the field configuration is the default.
  final bool isDefault;

  /// The name of the field configuration.
  final String name;

  FieldConfiguration(
      {required this.description,
      required this.id,
      bool? isDefault,
      required this.name})
      : isDefault = isDefault ?? false;

  factory FieldConfiguration.fromJson(Map<String, Object?> json) {
    return FieldConfiguration(
      description: json[r'description'] as String? ?? '',
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      isDefault: json[r'isDefault'] as bool? ?? false,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var isDefault = this.isDefault;
    var name = this.name;

    final json = <String, Object?>{};
    json[r'description'] = description;
    json[r'id'] = id;
    json[r'isDefault'] = isDefault;
    json[r'name'] = name;
    return json;
  }

  FieldConfiguration copyWith(
      {String? description, int? id, bool? isDefault, String? name}) {
    return FieldConfiguration(
      description: description ?? this.description,
      id: id ?? this.id,
      isDefault: isDefault ?? this.isDefault,
      name: name ?? this.name,
    );
  }
}

/// Details of a field configuration.
class FieldConfigurationDetails {
  /// The description of the field configuration.
  final String? description;

  /// The name of the field configuration. Must be unique.
  final String name;

  FieldConfigurationDetails({this.description, required this.name});

  factory FieldConfigurationDetails.fromJson(Map<String, Object?> json) {
    return FieldConfigurationDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'name'] = name;
    return json;
  }

  FieldConfigurationDetails copyWith({String? description, String? name}) {
    return FieldConfigurationDetails(
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// The field configuration for an issue type.
class FieldConfigurationIssueTypeItem {
  /// The ID of the field configuration.
  final String fieldConfigurationId;

  /// The ID of the field configuration scheme.
  final String fieldConfigurationSchemeId;

  /// The ID of the issue type or *default*. When set to *default* this field
  /// configuration issue type item applies to all issue types without a field
  /// configuration.
  final String issueTypeId;

  FieldConfigurationIssueTypeItem(
      {required this.fieldConfigurationId,
      required this.fieldConfigurationSchemeId,
      required this.issueTypeId});

  factory FieldConfigurationIssueTypeItem.fromJson(Map<String, Object?> json) {
    return FieldConfigurationIssueTypeItem(
      fieldConfigurationId: json[r'fieldConfigurationId'] as String? ?? '',
      fieldConfigurationSchemeId:
          json[r'fieldConfigurationSchemeId'] as String? ?? '',
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var fieldConfigurationId = this.fieldConfigurationId;
    var fieldConfigurationSchemeId = this.fieldConfigurationSchemeId;
    var issueTypeId = this.issueTypeId;

    final json = <String, Object?>{};
    json[r'fieldConfigurationId'] = fieldConfigurationId;
    json[r'fieldConfigurationSchemeId'] = fieldConfigurationSchemeId;
    json[r'issueTypeId'] = issueTypeId;
    return json;
  }

  FieldConfigurationIssueTypeItem copyWith(
      {String? fieldConfigurationId,
      String? fieldConfigurationSchemeId,
      String? issueTypeId}) {
    return FieldConfigurationIssueTypeItem(
      fieldConfigurationId: fieldConfigurationId ?? this.fieldConfigurationId,
      fieldConfigurationSchemeId:
          fieldConfigurationSchemeId ?? this.fieldConfigurationSchemeId,
      issueTypeId: issueTypeId ?? this.issueTypeId,
    );
  }
}

/// A field within a field configuration.
class FieldConfigurationItem {
  /// The description of the field within the field configuration.
  final String? description;

  /// The ID of the field within the field configuration.
  final String id;

  /// Whether the field is hidden in the field configuration.
  final bool isHidden;

  /// Whether the field is required in the field configuration.
  final bool isRequired;

  /// The renderer type for the field within the field configuration.
  final String? renderer;

  FieldConfigurationItem(
      {this.description,
      required this.id,
      bool? isHidden,
      bool? isRequired,
      this.renderer})
      : isHidden = isHidden ?? false,
        isRequired = isRequired ?? false;

  factory FieldConfigurationItem.fromJson(Map<String, Object?> json) {
    return FieldConfigurationItem(
      description: json[r'description'] as String?,
      id: json[r'id'] as String? ?? '',
      isHidden: json[r'isHidden'] as bool? ?? false,
      isRequired: json[r'isRequired'] as bool? ?? false,
      renderer: json[r'renderer'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var isHidden = this.isHidden;
    var isRequired = this.isRequired;
    var renderer = this.renderer;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'id'] = id;
    json[r'isHidden'] = isHidden;
    json[r'isRequired'] = isRequired;
    if (renderer != null) {
      json[r'renderer'] = renderer;
    }
    return json;
  }

  FieldConfigurationItem copyWith(
      {String? description,
      String? id,
      bool? isHidden,
      bool? isRequired,
      String? renderer}) {
    return FieldConfigurationItem(
      description: description ?? this.description,
      id: id ?? this.id,
      isHidden: isHidden ?? this.isHidden,
      isRequired: isRequired ?? this.isRequired,
      renderer: renderer ?? this.renderer,
    );
  }
}

/// Details of field configuration items.
class FieldConfigurationItemsDetails {
  /// Details of fields in a field configuration.
  final List<FieldConfigurationItem> fieldConfigurationItems;

  FieldConfigurationItemsDetails({required this.fieldConfigurationItems});

  factory FieldConfigurationItemsDetails.fromJson(Map<String, Object?> json) {
    return FieldConfigurationItemsDetails(
      fieldConfigurationItems:
          (json[r'fieldConfigurationItems'] as List<Object?>?)
                  ?.map((i) => FieldConfigurationItem.fromJson(
                      i as Map<String, Object?>? ?? const {}))
                  .toList() ??
              [],
    );
  }

  Map<String, Object?> toJson() {
    var fieldConfigurationItems = this.fieldConfigurationItems;

    final json = <String, Object?>{};
    json[r'fieldConfigurationItems'] =
        fieldConfigurationItems.map((i) => i.toJson()).toList();
    return json;
  }

  FieldConfigurationItemsDetails copyWith(
      {List<FieldConfigurationItem>? fieldConfigurationItems}) {
    return FieldConfigurationItemsDetails(
      fieldConfigurationItems:
          fieldConfigurationItems ?? this.fieldConfigurationItems,
    );
  }
}

/// Details of a field configuration scheme.
class FieldConfigurationScheme {
  /// The description of the field configuration scheme.
  final String? description;

  /// The ID of the field configuration scheme.
  final String id;

  /// The name of the field configuration scheme.
  final String name;

  FieldConfigurationScheme(
      {this.description, required this.id, required this.name});

  factory FieldConfigurationScheme.fromJson(Map<String, Object?> json) {
    return FieldConfigurationScheme(
      description: json[r'description'] as String?,
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'id'] = id;
    json[r'name'] = name;
    return json;
  }

  FieldConfigurationScheme copyWith(
      {String? description, String? id, String? name}) {
    return FieldConfigurationScheme(
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// Associated field configuration scheme and project.
class FieldConfigurationSchemeProjectAssociation {
  /// The ID of the field configuration scheme. If the field configuration
  /// scheme ID is `null`, the operation assigns the default field configuration
  /// scheme.
  final String? fieldConfigurationSchemeId;

  /// The ID of the project.
  final String projectId;

  FieldConfigurationSchemeProjectAssociation(
      {this.fieldConfigurationSchemeId, required this.projectId});

  factory FieldConfigurationSchemeProjectAssociation.fromJson(
      Map<String, Object?> json) {
    return FieldConfigurationSchemeProjectAssociation(
      fieldConfigurationSchemeId:
          json[r'fieldConfigurationSchemeId'] as String?,
      projectId: json[r'projectId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var fieldConfigurationSchemeId = this.fieldConfigurationSchemeId;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    if (fieldConfigurationSchemeId != null) {
      json[r'fieldConfigurationSchemeId'] = fieldConfigurationSchemeId;
    }
    json[r'projectId'] = projectId;
    return json;
  }

  FieldConfigurationSchemeProjectAssociation copyWith(
      {String? fieldConfigurationSchemeId, String? projectId}) {
    return FieldConfigurationSchemeProjectAssociation(
      fieldConfigurationSchemeId:
          fieldConfigurationSchemeId ?? this.fieldConfigurationSchemeId,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// Project list with assigned field configuration schema.
class FieldConfigurationSchemeProjects {
  final FieldConfigurationScheme? fieldConfigurationScheme;

  /// The IDs of projects using the field configuration scheme.
  final List<String> projectIds;

  FieldConfigurationSchemeProjects(
      {this.fieldConfigurationScheme, required this.projectIds});

  factory FieldConfigurationSchemeProjects.fromJson(Map<String, Object?> json) {
    return FieldConfigurationSchemeProjects(
      fieldConfigurationScheme: json[r'fieldConfigurationScheme'] != null
          ? FieldConfigurationScheme.fromJson(
              json[r'fieldConfigurationScheme']! as Map<String, Object?>)
          : null,
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var fieldConfigurationScheme = this.fieldConfigurationScheme;
    var projectIds = this.projectIds;

    final json = <String, Object?>{};
    if (fieldConfigurationScheme != null) {
      json[r'fieldConfigurationScheme'] = fieldConfigurationScheme.toJson();
    }
    json[r'projectIds'] = projectIds;
    return json;
  }

  FieldConfigurationSchemeProjects copyWith(
      {FieldConfigurationScheme? fieldConfigurationScheme,
      List<String>? projectIds}) {
    return FieldConfigurationSchemeProjects(
      fieldConfigurationScheme:
          fieldConfigurationScheme ?? this.fieldConfigurationScheme,
      projectIds: projectIds ?? this.projectIds,
    );
  }
}

/// The field configuration to issue type mapping.
class FieldConfigurationToIssueTypeMapping {
  /// The ID of the field configuration.
  final String fieldConfigurationId;

  /// The ID of the issue type or *default*. When set to *default* this field
  /// configuration issue type item applies to all issue types without a field
  /// configuration. An issue type can be included only once in a request.
  final String issueTypeId;

  FieldConfigurationToIssueTypeMapping(
      {required this.fieldConfigurationId, required this.issueTypeId});

  factory FieldConfigurationToIssueTypeMapping.fromJson(
      Map<String, Object?> json) {
    return FieldConfigurationToIssueTypeMapping(
      fieldConfigurationId: json[r'fieldConfigurationId'] as String? ?? '',
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var fieldConfigurationId = this.fieldConfigurationId;
    var issueTypeId = this.issueTypeId;

    final json = <String, Object?>{};
    json[r'fieldConfigurationId'] = fieldConfigurationId;
    json[r'issueTypeId'] = issueTypeId;
    return json;
  }

  FieldConfigurationToIssueTypeMapping copyWith(
      {String? fieldConfigurationId, String? issueTypeId}) {
    return FieldConfigurationToIssueTypeMapping(
      fieldConfigurationId: fieldConfigurationId ?? this.fieldConfigurationId,
      issueTypeId: issueTypeId ?? this.issueTypeId,
    );
  }
}

/// Details about a field.
class FieldDetails {
  /// The names that can be used to reference the field in an advanced search.
  /// For more information, see
  /// [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ).
  final List<String> clauseNames;

  /// Whether the field is a custom field.
  final bool custom;

  /// The ID of the field.
  final String? id;

  /// The key of the field.
  final String? key;

  /// The name of the field.
  final String? name;

  /// Whether the field can be used as a column on the issue navigator.
  final bool navigable;

  /// Whether the content of the field can be used to order lists.
  final bool orderable;

  /// The data schema for the field.
  final JsonTypeBean? schema;

  /// The scope of the field.
  final Scope? scope;

  /// Whether the content of the field can be searched.
  final bool searchable;

  FieldDetails(
      {List<String>? clauseNames,
      bool? custom,
      this.id,
      this.key,
      this.name,
      bool? navigable,
      bool? orderable,
      this.schema,
      this.scope,
      bool? searchable})
      : clauseNames = clauseNames ?? [],
        custom = custom ?? false,
        navigable = navigable ?? false,
        orderable = orderable ?? false,
        searchable = searchable ?? false;

  factory FieldDetails.fromJson(Map<String, Object?> json) {
    return FieldDetails(
      clauseNames: (json[r'clauseNames'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      custom: json[r'custom'] as bool? ?? false,
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      navigable: json[r'navigable'] as bool? ?? false,
      orderable: json[r'orderable'] as bool? ?? false,
      schema: json[r'schema'] != null
          ? JsonTypeBean.fromJson(json[r'schema']! as Map<String, Object?>)
          : null,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      searchable: json[r'searchable'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var clauseNames = this.clauseNames;
    var custom = this.custom;
    var id = this.id;
    var key = this.key;
    var name = this.name;
    var navigable = this.navigable;
    var orderable = this.orderable;
    var schema = this.schema;
    var scope = this.scope;
    var searchable = this.searchable;

    final json = <String, Object?>{};
    json[r'clauseNames'] = clauseNames;
    json[r'custom'] = custom;
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'navigable'] = navigable;
    json[r'orderable'] = orderable;
    if (schema != null) {
      json[r'schema'] = schema.toJson();
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    json[r'searchable'] = searchable;
    return json;
  }

  FieldDetails copyWith(
      {List<String>? clauseNames,
      bool? custom,
      String? id,
      String? key,
      String? name,
      bool? navigable,
      bool? orderable,
      JsonTypeBean? schema,
      Scope? scope,
      bool? searchable}) {
    return FieldDetails(
      clauseNames: clauseNames ?? this.clauseNames,
      custom: custom ?? this.custom,
      id: id ?? this.id,
      key: key ?? this.key,
      name: name ?? this.name,
      navigable: navigable ?? this.navigable,
      orderable: orderable ?? this.orderable,
      schema: schema ?? this.schema,
      scope: scope ?? this.scope,
      searchable: searchable ?? this.searchable,
    );
  }
}

/// Information about the most recent use of a field.
class FieldLastUsed {
  /// Last used value type:
  ///
  ///  *  *TRACKED*: field is tracked and a last used date is available.
  ///  *  *NOT_TRACKED*: field is not tracked, last used date is not available.
  ///  *  *NO_INFORMATION*: field is tracked, but no last used date is
  /// available.
  final FieldLastUsedType? type;

  /// The date when the value of the field last changed.
  final DateTime? value;

  FieldLastUsed({this.type, this.value});

  factory FieldLastUsed.fromJson(Map<String, Object?> json) {
    return FieldLastUsed(
      type: json[r'type'] != null
          ? FieldLastUsedType.fromValue(json[r'type']! as String)
          : null,
      value: DateTime.tryParse(json[r'value'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var value = this.value;

    final json = <String, Object?>{};
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (value != null) {
      json[r'value'] = value.toIso8601String();
    }
    return json;
  }

  FieldLastUsed copyWith({FieldLastUsedType? type, DateTime? value}) {
    return FieldLastUsed(
      type: type ?? this.type,
      value: value ?? this.value,
    );
  }
}

class FieldLastUsedType {
  static const tracked = FieldLastUsedType._('TRACKED');
  static const notTracked = FieldLastUsedType._('NOT_TRACKED');
  static const noInformation = FieldLastUsedType._('NO_INFORMATION');

  static const values = [
    tracked,
    notTracked,
    noInformation,
  ];
  final String value;

  const FieldLastUsedType._(this.value);

  static FieldLastUsedType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldLastUsedType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The metadata describing an issue field.
class FieldMetadata {
  /// The list of values allowed in the field.
  final List<dynamic> allowedValues;

  /// The URL that can be used to automatically complete the field.
  final String? autoCompleteUrl;

  /// The configuration properties.
  final Map<String, dynamic>? configuration;

  /// The default value of the field.
  final dynamic defaultValue;

  /// Whether the field has a default value.
  final bool hasDefaultValue;

  /// The key of the field.
  final String key;

  /// The name of the field.
  final String name;

  /// The list of operations that can be performed on the field.
  final List<String> operations;

  /// Whether the field is required.
  final bool required;

  /// The data type of the field.
  final JsonTypeBean schema;

  FieldMetadata(
      {List<dynamic>? allowedValues,
      this.autoCompleteUrl,
      this.configuration,
      this.defaultValue,
      bool? hasDefaultValue,
      required this.key,
      required this.name,
      required this.operations,
      required this.required,
      required this.schema})
      : allowedValues = allowedValues ?? [],
        hasDefaultValue = hasDefaultValue ?? false;

  factory FieldMetadata.fromJson(Map<String, Object?> json) {
    return FieldMetadata(
      allowedValues:
          (json[r'allowedValues'] as List<Object?>?)?.map((i) => i).toList() ??
              [],
      autoCompleteUrl: json[r'autoCompleteUrl'] as String?,
      configuration: json[r'configuration'] as Map<String, Object?>?,
      defaultValue: json[r'defaultValue'],
      hasDefaultValue: json[r'hasDefaultValue'] as bool? ?? false,
      key: json[r'key'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      operations: (json[r'operations'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      required: json[r'required'] as bool? ?? false,
      schema: JsonTypeBean.fromJson(
          json[r'schema'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var allowedValues = this.allowedValues;
    var autoCompleteUrl = this.autoCompleteUrl;
    var configuration = this.configuration;
    var defaultValue = this.defaultValue;
    var hasDefaultValue = this.hasDefaultValue;
    var key = this.key;
    var name = this.name;
    var operations = this.operations;
    var required = this.required;
    var schema = this.schema;

    final json = <String, Object?>{};
    json[r'allowedValues'] = allowedValues;
    if (autoCompleteUrl != null) {
      json[r'autoCompleteUrl'] = autoCompleteUrl;
    }
    if (configuration != null) {
      json[r'configuration'] = configuration;
    }
    if (defaultValue != null) {
      json[r'defaultValue'] = defaultValue;
    }
    json[r'hasDefaultValue'] = hasDefaultValue;
    json[r'key'] = key;
    json[r'name'] = name;
    json[r'operations'] = operations;
    json[r'required'] = required;
    json[r'schema'] = schema.toJson();
    return json;
  }

  FieldMetadata copyWith(
      {List<dynamic>? allowedValues,
      String? autoCompleteUrl,
      Map<String, dynamic>? configuration,
      dynamic defaultValue,
      bool? hasDefaultValue,
      String? key,
      String? name,
      List<String>? operations,
      bool? required,
      JsonTypeBean? schema}) {
    return FieldMetadata(
      allowedValues: allowedValues ?? this.allowedValues,
      autoCompleteUrl: autoCompleteUrl ?? this.autoCompleteUrl,
      configuration: configuration ?? this.configuration,
      defaultValue: defaultValue ?? this.defaultValue,
      hasDefaultValue: hasDefaultValue ?? this.hasDefaultValue,
      key: key ?? this.key,
      name: name ?? this.name,
      operations: operations ?? this.operations,
      required: required ?? this.required,
      schema: schema ?? this.schema,
    );
  }
}

/// Details of a field that can be used in advanced searches.
class FieldReferenceData {
  /// Whether the field provide auto-complete suggestions.
  final FieldReferenceDataAuto? auto;

  /// If the item is a custom field, the ID of the custom field.
  final String? cfid;

  /// Whether this field has been deprecated.
  final FieldReferenceDataDeprecated? deprecated;

  /// The searcher key of the field, only passed when the field is deprecated.
  final String? deprecatedSearcherKey;

  /// The display name contains the following:
  ///
  ///  *  for system fields, the field name. For example, `Summary`.
  ///  *  for collapsed custom fields, the field name followed by a hyphen and
  /// then the field name and field type. For example, `Component -
  /// Component[Dropdown]`.
  ///  *  for other custom fields, the field name followed by a hyphen and then
  /// the custom field ID. For example, `Component - cf[10061]`.
  final String? displayName;

  /// The valid search operators for the field.
  final List<String> operators;

  /// Whether the field can be used in a query's `ORDER BY` clause.
  final FieldReferenceDataOrderable? orderable;

  /// Whether the content of this field can be searched.
  final FieldReferenceDataSearchable? searchable;

  /// The data types of items in the field.
  final List<String> types;

  /// The field identifier.
  final String? value;

  FieldReferenceData(
      {this.auto,
      this.cfid,
      this.deprecated,
      this.deprecatedSearcherKey,
      this.displayName,
      List<String>? operators,
      this.orderable,
      this.searchable,
      List<String>? types,
      this.value})
      : operators = operators ?? [],
        types = types ?? [];

  factory FieldReferenceData.fromJson(Map<String, Object?> json) {
    return FieldReferenceData(
      auto: json[r'auto'] != null
          ? FieldReferenceDataAuto.fromValue(json[r'auto']! as String)
          : null,
      cfid: json[r'cfid'] as String?,
      deprecated: json[r'deprecated'] != null
          ? FieldReferenceDataDeprecated.fromValue(
              json[r'deprecated']! as String)
          : null,
      deprecatedSearcherKey: json[r'deprecatedSearcherKey'] as String?,
      displayName: json[r'displayName'] as String?,
      operators: (json[r'operators'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      orderable: json[r'orderable'] != null
          ? FieldReferenceDataOrderable.fromValue(json[r'orderable']! as String)
          : null,
      searchable: json[r'searchable'] != null
          ? FieldReferenceDataSearchable.fromValue(
              json[r'searchable']! as String)
          : null,
      types: (json[r'types'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var auto = this.auto;
    var cfid = this.cfid;
    var deprecated = this.deprecated;
    var deprecatedSearcherKey = this.deprecatedSearcherKey;
    var displayName = this.displayName;
    var operators = this.operators;
    var orderable = this.orderable;
    var searchable = this.searchable;
    var types = this.types;
    var value = this.value;

    final json = <String, Object?>{};
    if (auto != null) {
      json[r'auto'] = auto.value;
    }
    if (cfid != null) {
      json[r'cfid'] = cfid;
    }
    if (deprecated != null) {
      json[r'deprecated'] = deprecated.value;
    }
    if (deprecatedSearcherKey != null) {
      json[r'deprecatedSearcherKey'] = deprecatedSearcherKey;
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    json[r'operators'] = operators;
    if (orderable != null) {
      json[r'orderable'] = orderable.value;
    }
    if (searchable != null) {
      json[r'searchable'] = searchable.value;
    }
    json[r'types'] = types;
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  FieldReferenceData copyWith(
      {FieldReferenceDataAuto? auto,
      String? cfid,
      FieldReferenceDataDeprecated? deprecated,
      String? deprecatedSearcherKey,
      String? displayName,
      List<String>? operators,
      FieldReferenceDataOrderable? orderable,
      FieldReferenceDataSearchable? searchable,
      List<String>? types,
      String? value}) {
    return FieldReferenceData(
      auto: auto ?? this.auto,
      cfid: cfid ?? this.cfid,
      deprecated: deprecated ?? this.deprecated,
      deprecatedSearcherKey:
          deprecatedSearcherKey ?? this.deprecatedSearcherKey,
      displayName: displayName ?? this.displayName,
      operators: operators ?? this.operators,
      orderable: orderable ?? this.orderable,
      searchable: searchable ?? this.searchable,
      types: types ?? this.types,
      value: value ?? this.value,
    );
  }
}

class FieldReferenceDataAuto {
  static const true$ = FieldReferenceDataAuto._('true');
  static const false$ = FieldReferenceDataAuto._('false');

  static const values = [
    true$,
    false$,
  ];
  final String value;

  const FieldReferenceDataAuto._(this.value);

  static FieldReferenceDataAuto fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldReferenceDataAuto._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class FieldReferenceDataDeprecated {
  static const true$ = FieldReferenceDataDeprecated._('true');
  static const false$ = FieldReferenceDataDeprecated._('false');

  static const values = [
    true$,
    false$,
  ];
  final String value;

  const FieldReferenceDataDeprecated._(this.value);

  static FieldReferenceDataDeprecated fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldReferenceDataDeprecated._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class FieldReferenceDataOrderable {
  static const true$ = FieldReferenceDataOrderable._('true');
  static const false$ = FieldReferenceDataOrderable._('false');

  static const values = [
    true$,
    false$,
  ];
  final String value;

  const FieldReferenceDataOrderable._(this.value);

  static FieldReferenceDataOrderable fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldReferenceDataOrderable._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class FieldReferenceDataSearchable {
  static const true$ = FieldReferenceDataSearchable._('true');
  static const false$ = FieldReferenceDataSearchable._('false');

  static const values = [
    true$,
    false$,
  ];
  final String value;

  const FieldReferenceDataSearchable._(this.value);

  static FieldReferenceDataSearchable fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldReferenceDataSearchable._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of an operation to perform on a field.
class FieldUpdateOperation {
  /// The value to add to the field.
  final dynamic add;

  /// The field value to copy from another issue.
  final dynamic copy;

  /// The value to edit in the field.
  final dynamic edit;

  /// The value to removed from the field.
  final dynamic remove;

  /// The value to set in the field.
  final dynamic set;

  FieldUpdateOperation({this.add, this.copy, this.edit, this.remove, this.set});

  factory FieldUpdateOperation.fromJson(Map<String, Object?> json) {
    return FieldUpdateOperation(
      add: json[r'add'],
      copy: json[r'copy'],
      edit: json[r'edit'],
      remove: json[r'remove'],
      set: json[r'set'],
    );
  }

  Map<String, Object?> toJson() {
    var add = this.add;
    var copy = this.copy;
    var edit = this.edit;
    var remove = this.remove;
    var set = this.set;

    final json = <String, Object?>{};
    if (add != null) {
      json[r'add'] = add;
    }
    if (copy != null) {
      json[r'copy'] = copy;
    }
    if (edit != null) {
      json[r'edit'] = edit;
    }
    if (remove != null) {
      json[r'remove'] = remove;
    }
    if (set != null) {
      json[r'set'] = set;
    }
    return json;
  }

  FieldUpdateOperation copyWith(
      {dynamic add, dynamic copy, dynamic edit, dynamic remove, dynamic set}) {
    return FieldUpdateOperation(
      add: add ?? this.add,
      copy: copy ?? this.copy,
      edit: edit ?? this.edit,
      remove: remove ?? this.remove,
      set: set ?? this.set,
    );
  }
}

/// A clause that asserts the current value of a field. For example, `summary ~
/// test`.
class FieldValueClause {
  final JqlQueryField field;
  final JqlQueryClauseOperand operand;

  /// The operator between the field and operand.
  final FieldValueClauseOperator operator$;

  FieldValueClause(
      {required this.field, required this.operand, required this.operator$});

  factory FieldValueClause.fromJson(Map<String, Object?> json) {
    return FieldValueClause(
      field: JqlQueryField.fromJson(
          json[r'field'] as Map<String, Object?>? ?? const {}),
      operand: JqlQueryClauseOperand.fromJson(
          json[r'operand'] as Map<String, Object?>? ?? const {}),
      operator$: FieldValueClauseOperator.fromValue(
          json[r'operator'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var field = this.field;
    var operand = this.operand;
    var operator$ = this.operator$;

    final json = <String, Object?>{};
    json[r'field'] = field.toJson();
    json[r'operand'] = operand.toJson();
    json[r'operator'] = operator$.value;
    return json;
  }

  FieldValueClause copyWith(
      {JqlQueryField? field,
      JqlQueryClauseOperand? operand,
      FieldValueClauseOperator? operator$}) {
    return FieldValueClause(
      field: field ?? this.field,
      operand: operand ?? this.operand,
      operator$: operator$ ?? this.operator$,
    );
  }
}

class FieldValueClauseOperator {
  static const equal = FieldValueClauseOperator._('=');
  static const different = FieldValueClauseOperator._('!=');
  static const greaterThan = FieldValueClauseOperator._('>');
  static const lessThan = FieldValueClauseOperator._('<');
  static const greaterThanOrEquals = FieldValueClauseOperator._('>=');
  static const lessThanOrEquals = FieldValueClauseOperator._('<=');
  static const in$ = FieldValueClauseOperator._('in');
  static const notIn = FieldValueClauseOperator._('not in');
  static const tilde = FieldValueClauseOperator._('~');
  static const tildeEqual = FieldValueClauseOperator._('~=');
  static const is$ = FieldValueClauseOperator._('is');
  static const isNot = FieldValueClauseOperator._('is not');

  static const values = [
    equal,
    different,
    greaterThan,
    lessThan,
    greaterThanOrEquals,
    lessThanOrEquals,
    in$,
    notIn,
    tilde,
    tildeEqual,
    is$,
    isNot,
  ];
  final String value;

  const FieldValueClauseOperator._(this.value);

  static FieldValueClauseOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldValueClauseOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A clause that asserts a previous value of a field. For example, `status WAS
/// "Resolved" BY currentUser() BEFORE "2019/02/02"`. See
/// [WAS](https://confluence.atlassian.com/x/dgiiLQ#Advancedsearching-operatorsreference-WASWAS)
/// for more information about the WAS operator.
class FieldWasClause {
  final JqlQueryField field;
  final JqlQueryClauseOperand operand;

  /// The operator between the field and operand.
  final FieldWasClauseOperator operator$;

  /// The list of time predicates.
  final List<JqlQueryClauseTimePredicate> predicates;

  FieldWasClause(
      {required this.field,
      required this.operand,
      required this.operator$,
      required this.predicates});

  factory FieldWasClause.fromJson(Map<String, Object?> json) {
    return FieldWasClause(
      field: JqlQueryField.fromJson(
          json[r'field'] as Map<String, Object?>? ?? const {}),
      operand: JqlQueryClauseOperand.fromJson(
          json[r'operand'] as Map<String, Object?>? ?? const {}),
      operator$:
          FieldWasClauseOperator.fromValue(json[r'operator'] as String? ?? ''),
      predicates: (json[r'predicates'] as List<Object?>?)
              ?.map((i) => JqlQueryClauseTimePredicate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var field = this.field;
    var operand = this.operand;
    var operator$ = this.operator$;
    var predicates = this.predicates;

    final json = <String, Object?>{};
    json[r'field'] = field.toJson();
    json[r'operand'] = operand.toJson();
    json[r'operator'] = operator$.value;
    json[r'predicates'] = predicates.map((i) => i.toJson()).toList();
    return json;
  }

  FieldWasClause copyWith(
      {JqlQueryField? field,
      JqlQueryClauseOperand? operand,
      FieldWasClauseOperator? operator$,
      List<JqlQueryClauseTimePredicate>? predicates}) {
    return FieldWasClause(
      field: field ?? this.field,
      operand: operand ?? this.operand,
      operator$: operator$ ?? this.operator$,
      predicates: predicates ?? this.predicates,
    );
  }
}

class FieldWasClauseOperator {
  static const was = FieldWasClauseOperator._('was');
  static const wasIn = FieldWasClauseOperator._('was in');
  static const wasNotIn = FieldWasClauseOperator._('was not in');
  static const wasNot = FieldWasClauseOperator._('was not');

  static const values = [
    was,
    wasIn,
    wasNotIn,
    wasNot,
  ];
  final String value;

  const FieldWasClauseOperator._(this.value);

  static FieldWasClauseOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FieldWasClauseOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Key fields from the linked issue.
class Fields {
  /// The assignee of the linked issue.
  final UserDetails? assignee;

  /// The type of the linked issue.
  final IssueTypeDetails? issueType;

  /// The type of the linked issue.
  final IssueTypeDetails? issuetype;

  /// The priority of the linked issue.
  final Priority? priority;

  /// The status of the linked issue.
  final StatusDetails? status;

  /// The summary description of the linked issue.
  final String? summary;

  /// The time tracking of the linked issue.
  final TimeTrackingDetails? timetracking;

  Fields(
      {this.assignee,
      this.issueType,
      this.issuetype,
      this.priority,
      this.status,
      this.summary,
      this.timetracking});

  factory Fields.fromJson(Map<String, Object?> json) {
    return Fields(
      assignee: json[r'assignee'] != null
          ? UserDetails.fromJson(json[r'assignee']! as Map<String, Object?>)
          : null,
      issueType: json[r'issueType'] != null
          ? IssueTypeDetails.fromJson(
              json[r'issueType']! as Map<String, Object?>)
          : null,
      issuetype: json[r'issuetype'] != null
          ? IssueTypeDetails.fromJson(
              json[r'issuetype']! as Map<String, Object?>)
          : null,
      priority: json[r'priority'] != null
          ? Priority.fromJson(json[r'priority']! as Map<String, Object?>)
          : null,
      status: json[r'status'] != null
          ? StatusDetails.fromJson(json[r'status']! as Map<String, Object?>)
          : null,
      summary: json[r'summary'] as String?,
      timetracking: json[r'timetracking'] != null
          ? TimeTrackingDetails.fromJson(
              json[r'timetracking']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var assignee = this.assignee;
    var issueType = this.issueType;
    var issuetype = this.issuetype;
    var priority = this.priority;
    var status = this.status;
    var summary = this.summary;
    var timetracking = this.timetracking;

    final json = <String, Object?>{};
    if (assignee != null) {
      json[r'assignee'] = assignee.toJson();
    }
    if (issueType != null) {
      json[r'issueType'] = issueType.toJson();
    }
    if (issuetype != null) {
      json[r'issuetype'] = issuetype.toJson();
    }
    if (priority != null) {
      json[r'priority'] = priority.toJson();
    }
    if (status != null) {
      json[r'status'] = status.toJson();
    }
    if (summary != null) {
      json[r'summary'] = summary;
    }
    if (timetracking != null) {
      json[r'timetracking'] = timetracking.toJson();
    }
    return json;
  }

  Fields copyWith(
      {UserDetails? assignee,
      IssueTypeDetails? issueType,
      IssueTypeDetails? issuetype,
      Priority? priority,
      StatusDetails? status,
      String? summary,
      TimeTrackingDetails? timetracking}) {
    return Fields(
      assignee: assignee ?? this.assignee,
      issueType: issueType ?? this.issueType,
      issuetype: issuetype ?? this.issuetype,
      priority: priority ?? this.priority,
      status: status ?? this.status,
      summary: summary ?? this.summary,
      timetracking: timetracking ?? this.timetracking,
    );
  }
}

/// Details about a filter.
class Filter {
  /// A description of the filter.
  final String? description;

  /// The groups and projects that can edit the filter.
  final List<SharePermission> editPermissions;

  /// Whether the filter is selected as a favorite.
  final bool favourite;

  /// The count of how many users have selected this filter as a favorite,
  /// including the filter owner.
  final int? favouritedCount;

  /// The unique identifier for the filter.
  final String? id;

  /// The JQL query for the filter. For example, *project = SSP AND issuetype =
  /// Bug*.
  final String? jql;

  /// The name of the filter. Must be unique.
  final String name;

  /// The user who owns the filter. This is defaulted to the creator of the
  /// filter, however Jira administrators can change the owner of a shared
  /// filter in the admin settings.
  final User? owner;

  /// A URL to view the filter results in Jira, using the
  /// [Search for issues using JQL](#api-rest-api-3-filter-search-get) operation
  /// with the filter's JQL string to return the filter results. For example,
  /// *https://your-domain.atlassian.net/rest/api/3/search?jql=project+%3D+SSP+AND+issuetype+%3D+Bug*.
  final String? searchUrl;

  /// The URL of the filter.
  final String? self;

  /// The groups and projects that the filter is shared with.
  final List<SharePermission> sharePermissions;

  /// A paginated list of the users that the filter is shared with. This
  /// includes users that are members of the groups or can browse the projects
  /// that the filter is shared with.
  final UserList? sharedUsers;

  /// A paginated list of the users that are subscribed to the filter.
  final FilterSubscriptionsList? subscriptions;

  /// A URL to view the filter results in Jira, using the ID of the filter. For
  /// example, *https://your-domain.atlassian.net/issues/?filter=10100*.
  final String? viewUrl;

  Filter(
      {this.description,
      List<SharePermission>? editPermissions,
      bool? favourite,
      this.favouritedCount,
      this.id,
      this.jql,
      required this.name,
      this.owner,
      this.searchUrl,
      this.self,
      List<SharePermission>? sharePermissions,
      this.sharedUsers,
      this.subscriptions,
      this.viewUrl})
      : editPermissions = editPermissions ?? [],
        favourite = favourite ?? false,
        sharePermissions = sharePermissions ?? [];

  factory Filter.fromJson(Map<String, Object?> json) {
    return Filter(
      description: json[r'description'] as String?,
      editPermissions: (json[r'editPermissions'] as List<Object?>?)
              ?.map((i) => SharePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      favourite: json[r'favourite'] as bool? ?? false,
      favouritedCount: (json[r'favouritedCount'] as num?)?.toInt(),
      id: json[r'id'] as String?,
      jql: json[r'jql'] as String?,
      name: json[r'name'] as String? ?? '',
      owner: json[r'owner'] != null
          ? User.fromJson(json[r'owner']! as Map<String, Object?>)
          : null,
      searchUrl: json[r'searchUrl'] as String?,
      self: json[r'self'] as String?,
      sharePermissions: (json[r'sharePermissions'] as List<Object?>?)
              ?.map((i) => SharePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      sharedUsers: json[r'sharedUsers'] != null
          ? UserList.fromJson(json[r'sharedUsers']! as Map<String, Object?>)
          : null,
      subscriptions: json[r'subscriptions'] != null
          ? FilterSubscriptionsList.fromJson(
              json[r'subscriptions']! as Map<String, Object?>)
          : null,
      viewUrl: json[r'viewUrl'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var editPermissions = this.editPermissions;
    var favourite = this.favourite;
    var favouritedCount = this.favouritedCount;
    var id = this.id;
    var jql = this.jql;
    var name = this.name;
    var owner = this.owner;
    var searchUrl = this.searchUrl;
    var self = this.self;
    var sharePermissions = this.sharePermissions;
    var sharedUsers = this.sharedUsers;
    var subscriptions = this.subscriptions;
    var viewUrl = this.viewUrl;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'editPermissions'] = editPermissions.map((i) => i.toJson()).toList();
    json[r'favourite'] = favourite;
    if (favouritedCount != null) {
      json[r'favouritedCount'] = favouritedCount;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (jql != null) {
      json[r'jql'] = jql;
    }
    json[r'name'] = name;
    if (owner != null) {
      json[r'owner'] = owner.toJson();
    }
    if (searchUrl != null) {
      json[r'searchUrl'] = searchUrl;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'sharePermissions'] =
        sharePermissions.map((i) => i.toJson()).toList();
    if (sharedUsers != null) {
      json[r'sharedUsers'] = sharedUsers.toJson();
    }
    if (subscriptions != null) {
      json[r'subscriptions'] = subscriptions.toJson();
    }
    if (viewUrl != null) {
      json[r'viewUrl'] = viewUrl;
    }
    return json;
  }

  Filter copyWith(
      {String? description,
      List<SharePermission>? editPermissions,
      bool? favourite,
      int? favouritedCount,
      String? id,
      String? jql,
      String? name,
      User? owner,
      String? searchUrl,
      String? self,
      List<SharePermission>? sharePermissions,
      UserList? sharedUsers,
      FilterSubscriptionsList? subscriptions,
      String? viewUrl}) {
    return Filter(
      description: description ?? this.description,
      editPermissions: editPermissions ?? this.editPermissions,
      favourite: favourite ?? this.favourite,
      favouritedCount: favouritedCount ?? this.favouritedCount,
      id: id ?? this.id,
      jql: jql ?? this.jql,
      name: name ?? this.name,
      owner: owner ?? this.owner,
      searchUrl: searchUrl ?? this.searchUrl,
      self: self ?? this.self,
      sharePermissions: sharePermissions ?? this.sharePermissions,
      sharedUsers: sharedUsers ?? this.sharedUsers,
      subscriptions: subscriptions ?? this.subscriptions,
      viewUrl: viewUrl ?? this.viewUrl,
    );
  }
}

/// Details of a filter.
class FilterDetails {
  /// The description of the filter.
  final String? description;

  /// The groups and projects that can edit the filter. This can be specified
  /// when updating a filter, but not when creating a filter.
  final List<SharePermission> editPermissions;

  /// Expand options that include additional filter details in the response.
  final String? expand;

  /// Whether the filter is selected as a favorite by any users, not including
  /// the filter owner.
  final bool favourite;

  /// The count of how many users have selected this filter as a favorite,
  /// including the filter owner.
  final int? favouritedCount;

  /// The unique identifier for the filter.
  final String? id;

  /// The JQL query for the filter. For example, *project = SSP AND issuetype =
  /// Bug*.
  final String? jql;

  /// The name of the filter.
  final String name;

  /// The user who owns the filter. Defaults to the creator of the filter,
  /// however, Jira administrators can change the owner of a shared filter in
  /// the admin settings.
  final User? owner;

  /// A URL to view the filter results in Jira, using the
  /// [Search for issues using JQL](#api-rest-api-3-filter-search-get) operation
  /// with the filter's JQL string to return the filter results. For example,
  /// *https://your-domain.atlassian.net/rest/api/3/search?jql=project+%3D+SSP+AND+issuetype+%3D+Bug*.
  final String? searchUrl;

  /// The URL of the filter.
  final String? self;

  /// The groups and projects that the filter is shared with. This can be
  /// specified when updating a filter, but not when creating a filter.
  final List<SharePermission> sharePermissions;

  /// The users that are subscribed to the filter.
  final List<FilterSubscription> subscriptions;

  /// A URL to view the filter results in Jira, using the ID of the filter. For
  /// example, *https://your-domain.atlassian.net/issues/?filter=10100*.
  final String? viewUrl;

  FilterDetails(
      {this.description,
      List<SharePermission>? editPermissions,
      this.expand,
      bool? favourite,
      this.favouritedCount,
      this.id,
      this.jql,
      required this.name,
      this.owner,
      this.searchUrl,
      this.self,
      List<SharePermission>? sharePermissions,
      List<FilterSubscription>? subscriptions,
      this.viewUrl})
      : editPermissions = editPermissions ?? [],
        favourite = favourite ?? false,
        sharePermissions = sharePermissions ?? [],
        subscriptions = subscriptions ?? [];

  factory FilterDetails.fromJson(Map<String, Object?> json) {
    return FilterDetails(
      description: json[r'description'] as String?,
      editPermissions: (json[r'editPermissions'] as List<Object?>?)
              ?.map((i) => SharePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      expand: json[r'expand'] as String?,
      favourite: json[r'favourite'] as bool? ?? false,
      favouritedCount: (json[r'favouritedCount'] as num?)?.toInt(),
      id: json[r'id'] as String?,
      jql: json[r'jql'] as String?,
      name: json[r'name'] as String? ?? '',
      owner: json[r'owner'] != null
          ? User.fromJson(json[r'owner']! as Map<String, Object?>)
          : null,
      searchUrl: json[r'searchUrl'] as String?,
      self: json[r'self'] as String?,
      sharePermissions: (json[r'sharePermissions'] as List<Object?>?)
              ?.map((i) => SharePermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      subscriptions: (json[r'subscriptions'] as List<Object?>?)
              ?.map((i) => FilterSubscription.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      viewUrl: json[r'viewUrl'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var editPermissions = this.editPermissions;
    var expand = this.expand;
    var favourite = this.favourite;
    var favouritedCount = this.favouritedCount;
    var id = this.id;
    var jql = this.jql;
    var name = this.name;
    var owner = this.owner;
    var searchUrl = this.searchUrl;
    var self = this.self;
    var sharePermissions = this.sharePermissions;
    var subscriptions = this.subscriptions;
    var viewUrl = this.viewUrl;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'editPermissions'] = editPermissions.map((i) => i.toJson()).toList();
    if (expand != null) {
      json[r'expand'] = expand;
    }
    json[r'favourite'] = favourite;
    if (favouritedCount != null) {
      json[r'favouritedCount'] = favouritedCount;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (jql != null) {
      json[r'jql'] = jql;
    }
    json[r'name'] = name;
    if (owner != null) {
      json[r'owner'] = owner.toJson();
    }
    if (searchUrl != null) {
      json[r'searchUrl'] = searchUrl;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'sharePermissions'] =
        sharePermissions.map((i) => i.toJson()).toList();
    json[r'subscriptions'] = subscriptions.map((i) => i.toJson()).toList();
    if (viewUrl != null) {
      json[r'viewUrl'] = viewUrl;
    }
    return json;
  }

  FilterDetails copyWith(
      {String? description,
      List<SharePermission>? editPermissions,
      String? expand,
      bool? favourite,
      int? favouritedCount,
      String? id,
      String? jql,
      String? name,
      User? owner,
      String? searchUrl,
      String? self,
      List<SharePermission>? sharePermissions,
      List<FilterSubscription>? subscriptions,
      String? viewUrl}) {
    return FilterDetails(
      description: description ?? this.description,
      editPermissions: editPermissions ?? this.editPermissions,
      expand: expand ?? this.expand,
      favourite: favourite ?? this.favourite,
      favouritedCount: favouritedCount ?? this.favouritedCount,
      id: id ?? this.id,
      jql: jql ?? this.jql,
      name: name ?? this.name,
      owner: owner ?? this.owner,
      searchUrl: searchUrl ?? this.searchUrl,
      self: self ?? this.self,
      sharePermissions: sharePermissions ?? this.sharePermissions,
      subscriptions: subscriptions ?? this.subscriptions,
      viewUrl: viewUrl ?? this.viewUrl,
    );
  }
}

/// Details of a user or group subscribing to a filter.
class FilterSubscription {
  /// The group subscribing to filter.
  final GroupName? group;

  /// The ID of the filter subscription.
  final int? id;

  /// The user subscribing to filter.
  final User? user;

  FilterSubscription({this.group, this.id, this.user});

  factory FilterSubscription.fromJson(Map<String, Object?> json) {
    return FilterSubscription(
      group: json[r'group'] != null
          ? GroupName.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
      id: (json[r'id'] as num?)?.toInt(),
      user: json[r'user'] != null
          ? User.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var group = this.group;
    var id = this.id;
    var user = this.user;

    final json = <String, Object?>{};
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  FilterSubscription copyWith({GroupName? group, int? id, User? user}) {
    return FilterSubscription(
      group: group ?? this.group,
      id: id ?? this.id,
      user: user ?? this.user,
    );
  }
}

/// A paginated list of subscriptions to a filter.
class FilterSubscriptionsList {
  /// The index of the last item returned on the page.
  final int? endIndex;

  /// The list of items.
  final List<FilterSubscription> items;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The number of items on the page.
  final int? size;

  /// The index of the first item returned on the page.
  final int? startIndex;

  FilterSubscriptionsList(
      {this.endIndex,
      List<FilterSubscription>? items,
      this.maxResults,
      this.size,
      this.startIndex})
      : items = items ?? [];

  factory FilterSubscriptionsList.fromJson(Map<String, Object?> json) {
    return FilterSubscriptionsList(
      endIndex: (json[r'end-index'] as num?)?.toInt(),
      items: (json[r'items'] as List<Object?>?)
              ?.map((i) => FilterSubscription.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'max-results'] as num?)?.toInt(),
      size: (json[r'size'] as num?)?.toInt(),
      startIndex: (json[r'start-index'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var endIndex = this.endIndex;
    var items = this.items;
    var maxResults = this.maxResults;
    var size = this.size;
    var startIndex = this.startIndex;

    final json = <String, Object?>{};
    if (endIndex != null) {
      json[r'end-index'] = endIndex;
    }
    json[r'items'] = items.map((i) => i.toJson()).toList();
    if (maxResults != null) {
      json[r'max-results'] = maxResults;
    }
    if (size != null) {
      json[r'size'] = size;
    }
    if (startIndex != null) {
      json[r'start-index'] = startIndex;
    }
    return json;
  }

  FilterSubscriptionsList copyWith(
      {int? endIndex,
      List<FilterSubscription>? items,
      int? maxResults,
      int? size,
      int? startIndex}) {
    return FilterSubscriptionsList(
      endIndex: endIndex ?? this.endIndex,
      items: items ?? this.items,
      maxResults: maxResults ?? this.maxResults,
      size: size ?? this.size,
      startIndex: startIndex ?? this.startIndex,
    );
  }
}

/// A group found in a search.
class FoundGroup {
  /// The ID of the group, which uniquely identifies the group across all
  /// Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.
  final String? groupId;

  /// The group name with the matched query string highlighted with the HTML
  /// bold tag.
  final String? html;
  final List<GroupLabel> labels;

  /// The name of the group. The name of a group is mutable, to reliably
  /// identify a group use ``groupId`.`
  final String? name;

  FoundGroup({this.groupId, this.html, List<GroupLabel>? labels, this.name})
      : labels = labels ?? [];

  factory FoundGroup.fromJson(Map<String, Object?> json) {
    return FoundGroup(
      groupId: json[r'groupId'] as String?,
      html: json[r'html'] as String?,
      labels: (json[r'labels'] as List<Object?>?)
              ?.map((i) =>
                  GroupLabel.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var groupId = this.groupId;
    var html = this.html;
    var labels = this.labels;
    var name = this.name;

    final json = <String, Object?>{};
    if (groupId != null) {
      json[r'groupId'] = groupId;
    }
    if (html != null) {
      json[r'html'] = html;
    }
    json[r'labels'] = labels.map((i) => i.toJson()).toList();
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  FoundGroup copyWith(
      {String? groupId, String? html, List<GroupLabel>? labels, String? name}) {
    return FoundGroup(
      groupId: groupId ?? this.groupId,
      html: html ?? this.html,
      labels: labels ?? this.labels,
      name: name ?? this.name,
    );
  }
}

/// The list of groups found in a search, including header text (Showing X of Y
/// matching groups) and total of matched groups.
class FoundGroups {
  final List<FoundGroup> groups;

  /// Header text indicating the number of groups in the response and the total
  /// number of groups found in the search.
  final String? header;

  /// The total number of groups found in the search.
  final int? total;

  FoundGroups({List<FoundGroup>? groups, this.header, this.total})
      : groups = groups ?? [];

  factory FoundGroups.fromJson(Map<String, Object?> json) {
    return FoundGroups(
      groups: (json[r'groups'] as List<Object?>?)
              ?.map((i) =>
                  FoundGroup.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      header: json[r'header'] as String?,
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var groups = this.groups;
    var header = this.header;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'groups'] = groups.map((i) => i.toJson()).toList();
    if (header != null) {
      json[r'header'] = header;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  FoundGroups copyWith({List<FoundGroup>? groups, String? header, int? total}) {
    return FoundGroups(
      groups: groups ?? this.groups,
      header: header ?? this.header,
      total: total ?? this.total,
    );
  }
}

/// The list of users found in a search, including header text (Showing X of Y
/// matching users) and total of matched users.
class FoundUsers {
  /// Header text indicating the number of users in the response and the total
  /// number of users found in the search.
  final String? header;

  /// The total number of users found in the search.
  final int? total;
  final List<UserPickerUser> users;

  FoundUsers({this.header, this.total, List<UserPickerUser>? users})
      : users = users ?? [];

  factory FoundUsers.fromJson(Map<String, Object?> json) {
    return FoundUsers(
      header: json[r'header'] as String?,
      total: (json[r'total'] as num?)?.toInt(),
      users: (json[r'users'] as List<Object?>?)
              ?.map((i) => UserPickerUser.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var header = this.header;
    var total = this.total;
    var users = this.users;

    final json = <String, Object?>{};
    if (header != null) {
      json[r'header'] = header;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'users'] = users.map((i) => i.toJson()).toList();
    return json;
  }

  FoundUsers copyWith(
      {String? header, int? total, List<UserPickerUser>? users}) {
    return FoundUsers(
      header: header ?? this.header,
      total: total ?? this.total,
      users: users ?? this.users,
    );
  }
}

/// List of users and groups found in a search.
class FoundUsersAndGroups {
  final FoundGroups? groups;
  final FoundUsers? users;

  FoundUsersAndGroups({this.groups, this.users});

  factory FoundUsersAndGroups.fromJson(Map<String, Object?> json) {
    return FoundUsersAndGroups(
      groups: json[r'groups'] != null
          ? FoundGroups.fromJson(json[r'groups']! as Map<String, Object?>)
          : null,
      users: json[r'users'] != null
          ? FoundUsers.fromJson(json[r'users']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var groups = this.groups;
    var users = this.users;

    final json = <String, Object?>{};
    if (groups != null) {
      json[r'groups'] = groups.toJson();
    }
    if (users != null) {
      json[r'users'] = users.toJson();
    }
    return json;
  }

  FoundUsersAndGroups copyWith({FoundGroups? groups, FoundUsers? users}) {
    return FoundUsersAndGroups(
      groups: groups ?? this.groups,
      users: users ?? this.users,
    );
  }
}

/// An operand that is a function. See
/// [Advanced searching - functions reference](https://confluence.atlassian.com/x/dwiiLQ)
/// for more information about JQL functions.
class FunctionOperand {
  /// The list of function arguments.
  final List<String> arguments;

  /// Encoded operand, which can be used directly in a JQL query.
  final String? encodedOperand;

  /// The name of the function.
  final String function;

  FunctionOperand(
      {required this.arguments, this.encodedOperand, required this.function});

  factory FunctionOperand.fromJson(Map<String, Object?> json) {
    return FunctionOperand(
      arguments: (json[r'arguments'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      encodedOperand: json[r'encodedOperand'] as String?,
      function: json[r'function'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var arguments = this.arguments;
    var encodedOperand = this.encodedOperand;
    var function = this.function;

    final json = <String, Object?>{};
    json[r'arguments'] = arguments;
    if (encodedOperand != null) {
      json[r'encodedOperand'] = encodedOperand;
    }
    json[r'function'] = function;
    return json;
  }

  FunctionOperand copyWith(
      {List<String>? arguments, String? encodedOperand, String? function}) {
    return FunctionOperand(
      arguments: arguments ?? this.arguments,
      encodedOperand: encodedOperand ?? this.encodedOperand,
      function: function ?? this.function,
    );
  }
}

/// Details of functions that can be used in advanced searches.
class FunctionReferenceData {
  /// The display name of the function.
  final String? displayName;

  /// Whether the function can take a list of arguments.
  final FunctionReferenceDataIsList? isList;

  /// The data types returned by the function.
  final List<String> types;

  /// The function identifier.
  final String? value;

  FunctionReferenceData(
      {this.displayName, this.isList, List<String>? types, this.value})
      : types = types ?? [];

  factory FunctionReferenceData.fromJson(Map<String, Object?> json) {
    return FunctionReferenceData(
      displayName: json[r'displayName'] as String?,
      isList: json[r'isList'] != null
          ? FunctionReferenceDataIsList.fromValue(json[r'isList']! as String)
          : null,
      types: (json[r'types'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var displayName = this.displayName;
    var isList = this.isList;
    var types = this.types;
    var value = this.value;

    final json = <String, Object?>{};
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (isList != null) {
      json[r'isList'] = isList.value;
    }
    json[r'types'] = types;
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  FunctionReferenceData copyWith(
      {String? displayName,
      FunctionReferenceDataIsList? isList,
      List<String>? types,
      String? value}) {
    return FunctionReferenceData(
      displayName: displayName ?? this.displayName,
      isList: isList ?? this.isList,
      types: types ?? this.types,
      value: value ?? this.value,
    );
  }
}

class FunctionReferenceDataIsList {
  static const true$ = FunctionReferenceDataIsList._('true');
  static const false$ = FunctionReferenceDataIsList._('false');

  static const values = [
    true$,
    false$,
  ];
  final String value;

  const FunctionReferenceDataIsList._(this.value);

  static FunctionReferenceDataIsList fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => FunctionReferenceDataIsList._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class GlobalScopeBean {
  /// Defines the behavior of the option in the global context.If notSelectable
  /// is set, the option cannot be set as the field's value. This is useful for
  /// archiving an option that has previously been selected but shouldn't be
  /// used anymore.If defaultValue is set, the option is selected by default.
  final List<GlobalScopeBeanAttributes> attributes;

  GlobalScopeBean({List<GlobalScopeBeanAttributes>? attributes})
      : attributes = attributes ?? [];

  factory GlobalScopeBean.fromJson(Map<String, Object?> json) {
    return GlobalScopeBean(
      attributes: (json[r'attributes'] as List<Object?>?)
              ?.map((i) =>
                  GlobalScopeBeanAttributes.fromValue(i as String? ?? ''))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var attributes = this.attributes;

    final json = <String, Object?>{};
    json[r'attributes'] = attributes.map((i) => i.value).toList();
    return json;
  }

  GlobalScopeBean copyWith({List<GlobalScopeBeanAttributes>? attributes}) {
    return GlobalScopeBean(
      attributes: attributes ?? this.attributes,
    );
  }
}

class GlobalScopeBeanAttributes {
  static const notSelectable = GlobalScopeBeanAttributes._('notSelectable');
  static const defaultValue = GlobalScopeBeanAttributes._('defaultValue');

  static const values = [
    notSelectable,
    defaultValue,
  ];
  final String value;

  const GlobalScopeBeanAttributes._(this.value);

  static GlobalScopeBeanAttributes fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => GlobalScopeBeanAttributes._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class Group {
  /// Expand options that include additional group details in the response.
  final String? expand;

  /// The ID of the group, which uniquely identifies the group across all
  /// Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.
  final String? groupId;

  /// The name of group.
  final String? name;

  /// The URL for these group details.
  final String? self;

  /// A paginated list of the users that are members of the group. A maximum of
  /// 50 users is returned in the list, to access additional users append
  /// `[start-index:end-index]` to the expand request. For example, to access
  /// the next 50 users, use`?expand=users[51:100]`.
  final PagedListUserDetailsApplicationUser? users;

  Group({this.expand, this.groupId, this.name, this.self, this.users});

  factory Group.fromJson(Map<String, Object?> json) {
    return Group(
      expand: json[r'expand'] as String?,
      groupId: json[r'groupId'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
      users: json[r'users'] != null
          ? PagedListUserDetailsApplicationUser.fromJson(
              json[r'users']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var groupId = this.groupId;
    var name = this.name;
    var self = this.self;
    var users = this.users;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (groupId != null) {
      json[r'groupId'] = groupId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (users != null) {
      json[r'users'] = users.toJson();
    }
    return json;
  }

  Group copyWith(
      {String? expand,
      String? groupId,
      String? name,
      String? self,
      PagedListUserDetailsApplicationUser? users}) {
    return Group(
      expand: expand ?? this.expand,
      groupId: groupId ?? this.groupId,
      name: name ?? this.name,
      self: self ?? this.self,
      users: users ?? this.users,
    );
  }
}

/// Details about a group.
class GroupDetails {
  /// The ID of the group, which uniquely identifies the group across all
  /// Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.
  final String? groupId;

  /// The name of the group.
  final String? name;

  GroupDetails({this.groupId, this.name});

  factory GroupDetails.fromJson(Map<String, Object?> json) {
    return GroupDetails(
      groupId: json[r'groupId'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var groupId = this.groupId;
    var name = this.name;

    final json = <String, Object?>{};
    if (groupId != null) {
      json[r'groupId'] = groupId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  GroupDetails copyWith({String? groupId, String? name}) {
    return GroupDetails(
      groupId: groupId ?? this.groupId,
      name: name ?? this.name,
    );
  }
}

/// A group label.
class GroupLabel {
  /// The group label name.
  final String? text;

  /// The title of the group label.
  final String? title;

  /// The type of the group label.
  final GroupLabelType? type;

  GroupLabel({this.text, this.title, this.type});

  factory GroupLabel.fromJson(Map<String, Object?> json) {
    return GroupLabel(
      text: json[r'text'] as String?,
      title: json[r'title'] as String?,
      type: json[r'type'] != null
          ? GroupLabelType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var text = this.text;
    var title = this.title;
    var type = this.type;

    final json = <String, Object?>{};
    if (text != null) {
      json[r'text'] = text;
    }
    if (title != null) {
      json[r'title'] = title;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  GroupLabel copyWith({String? text, String? title, GroupLabelType? type}) {
    return GroupLabel(
      text: text ?? this.text,
      title: title ?? this.title,
      type: type ?? this.type,
    );
  }
}

class GroupLabelType {
  static const admin = GroupLabelType._('ADMIN');
  static const single = GroupLabelType._('SINGLE');
  static const multiple = GroupLabelType._('MULTIPLE');

  static const values = [
    admin,
    single,
    multiple,
  ];
  final String value;

  const GroupLabelType._(this.value);

  static GroupLabelType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => GroupLabelType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about a group.
class GroupName {
  /// The ID of the group, which uniquely identifies the group across all
  /// Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.
  final String? groupId;

  /// The name of group.
  final String? name;

  /// The URL for these group details.
  final String? self;

  GroupName({this.groupId, this.name, this.self});

  factory GroupName.fromJson(Map<String, Object?> json) {
    return GroupName(
      groupId: json[r'groupId'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var groupId = this.groupId;
    var name = this.name;
    var self = this.self;

    final json = <String, Object?>{};
    if (groupId != null) {
      json[r'groupId'] = groupId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  GroupName copyWith({String? groupId, String? name, String? self}) {
    return GroupName(
      groupId: groupId ?? this.groupId,
      name: name ?? this.name,
      self: self ?? this.self,
    );
  }
}

/// Jira instance health check results. Deprecated and no longer returned.
class HealthCheckResult {
  /// The description of the Jira health check item.
  final String? description;

  /// The name of the Jira health check item.
  final String? name;

  /// Whether the Jira health check item passed or failed.
  final bool passed;

  HealthCheckResult({this.description, this.name, bool? passed})
      : passed = passed ?? false;

  factory HealthCheckResult.fromJson(Map<String, Object?> json) {
    return HealthCheckResult(
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
      passed: json[r'passed'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;
    var passed = this.passed;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'passed'] = passed;
    return json;
  }

  HealthCheckResult copyWith(
      {String? description, String? name, bool? passed}) {
    return HealthCheckResult(
      description: description ?? this.description,
      name: name ?? this.name,
      passed: passed ?? this.passed,
    );
  }
}

/// The project issue type hierarchy.
class Hierarchy {
  /// The ID of the base level. This property is deprecated, see
  /// [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final int? baseLevelId;

  /// Details about the hierarchy level.
  final List<SimplifiedHierarchyLevel> levels;

  Hierarchy({this.baseLevelId, List<SimplifiedHierarchyLevel>? levels})
      : levels = levels ?? [];

  factory Hierarchy.fromJson(Map<String, Object?> json) {
    return Hierarchy(
      baseLevelId: (json[r'baseLevelId'] as num?)?.toInt(),
      levels: (json[r'levels'] as List<Object?>?)
              ?.map((i) => SimplifiedHierarchyLevel.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var baseLevelId = this.baseLevelId;
    var levels = this.levels;

    final json = <String, Object?>{};
    if (baseLevelId != null) {
      json[r'baseLevelId'] = baseLevelId;
    }
    json[r'levels'] = levels.map((i) => i.toJson()).toList();
    return json;
  }

  Hierarchy copyWith(
      {int? baseLevelId, List<SimplifiedHierarchyLevel>? levels}) {
    return Hierarchy(
      baseLevelId: baseLevelId ?? this.baseLevelId,
      levels: levels ?? this.levels,
    );
  }
}

/// Details of issue history metadata.
class HistoryMetadata {
  /// The activity described in the history record.
  final String? activityDescription;

  /// The key of the activity described in the history record.
  final String? activityDescriptionKey;

  /// Details of the user whose action created the history record.
  final HistoryMetadataParticipant? actor;

  /// Details of the cause that triggered the creation the history record.
  final HistoryMetadataParticipant? cause;

  /// The description of the history record.
  final String? description;

  /// The description key of the history record.
  final String? descriptionKey;

  /// The description of the email address associated the history record.
  final String? emailDescription;

  /// The description key of the email address associated the history record.
  final String? emailDescriptionKey;

  /// Additional arbitrary information about the history record.
  final Map<String, dynamic>? extraData;

  /// Details of the system that generated the history record.
  final HistoryMetadataParticipant? generator;

  /// The type of the history record.
  final String? type;

  HistoryMetadata(
      {this.activityDescription,
      this.activityDescriptionKey,
      this.actor,
      this.cause,
      this.description,
      this.descriptionKey,
      this.emailDescription,
      this.emailDescriptionKey,
      this.extraData,
      this.generator,
      this.type});

  factory HistoryMetadata.fromJson(Map<String, Object?> json) {
    return HistoryMetadata(
      activityDescription: json[r'activityDescription'] as String?,
      activityDescriptionKey: json[r'activityDescriptionKey'] as String?,
      actor: json[r'actor'] != null
          ? HistoryMetadataParticipant.fromJson(
              json[r'actor']! as Map<String, Object?>)
          : null,
      cause: json[r'cause'] != null
          ? HistoryMetadataParticipant.fromJson(
              json[r'cause']! as Map<String, Object?>)
          : null,
      description: json[r'description'] as String?,
      descriptionKey: json[r'descriptionKey'] as String?,
      emailDescription: json[r'emailDescription'] as String?,
      emailDescriptionKey: json[r'emailDescriptionKey'] as String?,
      extraData: json[r'extraData'] as Map<String, Object?>?,
      generator: json[r'generator'] != null
          ? HistoryMetadataParticipant.fromJson(
              json[r'generator']! as Map<String, Object?>)
          : null,
      type: json[r'type'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var activityDescription = this.activityDescription;
    var activityDescriptionKey = this.activityDescriptionKey;
    var actor = this.actor;
    var cause = this.cause;
    var description = this.description;
    var descriptionKey = this.descriptionKey;
    var emailDescription = this.emailDescription;
    var emailDescriptionKey = this.emailDescriptionKey;
    var extraData = this.extraData;
    var generator = this.generator;
    var type = this.type;

    final json = <String, Object?>{};
    if (activityDescription != null) {
      json[r'activityDescription'] = activityDescription;
    }
    if (activityDescriptionKey != null) {
      json[r'activityDescriptionKey'] = activityDescriptionKey;
    }
    if (actor != null) {
      json[r'actor'] = actor.toJson();
    }
    if (cause != null) {
      json[r'cause'] = cause.toJson();
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (descriptionKey != null) {
      json[r'descriptionKey'] = descriptionKey;
    }
    if (emailDescription != null) {
      json[r'emailDescription'] = emailDescription;
    }
    if (emailDescriptionKey != null) {
      json[r'emailDescriptionKey'] = emailDescriptionKey;
    }
    if (extraData != null) {
      json[r'extraData'] = extraData;
    }
    if (generator != null) {
      json[r'generator'] = generator.toJson();
    }
    if (type != null) {
      json[r'type'] = type;
    }
    return json;
  }

  HistoryMetadata copyWith(
      {String? activityDescription,
      String? activityDescriptionKey,
      HistoryMetadataParticipant? actor,
      HistoryMetadataParticipant? cause,
      String? description,
      String? descriptionKey,
      String? emailDescription,
      String? emailDescriptionKey,
      Map<String, dynamic>? extraData,
      HistoryMetadataParticipant? generator,
      String? type}) {
    return HistoryMetadata(
      activityDescription: activityDescription ?? this.activityDescription,
      activityDescriptionKey:
          activityDescriptionKey ?? this.activityDescriptionKey,
      actor: actor ?? this.actor,
      cause: cause ?? this.cause,
      description: description ?? this.description,
      descriptionKey: descriptionKey ?? this.descriptionKey,
      emailDescription: emailDescription ?? this.emailDescription,
      emailDescriptionKey: emailDescriptionKey ?? this.emailDescriptionKey,
      extraData: extraData ?? this.extraData,
      generator: generator ?? this.generator,
      type: type ?? this.type,
    );
  }
}

/// Details of user or system associated with a issue history metadata item.
class HistoryMetadataParticipant {
  /// The URL to an avatar for the user or system associated with a history
  /// record.
  final String? avatarUrl;

  /// The display name of the user or system associated with a history record.
  final String? displayName;

  /// The key of the display name of the user or system associated with a
  /// history record.
  final String? displayNameKey;

  /// The ID of the user or system associated with a history record.
  final String? id;

  /// The type of the user or system associated with a history record.
  final String? type;

  /// The URL of the user or system associated with a history record.
  final String? url;

  HistoryMetadataParticipant(
      {this.avatarUrl,
      this.displayName,
      this.displayNameKey,
      this.id,
      this.type,
      this.url});

  factory HistoryMetadataParticipant.fromJson(Map<String, Object?> json) {
    return HistoryMetadataParticipant(
      avatarUrl: json[r'avatarUrl'] as String?,
      displayName: json[r'displayName'] as String?,
      displayNameKey: json[r'displayNameKey'] as String?,
      id: json[r'id'] as String?,
      type: json[r'type'] as String?,
      url: json[r'url'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var avatarUrl = this.avatarUrl;
    var displayName = this.displayName;
    var displayNameKey = this.displayNameKey;
    var id = this.id;
    var type = this.type;
    var url = this.url;

    final json = <String, Object?>{};
    if (avatarUrl != null) {
      json[r'avatarUrl'] = avatarUrl;
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (displayNameKey != null) {
      json[r'displayNameKey'] = displayNameKey;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (type != null) {
      json[r'type'] = type;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    return json;
  }

  HistoryMetadataParticipant copyWith(
      {String? avatarUrl,
      String? displayName,
      String? displayNameKey,
      String? id,
      String? type,
      String? url}) {
    return HistoryMetadataParticipant(
      avatarUrl: avatarUrl ?? this.avatarUrl,
      displayName: displayName ?? this.displayName,
      displayNameKey: displayNameKey ?? this.displayNameKey,
      id: id ?? this.id,
      type: type ?? this.type,
      url: url ?? this.url,
    );
  }
}

/// An icon. If no icon is defined:
///
///  *  for a status icon, no status icon displays in Jira.
///  *  for the remote object icon, the default link icon displays in Jira.
class Icon {
  /// The URL of the tooltip, used only for a status icon. If not set, the
  /// status icon in Jira is not clickable.
  final String? link;

  /// The title of the icon. This is used as follows:
  ///
  ///  *  For a status icon it is used as a tooltip on the icon. If not set, the
  /// status icon doesn't display a tooltip in Jira.
  ///  *  For the remote object icon it is used in conjunction with the
  /// application name to display a tooltip for the link's icon. The tooltip
  /// takes the format "[application name] icon title". Blank itemsare excluded
  /// from the tooltip title. If both items are blank, the icon tooltop displays
  /// as "Web Link".
  final String? title;

  /// The URL of an icon that displays at 16x16 pixel in Jira.
  final String? url16X16;

  Icon({this.link, this.title, this.url16X16});

  factory Icon.fromJson(Map<String, Object?> json) {
    return Icon(
      link: json[r'link'] as String?,
      title: json[r'title'] as String?,
      url16X16: json[r'url16x16'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var link = this.link;
    var title = this.title;
    var url16X16 = this.url16X16;

    final json = <String, Object?>{};
    if (link != null) {
      json[r'link'] = link;
    }
    if (title != null) {
      json[r'title'] = title;
    }
    if (url16X16 != null) {
      json[r'url16x16'] = url16X16;
    }
    return json;
  }

  Icon copyWith({String? link, String? title, String? url16X16}) {
    return Icon(
      link: link ?? this.link,
      title: title ?? this.title,
      url16X16: url16X16 ?? this.url16X16,
    );
  }
}

/// An icon.
class IconBean {
  /// The URL of the tooltip, used only for a status icon.
  final String? link;

  /// The title of the icon, for use as a tooltip on the icon.
  final String? title;

  /// The URL of a 16x16 pixel icon.
  final String? url16X16;

  IconBean({this.link, this.title, this.url16X16});

  factory IconBean.fromJson(Map<String, Object?> json) {
    return IconBean(
      link: json[r'link'] as String?,
      title: json[r'title'] as String?,
      url16X16: json[r'url16x16'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var link = this.link;
    var title = this.title;
    var url16X16 = this.url16X16;

    final json = <String, Object?>{};
    if (link != null) {
      json[r'link'] = link;
    }
    if (title != null) {
      json[r'title'] = title;
    }
    if (url16X16 != null) {
      json[r'url16x16'] = url16X16;
    }
    return json;
  }

  IconBean copyWith({String? link, String? title, String? url16X16}) {
    return IconBean(
      link: link ?? this.link,
      title: title ?? this.title,
      url16X16: url16X16 ?? this.url16X16,
    );
  }
}

class IdBean {
  /// The ID of the permission scheme to associate with the project. Use the
  /// [Get all permission schemes](#api-rest-api-3-permissionscheme-get)
  /// resource to get a list of permission scheme IDs.
  final int id;

  IdBean({required this.id});

  factory IdBean.fromJson(Map<String, Object?> json) {
    return IdBean(
      id: (json[r'id'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  IdBean copyWith({int? id}) {
    return IdBean(
      id: id ?? this.id,
    );
  }
}

class IdOrKeyBean {
  /// The ID of the referenced item.
  final int? id;

  /// The key of the referenced item.
  final String? key;

  IdOrKeyBean({this.id, this.key});

  factory IdOrKeyBean.fromJson(Map<String, Object?> json) {
    return IdOrKeyBean(
      id: (json[r'id'] as num?)?.toInt(),
      key: json[r'key'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    return json;
  }

  IdOrKeyBean copyWith({int? id, String? key}) {
    return IdOrKeyBean(
      id: id ?? this.id,
      key: key ?? this.key,
    );
  }
}

class IncludedFields {
  final List<String> actuallyIncluded;
  final List<String> excluded;
  final List<String> included;

  IncludedFields(
      {List<String>? actuallyIncluded,
      List<String>? excluded,
      List<String>? included})
      : actuallyIncluded = actuallyIncluded ?? [],
        excluded = excluded ?? [],
        included = included ?? [];

  factory IncludedFields.fromJson(Map<String, Object?> json) {
    return IncludedFields(
      actuallyIncluded: (json[r'actuallyIncluded'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      excluded: (json[r'excluded'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      included: (json[r'included'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var actuallyIncluded = this.actuallyIncluded;
    var excluded = this.excluded;
    var included = this.included;

    final json = <String, Object?>{};
    json[r'actuallyIncluded'] = actuallyIncluded;
    json[r'excluded'] = excluded;
    json[r'included'] = included;
    return json;
  }

  IncludedFields copyWith(
      {List<String>? actuallyIncluded,
      List<String>? excluded,
      List<String>? included}) {
    return IncludedFields(
      actuallyIncluded: actuallyIncluded ?? this.actuallyIncluded,
      excluded: excluded ?? this.excluded,
      included: included ?? this.included,
    );
  }
}

/// Details about an issue.
class IssueBean {
  /// Details of changelogs associated with the issue.
  final PageOfChangelogs? changelog;

  /// The metadata for the fields on the issue that can be amended.
  final IssueUpdateMetadata? editmeta;

  /// Expand options that include additional issue details in the response.
  final String? expand;
  final Map<String, dynamic>? fields;
  final IncludedFields? fieldsToInclude;

  /// The ID of the issue.
  final String? id;

  /// The key of the issue.
  final String? key;

  /// The ID and name of each field present on the issue.
  final Map<String, dynamic>? names;

  /// The operations that can be performed on the issue.
  final Operations? operations;

  /// Details of the issue properties identified in the request.
  final Map<String, dynamic>? properties;

  /// The rendered value of each field present on the issue.
  final Map<String, dynamic>? renderedFields;

  /// The schema describing each field present on the issue.
  final Map<String, dynamic>? schema;

  /// The URL of the issue details.
  final String? self;

  /// The transitions that can be performed on the issue.
  final List<IssueTransition> transitions;

  /// The versions of each field on the issue.
  final Map<String, dynamic>? versionedRepresentations;

  IssueBean(
      {this.changelog,
      this.editmeta,
      this.expand,
      this.fields,
      this.fieldsToInclude,
      this.id,
      this.key,
      this.names,
      this.operations,
      this.properties,
      this.renderedFields,
      this.schema,
      this.self,
      List<IssueTransition>? transitions,
      this.versionedRepresentations})
      : transitions = transitions ?? [];

  factory IssueBean.fromJson(Map<String, Object?> json) {
    return IssueBean(
      changelog: json[r'changelog'] != null
          ? PageOfChangelogs.fromJson(
              json[r'changelog']! as Map<String, Object?>)
          : null,
      editmeta: json[r'editmeta'] != null
          ? IssueUpdateMetadata.fromJson(
              json[r'editmeta']! as Map<String, Object?>)
          : null,
      expand: json[r'expand'] as String?,
      fields: json[r'fields'] as Map<String, Object?>?,
      fieldsToInclude: json[r'fieldsToInclude'] != null
          ? IncludedFields.fromJson(
              json[r'fieldsToInclude']! as Map<String, Object?>)
          : null,
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      names: json[r'names'] as Map<String, Object?>?,
      operations: json[r'operations'] != null
          ? Operations.fromJson(json[r'operations']! as Map<String, Object?>)
          : null,
      properties: json[r'properties'] as Map<String, Object?>?,
      renderedFields: json[r'renderedFields'] as Map<String, Object?>?,
      schema: json[r'schema'] as Map<String, Object?>?,
      self: json[r'self'] as String?,
      transitions: (json[r'transitions'] as List<Object?>?)
              ?.map((i) => IssueTransition.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      versionedRepresentations:
          json[r'versionedRepresentations'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var changelog = this.changelog;
    var editmeta = this.editmeta;
    var expand = this.expand;
    var fields = this.fields;
    var fieldsToInclude = this.fieldsToInclude;
    var id = this.id;
    var key = this.key;
    var names = this.names;
    var operations = this.operations;
    var properties = this.properties;
    var renderedFields = this.renderedFields;
    var schema = this.schema;
    var self = this.self;
    var transitions = this.transitions;
    var versionedRepresentations = this.versionedRepresentations;

    final json = <String, Object?>{};
    if (changelog != null) {
      json[r'changelog'] = changelog.toJson();
    }
    if (editmeta != null) {
      json[r'editmeta'] = editmeta.toJson();
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (fields != null) {
      json[r'fields'] = fields;
    }
    if (fieldsToInclude != null) {
      json[r'fieldsToInclude'] = fieldsToInclude.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (names != null) {
      json[r'names'] = names;
    }
    if (operations != null) {
      json[r'operations'] = operations.toJson();
    }
    if (properties != null) {
      json[r'properties'] = properties;
    }
    if (renderedFields != null) {
      json[r'renderedFields'] = renderedFields;
    }
    if (schema != null) {
      json[r'schema'] = schema;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'transitions'] = transitions.map((i) => i.toJson()).toList();
    if (versionedRepresentations != null) {
      json[r'versionedRepresentations'] = versionedRepresentations;
    }
    return json;
  }

  IssueBean copyWith(
      {PageOfChangelogs? changelog,
      IssueUpdateMetadata? editmeta,
      String? expand,
      Map<String, dynamic>? fields,
      IncludedFields? fieldsToInclude,
      String? id,
      String? key,
      Map<String, dynamic>? names,
      Operations? operations,
      Map<String, dynamic>? properties,
      Map<String, dynamic>? renderedFields,
      Map<String, dynamic>? schema,
      String? self,
      List<IssueTransition>? transitions,
      Map<String, dynamic>? versionedRepresentations}) {
    return IssueBean(
      changelog: changelog ?? this.changelog,
      editmeta: editmeta ?? this.editmeta,
      expand: expand ?? this.expand,
      fields: fields ?? this.fields,
      fieldsToInclude: fieldsToInclude ?? this.fieldsToInclude,
      id: id ?? this.id,
      key: key ?? this.key,
      names: names ?? this.names,
      operations: operations ?? this.operations,
      properties: properties ?? this.properties,
      renderedFields: renderedFields ?? this.renderedFields,
      schema: schema ?? this.schema,
      self: self ?? this.self,
      transitions: transitions ?? this.transitions,
      versionedRepresentations:
          versionedRepresentations ?? this.versionedRepresentations,
    );
  }
}

/// A list of changelog IDs.
class IssueChangelogIds {
  /// The list of changelog IDs.
  final List<int> changelogIds;

  IssueChangelogIds({required this.changelogIds});

  factory IssueChangelogIds.fromJson(Map<String, Object?> json) {
    return IssueChangelogIds(
      changelogIds: (json[r'changelogIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var changelogIds = this.changelogIds;

    final json = <String, Object?>{};
    json[r'changelogIds'] = changelogIds;
    return json;
  }

  IssueChangelogIds copyWith({List<int>? changelogIds}) {
    return IssueChangelogIds(
      changelogIds: changelogIds ?? this.changelogIds,
    );
  }
}

class IssueCommentListRequestBean {
  /// The list of comment IDs. A maximum of 1000 IDs can be specified.
  final List<int> ids;

  IssueCommentListRequestBean({required this.ids});

  factory IssueCommentListRequestBean.fromJson(Map<String, Object?> json) {
    return IssueCommentListRequestBean(
      ids: (json[r'ids'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var ids = this.ids;

    final json = <String, Object?>{};
    json[r'ids'] = ids;
    return json;
  }

  IssueCommentListRequestBean copyWith({List<int>? ids}) {
    return IssueCommentListRequestBean(
      ids: ids ?? this.ids,
    );
  }
}

/// An
/// [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue)
/// specified by ID or key. All the fields of the issue object are available in
/// the Jira expression.
class IssueContextVariable {
  /// The issue ID.
  final int? id;

  /// The issue key.
  final String? key;

  /// Type of custom context variable.
  final String type;

  IssueContextVariable({this.id, this.key, required this.type});

  factory IssueContextVariable.fromJson(Map<String, Object?> json) {
    return IssueContextVariable(
      id: (json[r'id'] as num?)?.toInt(),
      key: json[r'key'] as String?,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;
    var type = this.type;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    json[r'type'] = type;
    return json;
  }

  IssueContextVariable copyWith({int? id, String? key, String? type}) {
    return IssueContextVariable(
      id: id ?? this.id,
      key: key ?? this.key,
      type: type ?? this.type,
    );
  }
}

/// The wrapper for the issue creation metadata for a list of projects.
class IssueCreateMetadata {
  /// Expand options that include additional project details in the response.
  final String? expand;

  /// List of projects and their issue creation metadata.
  final List<ProjectIssueCreateMetadata> projects;

  IssueCreateMetadata({this.expand, List<ProjectIssueCreateMetadata>? projects})
      : projects = projects ?? [];

  factory IssueCreateMetadata.fromJson(Map<String, Object?> json) {
    return IssueCreateMetadata(
      expand: json[r'expand'] as String?,
      projects: (json[r'projects'] as List<Object?>?)
              ?.map((i) => ProjectIssueCreateMetadata.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var projects = this.projects;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    json[r'projects'] = projects.map((i) => i.toJson()).toList();
    return json;
  }

  IssueCreateMetadata copyWith(
      {String? expand, List<ProjectIssueCreateMetadata>? projects}) {
    return IssueCreateMetadata(
      expand: expand ?? this.expand,
      projects: projects ?? this.projects,
    );
  }
}

/// Lists of issues and entity properties. See
/// [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/)
/// for more information.
class IssueEntityProperties {
  /// A list of entity property IDs.
  final List<int> entitiesIds;

  /// A list of entity property keys and values.
  final Map<String, dynamic>? properties;

  IssueEntityProperties({List<int>? entitiesIds, this.properties})
      : entitiesIds = entitiesIds ?? [];

  factory IssueEntityProperties.fromJson(Map<String, Object?> json) {
    return IssueEntityProperties(
      entitiesIds: (json[r'entitiesIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      properties: json[r'properties'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var entitiesIds = this.entitiesIds;
    var properties = this.properties;

    final json = <String, Object?>{};
    json[r'entitiesIds'] = entitiesIds;
    if (properties != null) {
      json[r'properties'] = properties;
    }
    return json;
  }

  IssueEntityProperties copyWith(
      {List<int>? entitiesIds, Map<String, dynamic>? properties}) {
    return IssueEntityProperties(
      entitiesIds: entitiesIds ?? this.entitiesIds,
      properties: properties ?? this.properties,
    );
  }
}

/// An issue ID with entity property values. See
/// [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/)
/// for more information.
class IssueEntityPropertiesForMultiUpdate {
  /// The ID of the issue.
  final int? issueId;

  /// Entity properties to set on the issue. The maximum length of an issue
  /// property value is 32768 characters.
  final Map<String, dynamic>? properties;

  IssueEntityPropertiesForMultiUpdate({this.issueId, this.properties});

  factory IssueEntityPropertiesForMultiUpdate.fromJson(
      Map<String, Object?> json) {
    return IssueEntityPropertiesForMultiUpdate(
      issueId: (json[r'issueID'] as num?)?.toInt(),
      properties: json[r'properties'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var issueId = this.issueId;
    var properties = this.properties;

    final json = <String, Object?>{};
    if (issueId != null) {
      json[r'issueID'] = issueId;
    }
    if (properties != null) {
      json[r'properties'] = properties;
    }
    return json;
  }

  IssueEntityPropertiesForMultiUpdate copyWith(
      {int? issueId, Map<String, dynamic>? properties}) {
    return IssueEntityPropertiesForMultiUpdate(
      issueId: issueId ?? this.issueId,
      properties: properties ?? this.properties,
    );
  }
}

/// Details about an issue event.
class IssueEvent {
  /// The ID of the event.
  final int? id;

  /// The name of the event.
  final String? name;

  IssueEvent({this.id, this.name});

  factory IssueEvent.fromJson(Map<String, Object?> json) {
    return IssueEvent(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  IssueEvent copyWith({int? id, String? name}) {
    return IssueEvent(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// Details of the options for a select list issue field.
class IssueFieldOption {
  final IssueFieldOptionConfiguration? config;

  /// The unique identifier for the option. This is only unique within the
  /// select field's set of options.
  final int id;

  /// The properties of the object, as arbitrary key-value pairs. These
  /// properties can be searched using JQL, if the extractions (see
  /// [Issue Field Option Property Index](https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/))
  /// are defined in the descriptor for the issue field module.
  final Map<String, dynamic>? properties;

  /// The option's name, which is displayed in Jira.
  final String value;

  IssueFieldOption(
      {this.config, required this.id, this.properties, required this.value});

  factory IssueFieldOption.fromJson(Map<String, Object?> json) {
    return IssueFieldOption(
      config: json[r'config'] != null
          ? IssueFieldOptionConfiguration.fromJson(
              json[r'config']! as Map<String, Object?>)
          : null,
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      properties: json[r'properties'] as Map<String, Object?>?,
      value: json[r'value'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var config = this.config;
    var id = this.id;
    var properties = this.properties;
    var value = this.value;

    final json = <String, Object?>{};
    if (config != null) {
      json[r'config'] = config.toJson();
    }
    json[r'id'] = id;
    if (properties != null) {
      json[r'properties'] = properties;
    }
    json[r'value'] = value;
    return json;
  }

  IssueFieldOption copyWith(
      {IssueFieldOptionConfiguration? config,
      int? id,
      Map<String, dynamic>? properties,
      String? value}) {
    return IssueFieldOption(
      config: config ?? this.config,
      id: id ?? this.id,
      properties: properties ?? this.properties,
      value: value ?? this.value,
    );
  }
}

/// Details of the projects the option is available in.
class IssueFieldOptionConfiguration {
  /// DEPRECATED
  final List<IssueFieldOptionConfigurationAttributes> attributes;

  /// Defines the projects that the option is available in. If the scope is not
  /// defined, then the option is available in all projects.
  final IssueFieldOptionScopeBean? scope;

  IssueFieldOptionConfiguration(
      {List<IssueFieldOptionConfigurationAttributes>? attributes, this.scope})
      : attributes = attributes ?? [];

  factory IssueFieldOptionConfiguration.fromJson(Map<String, Object?> json) {
    return IssueFieldOptionConfiguration(
      attributes: (json[r'attributes'] as List<Object?>?)
              ?.map((i) => IssueFieldOptionConfigurationAttributes.fromValue(
                  i as String? ?? ''))
              .toList() ??
          [],
      scope: json[r'scope'] != null
          ? IssueFieldOptionScopeBean.fromJson(
              json[r'scope']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var attributes = this.attributes;
    var scope = this.scope;

    final json = <String, Object?>{};
    json[r'attributes'] = attributes.map((i) => i.value).toList();
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    return json;
  }

  IssueFieldOptionConfiguration copyWith(
      {List<IssueFieldOptionConfigurationAttributes>? attributes,
      IssueFieldOptionScopeBean? scope}) {
    return IssueFieldOptionConfiguration(
      attributes: attributes ?? this.attributes,
      scope: scope ?? this.scope,
    );
  }
}

class IssueFieldOptionConfigurationAttributes {
  static const notSelectable =
      IssueFieldOptionConfigurationAttributes._('notSelectable');
  static const defaultValue =
      IssueFieldOptionConfigurationAttributes._('defaultValue');

  static const values = [
    notSelectable,
    defaultValue,
  ];
  final String value;

  const IssueFieldOptionConfigurationAttributes._(this.value);

  static IssueFieldOptionConfigurationAttributes fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => IssueFieldOptionConfigurationAttributes._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class IssueFieldOptionCreateBean {
  final IssueFieldOptionConfiguration? config;

  /// The properties of the option as arbitrary key-value pairs. These
  /// properties can be searched using JQL, if the extractions (see
  /// https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/)
  /// are defined in the descriptor for the issue field module.
  final Map<String, dynamic>? properties;

  /// The option's name, which is displayed in Jira.
  final String value;

  IssueFieldOptionCreateBean(
      {this.config, this.properties, required this.value});

  factory IssueFieldOptionCreateBean.fromJson(Map<String, Object?> json) {
    return IssueFieldOptionCreateBean(
      config: json[r'config'] != null
          ? IssueFieldOptionConfiguration.fromJson(
              json[r'config']! as Map<String, Object?>)
          : null,
      properties: json[r'properties'] as Map<String, Object?>?,
      value: json[r'value'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var config = this.config;
    var properties = this.properties;
    var value = this.value;

    final json = <String, Object?>{};
    if (config != null) {
      json[r'config'] = config.toJson();
    }
    if (properties != null) {
      json[r'properties'] = properties;
    }
    json[r'value'] = value;
    return json;
  }

  IssueFieldOptionCreateBean copyWith(
      {IssueFieldOptionConfiguration? config,
      Map<String, dynamic>? properties,
      String? value}) {
    return IssueFieldOptionCreateBean(
      config: config ?? this.config,
      properties: properties ?? this.properties,
      value: value ?? this.value,
    );
  }
}

class IssueFieldOptionScopeBean {
  /// Defines the behavior of the option within the global context. If this
  /// property is set, even if set to an empty object, then the option is
  /// available in all projects.
  final GlobalScopeBean? global;

  /// DEPRECATED
  final List<int> projects;

  /// Defines the projects in which the option is available and the behavior of
  /// the option within each project. Specify one object per project. The
  /// behavior of the option in a project context overrides the behavior in the
  /// global context.
  final List<ProjectScopeBean> projects2;

  IssueFieldOptionScopeBean(
      {this.global, List<int>? projects, List<ProjectScopeBean>? projects2})
      : projects = projects ?? [],
        projects2 = projects2 ?? [];

  factory IssueFieldOptionScopeBean.fromJson(Map<String, Object?> json) {
    return IssueFieldOptionScopeBean(
      global: json[r'global'] != null
          ? GlobalScopeBean.fromJson(json[r'global']! as Map<String, Object?>)
          : null,
      projects: (json[r'projects'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      projects2: (json[r'projects2'] as List<Object?>?)
              ?.map((i) => ProjectScopeBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var global = this.global;
    var projects = this.projects;
    var projects2 = this.projects2;

    final json = <String, Object?>{};
    if (global != null) {
      json[r'global'] = global.toJson();
    }
    json[r'projects'] = projects;
    json[r'projects2'] = projects2.map((i) => i.toJson()).toList();
    return json;
  }

  IssueFieldOptionScopeBean copyWith(
      {GlobalScopeBean? global,
      List<int>? projects,
      List<ProjectScopeBean>? projects2}) {
    return IssueFieldOptionScopeBean(
      global: global ?? this.global,
      projects: projects ?? this.projects,
      projects2: projects2 ?? this.projects2,
    );
  }
}

/// Bulk operation filter details.
class IssueFilterForBulkPropertyDelete {
  /// The value of properties to perform the bulk operation on.
  final dynamic currentValue;

  /// List of issues to perform the bulk delete operation on.
  final List<int> entityIds;

  IssueFilterForBulkPropertyDelete({this.currentValue, List<int>? entityIds})
      : entityIds = entityIds ?? [];

  factory IssueFilterForBulkPropertyDelete.fromJson(Map<String, Object?> json) {
    return IssueFilterForBulkPropertyDelete(
      currentValue: json[r'currentValue'],
      entityIds: (json[r'entityIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var currentValue = this.currentValue;
    var entityIds = this.entityIds;

    final json = <String, Object?>{};
    if (currentValue != null) {
      json[r'currentValue'] = currentValue;
    }
    json[r'entityIds'] = entityIds;
    return json;
  }

  IssueFilterForBulkPropertyDelete copyWith(
      {dynamic currentValue, List<int>? entityIds}) {
    return IssueFilterForBulkPropertyDelete(
      currentValue: currentValue ?? this.currentValue,
      entityIds: entityIds ?? this.entityIds,
    );
  }
}

/// Bulk operation filter details.
class IssueFilterForBulkPropertySet {
  /// The value of properties to perform the bulk operation on.
  final dynamic currentValue;

  /// List of issues to perform the bulk operation on.
  final List<int> entityIds;

  /// Whether the bulk operation occurs only when the property is present on or
  /// absent from an issue.
  final bool hasProperty;

  IssueFilterForBulkPropertySet(
      {this.currentValue, List<int>? entityIds, bool? hasProperty})
      : entityIds = entityIds ?? [],
        hasProperty = hasProperty ?? false;

  factory IssueFilterForBulkPropertySet.fromJson(Map<String, Object?> json) {
    return IssueFilterForBulkPropertySet(
      currentValue: json[r'currentValue'],
      entityIds: (json[r'entityIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      hasProperty: json[r'hasProperty'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var currentValue = this.currentValue;
    var entityIds = this.entityIds;
    var hasProperty = this.hasProperty;

    final json = <String, Object?>{};
    if (currentValue != null) {
      json[r'currentValue'] = currentValue;
    }
    json[r'entityIds'] = entityIds;
    json[r'hasProperty'] = hasProperty;
    return json;
  }

  IssueFilterForBulkPropertySet copyWith(
      {dynamic currentValue, List<int>? entityIds, bool? hasProperty}) {
    return IssueFilterForBulkPropertySet(
      currentValue: currentValue ?? this.currentValue,
      entityIds: entityIds ?? this.entityIds,
      hasProperty: hasProperty ?? this.hasProperty,
    );
  }
}

/// Details of a link between issues.
class IssueLink {
  /// The ID of the issue link.
  final String? id;

  /// Provides details about the linked issue. If presenting this link in a user
  /// interface, use the `inward` field of the issue link type to label the
  /// link.
  final LinkedIssue inwardIssue;

  /// Provides details about the linked issue. If presenting this link in a user
  /// interface, use the `outward` field of the issue link type to label the
  /// link.
  final LinkedIssue outwardIssue;

  /// The URL of the issue link.
  final String? self;

  /// The type of link between the issues.
  final IssueLinkType type;

  IssueLink(
      {this.id,
      required this.inwardIssue,
      required this.outwardIssue,
      this.self,
      required this.type});

  factory IssueLink.fromJson(Map<String, Object?> json) {
    return IssueLink(
      id: json[r'id'] as String?,
      inwardIssue: LinkedIssue.fromJson(
          json[r'inwardIssue'] as Map<String, Object?>? ?? const {}),
      outwardIssue: LinkedIssue.fromJson(
          json[r'outwardIssue'] as Map<String, Object?>? ?? const {}),
      self: json[r'self'] as String?,
      type: IssueLinkType.fromJson(
          json[r'type'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var inwardIssue = this.inwardIssue;
    var outwardIssue = this.outwardIssue;
    var self = this.self;
    var type = this.type;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'inwardIssue'] = inwardIssue.toJson();
    json[r'outwardIssue'] = outwardIssue.toJson();
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'type'] = type.toJson();
    return json;
  }

  IssueLink copyWith(
      {String? id,
      LinkedIssue? inwardIssue,
      LinkedIssue? outwardIssue,
      String? self,
      IssueLinkType? type}) {
    return IssueLink(
      id: id ?? this.id,
      inwardIssue: inwardIssue ?? this.inwardIssue,
      outwardIssue: outwardIssue ?? this.outwardIssue,
      self: self ?? this.self,
      type: type ?? this.type,
    );
  }
}

/// This object is used as follows:
///
///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it defines
/// and reports on the type of link between the issues. Find a list of issue
/// link types with [Get issue link types](#api-rest-api-3-issueLinkType-get).
///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it
/// defines and reports on issue link types.
class IssueLinkType {
  /// The ID of the issue link type and is used as follows:
  ///
  ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is the
  /// type of issue link. Required on create when `name` isn't provided.
  /// Otherwise, read only.
  ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource
  /// it is read only.
  final String? id;

  /// The description of the issue link type inward link and is used as follows:
  ///
  ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is
  /// read only.
  ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource
  /// it is required on create and optional on update. Otherwise, read only.
  final String? inward;

  /// The name of the issue link type and is used as follows:
  ///
  ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is the
  /// type of issue link. Required on create when `id` isn't provided.
  /// Otherwise, read only.
  ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource
  /// it is required on create and optional on update. Otherwise, read only.
  final String? name;

  /// The description of the issue link type outward link and is used as
  /// follows:
  ///
  ///  *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is
  /// read only.
  ///  *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource
  /// it is required on create and optional on update. Otherwise, read only.
  final String? outward;

  /// The URL of the issue link type. Read only.
  final String? self;

  IssueLinkType({this.id, this.inward, this.name, this.outward, this.self});

  factory IssueLinkType.fromJson(Map<String, Object?> json) {
    return IssueLinkType(
      id: json[r'id'] as String?,
      inward: json[r'inward'] as String?,
      name: json[r'name'] as String?,
      outward: json[r'outward'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var inward = this.inward;
    var name = this.name;
    var outward = this.outward;
    var self = this.self;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (inward != null) {
      json[r'inward'] = inward;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (outward != null) {
      json[r'outward'] = outward;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  IssueLinkType copyWith(
      {String? id,
      String? inward,
      String? name,
      String? outward,
      String? self}) {
    return IssueLinkType(
      id: id ?? this.id,
      inward: inward ?? this.inward,
      name: name ?? this.name,
      outward: outward ?? this.outward,
      self: self ?? this.self,
    );
  }
}

/// A list of issue link type beans.
class IssueLinkTypes {
  /// The issue link type bean.
  final List<IssueLinkType> issueLinkTypes;

  IssueLinkTypes({List<IssueLinkType>? issueLinkTypes})
      : issueLinkTypes = issueLinkTypes ?? [];

  factory IssueLinkTypes.fromJson(Map<String, Object?> json) {
    return IssueLinkTypes(
      issueLinkTypes: (json[r'issueLinkTypes'] as List<Object?>?)
              ?.map((i) => IssueLinkType.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueLinkTypes = this.issueLinkTypes;

    final json = <String, Object?>{};
    json[r'issueLinkTypes'] = issueLinkTypes.map((i) => i.toJson()).toList();
    return json;
  }

  IssueLinkTypes copyWith({List<IssueLinkType>? issueLinkTypes}) {
    return IssueLinkTypes(
      issueLinkTypes: issueLinkTypes ?? this.issueLinkTypes,
    );
  }
}

/// A list of issue IDs.
class IssueList {
  /// The list of issue IDs.
  final List<String> issueIds;

  IssueList({required this.issueIds});

  factory IssueList.fromJson(Map<String, Object?> json) {
    return IssueList(
      issueIds: (json[r'issueIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueIds = this.issueIds;

    final json = <String, Object?>{};
    json[r'issueIds'] = issueIds;
    return json;
  }

  IssueList copyWith({List<String>? issueIds}) {
    return IssueList(
      issueIds: issueIds ?? this.issueIds,
    );
  }
}

/// A list of matched issues or errors for each JQL query, in the order the JQL
/// queries were passed.
class IssueMatches {
  final List<IssueMatchesForJQL> matches;

  IssueMatches({required this.matches});

  factory IssueMatches.fromJson(Map<String, Object?> json) {
    return IssueMatches(
      matches: (json[r'matches'] as List<Object?>?)
              ?.map((i) => IssueMatchesForJQL.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var matches = this.matches;

    final json = <String, Object?>{};
    json[r'matches'] = matches.map((i) => i.toJson()).toList();
    return json;
  }

  IssueMatches copyWith({List<IssueMatchesForJQL>? matches}) {
    return IssueMatches(
      matches: matches ?? this.matches,
    );
  }
}

/// A list of the issues matched to a JQL query or details of errors encountered
/// during matching.
class IssueMatchesForJQL {
  /// A list of errors.
  final List<String> errors;

  /// A list of issue IDs.
  final List<int> matchedIssues;

  IssueMatchesForJQL({required this.errors, required this.matchedIssues});

  factory IssueMatchesForJQL.fromJson(Map<String, Object?> json) {
    return IssueMatchesForJQL(
      errors: (json[r'errors'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      matchedIssues: (json[r'matchedIssues'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var errors = this.errors;
    var matchedIssues = this.matchedIssues;

    final json = <String, Object?>{};
    json[r'errors'] = errors;
    json[r'matchedIssues'] = matchedIssues;
    return json;
  }

  IssueMatchesForJQL copyWith(
      {List<String>? errors, List<int>? matchedIssues}) {
    return IssueMatchesForJQL(
      errors: errors ?? this.errors,
      matchedIssues: matchedIssues ?? this.matchedIssues,
    );
  }
}

/// A list of issues suggested for use in auto-completion.
class IssuePickerSuggestions {
  /// A list of issues for an issue type suggested for use in auto-completion.
  final List<IssuePickerSuggestionsIssueType> sections;

  IssuePickerSuggestions({List<IssuePickerSuggestionsIssueType>? sections})
      : sections = sections ?? [];

  factory IssuePickerSuggestions.fromJson(Map<String, Object?> json) {
    return IssuePickerSuggestions(
      sections: (json[r'sections'] as List<Object?>?)
              ?.map((i) => IssuePickerSuggestionsIssueType.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var sections = this.sections;

    final json = <String, Object?>{};
    json[r'sections'] = sections.map((i) => i.toJson()).toList();
    return json;
  }

  IssuePickerSuggestions copyWith(
      {List<IssuePickerSuggestionsIssueType>? sections}) {
    return IssuePickerSuggestions(
      sections: sections ?? this.sections,
    );
  }
}

/// A type of issue suggested for use in auto-completion.
class IssuePickerSuggestionsIssueType {
  /// The ID of the type of issues suggested for use in auto-completion.
  final String? id;

  /// A list of issues suggested for use in auto-completion.
  final List<SuggestedIssue> issues;

  /// The label of the type of issues suggested for use in auto-completion.
  final String? label;

  /// If no issue suggestions are found, returns a message indicating no
  /// suggestions were found,
  final String? msg;

  /// If issue suggestions are found, returns a message indicating the number of
  /// issues suggestions found and returned.
  final String? sub;

  IssuePickerSuggestionsIssueType(
      {this.id, List<SuggestedIssue>? issues, this.label, this.msg, this.sub})
      : issues = issues ?? [];

  factory IssuePickerSuggestionsIssueType.fromJson(Map<String, Object?> json) {
    return IssuePickerSuggestionsIssueType(
      id: json[r'id'] as String?,
      issues: (json[r'issues'] as List<Object?>?)
              ?.map((i) => SuggestedIssue.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      label: json[r'label'] as String?,
      msg: json[r'msg'] as String?,
      sub: json[r'sub'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var issues = this.issues;
    var label = this.label;
    var msg = this.msg;
    var sub = this.sub;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'issues'] = issues.map((i) => i.toJson()).toList();
    if (label != null) {
      json[r'label'] = label;
    }
    if (msg != null) {
      json[r'msg'] = msg;
    }
    if (sub != null) {
      json[r'sub'] = sub;
    }
    return json;
  }

  IssuePickerSuggestionsIssueType copyWith(
      {String? id,
      List<SuggestedIssue>? issues,
      String? label,
      String? msg,
      String? sub}) {
    return IssuePickerSuggestionsIssueType(
      id: id ?? this.id,
      issues: issues ?? this.issues,
      label: label ?? this.label,
      msg: msg ?? this.msg,
      sub: sub ?? this.sub,
    );
  }
}

/// Issue security level member.
class IssueSecurityLevelMember {
  /// The user or group being granted the permission. It consists of a `type`
  /// and a type-dependent `parameter`. See
  /// [Holder object](../api-group-permission-schemes/#holder-object) in *Get
  /// all permission schemes* for more information.
  final PermissionHolder holder;

  /// The ID of the issue security level member.
  final int id;

  /// The ID of the issue security level.
  final int issueSecurityLevelId;

  IssueSecurityLevelMember(
      {required this.holder,
      required this.id,
      required this.issueSecurityLevelId});

  factory IssueSecurityLevelMember.fromJson(Map<String, Object?> json) {
    return IssueSecurityLevelMember(
      holder: PermissionHolder.fromJson(
          json[r'holder'] as Map<String, Object?>? ?? const {}),
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      issueSecurityLevelId:
          (json[r'issueSecurityLevelId'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var holder = this.holder;
    var id = this.id;
    var issueSecurityLevelId = this.issueSecurityLevelId;

    final json = <String, Object?>{};
    json[r'holder'] = holder.toJson();
    json[r'id'] = id;
    json[r'issueSecurityLevelId'] = issueSecurityLevelId;
    return json;
  }

  IssueSecurityLevelMember copyWith(
      {PermissionHolder? holder, int? id, int? issueSecurityLevelId}) {
    return IssueSecurityLevelMember(
      holder: holder ?? this.holder,
      id: id ?? this.id,
      issueSecurityLevelId: issueSecurityLevelId ?? this.issueSecurityLevelId,
    );
  }
}

/// Details about an project using security scheme mapping.
class IssueSecuritySchemeToProjectMapping {
  final String? issueSecuritySchemeId;
  final String? projectId;

  IssueSecuritySchemeToProjectMapping(
      {this.issueSecuritySchemeId, this.projectId});

  factory IssueSecuritySchemeToProjectMapping.fromJson(
      Map<String, Object?> json) {
    return IssueSecuritySchemeToProjectMapping(
      issueSecuritySchemeId: json[r'issueSecuritySchemeId'] as String?,
      projectId: json[r'projectId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var issueSecuritySchemeId = this.issueSecuritySchemeId;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    if (issueSecuritySchemeId != null) {
      json[r'issueSecuritySchemeId'] = issueSecuritySchemeId;
    }
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    return json;
  }

  IssueSecuritySchemeToProjectMapping copyWith(
      {String? issueSecuritySchemeId, String? projectId}) {
    return IssueSecuritySchemeToProjectMapping(
      issueSecuritySchemeId:
          issueSecuritySchemeId ?? this.issueSecuritySchemeId,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// Details of an issue transition.
class IssueTransition {
  /// Expand options that include additional transition details in the response.
  final String? expand;

  /// Details of the fields associated with the issue transition screen. Use
  /// this information to populate `fields` and `update` in a transition
  /// request.
  final Map<String, dynamic>? fields;

  /// Whether there is a screen associated with the issue transition.
  final bool hasScreen;

  /// The ID of the issue transition. Required when specifying a transition to
  /// undertake.
  final String? id;

  /// Whether the transition is available to be performed.
  final bool isAvailable;

  /// Whether the issue has to meet criteria before the issue transition is
  /// applied.
  final bool isConditional;

  /// Whether the issue transition is global, that is, the transition is applied
  /// to issues regardless of their status.
  final bool isGlobal;

  /// Whether this is the initial issue transition for the workflow.
  final bool isInitial;
  final bool looped;

  /// The name of the issue transition.
  final String? name;

  /// Details of the issue status after the transition.
  final StatusDetails? to;

  IssueTransition(
      {this.expand,
      this.fields,
      bool? hasScreen,
      this.id,
      bool? isAvailable,
      bool? isConditional,
      bool? isGlobal,
      bool? isInitial,
      bool? looped,
      this.name,
      this.to})
      : hasScreen = hasScreen ?? false,
        isAvailable = isAvailable ?? false,
        isConditional = isConditional ?? false,
        isGlobal = isGlobal ?? false,
        isInitial = isInitial ?? false,
        looped = looped ?? false;

  factory IssueTransition.fromJson(Map<String, Object?> json) {
    return IssueTransition(
      expand: json[r'expand'] as String?,
      fields: json[r'fields'] as Map<String, Object?>?,
      hasScreen: json[r'hasScreen'] as bool? ?? false,
      id: json[r'id'] as String?,
      isAvailable: json[r'isAvailable'] as bool? ?? false,
      isConditional: json[r'isConditional'] as bool? ?? false,
      isGlobal: json[r'isGlobal'] as bool? ?? false,
      isInitial: json[r'isInitial'] as bool? ?? false,
      looped: json[r'looped'] as bool? ?? false,
      name: json[r'name'] as String?,
      to: json[r'to'] != null
          ? StatusDetails.fromJson(json[r'to']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var fields = this.fields;
    var hasScreen = this.hasScreen;
    var id = this.id;
    var isAvailable = this.isAvailable;
    var isConditional = this.isConditional;
    var isGlobal = this.isGlobal;
    var isInitial = this.isInitial;
    var looped = this.looped;
    var name = this.name;
    var to = this.to;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (fields != null) {
      json[r'fields'] = fields;
    }
    json[r'hasScreen'] = hasScreen;
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'isAvailable'] = isAvailable;
    json[r'isConditional'] = isConditional;
    json[r'isGlobal'] = isGlobal;
    json[r'isInitial'] = isInitial;
    json[r'looped'] = looped;
    if (name != null) {
      json[r'name'] = name;
    }
    if (to != null) {
      json[r'to'] = to.toJson();
    }
    return json;
  }

  IssueTransition copyWith(
      {String? expand,
      Map<String, dynamic>? fields,
      bool? hasScreen,
      String? id,
      bool? isAvailable,
      bool? isConditional,
      bool? isGlobal,
      bool? isInitial,
      bool? looped,
      String? name,
      StatusDetails? to}) {
    return IssueTransition(
      expand: expand ?? this.expand,
      fields: fields ?? this.fields,
      hasScreen: hasScreen ?? this.hasScreen,
      id: id ?? this.id,
      isAvailable: isAvailable ?? this.isAvailable,
      isConditional: isConditional ?? this.isConditional,
      isGlobal: isGlobal ?? this.isGlobal,
      isInitial: isInitial ?? this.isInitial,
      looped: looped ?? this.looped,
      name: name ?? this.name,
      to: to ?? this.to,
    );
  }
}

class IssueTypeCreateBean {
  /// The description of the issue type.
  final String? description;

  /// The hierarchy level of the issue type. Use:
  ///
  ///  *  `-1` for Subtask.
  ///  *  `0` for Base.
  ///
  /// Defaults to `0`.
  final int? hierarchyLevel;

  /// The unique name for the issue type. The maximum length is 60 characters.
  final String name;

  /// Deprecated. Use `hierarchyLevel` instead. See the
  /// [deprecation notice](https://community.developer.atlassian.com/t/deprecation-of-the-epic-link-parent-link-and-other-related-fields-in-rest-apis-and-webhooks/54048)
  /// for details.
  ///
  /// Whether the issue type is `subtype` or `standard`. Defaults to `standard`.
  final IssueTypeCreateBeanType? type;

  IssueTypeCreateBean(
      {this.description, this.hierarchyLevel, required this.name, this.type});

  factory IssueTypeCreateBean.fromJson(Map<String, Object?> json) {
    return IssueTypeCreateBean(
      description: json[r'description'] as String?,
      hierarchyLevel: (json[r'hierarchyLevel'] as num?)?.toInt(),
      name: json[r'name'] as String? ?? '',
      type: json[r'type'] != null
          ? IssueTypeCreateBeanType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var hierarchyLevel = this.hierarchyLevel;
    var name = this.name;
    var type = this.type;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (hierarchyLevel != null) {
      json[r'hierarchyLevel'] = hierarchyLevel;
    }
    json[r'name'] = name;
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  IssueTypeCreateBean copyWith(
      {String? description,
      int? hierarchyLevel,
      String? name,
      IssueTypeCreateBeanType? type}) {
    return IssueTypeCreateBean(
      description: description ?? this.description,
      hierarchyLevel: hierarchyLevel ?? this.hierarchyLevel,
      name: name ?? this.name,
      type: type ?? this.type,
    );
  }
}

class IssueTypeCreateBeanType {
  static const subtask = IssueTypeCreateBeanType._('subtask');
  static const standard = IssueTypeCreateBeanType._('standard');

  static const values = [
    subtask,
    standard,
  ];
  final String value;

  const IssueTypeCreateBeanType._(this.value);

  static IssueTypeCreateBeanType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => IssueTypeCreateBeanType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about an issue type.
class IssueTypeDetails {
  /// The ID of the issue type's avatar.
  final int? avatarId;

  /// The description of the issue type.
  final String? description;

  /// Unique ID for next-gen projects.
  final String? entityId;

  /// Hierarchy level of the issue type.
  final int? hierarchyLevel;

  /// The URL of the issue type's avatar.
  final String? iconUrl;

  /// The ID of the issue type.
  final String? id;

  /// The name of the issue type.
  final String? name;

  /// Details of the next-gen projects the issue type is available in.
  final Scope? scope;

  /// The URL of these issue type details.
  final String? self;

  /// Whether this issue type is used to create subtasks.
  final bool subtask;

  IssueTypeDetails(
      {this.avatarId,
      this.description,
      this.entityId,
      this.hierarchyLevel,
      this.iconUrl,
      this.id,
      this.name,
      this.scope,
      this.self,
      bool? subtask})
      : subtask = subtask ?? false;

  factory IssueTypeDetails.fromJson(Map<String, Object?> json) {
    return IssueTypeDetails(
      avatarId: (json[r'avatarId'] as num?)?.toInt(),
      description: json[r'description'] as String?,
      entityId: json[r'entityId'] as String?,
      hierarchyLevel: (json[r'hierarchyLevel'] as num?)?.toInt(),
      iconUrl: json[r'iconUrl'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      self: json[r'self'] as String?,
      subtask: json[r'subtask'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var avatarId = this.avatarId;
    var description = this.description;
    var entityId = this.entityId;
    var hierarchyLevel = this.hierarchyLevel;
    var iconUrl = this.iconUrl;
    var id = this.id;
    var name = this.name;
    var scope = this.scope;
    var self = this.self;
    var subtask = this.subtask;

    final json = <String, Object?>{};
    if (avatarId != null) {
      json[r'avatarId'] = avatarId;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (entityId != null) {
      json[r'entityId'] = entityId;
    }
    if (hierarchyLevel != null) {
      json[r'hierarchyLevel'] = hierarchyLevel;
    }
    if (iconUrl != null) {
      json[r'iconUrl'] = iconUrl;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'subtask'] = subtask;
    return json;
  }

  IssueTypeDetails copyWith(
      {int? avatarId,
      String? description,
      String? entityId,
      int? hierarchyLevel,
      String? iconUrl,
      String? id,
      String? name,
      Scope? scope,
      String? self,
      bool? subtask}) {
    return IssueTypeDetails(
      avatarId: avatarId ?? this.avatarId,
      description: description ?? this.description,
      entityId: entityId ?? this.entityId,
      hierarchyLevel: hierarchyLevel ?? this.hierarchyLevel,
      iconUrl: iconUrl ?? this.iconUrl,
      id: id ?? this.id,
      name: name ?? this.name,
      scope: scope ?? this.scope,
      self: self ?? this.self,
      subtask: subtask ?? this.subtask,
    );
  }
}

/// The list of issue type IDs.
class IssueTypeIds {
  /// The list of issue type IDs.
  final List<String> issueTypeIds;

  IssueTypeIds({required this.issueTypeIds});

  factory IssueTypeIds.fromJson(Map<String, Object?> json) {
    return IssueTypeIds(
      issueTypeIds: (json[r'issueTypeIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeIds = this.issueTypeIds;

    final json = <String, Object?>{};
    json[r'issueTypeIds'] = issueTypeIds;
    return json;
  }

  IssueTypeIds copyWith({List<String>? issueTypeIds}) {
    return IssueTypeIds(
      issueTypeIds: issueTypeIds ?? this.issueTypeIds,
    );
  }
}

/// The list of issue type IDs to be removed from the field configuration
/// scheme.
class IssueTypeIdsToRemove {
  /// The list of issue type IDs. Must contain unique values not longer than 255
  /// characters and not be empty. Maximum of 100 IDs.
  final List<String> issueTypeIds;

  IssueTypeIdsToRemove({required this.issueTypeIds});

  factory IssueTypeIdsToRemove.fromJson(Map<String, Object?> json) {
    return IssueTypeIdsToRemove(
      issueTypeIds: (json[r'issueTypeIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeIds = this.issueTypeIds;

    final json = <String, Object?>{};
    json[r'issueTypeIds'] = issueTypeIds;
    return json;
  }

  IssueTypeIdsToRemove copyWith({List<String>? issueTypeIds}) {
    return IssueTypeIdsToRemove(
      issueTypeIds: issueTypeIds ?? this.issueTypeIds,
    );
  }
}

/// Details of an issue type.
class IssueTypeInfo {
  /// The avatar of the issue type.
  final int? avatarId;

  /// The ID of the issue type.
  final int? id;

  /// The name of the issue type.
  final String? name;

  IssueTypeInfo({this.avatarId, this.id, this.name});

  factory IssueTypeInfo.fromJson(Map<String, Object?> json) {
    return IssueTypeInfo(
      avatarId: (json[r'avatarId'] as num?)?.toInt(),
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var avatarId = this.avatarId;
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    if (avatarId != null) {
      json[r'avatarId'] = avatarId;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  IssueTypeInfo copyWith({int? avatarId, int? id, String? name}) {
    return IssueTypeInfo(
      avatarId: avatarId ?? this.avatarId,
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// Details of the issue creation metadata for an issue type.
class IssueTypeIssueCreateMetadata {
  /// The ID of the issue type's avatar.
  final int? avatarId;

  /// The description of the issue type.
  final String? description;

  /// Unique ID for next-gen projects.
  final String? entityId;

  /// Expand options that include additional issue type metadata details in the
  /// response.
  final String? expand;

  /// List of the fields available when creating an issue for the issue type.
  final Map<String, dynamic>? fields;

  /// Hierarchy level of the issue type.
  final int? hierarchyLevel;

  /// The URL of the issue type's avatar.
  final String? iconUrl;

  /// The ID of the issue type.
  final String? id;

  /// The name of the issue type.
  final String? name;

  /// Details of the next-gen projects the issue type is available in.
  final Scope? scope;

  /// The URL of these issue type details.
  final String? self;

  /// Whether this issue type is used to create subtasks.
  final bool subtask;

  IssueTypeIssueCreateMetadata(
      {this.avatarId,
      this.description,
      this.entityId,
      this.expand,
      this.fields,
      this.hierarchyLevel,
      this.iconUrl,
      this.id,
      this.name,
      this.scope,
      this.self,
      bool? subtask})
      : subtask = subtask ?? false;

  factory IssueTypeIssueCreateMetadata.fromJson(Map<String, Object?> json) {
    return IssueTypeIssueCreateMetadata(
      avatarId: (json[r'avatarId'] as num?)?.toInt(),
      description: json[r'description'] as String?,
      entityId: json[r'entityId'] as String?,
      expand: json[r'expand'] as String?,
      fields: json[r'fields'] as Map<String, Object?>?,
      hierarchyLevel: (json[r'hierarchyLevel'] as num?)?.toInt(),
      iconUrl: json[r'iconUrl'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      self: json[r'self'] as String?,
      subtask: json[r'subtask'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var avatarId = this.avatarId;
    var description = this.description;
    var entityId = this.entityId;
    var expand = this.expand;
    var fields = this.fields;
    var hierarchyLevel = this.hierarchyLevel;
    var iconUrl = this.iconUrl;
    var id = this.id;
    var name = this.name;
    var scope = this.scope;
    var self = this.self;
    var subtask = this.subtask;

    final json = <String, Object?>{};
    if (avatarId != null) {
      json[r'avatarId'] = avatarId;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (entityId != null) {
      json[r'entityId'] = entityId;
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (fields != null) {
      json[r'fields'] = fields;
    }
    if (hierarchyLevel != null) {
      json[r'hierarchyLevel'] = hierarchyLevel;
    }
    if (iconUrl != null) {
      json[r'iconUrl'] = iconUrl;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'subtask'] = subtask;
    return json;
  }

  IssueTypeIssueCreateMetadata copyWith(
      {int? avatarId,
      String? description,
      String? entityId,
      String? expand,
      Map<String, dynamic>? fields,
      int? hierarchyLevel,
      String? iconUrl,
      String? id,
      String? name,
      Scope? scope,
      String? self,
      bool? subtask}) {
    return IssueTypeIssueCreateMetadata(
      avatarId: avatarId ?? this.avatarId,
      description: description ?? this.description,
      entityId: entityId ?? this.entityId,
      expand: expand ?? this.expand,
      fields: fields ?? this.fields,
      hierarchyLevel: hierarchyLevel ?? this.hierarchyLevel,
      iconUrl: iconUrl ?? this.iconUrl,
      id: id ?? this.id,
      name: name ?? this.name,
      scope: scope ?? this.scope,
      self: self ?? this.self,
      subtask: subtask ?? this.subtask,
    );
  }
}

/// Details of an issue type scheme.
class IssueTypeScheme {
  /// The ID of the default issue type of the issue type scheme.
  final String? defaultIssueTypeId;

  /// The description of the issue type scheme.
  final String? description;

  /// The ID of the issue type scheme.
  final String id;

  /// Whether the issue type scheme is the default.
  final bool isDefault;

  /// The name of the issue type scheme.
  final String name;

  IssueTypeScheme(
      {this.defaultIssueTypeId,
      this.description,
      required this.id,
      bool? isDefault,
      required this.name})
      : isDefault = isDefault ?? false;

  factory IssueTypeScheme.fromJson(Map<String, Object?> json) {
    return IssueTypeScheme(
      defaultIssueTypeId: json[r'defaultIssueTypeId'] as String?,
      description: json[r'description'] as String?,
      id: json[r'id'] as String? ?? '',
      isDefault: json[r'isDefault'] as bool? ?? false,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var defaultIssueTypeId = this.defaultIssueTypeId;
    var description = this.description;
    var id = this.id;
    var isDefault = this.isDefault;
    var name = this.name;

    final json = <String, Object?>{};
    if (defaultIssueTypeId != null) {
      json[r'defaultIssueTypeId'] = defaultIssueTypeId;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'id'] = id;
    json[r'isDefault'] = isDefault;
    json[r'name'] = name;
    return json;
  }

  IssueTypeScheme copyWith(
      {String? defaultIssueTypeId,
      String? description,
      String? id,
      bool? isDefault,
      String? name}) {
    return IssueTypeScheme(
      defaultIssueTypeId: defaultIssueTypeId ?? this.defaultIssueTypeId,
      description: description ?? this.description,
      id: id ?? this.id,
      isDefault: isDefault ?? this.isDefault,
      name: name ?? this.name,
    );
  }
}

/// Details of an issue type scheme and its associated issue types.
class IssueTypeSchemeDetails {
  /// The ID of the default issue type of the issue type scheme. This ID must be
  /// included in `issueTypeIds`.
  final String? defaultIssueTypeId;

  /// The description of the issue type scheme. The maximum length is 4000
  /// characters.
  final String? description;

  /// The list of issue types IDs of the issue type scheme. At least one
  /// standard issue type ID is required.
  final List<String> issueTypeIds;

  /// The name of the issue type scheme. The name must be unique. The maximum
  /// length is 255 characters.
  final String name;

  IssueTypeSchemeDetails(
      {this.defaultIssueTypeId,
      this.description,
      required this.issueTypeIds,
      required this.name});

  factory IssueTypeSchemeDetails.fromJson(Map<String, Object?> json) {
    return IssueTypeSchemeDetails(
      defaultIssueTypeId: json[r'defaultIssueTypeId'] as String?,
      description: json[r'description'] as String?,
      issueTypeIds: (json[r'issueTypeIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var defaultIssueTypeId = this.defaultIssueTypeId;
    var description = this.description;
    var issueTypeIds = this.issueTypeIds;
    var name = this.name;

    final json = <String, Object?>{};
    if (defaultIssueTypeId != null) {
      json[r'defaultIssueTypeId'] = defaultIssueTypeId;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'issueTypeIds'] = issueTypeIds;
    json[r'name'] = name;
    return json;
  }

  IssueTypeSchemeDetails copyWith(
      {String? defaultIssueTypeId,
      String? description,
      List<String>? issueTypeIds,
      String? name}) {
    return IssueTypeSchemeDetails(
      defaultIssueTypeId: defaultIssueTypeId ?? this.defaultIssueTypeId,
      description: description ?? this.description,
      issueTypeIds: issueTypeIds ?? this.issueTypeIds,
      name: name ?? this.name,
    );
  }
}

/// The ID of an issue type scheme.
class IssueTypeSchemeID {
  /// The ID of the issue type scheme.
  final String issueTypeSchemeId;

  IssueTypeSchemeID({required this.issueTypeSchemeId});

  factory IssueTypeSchemeID.fromJson(Map<String, Object?> json) {
    return IssueTypeSchemeID(
      issueTypeSchemeId: json[r'issueTypeSchemeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeSchemeId = this.issueTypeSchemeId;

    final json = <String, Object?>{};
    json[r'issueTypeSchemeId'] = issueTypeSchemeId;
    return json;
  }

  IssueTypeSchemeID copyWith({String? issueTypeSchemeId}) {
    return IssueTypeSchemeID(
      issueTypeSchemeId: issueTypeSchemeId ?? this.issueTypeSchemeId,
    );
  }
}

/// Issue type scheme item.
class IssueTypeSchemeMapping {
  /// The ID of the issue type.
  final String issueTypeId;

  /// The ID of the issue type scheme.
  final String issueTypeSchemeId;

  IssueTypeSchemeMapping(
      {required this.issueTypeId, required this.issueTypeSchemeId});

  factory IssueTypeSchemeMapping.fromJson(Map<String, Object?> json) {
    return IssueTypeSchemeMapping(
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
      issueTypeSchemeId: json[r'issueTypeSchemeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeId = this.issueTypeId;
    var issueTypeSchemeId = this.issueTypeSchemeId;

    final json = <String, Object?>{};
    json[r'issueTypeId'] = issueTypeId;
    json[r'issueTypeSchemeId'] = issueTypeSchemeId;
    return json;
  }

  IssueTypeSchemeMapping copyWith(
      {String? issueTypeId, String? issueTypeSchemeId}) {
    return IssueTypeSchemeMapping(
      issueTypeId: issueTypeId ?? this.issueTypeId,
      issueTypeSchemeId: issueTypeSchemeId ?? this.issueTypeSchemeId,
    );
  }
}

/// Details of the association between an issue type scheme and project.
class IssueTypeSchemeProjectAssociation {
  /// The ID of the issue type scheme.
  final String issueTypeSchemeId;

  /// The ID of the project.
  final String projectId;

  IssueTypeSchemeProjectAssociation(
      {required this.issueTypeSchemeId, required this.projectId});

  factory IssueTypeSchemeProjectAssociation.fromJson(
      Map<String, Object?> json) {
    return IssueTypeSchemeProjectAssociation(
      issueTypeSchemeId: json[r'issueTypeSchemeId'] as String? ?? '',
      projectId: json[r'projectId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeSchemeId = this.issueTypeSchemeId;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    json[r'issueTypeSchemeId'] = issueTypeSchemeId;
    json[r'projectId'] = projectId;
    return json;
  }

  IssueTypeSchemeProjectAssociation copyWith(
      {String? issueTypeSchemeId, String? projectId}) {
    return IssueTypeSchemeProjectAssociation(
      issueTypeSchemeId: issueTypeSchemeId ?? this.issueTypeSchemeId,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// Issue type scheme with a list of the projects that use it.
class IssueTypeSchemeProjects {
  /// Details of an issue type scheme.
  final IssueTypeScheme issueTypeScheme;

  /// The IDs of the projects using the issue type scheme.
  final List<String> projectIds;

  IssueTypeSchemeProjects(
      {required this.issueTypeScheme, required this.projectIds});

  factory IssueTypeSchemeProjects.fromJson(Map<String, Object?> json) {
    return IssueTypeSchemeProjects(
      issueTypeScheme: IssueTypeScheme.fromJson(
          json[r'issueTypeScheme'] as Map<String, Object?>? ?? const {}),
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeScheme = this.issueTypeScheme;
    var projectIds = this.projectIds;

    final json = <String, Object?>{};
    json[r'issueTypeScheme'] = issueTypeScheme.toJson();
    json[r'projectIds'] = projectIds;
    return json;
  }

  IssueTypeSchemeProjects copyWith(
      {IssueTypeScheme? issueTypeScheme, List<String>? projectIds}) {
    return IssueTypeSchemeProjects(
      issueTypeScheme: issueTypeScheme ?? this.issueTypeScheme,
      projectIds: projectIds ?? this.projectIds,
    );
  }
}

/// Details of the name, description, and default issue type for an issue type
/// scheme.
class IssueTypeSchemeUpdateDetails {
  /// The ID of the default issue type of the issue type scheme.
  final String? defaultIssueTypeId;

  /// The description of the issue type scheme. The maximum length is 4000
  /// characters.
  final String? description;

  /// The name of the issue type scheme. The name must be unique. The maximum
  /// length is 255 characters.
  final String? name;

  IssueTypeSchemeUpdateDetails(
      {this.defaultIssueTypeId, this.description, this.name});

  factory IssueTypeSchemeUpdateDetails.fromJson(Map<String, Object?> json) {
    return IssueTypeSchemeUpdateDetails(
      defaultIssueTypeId: json[r'defaultIssueTypeId'] as String?,
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var defaultIssueTypeId = this.defaultIssueTypeId;
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (defaultIssueTypeId != null) {
      json[r'defaultIssueTypeId'] = defaultIssueTypeId;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  IssueTypeSchemeUpdateDetails copyWith(
      {String? defaultIssueTypeId, String? description, String? name}) {
    return IssueTypeSchemeUpdateDetails(
      defaultIssueTypeId: defaultIssueTypeId ?? this.defaultIssueTypeId,
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// Details of an issue type screen scheme.
class IssueTypeScreenScheme {
  /// The description of the issue type screen scheme.
  final String? description;

  /// The ID of the issue type screen scheme.
  final String id;

  /// The name of the issue type screen scheme.
  final String name;

  IssueTypeScreenScheme(
      {this.description, required this.id, required this.name});

  factory IssueTypeScreenScheme.fromJson(Map<String, Object?> json) {
    return IssueTypeScreenScheme(
      description: json[r'description'] as String?,
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'id'] = id;
    json[r'name'] = name;
    return json;
  }

  IssueTypeScreenScheme copyWith(
      {String? description, String? id, String? name}) {
    return IssueTypeScreenScheme(
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// The details of an issue type screen scheme.
class IssueTypeScreenSchemeDetails {
  /// The description of the issue type screen scheme. The maximum length is 255
  /// characters.
  final String? description;

  /// The IDs of the screen schemes for the issue type IDs and *default*. A
  /// *default* entry is required to create an issue type screen scheme, it
  /// defines the mapping for all issue types without a screen scheme.
  final List<IssueTypeScreenSchemeMapping> issueTypeMappings;

  /// The name of the issue type screen scheme. The name must be unique. The
  /// maximum length is 255 characters.
  final String name;

  IssueTypeScreenSchemeDetails(
      {this.description, required this.issueTypeMappings, required this.name});

  factory IssueTypeScreenSchemeDetails.fromJson(Map<String, Object?> json) {
    return IssueTypeScreenSchemeDetails(
      description: json[r'description'] as String?,
      issueTypeMappings: (json[r'issueTypeMappings'] as List<Object?>?)
              ?.map((i) => IssueTypeScreenSchemeMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var issueTypeMappings = this.issueTypeMappings;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'issueTypeMappings'] =
        issueTypeMappings.map((i) => i.toJson()).toList();
    json[r'name'] = name;
    return json;
  }

  IssueTypeScreenSchemeDetails copyWith(
      {String? description,
      List<IssueTypeScreenSchemeMapping>? issueTypeMappings,
      String? name}) {
    return IssueTypeScreenSchemeDetails(
      description: description ?? this.description,
      issueTypeMappings: issueTypeMappings ?? this.issueTypeMappings,
      name: name ?? this.name,
    );
  }
}

/// The ID of an issue type screen scheme.
class IssueTypeScreenSchemeId {
  /// The ID of the issue type screen scheme.
  final String id;

  IssueTypeScreenSchemeId({required this.id});

  factory IssueTypeScreenSchemeId.fromJson(Map<String, Object?> json) {
    return IssueTypeScreenSchemeId(
      id: json[r'id'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  IssueTypeScreenSchemeId copyWith({String? id}) {
    return IssueTypeScreenSchemeId(
      id: id ?? this.id,
    );
  }
}

/// The screen scheme for an issue type.
class IssueTypeScreenSchemeItem {
  /// The ID of the issue type or *default*. Only issue types used in classic
  /// projects are accepted. When creating an issue screen scheme, an entry for
  /// *default* must be provided and defines the mapping for all issue types
  /// without a screen scheme. Otherwise, a *default* entry can't be provided.
  final String issueTypeId;

  /// The ID of the issue type screen scheme.
  final String issueTypeScreenSchemeId;

  /// The ID of the screen scheme.
  final String screenSchemeId;

  IssueTypeScreenSchemeItem(
      {required this.issueTypeId,
      required this.issueTypeScreenSchemeId,
      required this.screenSchemeId});

  factory IssueTypeScreenSchemeItem.fromJson(Map<String, Object?> json) {
    return IssueTypeScreenSchemeItem(
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
      issueTypeScreenSchemeId:
          json[r'issueTypeScreenSchemeId'] as String? ?? '',
      screenSchemeId: json[r'screenSchemeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeId = this.issueTypeId;
    var issueTypeScreenSchemeId = this.issueTypeScreenSchemeId;
    var screenSchemeId = this.screenSchemeId;

    final json = <String, Object?>{};
    json[r'issueTypeId'] = issueTypeId;
    json[r'issueTypeScreenSchemeId'] = issueTypeScreenSchemeId;
    json[r'screenSchemeId'] = screenSchemeId;
    return json;
  }

  IssueTypeScreenSchemeItem copyWith(
      {String? issueTypeId,
      String? issueTypeScreenSchemeId,
      String? screenSchemeId}) {
    return IssueTypeScreenSchemeItem(
      issueTypeId: issueTypeId ?? this.issueTypeId,
      issueTypeScreenSchemeId:
          issueTypeScreenSchemeId ?? this.issueTypeScreenSchemeId,
      screenSchemeId: screenSchemeId ?? this.screenSchemeId,
    );
  }
}

/// The IDs of the screen schemes for the issue type IDs.
class IssueTypeScreenSchemeMapping {
  /// The ID of the issue type or *default*. Only issue types used in classic
  /// projects are accepted. An entry for *default* must be provided and defines
  /// the mapping for all issue types without a screen scheme.
  final String issueTypeId;

  /// The ID of the screen scheme. Only screen schemes used in classic projects
  /// are accepted.
  final String screenSchemeId;

  IssueTypeScreenSchemeMapping(
      {required this.issueTypeId, required this.screenSchemeId});

  factory IssueTypeScreenSchemeMapping.fromJson(Map<String, Object?> json) {
    return IssueTypeScreenSchemeMapping(
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
      screenSchemeId: json[r'screenSchemeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeId = this.issueTypeId;
    var screenSchemeId = this.screenSchemeId;

    final json = <String, Object?>{};
    json[r'issueTypeId'] = issueTypeId;
    json[r'screenSchemeId'] = screenSchemeId;
    return json;
  }

  IssueTypeScreenSchemeMapping copyWith(
      {String? issueTypeId, String? screenSchemeId}) {
    return IssueTypeScreenSchemeMapping(
      issueTypeId: issueTypeId ?? this.issueTypeId,
      screenSchemeId: screenSchemeId ?? this.screenSchemeId,
    );
  }
}

/// A list of issue type screen scheme mappings.
class IssueTypeScreenSchemeMappingDetails {
  /// The list of issue type to screen scheme mappings. A *default* entry cannot
  /// be specified because a default entry is added when an issue type screen
  /// scheme is created.
  final List<IssueTypeScreenSchemeMapping> issueTypeMappings;

  IssueTypeScreenSchemeMappingDetails({required this.issueTypeMappings});

  factory IssueTypeScreenSchemeMappingDetails.fromJson(
      Map<String, Object?> json) {
    return IssueTypeScreenSchemeMappingDetails(
      issueTypeMappings: (json[r'issueTypeMappings'] as List<Object?>?)
              ?.map((i) => IssueTypeScreenSchemeMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeMappings = this.issueTypeMappings;

    final json = <String, Object?>{};
    json[r'issueTypeMappings'] =
        issueTypeMappings.map((i) => i.toJson()).toList();
    return json;
  }

  IssueTypeScreenSchemeMappingDetails copyWith(
      {List<IssueTypeScreenSchemeMapping>? issueTypeMappings}) {
    return IssueTypeScreenSchemeMappingDetails(
      issueTypeMappings: issueTypeMappings ?? this.issueTypeMappings,
    );
  }
}

/// Associated issue type screen scheme and project.
class IssueTypeScreenSchemeProjectAssociation {
  /// The ID of the issue type screen scheme.
  final String? issueTypeScreenSchemeId;

  /// The ID of the project.
  final String? projectId;

  IssueTypeScreenSchemeProjectAssociation(
      {this.issueTypeScreenSchemeId, this.projectId});

  factory IssueTypeScreenSchemeProjectAssociation.fromJson(
      Map<String, Object?> json) {
    return IssueTypeScreenSchemeProjectAssociation(
      issueTypeScreenSchemeId: json[r'issueTypeScreenSchemeId'] as String?,
      projectId: json[r'projectId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeScreenSchemeId = this.issueTypeScreenSchemeId;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    if (issueTypeScreenSchemeId != null) {
      json[r'issueTypeScreenSchemeId'] = issueTypeScreenSchemeId;
    }
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    return json;
  }

  IssueTypeScreenSchemeProjectAssociation copyWith(
      {String? issueTypeScreenSchemeId, String? projectId}) {
    return IssueTypeScreenSchemeProjectAssociation(
      issueTypeScreenSchemeId:
          issueTypeScreenSchemeId ?? this.issueTypeScreenSchemeId,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// Details of an issue type screen scheme.
class IssueTypeScreenSchemeUpdateDetails {
  /// The description of the issue type screen scheme. The maximum length is 255
  /// characters.
  final String? description;

  /// The name of the issue type screen scheme. The name must be unique. The
  /// maximum length is 255 characters.
  final String? name;

  IssueTypeScreenSchemeUpdateDetails({this.description, this.name});

  factory IssueTypeScreenSchemeUpdateDetails.fromJson(
      Map<String, Object?> json) {
    return IssueTypeScreenSchemeUpdateDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  IssueTypeScreenSchemeUpdateDetails copyWith(
      {String? description, String? name}) {
    return IssueTypeScreenSchemeUpdateDetails(
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// Issue type screen scheme with a list of the projects that use it.
class IssueTypeScreenSchemesProjects {
  /// Details of an issue type screen scheme.
  final IssueTypeScreenScheme issueTypeScreenScheme;

  /// The IDs of the projects using the issue type screen scheme.
  final List<String> projectIds;

  IssueTypeScreenSchemesProjects(
      {required this.issueTypeScreenScheme, required this.projectIds});

  factory IssueTypeScreenSchemesProjects.fromJson(Map<String, Object?> json) {
    return IssueTypeScreenSchemesProjects(
      issueTypeScreenScheme: IssueTypeScreenScheme.fromJson(
          json[r'issueTypeScreenScheme'] as Map<String, Object?>? ?? const {}),
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeScreenScheme = this.issueTypeScreenScheme;
    var projectIds = this.projectIds;

    final json = <String, Object?>{};
    json[r'issueTypeScreenScheme'] = issueTypeScreenScheme.toJson();
    json[r'projectIds'] = projectIds;
    return json;
  }

  IssueTypeScreenSchemesProjects copyWith(
      {IssueTypeScreenScheme? issueTypeScreenScheme,
      List<String>? projectIds}) {
    return IssueTypeScreenSchemesProjects(
      issueTypeScreenScheme:
          issueTypeScreenScheme ?? this.issueTypeScreenScheme,
      projectIds: projectIds ?? this.projectIds,
    );
  }
}

/// Mapping of an issue type to a context.
class IssueTypeToContextMapping {
  /// The ID of the context.
  final String contextId;

  /// Whether the context is mapped to any issue type.
  final bool isAnyIssueType;

  /// The ID of the issue type.
  final String? issueTypeId;

  IssueTypeToContextMapping(
      {required this.contextId, bool? isAnyIssueType, this.issueTypeId})
      : isAnyIssueType = isAnyIssueType ?? false;

  factory IssueTypeToContextMapping.fromJson(Map<String, Object?> json) {
    return IssueTypeToContextMapping(
      contextId: json[r'contextId'] as String? ?? '',
      isAnyIssueType: json[r'isAnyIssueType'] as bool? ?? false,
      issueTypeId: json[r'issueTypeId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var contextId = this.contextId;
    var isAnyIssueType = this.isAnyIssueType;
    var issueTypeId = this.issueTypeId;

    final json = <String, Object?>{};
    json[r'contextId'] = contextId;
    json[r'isAnyIssueType'] = isAnyIssueType;
    if (issueTypeId != null) {
      json[r'issueTypeId'] = issueTypeId;
    }
    return json;
  }

  IssueTypeToContextMapping copyWith(
      {String? contextId, bool? isAnyIssueType, String? issueTypeId}) {
    return IssueTypeToContextMapping(
      contextId: contextId ?? this.contextId,
      isAnyIssueType: isAnyIssueType ?? this.isAnyIssueType,
      issueTypeId: issueTypeId ?? this.issueTypeId,
    );
  }
}

class IssueTypeUpdateBean {
  /// The ID of an issue type avatar.
  final int? avatarId;

  /// The description of the issue type.
  final String? description;

  /// The unique name for the issue type. The maximum length is 60 characters.
  final String? name;

  IssueTypeUpdateBean({this.avatarId, this.description, this.name});

  factory IssueTypeUpdateBean.fromJson(Map<String, Object?> json) {
    return IssueTypeUpdateBean(
      avatarId: (json[r'avatarId'] as num?)?.toInt(),
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var avatarId = this.avatarId;
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (avatarId != null) {
      json[r'avatarId'] = avatarId;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  IssueTypeUpdateBean copyWith(
      {int? avatarId, String? description, String? name}) {
    return IssueTypeUpdateBean(
      avatarId: avatarId ?? this.avatarId,
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// Status details for an issue type.
class IssueTypeWithStatus {
  /// The ID of the issue type.
  final String id;

  /// The name of the issue type.
  final String name;

  /// The URL of the issue type's status details.
  final String self;

  /// List of status details for the issue type.
  final List<StatusDetails> statuses;

  /// Whether this issue type represents subtasks.
  final bool subtask;

  IssueTypeWithStatus(
      {required this.id,
      required this.name,
      required this.self,
      required this.statuses,
      required this.subtask});

  factory IssueTypeWithStatus.fromJson(Map<String, Object?> json) {
    return IssueTypeWithStatus(
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      self: json[r'self'] as String? ?? '',
      statuses: (json[r'statuses'] as List<Object?>?)
              ?.map((i) => StatusDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      subtask: json[r'subtask'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var self = this.self;
    var statuses = this.statuses;
    var subtask = this.subtask;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    json[r'self'] = self;
    json[r'statuses'] = statuses.map((i) => i.toJson()).toList();
    json[r'subtask'] = subtask;
    return json;
  }

  IssueTypeWithStatus copyWith(
      {String? id,
      String? name,
      String? self,
      List<StatusDetails>? statuses,
      bool? subtask}) {
    return IssueTypeWithStatus(
      id: id ?? this.id,
      name: name ?? this.name,
      self: self ?? this.self,
      statuses: statuses ?? this.statuses,
      subtask: subtask ?? this.subtask,
    );
  }
}

/// Details about the mapping between an issue type and a workflow.
class IssueTypeWorkflowMapping {
  /// The ID of the issue type. Not required if updating the issue type-workflow
  /// mapping.
  final String? issueType;

  /// Set to true to create or update the draft of a workflow scheme and update
  /// the mapping in the draft, when the workflow scheme cannot be edited.
  /// Defaults to `false`. Only applicable when updating the workflow-issue
  /// types mapping.
  final bool updateDraftIfNeeded;

  /// The name of the workflow.
  final String? workflow;

  IssueTypeWorkflowMapping(
      {this.issueType, bool? updateDraftIfNeeded, this.workflow})
      : updateDraftIfNeeded = updateDraftIfNeeded ?? false;

  factory IssueTypeWorkflowMapping.fromJson(Map<String, Object?> json) {
    return IssueTypeWorkflowMapping(
      issueType: json[r'issueType'] as String?,
      updateDraftIfNeeded: json[r'updateDraftIfNeeded'] as bool? ?? false,
      workflow: json[r'workflow'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var issueType = this.issueType;
    var updateDraftIfNeeded = this.updateDraftIfNeeded;
    var workflow = this.workflow;

    final json = <String, Object?>{};
    if (issueType != null) {
      json[r'issueType'] = issueType;
    }
    json[r'updateDraftIfNeeded'] = updateDraftIfNeeded;
    if (workflow != null) {
      json[r'workflow'] = workflow;
    }
    return json;
  }

  IssueTypeWorkflowMapping copyWith(
      {String? issueType, bool? updateDraftIfNeeded, String? workflow}) {
    return IssueTypeWorkflowMapping(
      issueType: issueType ?? this.issueType,
      updateDraftIfNeeded: updateDraftIfNeeded ?? this.updateDraftIfNeeded,
      workflow: workflow ?? this.workflow,
    );
  }
}

/// Details about the mapping between issue types and a workflow.
class IssueTypesWorkflowMapping {
  /// Whether the workflow is the default workflow for the workflow scheme.
  final bool defaultMapping;

  /// The list of issue type IDs.
  final List<String> issueTypes;

  /// Whether a draft workflow scheme is created or updated when updating an
  /// active workflow scheme. The draft is updated with the new workflow-issue
  /// types mapping. Defaults to `false`.
  final bool updateDraftIfNeeded;

  /// The name of the workflow. Optional if updating the workflow-issue types
  /// mapping.
  final String? workflow;

  IssueTypesWorkflowMapping(
      {bool? defaultMapping,
      List<String>? issueTypes,
      bool? updateDraftIfNeeded,
      this.workflow})
      : defaultMapping = defaultMapping ?? false,
        issueTypes = issueTypes ?? [],
        updateDraftIfNeeded = updateDraftIfNeeded ?? false;

  factory IssueTypesWorkflowMapping.fromJson(Map<String, Object?> json) {
    return IssueTypesWorkflowMapping(
      defaultMapping: json[r'defaultMapping'] as bool? ?? false,
      issueTypes: (json[r'issueTypes'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      updateDraftIfNeeded: json[r'updateDraftIfNeeded'] as bool? ?? false,
      workflow: json[r'workflow'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var defaultMapping = this.defaultMapping;
    var issueTypes = this.issueTypes;
    var updateDraftIfNeeded = this.updateDraftIfNeeded;
    var workflow = this.workflow;

    final json = <String, Object?>{};
    json[r'defaultMapping'] = defaultMapping;
    json[r'issueTypes'] = issueTypes;
    json[r'updateDraftIfNeeded'] = updateDraftIfNeeded;
    if (workflow != null) {
      json[r'workflow'] = workflow;
    }
    return json;
  }

  IssueTypesWorkflowMapping copyWith(
      {bool? defaultMapping,
      List<String>? issueTypes,
      bool? updateDraftIfNeeded,
      String? workflow}) {
    return IssueTypesWorkflowMapping(
      defaultMapping: defaultMapping ?? this.defaultMapping,
      issueTypes: issueTypes ?? this.issueTypes,
      updateDraftIfNeeded: updateDraftIfNeeded ?? this.updateDraftIfNeeded,
      workflow: workflow ?? this.workflow,
    );
  }
}

/// Details of an issue update request.
class IssueUpdateDetails {
  /// List of issue screen fields to update, specifying the sub-field to update
  /// and its value for each field. This field provides a straightforward option
  /// when setting a sub-field. When multiple sub-fields or other operations are
  /// required, use `update`. Fields included in here cannot be included in
  /// `update`.
  final Map<String, dynamic>? fields;

  /// Additional issue history details.
  final HistoryMetadata? historyMetadata;

  /// Details of issue properties to be add or update.
  final List<EntityProperty> properties;

  /// Details of a transition. Required when performing a transition, optional
  /// when creating or editing an issue.
  final IssueTransition? transition;

  /// A Map containing the field field name and a list of operations to perform
  /// on the issue screen field. Note that fields included in here cannot be
  /// included in `fields`.
  final Map<String, dynamic>? update;

  IssueUpdateDetails(
      {this.fields,
      this.historyMetadata,
      List<EntityProperty>? properties,
      this.transition,
      this.update})
      : properties = properties ?? [];

  factory IssueUpdateDetails.fromJson(Map<String, Object?> json) {
    return IssueUpdateDetails(
      fields: json[r'fields'] as Map<String, Object?>?,
      historyMetadata: json[r'historyMetadata'] != null
          ? HistoryMetadata.fromJson(
              json[r'historyMetadata']! as Map<String, Object?>)
          : null,
      properties: (json[r'properties'] as List<Object?>?)
              ?.map((i) => EntityProperty.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      transition: json[r'transition'] != null
          ? IssueTransition.fromJson(
              json[r'transition']! as Map<String, Object?>)
          : null,
      update: json[r'update'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var fields = this.fields;
    var historyMetadata = this.historyMetadata;
    var properties = this.properties;
    var transition = this.transition;
    var update = this.update;

    final json = <String, Object?>{};
    if (fields != null) {
      json[r'fields'] = fields;
    }
    if (historyMetadata != null) {
      json[r'historyMetadata'] = historyMetadata.toJson();
    }
    json[r'properties'] = properties.map((i) => i.toJson()).toList();
    if (transition != null) {
      json[r'transition'] = transition.toJson();
    }
    if (update != null) {
      json[r'update'] = update;
    }
    return json;
  }

  IssueUpdateDetails copyWith(
      {Map<String, dynamic>? fields,
      HistoryMetadata? historyMetadata,
      List<EntityProperty>? properties,
      IssueTransition? transition,
      Map<String, dynamic>? update}) {
    return IssueUpdateDetails(
      fields: fields ?? this.fields,
      historyMetadata: historyMetadata ?? this.historyMetadata,
      properties: properties ?? this.properties,
      transition: transition ?? this.transition,
      update: update ?? this.update,
    );
  }
}

/// A list of editable field details.
class IssueUpdateMetadata {
  /// A list of editable field details.
  final Map<String, dynamic>? fields;

  IssueUpdateMetadata({this.fields});

  factory IssueUpdateMetadata.fromJson(Map<String, Object?> json) {
    return IssueUpdateMetadata(
      fields: json[r'fields'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var fields = this.fields;

    final json = <String, Object?>{};
    if (fields != null) {
      json[r'fields'] = fields;
    }
    return json;
  }

  IssueUpdateMetadata copyWith({Map<String, dynamic>? fields}) {
    return IssueUpdateMetadata(
      fields: fields ?? this.fields,
    );
  }
}

/// List of issues and JQL queries.
class IssuesAndJQLQueries {
  /// A list of issue IDs.
  final List<int> issueIds;

  /// A list of JQL queries.
  final List<String> jqls;

  IssuesAndJQLQueries({required this.issueIds, required this.jqls});

  factory IssuesAndJQLQueries.fromJson(Map<String, Object?> json) {
    return IssuesAndJQLQueries(
      issueIds: (json[r'issueIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      jqls: (json[r'jqls'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueIds = this.issueIds;
    var jqls = this.jqls;

    final json = <String, Object?>{};
    json[r'issueIds'] = issueIds;
    json[r'jqls'] = jqls;
    return json;
  }

  IssuesAndJQLQueries copyWith({List<int>? issueIds, List<String>? jqls}) {
    return IssuesAndJQLQueries(
      issueIds: issueIds ?? this.issueIds,
      jqls: jqls ?? this.jqls,
    );
  }
}

/// The description of the page of issues loaded by the provided JQL query.
class IssuesJqlMetaDataBean {
  /// The number of issues that were loaded in this evaluation.
  final int count;

  /// The maximum number of issues that could be loaded in this evaluation.
  final int maxResults;

  /// The index of the first issue.
  final int startAt;

  /// The total number of issues the JQL returned.
  final int totalCount;

  /// Any warnings related to the JQL query. Present only if the validation mode
  /// was set to `warn`.
  final List<String> validationWarnings;

  IssuesJqlMetaDataBean(
      {required this.count,
      required this.maxResults,
      required this.startAt,
      required this.totalCount,
      List<String>? validationWarnings})
      : validationWarnings = validationWarnings ?? [];

  factory IssuesJqlMetaDataBean.fromJson(Map<String, Object?> json) {
    return IssuesJqlMetaDataBean(
      count: (json[r'count'] as num?)?.toInt() ?? 0,
      maxResults: (json[r'maxResults'] as num?)?.toInt() ?? 0,
      startAt: (json[r'startAt'] as num?)?.toInt() ?? 0,
      totalCount: (json[r'totalCount'] as num?)?.toInt() ?? 0,
      validationWarnings: (json[r'validationWarnings'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var count = this.count;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var totalCount = this.totalCount;
    var validationWarnings = this.validationWarnings;

    final json = <String, Object?>{};
    json[r'count'] = count;
    json[r'maxResults'] = maxResults;
    json[r'startAt'] = startAt;
    json[r'totalCount'] = totalCount;
    json[r'validationWarnings'] = validationWarnings;
    return json;
  }

  IssuesJqlMetaDataBean copyWith(
      {int? count,
      int? maxResults,
      int? startAt,
      int? totalCount,
      List<String>? validationWarnings}) {
    return IssuesJqlMetaDataBean(
      count: count ?? this.count,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      totalCount: totalCount ?? this.totalCount,
      validationWarnings: validationWarnings ?? this.validationWarnings,
    );
  }
}

/// Meta data describing the `issues` context variable.
class IssuesMetaBean {
  final IssuesJqlMetaDataBean? jql;

  IssuesMetaBean({this.jql});

  factory IssuesMetaBean.fromJson(Map<String, Object?> json) {
    return IssuesMetaBean(
      jql: json[r'jql'] != null
          ? IssuesJqlMetaDataBean.fromJson(
              json[r'jql']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var jql = this.jql;

    final json = <String, Object?>{};
    if (jql != null) {
      json[r'jql'] = jql.toJson();
    }
    return json;
  }

  IssuesMetaBean copyWith({IssuesJqlMetaDataBean? jql}) {
    return IssuesMetaBean(
      jql: jql ?? this.jql,
    );
  }
}

class IssuesUpdateBean {
  final List<IssueUpdateDetails> issueUpdates;

  IssuesUpdateBean({List<IssueUpdateDetails>? issueUpdates})
      : issueUpdates = issueUpdates ?? [];

  factory IssuesUpdateBean.fromJson(Map<String, Object?> json) {
    return IssuesUpdateBean(
      issueUpdates: (json[r'issueUpdates'] as List<Object?>?)
              ?.map((i) => IssueUpdateDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueUpdates = this.issueUpdates;

    final json = <String, Object?>{};
    json[r'issueUpdates'] = issueUpdates.map((i) => i.toJson()).toList();
    return json;
  }

  IssuesUpdateBean copyWith({List<IssueUpdateDetails>? issueUpdates}) {
    return IssuesUpdateBean(
      issueUpdates: issueUpdates ?? this.issueUpdates,
    );
  }
}

/// The JQL queries to be converted.
class JQLPersonalDataMigrationRequest {
  /// A list of queries with user identifiers. Maximum of 100 queries.
  final List<String> queryStrings;

  JQLPersonalDataMigrationRequest({List<String>? queryStrings})
      : queryStrings = queryStrings ?? [];

  factory JQLPersonalDataMigrationRequest.fromJson(Map<String, Object?> json) {
    return JQLPersonalDataMigrationRequest(
      queryStrings: (json[r'queryStrings'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var queryStrings = this.queryStrings;

    final json = <String, Object?>{};
    json[r'queryStrings'] = queryStrings;
    return json;
  }

  JQLPersonalDataMigrationRequest copyWith({List<String>? queryStrings}) {
    return JQLPersonalDataMigrationRequest(
      queryStrings: queryStrings ?? this.queryStrings,
    );
  }
}

/// JQL queries that contained users that could not be found
class JQLQueryWithUnknownUsers {
  /// The converted query, with accountIDs instead of user identifiers, or
  /// 'unknown' for users that could not be found
  final String? convertedQuery;

  /// The original query, for reference
  final String? originalQuery;

  JQLQueryWithUnknownUsers({this.convertedQuery, this.originalQuery});

  factory JQLQueryWithUnknownUsers.fromJson(Map<String, Object?> json) {
    return JQLQueryWithUnknownUsers(
      convertedQuery: json[r'convertedQuery'] as String?,
      originalQuery: json[r'originalQuery'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var convertedQuery = this.convertedQuery;
    var originalQuery = this.originalQuery;

    final json = <String, Object?>{};
    if (convertedQuery != null) {
      json[r'convertedQuery'] = convertedQuery;
    }
    if (originalQuery != null) {
      json[r'originalQuery'] = originalQuery;
    }
    return json;
  }

  JQLQueryWithUnknownUsers copyWith(
      {String? convertedQuery, String? originalQuery}) {
    return JQLQueryWithUnknownUsers(
      convertedQuery: convertedQuery ?? this.convertedQuery,
      originalQuery: originalQuery ?? this.originalQuery,
    );
  }
}

/// Lists of JQL reference data.
class JQLReferenceData {
  /// List of JQL query reserved words.
  final List<String> jqlReservedWords;

  /// List of fields usable in JQL queries.
  final List<FieldReferenceData> visibleFieldNames;

  /// List of functions usable in JQL queries.
  final List<FunctionReferenceData> visibleFunctionNames;

  JQLReferenceData(
      {List<String>? jqlReservedWords,
      List<FieldReferenceData>? visibleFieldNames,
      List<FunctionReferenceData>? visibleFunctionNames})
      : jqlReservedWords = jqlReservedWords ?? [],
        visibleFieldNames = visibleFieldNames ?? [],
        visibleFunctionNames = visibleFunctionNames ?? [];

  factory JQLReferenceData.fromJson(Map<String, Object?> json) {
    return JQLReferenceData(
      jqlReservedWords: (json[r'jqlReservedWords'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      visibleFieldNames: (json[r'visibleFieldNames'] as List<Object?>?)
              ?.map((i) => FieldReferenceData.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      visibleFunctionNames: (json[r'visibleFunctionNames'] as List<Object?>?)
              ?.map((i) => FunctionReferenceData.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var jqlReservedWords = this.jqlReservedWords;
    var visibleFieldNames = this.visibleFieldNames;
    var visibleFunctionNames = this.visibleFunctionNames;

    final json = <String, Object?>{};
    json[r'jqlReservedWords'] = jqlReservedWords;
    json[r'visibleFieldNames'] =
        visibleFieldNames.map((i) => i.toJson()).toList();
    json[r'visibleFunctionNames'] =
        visibleFunctionNames.map((i) => i.toJson()).toList();
    return json;
  }

  JQLReferenceData copyWith(
      {List<String>? jqlReservedWords,
      List<FieldReferenceData>? visibleFieldNames,
      List<FunctionReferenceData>? visibleFunctionNames}) {
    return JQLReferenceData(
      jqlReservedWords: jqlReservedWords ?? this.jqlReservedWords,
      visibleFieldNames: visibleFieldNames ?? this.visibleFieldNames,
      visibleFunctionNames: visibleFunctionNames ?? this.visibleFunctionNames,
    );
  }
}

/// The JQL specifying the issues available in the evaluated Jira expression
/// under the `issues` context variable.
class JexpIssues {
  /// The JQL query that specifies the set of issues available in the Jira
  /// expression.
  final JexpJqlIssues? jql;

  JexpIssues({this.jql});

  factory JexpIssues.fromJson(Map<String, Object?> json) {
    return JexpIssues(
      jql: json[r'jql'] != null
          ? JexpJqlIssues.fromJson(json[r'jql']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var jql = this.jql;

    final json = <String, Object?>{};
    if (jql != null) {
      json[r'jql'] = jql.toJson();
    }
    return json;
  }

  JexpIssues copyWith({JexpJqlIssues? jql}) {
    return JexpIssues(
      jql: jql ?? this.jql,
    );
  }
}

/// The JQL specifying the issues available in the evaluated Jira expression
/// under the `issues` context variable. Not all issues returned by the JQL
/// query are loaded, only those described by the `startAt` and `maxResults`
/// properties. To determine whether it is necessary to iterate to ensure all
/// the issues returned by the JQL query are evaluated, inspect
/// `meta.issues.jql.count` in the response.
class JexpJqlIssues {
  /// The maximum number of issues to return from the JQL query. Inspect
  /// `meta.issues.jql.maxResults` in the response to ensure the maximum value
  /// has not been exceeded.
  final int? maxResults;

  /// The JQL query.
  final String? query;

  /// The index of the first issue to return from the JQL query.
  final int? startAt;

  /// Determines how to validate the JQL query and treat the validation results.
  final JexpJqlIssuesValidation? validation;

  JexpJqlIssues({this.maxResults, this.query, this.startAt, this.validation});

  factory JexpJqlIssues.fromJson(Map<String, Object?> json) {
    return JexpJqlIssues(
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      query: json[r'query'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      validation: json[r'validation'] != null
          ? JexpJqlIssuesValidation.fromValue(json[r'validation']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var maxResults = this.maxResults;
    var query = this.query;
    var startAt = this.startAt;
    var validation = this.validation;

    final json = <String, Object?>{};
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (query != null) {
      json[r'query'] = query;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (validation != null) {
      json[r'validation'] = validation.value;
    }
    return json;
  }

  JexpJqlIssues copyWith(
      {int? maxResults,
      String? query,
      int? startAt,
      JexpJqlIssuesValidation? validation}) {
    return JexpJqlIssues(
      maxResults: maxResults ?? this.maxResults,
      query: query ?? this.query,
      startAt: startAt ?? this.startAt,
      validation: validation ?? this.validation,
    );
  }
}

class JexpJqlIssuesValidation {
  static const strict = JexpJqlIssuesValidation._('strict');
  static const warn = JexpJqlIssuesValidation._('warn');
  static const none = JexpJqlIssuesValidation._('none');

  static const values = [
    strict,
    warn,
    none,
  ];
  final String value;

  const JexpJqlIssuesValidation._(this.value);

  static JexpJqlIssuesValidation fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JexpJqlIssuesValidation._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about the analysed Jira expression.
class JiraExpressionAnalysis {
  final JiraExpressionComplexity? complexity;

  /// A list of validation errors. Not included if the expression is valid.
  final List<JiraExpressionValidationError> errors;

  /// The analysed expression.
  final String expression;

  /// EXPERIMENTAL. The inferred type of the expression.
  final String? type;

  /// Whether the expression is valid and the interpreter will evaluate it. Note
  /// that the expression may fail at runtime (for example, if it executes too
  /// many expensive operations).
  final bool valid;

  JiraExpressionAnalysis(
      {this.complexity,
      List<JiraExpressionValidationError>? errors,
      required this.expression,
      this.type,
      required this.valid})
      : errors = errors ?? [];

  factory JiraExpressionAnalysis.fromJson(Map<String, Object?> json) {
    return JiraExpressionAnalysis(
      complexity: json[r'complexity'] != null
          ? JiraExpressionComplexity.fromJson(
              json[r'complexity']! as Map<String, Object?>)
          : null,
      errors: (json[r'errors'] as List<Object?>?)
              ?.map((i) => JiraExpressionValidationError.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      expression: json[r'expression'] as String? ?? '',
      type: json[r'type'] as String?,
      valid: json[r'valid'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var complexity = this.complexity;
    var errors = this.errors;
    var expression = this.expression;
    var type = this.type;
    var valid = this.valid;

    final json = <String, Object?>{};
    if (complexity != null) {
      json[r'complexity'] = complexity.toJson();
    }
    json[r'errors'] = errors.map((i) => i.toJson()).toList();
    json[r'expression'] = expression;
    if (type != null) {
      json[r'type'] = type;
    }
    json[r'valid'] = valid;
    return json;
  }

  JiraExpressionAnalysis copyWith(
      {JiraExpressionComplexity? complexity,
      List<JiraExpressionValidationError>? errors,
      String? expression,
      String? type,
      bool? valid}) {
    return JiraExpressionAnalysis(
      complexity: complexity ?? this.complexity,
      errors: errors ?? this.errors,
      expression: expression ?? this.expression,
      type: type ?? this.type,
      valid: valid ?? this.valid,
    );
  }
}

/// Details about the complexity of the analysed Jira expression.
class JiraExpressionComplexity {
  /// Information that can be used to determine how many
  /// [expensive operations](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#expensive-operations)
  /// the evaluation of the expression will perform. This information may be a
  /// formula or number. For example:
  ///
  ///  *  `issues.map(i => i.comments)` performs as many expensive operations as
  /// there are issues on the issues list. So this parameter returns `N`, where
  /// `N` is the size of issue list.
  ///  *  `new Issue(10010).comments` gets comments for one issue, so its
  /// complexity is `2` (`1` to retrieve issue 10010 from the database plus `1`
  /// to get its comments).
  final String expensiveOperations;

  /// Variables used in the formula, mapped to the parts of the expression they
  /// refer to.
  final Map<String, dynamic>? variables;

  JiraExpressionComplexity({required this.expensiveOperations, this.variables});

  factory JiraExpressionComplexity.fromJson(Map<String, Object?> json) {
    return JiraExpressionComplexity(
      expensiveOperations: json[r'expensiveOperations'] as String? ?? '',
      variables: json[r'variables'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var expensiveOperations = this.expensiveOperations;
    var variables = this.variables;

    final json = <String, Object?>{};
    json[r'expensiveOperations'] = expensiveOperations;
    if (variables != null) {
      json[r'variables'] = variables;
    }
    return json;
  }

  JiraExpressionComplexity copyWith(
      {String? expensiveOperations, Map<String, dynamic>? variables}) {
    return JiraExpressionComplexity(
      expensiveOperations: expensiveOperations ?? this.expensiveOperations,
      variables: variables ?? this.variables,
    );
  }
}

class JiraExpressionEvalContextBean {
  /// The ID of the board that is available under the `board` variable when
  /// evaluating the expression.
  final int? board;

  /// Custom context variables and their types. These variable types are
  /// available for use in a custom context:
  ///
  ///  *  `user`: A
  /// [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user)
  /// specified as an Atlassian account ID.
  ///  *  `issue`: An
  /// [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue)
  /// specified by ID or key. All the fields of the issue object are available
  /// in the Jira expression.
  ///  *  `json`: A JSON object containing custom content.
  ///  *  `list`: A JSON list of `user`, `issue`, or `json` variable types.
  final List<CustomContextVariable> custom;

  /// The ID of the customer request that is available under the
  /// `customerRequest` variable when evaluating the expression. This is the
  /// same as the ID of the underlying Jira issue, but the customer request
  /// context variable will have a different type.
  final int? customerRequest;

  /// The issue that is available under the `issue` variable when evaluating the
  /// expression.
  final IdOrKeyBean? issue;

  /// The collection of issues that is available under the `issues` variable
  /// when evaluating the expression.
  final JexpIssues? issues;

  /// The project that is available under the `project` variable when evaluating
  /// the expression.
  final IdOrKeyBean? project;

  /// The ID of the service desk that is available under the `serviceDesk`
  /// variable when evaluating the expression.
  final int? serviceDesk;

  /// The ID of the sprint that is available under the `sprint` variable when
  /// evaluating the expression.
  final int? sprint;

  JiraExpressionEvalContextBean(
      {this.board,
      List<CustomContextVariable>? custom,
      this.customerRequest,
      this.issue,
      this.issues,
      this.project,
      this.serviceDesk,
      this.sprint})
      : custom = custom ?? [];

  factory JiraExpressionEvalContextBean.fromJson(Map<String, Object?> json) {
    return JiraExpressionEvalContextBean(
      board: (json[r'board'] as num?)?.toInt(),
      custom: (json[r'custom'] as List<Object?>?)
              ?.map((i) => CustomContextVariable.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      customerRequest: (json[r'customerRequest'] as num?)?.toInt(),
      issue: json[r'issue'] != null
          ? IdOrKeyBean.fromJson(json[r'issue']! as Map<String, Object?>)
          : null,
      issues: json[r'issues'] != null
          ? JexpIssues.fromJson(json[r'issues']! as Map<String, Object?>)
          : null,
      project: json[r'project'] != null
          ? IdOrKeyBean.fromJson(json[r'project']! as Map<String, Object?>)
          : null,
      serviceDesk: (json[r'serviceDesk'] as num?)?.toInt(),
      sprint: (json[r'sprint'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var board = this.board;
    var custom = this.custom;
    var customerRequest = this.customerRequest;
    var issue = this.issue;
    var issues = this.issues;
    var project = this.project;
    var serviceDesk = this.serviceDesk;
    var sprint = this.sprint;

    final json = <String, Object?>{};
    if (board != null) {
      json[r'board'] = board;
    }
    json[r'custom'] = custom.map((i) => i.toJson()).toList();
    if (customerRequest != null) {
      json[r'customerRequest'] = customerRequest;
    }
    if (issue != null) {
      json[r'issue'] = issue.toJson();
    }
    if (issues != null) {
      json[r'issues'] = issues.toJson();
    }
    if (project != null) {
      json[r'project'] = project.toJson();
    }
    if (serviceDesk != null) {
      json[r'serviceDesk'] = serviceDesk;
    }
    if (sprint != null) {
      json[r'sprint'] = sprint;
    }
    return json;
  }

  JiraExpressionEvalContextBean copyWith(
      {int? board,
      List<CustomContextVariable>? custom,
      int? customerRequest,
      IdOrKeyBean? issue,
      JexpIssues? issues,
      IdOrKeyBean? project,
      int? serviceDesk,
      int? sprint}) {
    return JiraExpressionEvalContextBean(
      board: board ?? this.board,
      custom: custom ?? this.custom,
      customerRequest: customerRequest ?? this.customerRequest,
      issue: issue ?? this.issue,
      issues: issues ?? this.issues,
      project: project ?? this.project,
      serviceDesk: serviceDesk ?? this.serviceDesk,
      sprint: sprint ?? this.sprint,
    );
  }
}

class JiraExpressionEvalRequestBean {
  /// The context in which the Jira expression is evaluated.
  final JiraExpressionEvalContextBean? context;

  /// The Jira expression to evaluate.
  final String expression;

  JiraExpressionEvalRequestBean({this.context, required this.expression});

  factory JiraExpressionEvalRequestBean.fromJson(Map<String, Object?> json) {
    return JiraExpressionEvalRequestBean(
      context: json[r'context'] != null
          ? JiraExpressionEvalContextBean.fromJson(
              json[r'context']! as Map<String, Object?>)
          : null,
      expression: json[r'expression'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var context = this.context;
    var expression = this.expression;

    final json = <String, Object?>{};
    if (context != null) {
      json[r'context'] = context.toJson();
    }
    json[r'expression'] = expression;
    return json;
  }

  JiraExpressionEvalRequestBean copyWith(
      {JiraExpressionEvalContextBean? context, String? expression}) {
    return JiraExpressionEvalRequestBean(
      context: context ?? this.context,
      expression: expression ?? this.expression,
    );
  }
}

class JiraExpressionEvaluationMetaDataBean {
  /// Contains information about the expression complexity. For example, the
  /// number of steps it took to evaluate the expression.
  final JiraExpressionsComplexityBean? complexity;

  /// Contains information about the `issues` variable in the context. For
  /// example, is the issues were loaded with JQL, information about the page
  /// will be included here.
  final IssuesMetaBean? issues;

  JiraExpressionEvaluationMetaDataBean({this.complexity, this.issues});

  factory JiraExpressionEvaluationMetaDataBean.fromJson(
      Map<String, Object?> json) {
    return JiraExpressionEvaluationMetaDataBean(
      complexity: json[r'complexity'] != null
          ? JiraExpressionsComplexityBean.fromJson(
              json[r'complexity']! as Map<String, Object?>)
          : null,
      issues: json[r'issues'] != null
          ? IssuesMetaBean.fromJson(json[r'issues']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var complexity = this.complexity;
    var issues = this.issues;

    final json = <String, Object?>{};
    if (complexity != null) {
      json[r'complexity'] = complexity.toJson();
    }
    if (issues != null) {
      json[r'issues'] = issues.toJson();
    }
    return json;
  }

  JiraExpressionEvaluationMetaDataBean copyWith(
      {JiraExpressionsComplexityBean? complexity, IssuesMetaBean? issues}) {
    return JiraExpressionEvaluationMetaDataBean(
      complexity: complexity ?? this.complexity,
      issues: issues ?? this.issues,
    );
  }
}

/// Details of Jira expressions for analysis.
class JiraExpressionForAnalysis {
  /// Context variables and their types. The type checker assumes that
  /// [common context variables](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#context-variables),
  /// such as `issue` or `project`, are available in context and sets their
  /// type. Use this property to override the default types or provide details
  /// of new variables.
  final Map<String, dynamic>? contextVariables;

  /// The list of Jira expressions to analyse.
  final List<String> expressions;

  JiraExpressionForAnalysis({this.contextVariables, required this.expressions});

  factory JiraExpressionForAnalysis.fromJson(Map<String, Object?> json) {
    return JiraExpressionForAnalysis(
      contextVariables: json[r'contextVariables'] as Map<String, Object?>?,
      expressions: (json[r'expressions'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var contextVariables = this.contextVariables;
    var expressions = this.expressions;

    final json = <String, Object?>{};
    if (contextVariables != null) {
      json[r'contextVariables'] = contextVariables;
    }
    json[r'expressions'] = expressions;
    return json;
  }

  JiraExpressionForAnalysis copyWith(
      {Map<String, dynamic>? contextVariables, List<String>? expressions}) {
    return JiraExpressionForAnalysis(
      contextVariables: contextVariables ?? this.contextVariables,
      expressions: expressions ?? this.expressions,
    );
  }
}

/// The result of evaluating a Jira expression.
class JiraExpressionResult {
  /// Contains various characteristics of the performed expression evaluation.
  final JiraExpressionEvaluationMetaDataBean? meta;

  /// The value of the evaluated expression. It may be a primitive JSON value or
  /// a Jira REST API object. (Some expressions do not produce any meaningful
  /// results—for example, an expression that returns a lambda function—if
  /// that's the case a simple string representation is returned. These string
  /// representations should not be relied upon and may change without notice.)
  final dynamic value;

  JiraExpressionResult({this.meta, required this.value});

  factory JiraExpressionResult.fromJson(Map<String, Object?> json) {
    return JiraExpressionResult(
      meta: json[r'meta'] != null
          ? JiraExpressionEvaluationMetaDataBean.fromJson(
              json[r'meta']! as Map<String, Object?>)
          : null,
      value: json[r'value'],
    );
  }

  Map<String, Object?> toJson() {
    var meta = this.meta;
    var value = this.value;

    final json = <String, Object?>{};
    if (meta != null) {
      json[r'meta'] = meta.toJson();
    }
    json[r'value'] = value;
    return json;
  }

  JiraExpressionResult copyWith(
      {JiraExpressionEvaluationMetaDataBean? meta, dynamic value}) {
    return JiraExpressionResult(
      meta: meta ?? this.meta,
      value: value ?? this.value,
    );
  }
}

/// Details about syntax and type errors. The error details apply to the entire
/// expression, unless the object includes:
///
///  *  `line` and `column`
///  *  `expression`
class JiraExpressionValidationError {
  /// The text column in which the error occurred.
  final int? column;

  /// The part of the expression in which the error occurred.
  final String? expression;

  /// The text line in which the error occurred.
  final int? line;

  /// Details about the error.
  final String message;

  /// The error type.
  final JiraExpressionValidationErrorType type;

  JiraExpressionValidationError(
      {this.column,
      this.expression,
      this.line,
      required this.message,
      required this.type});

  factory JiraExpressionValidationError.fromJson(Map<String, Object?> json) {
    return JiraExpressionValidationError(
      column: (json[r'column'] as num?)?.toInt(),
      expression: json[r'expression'] as String?,
      line: (json[r'line'] as num?)?.toInt(),
      message: json[r'message'] as String? ?? '',
      type: JiraExpressionValidationErrorType.fromValue(
          json[r'type'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var column = this.column;
    var expression = this.expression;
    var line = this.line;
    var message = this.message;
    var type = this.type;

    final json = <String, Object?>{};
    if (column != null) {
      json[r'column'] = column;
    }
    if (expression != null) {
      json[r'expression'] = expression;
    }
    if (line != null) {
      json[r'line'] = line;
    }
    json[r'message'] = message;
    json[r'type'] = type.value;
    return json;
  }

  JiraExpressionValidationError copyWith(
      {int? column,
      String? expression,
      int? line,
      String? message,
      JiraExpressionValidationErrorType? type}) {
    return JiraExpressionValidationError(
      column: column ?? this.column,
      expression: expression ?? this.expression,
      line: line ?? this.line,
      message: message ?? this.message,
      type: type ?? this.type,
    );
  }
}

class JiraExpressionValidationErrorType {
  static const syntax = JiraExpressionValidationErrorType._('syntax');
  static const type = JiraExpressionValidationErrorType._('type');
  static const other = JiraExpressionValidationErrorType._('other');

  static const values = [
    syntax,
    type,
    other,
  ];
  final String value;

  const JiraExpressionValidationErrorType._(this.value);

  static JiraExpressionValidationErrorType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JiraExpressionValidationErrorType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about the analysed Jira expression.
class JiraExpressionsAnalysis {
  /// The results of Jira expressions analysis.
  final List<JiraExpressionAnalysis> results;

  JiraExpressionsAnalysis({required this.results});

  factory JiraExpressionsAnalysis.fromJson(Map<String, Object?> json) {
    return JiraExpressionsAnalysis(
      results: (json[r'results'] as List<Object?>?)
              ?.map((i) => JiraExpressionAnalysis.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var results = this.results;

    final json = <String, Object?>{};
    json[r'results'] = results.map((i) => i.toJson()).toList();
    return json;
  }

  JiraExpressionsAnalysis copyWith({List<JiraExpressionAnalysis>? results}) {
    return JiraExpressionsAnalysis(
      results: results ?? this.results,
    );
  }
}

class JiraExpressionsComplexityBean {
  /// The number of Jira REST API beans returned in the response.
  final JiraExpressionsComplexityValueBean beans;

  /// The number of expensive operations executed while evaluating the
  /// expression. Expensive operations are those that load additional data, such
  /// as entity properties, comments, or custom fields.
  final JiraExpressionsComplexityValueBean expensiveOperations;

  /// The number of primitive values returned in the response.
  final JiraExpressionsComplexityValueBean primitiveValues;

  /// The number of steps it took to evaluate the expression, where a step is a
  /// high-level operation performed by the expression. A step is an operation
  /// such as arithmetic, accessing a property, accessing a context variable, or
  /// calling a function.
  final JiraExpressionsComplexityValueBean steps;

  JiraExpressionsComplexityBean(
      {required this.beans,
      required this.expensiveOperations,
      required this.primitiveValues,
      required this.steps});

  factory JiraExpressionsComplexityBean.fromJson(Map<String, Object?> json) {
    return JiraExpressionsComplexityBean(
      beans: JiraExpressionsComplexityValueBean.fromJson(
          json[r'beans'] as Map<String, Object?>? ?? const {}),
      expensiveOperations: JiraExpressionsComplexityValueBean.fromJson(
          json[r'expensiveOperations'] as Map<String, Object?>? ?? const {}),
      primitiveValues: JiraExpressionsComplexityValueBean.fromJson(
          json[r'primitiveValues'] as Map<String, Object?>? ?? const {}),
      steps: JiraExpressionsComplexityValueBean.fromJson(
          json[r'steps'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var beans = this.beans;
    var expensiveOperations = this.expensiveOperations;
    var primitiveValues = this.primitiveValues;
    var steps = this.steps;

    final json = <String, Object?>{};
    json[r'beans'] = beans.toJson();
    json[r'expensiveOperations'] = expensiveOperations.toJson();
    json[r'primitiveValues'] = primitiveValues.toJson();
    json[r'steps'] = steps.toJson();
    return json;
  }

  JiraExpressionsComplexityBean copyWith(
      {JiraExpressionsComplexityValueBean? beans,
      JiraExpressionsComplexityValueBean? expensiveOperations,
      JiraExpressionsComplexityValueBean? primitiveValues,
      JiraExpressionsComplexityValueBean? steps}) {
    return JiraExpressionsComplexityBean(
      beans: beans ?? this.beans,
      expensiveOperations: expensiveOperations ?? this.expensiveOperations,
      primitiveValues: primitiveValues ?? this.primitiveValues,
      steps: steps ?? this.steps,
    );
  }
}

class JiraExpressionsComplexityValueBean {
  /// The maximum allowed complexity. The evaluation will fail if this value is
  /// exceeded.
  final int limit;

  /// The complexity value of the current expression.
  final int value;

  JiraExpressionsComplexityValueBean(
      {required this.limit, required this.value});

  factory JiraExpressionsComplexityValueBean.fromJson(
      Map<String, Object?> json) {
    return JiraExpressionsComplexityValueBean(
      limit: (json[r'limit'] as num?)?.toInt() ?? 0,
      value: (json[r'value'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var limit = this.limit;
    var value = this.value;

    final json = <String, Object?>{};
    json[r'limit'] = limit;
    json[r'value'] = value;
    return json;
  }

  JiraExpressionsComplexityValueBean copyWith({int? limit, int? value}) {
    return JiraExpressionsComplexityValueBean(
      limit: limit ?? this.limit,
      value: value ?? this.value,
    );
  }
}

/// Details of a status.
class JiraStatus {
  /// The description of the status.
  final String? description;

  /// The ID of the status.
  final String? id;

  /// The name of the status.
  final String? name;
  final StatusScope? scope;

  /// The category of the status.
  final JiraStatusStatusCategory? statusCategory;

  /// Projects and issue types where the status is used. Only available if the
  /// `usages` expand is requested.
  final List<ProjectIssueTypes> usages;

  /// The workflows that use this status. Only available if the `workflowUsages`
  /// expand is requested.
  final List<WorkflowUsages> workflowUsages;

  JiraStatus(
      {this.description,
      this.id,
      this.name,
      this.scope,
      this.statusCategory,
      List<ProjectIssueTypes>? usages,
      List<WorkflowUsages>? workflowUsages})
      : usages = usages ?? [],
        workflowUsages = workflowUsages ?? [];

  factory JiraStatus.fromJson(Map<String, Object?> json) {
    return JiraStatus(
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      scope: json[r'scope'] != null
          ? StatusScope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      statusCategory: json[r'statusCategory'] != null
          ? JiraStatusStatusCategory.fromValue(
              json[r'statusCategory']! as String)
          : null,
      usages: (json[r'usages'] as List<Object?>?)
              ?.map((i) => ProjectIssueTypes.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      workflowUsages: (json[r'workflowUsages'] as List<Object?>?)
              ?.map((i) => WorkflowUsages.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var name = this.name;
    var scope = this.scope;
    var statusCategory = this.statusCategory;
    var usages = this.usages;
    var workflowUsages = this.workflowUsages;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (statusCategory != null) {
      json[r'statusCategory'] = statusCategory.value;
    }
    json[r'usages'] = usages.map((i) => i.toJson()).toList();
    json[r'workflowUsages'] = workflowUsages.map((i) => i.toJson()).toList();
    return json;
  }

  JiraStatus copyWith(
      {String? description,
      String? id,
      String? name,
      StatusScope? scope,
      JiraStatusStatusCategory? statusCategory,
      List<ProjectIssueTypes>? usages,
      List<WorkflowUsages>? workflowUsages}) {
    return JiraStatus(
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
      scope: scope ?? this.scope,
      statusCategory: statusCategory ?? this.statusCategory,
      usages: usages ?? this.usages,
      workflowUsages: workflowUsages ?? this.workflowUsages,
    );
  }
}

class JiraStatusStatusCategory {
  static const todo = JiraStatusStatusCategory._('TODO');
  static const inProgress = JiraStatusStatusCategory._('IN_PROGRESS');
  static const done = JiraStatusStatusCategory._('DONE');

  static const values = [
    todo,
    inProgress,
    done,
  ];
  final String value;

  const JiraStatusStatusCategory._(this.value);

  static JiraStatusStatusCategory fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JiraStatusStatusCategory._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Jql function precomputation.
class JqlFunctionPrecomputationBean {
  final List<String> arguments;
  final DateTime? created;
  final String? field;
  final String? functionKey;
  final String? functionName;
  final String? id;
  final String? operator$;
  final DateTime? updated;
  final DateTime? used;
  final String? value;

  JqlFunctionPrecomputationBean(
      {List<String>? arguments,
      this.created,
      this.field,
      this.functionKey,
      this.functionName,
      this.id,
      this.operator$,
      this.updated,
      this.used,
      this.value})
      : arguments = arguments ?? [];

  factory JqlFunctionPrecomputationBean.fromJson(Map<String, Object?> json) {
    return JqlFunctionPrecomputationBean(
      arguments: (json[r'arguments'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      field: json[r'field'] as String?,
      functionKey: json[r'functionKey'] as String?,
      functionName: json[r'functionName'] as String?,
      id: json[r'id'] as String?,
      operator$: json[r'operator'] as String?,
      updated: DateTime.tryParse(json[r'updated'] as String? ?? ''),
      used: DateTime.tryParse(json[r'used'] as String? ?? ''),
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var arguments = this.arguments;
    var created = this.created;
    var field = this.field;
    var functionKey = this.functionKey;
    var functionName = this.functionName;
    var id = this.id;
    var operator$ = this.operator$;
    var updated = this.updated;
    var used = this.used;
    var value = this.value;

    final json = <String, Object?>{};
    json[r'arguments'] = arguments;
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    if (field != null) {
      json[r'field'] = field;
    }
    if (functionKey != null) {
      json[r'functionKey'] = functionKey;
    }
    if (functionName != null) {
      json[r'functionName'] = functionName;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (operator$ != null) {
      json[r'operator'] = operator$;
    }
    if (updated != null) {
      json[r'updated'] = updated.toIso8601String();
    }
    if (used != null) {
      json[r'used'] = used.toIso8601String();
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  JqlFunctionPrecomputationBean copyWith(
      {List<String>? arguments,
      DateTime? created,
      String? field,
      String? functionKey,
      String? functionName,
      String? id,
      String? operator$,
      DateTime? updated,
      DateTime? used,
      String? value}) {
    return JqlFunctionPrecomputationBean(
      arguments: arguments ?? this.arguments,
      created: created ?? this.created,
      field: field ?? this.field,
      functionKey: functionKey ?? this.functionKey,
      functionName: functionName ?? this.functionName,
      id: id ?? this.id,
      operator$: operator$ ?? this.operator$,
      updated: updated ?? this.updated,
      used: used ?? this.used,
      value: value ?? this.value,
    );
  }
}

/// Precomputation id and its new value.
class JqlFunctionPrecomputationUpdateBean {
  final int id;
  final String value;

  JqlFunctionPrecomputationUpdateBean({required this.id, required this.value});

  factory JqlFunctionPrecomputationUpdateBean.fromJson(
      Map<String, Object?> json) {
    return JqlFunctionPrecomputationUpdateBean(
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      value: json[r'value'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var value = this.value;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'value'] = value;
    return json;
  }

  JqlFunctionPrecomputationUpdateBean copyWith({int? id, String? value}) {
    return JqlFunctionPrecomputationUpdateBean(
      id: id ?? this.id,
      value: value ?? this.value,
    );
  }
}

/// List of pairs (id and value) for precomputation updates.
class JqlFunctionPrecomputationUpdateRequestBean {
  final List<JqlFunctionPrecomputationUpdateBean> values;

  JqlFunctionPrecomputationUpdateRequestBean(
      {List<JqlFunctionPrecomputationUpdateBean>? values})
      : values = values ?? [];

  factory JqlFunctionPrecomputationUpdateRequestBean.fromJson(
      Map<String, Object?> json) {
    return JqlFunctionPrecomputationUpdateRequestBean(
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => JqlFunctionPrecomputationUpdateBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var values = this.values;

    final json = <String, Object?>{};
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  JqlFunctionPrecomputationUpdateRequestBean copyWith(
      {List<JqlFunctionPrecomputationUpdateBean>? values}) {
    return JqlFunctionPrecomputationUpdateRequestBean(
      values: values ?? this.values,
    );
  }
}

/// A list of JQL queries to parse.
class JqlQueriesToParse {
  /// A list of queries to parse.
  final List<String> queries;

  JqlQueriesToParse({required this.queries});

  factory JqlQueriesToParse.fromJson(Map<String, Object?> json) {
    return JqlQueriesToParse(
      queries: (json[r'queries'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var queries = this.queries;

    final json = <String, Object?>{};
    json[r'queries'] = queries;
    return json;
  }

  JqlQueriesToParse copyWith({List<String>? queries}) {
    return JqlQueriesToParse(
      queries: queries ?? this.queries,
    );
  }
}

/// The list of JQL queries to sanitize for the given account IDs.
class JqlQueriesToSanitize {
  /// The list of JQL queries to sanitize. Must contain unique values. Maximum
  /// of 20 queries.
  final List<JqlQueryToSanitize> queries;

  JqlQueriesToSanitize({required this.queries});

  factory JqlQueriesToSanitize.fromJson(Map<String, Object?> json) {
    return JqlQueriesToSanitize(
      queries: (json[r'queries'] as List<Object?>?)
              ?.map((i) => JqlQueryToSanitize.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var queries = this.queries;

    final json = <String, Object?>{};
    json[r'queries'] = queries.map((i) => i.toJson()).toList();
    return json;
  }

  JqlQueriesToSanitize copyWith({List<JqlQueryToSanitize>? queries}) {
    return JqlQueriesToSanitize(
      queries: queries ?? this.queries,
    );
  }
}

/// A parsed JQL query.
class JqlQuery {
  final JqlQueryOrderByClause? orderBy;
  final JqlQueryClause? where;

  JqlQuery({this.orderBy, this.where});

  factory JqlQuery.fromJson(Map<String, Object?> json) {
    return JqlQuery(
      orderBy: json[r'orderBy'] != null
          ? JqlQueryOrderByClause.fromJson(
              json[r'orderBy']! as Map<String, Object?>)
          : null,
      where: json[r'where'] != null
          ? JqlQueryClause.fromJson(json[r'where']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var orderBy = this.orderBy;
    var where = this.where;

    final json = <String, Object?>{};
    if (orderBy != null) {
      json[r'orderBy'] = orderBy.toJson();
    }
    if (where != null) {
      json[r'where'] = where.toJson();
    }
    return json;
  }

  JqlQuery copyWith({JqlQueryOrderByClause? orderBy, JqlQueryClause? where}) {
    return JqlQuery(
      orderBy: orderBy ?? this.orderBy,
      where: where ?? this.where,
    );
  }
}

/// A JQL query clause.
class JqlQueryClause {
  JqlQueryClause();

  factory JqlQueryClause.fromJson(Map<String, Object?> json) {
    return JqlQueryClause();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// Details of an operand in a JQL clause.
class JqlQueryClauseOperand {
  JqlQueryClauseOperand();

  factory JqlQueryClauseOperand.fromJson(Map<String, Object?> json) {
    return JqlQueryClauseOperand();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// A time predicate for a temporal JQL clause.
class JqlQueryClauseTimePredicate {
  final JqlQueryClauseOperand operand;

  /// The operator between the field and the operand.
  final JqlQueryClauseTimePredicateOperator operator$;

  JqlQueryClauseTimePredicate({required this.operand, required this.operator$});

  factory JqlQueryClauseTimePredicate.fromJson(Map<String, Object?> json) {
    return JqlQueryClauseTimePredicate(
      operand: JqlQueryClauseOperand.fromJson(
          json[r'operand'] as Map<String, Object?>? ?? const {}),
      operator$: JqlQueryClauseTimePredicateOperator.fromValue(
          json[r'operator'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var operand = this.operand;
    var operator$ = this.operator$;

    final json = <String, Object?>{};
    json[r'operand'] = operand.toJson();
    json[r'operator'] = operator$.value;
    return json;
  }

  JqlQueryClauseTimePredicate copyWith(
      {JqlQueryClauseOperand? operand,
      JqlQueryClauseTimePredicateOperator? operator$}) {
    return JqlQueryClauseTimePredicate(
      operand: operand ?? this.operand,
      operator$: operator$ ?? this.operator$,
    );
  }
}

class JqlQueryClauseTimePredicateOperator {
  static const before = JqlQueryClauseTimePredicateOperator._('before');
  static const after = JqlQueryClauseTimePredicateOperator._('after');
  static const from = JqlQueryClauseTimePredicateOperator._('from');
  static const to = JqlQueryClauseTimePredicateOperator._('to');
  static const on = JqlQueryClauseTimePredicateOperator._('on');
  static const during = JqlQueryClauseTimePredicateOperator._('during');
  static const by = JqlQueryClauseTimePredicateOperator._('by');

  static const values = [
    before,
    after,
    from,
    to,
    on,
    during,
    by,
  ];
  final String value;

  const JqlQueryClauseTimePredicateOperator._(this.value);

  static JqlQueryClauseTimePredicateOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JqlQueryClauseTimePredicateOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A field used in a JQL query. See
/// [Advanced searching - fields reference](https://confluence.atlassian.com/x/dAiiLQ)
/// for more information about fields in JQL queries.
class JqlQueryField {
  /// The encoded name of the field, which can be used directly in a JQL query.
  final String? encodedName;

  /// The name of the field.
  final String name;

  /// When the field refers to a value in an entity property, details of the
  /// entity property value.
  final List<JqlQueryFieldEntityProperty> property;

  JqlQueryField(
      {this.encodedName,
      required this.name,
      List<JqlQueryFieldEntityProperty>? property})
      : property = property ?? [];

  factory JqlQueryField.fromJson(Map<String, Object?> json) {
    return JqlQueryField(
      encodedName: json[r'encodedName'] as String?,
      name: json[r'name'] as String? ?? '',
      property: (json[r'property'] as List<Object?>?)
              ?.map((i) => JqlQueryFieldEntityProperty.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var encodedName = this.encodedName;
    var name = this.name;
    var property = this.property;

    final json = <String, Object?>{};
    if (encodedName != null) {
      json[r'encodedName'] = encodedName;
    }
    json[r'name'] = name;
    json[r'property'] = property.map((i) => i.toJson()).toList();
    return json;
  }

  JqlQueryField copyWith(
      {String? encodedName,
      String? name,
      List<JqlQueryFieldEntityProperty>? property}) {
    return JqlQueryField(
      encodedName: encodedName ?? this.encodedName,
      name: name ?? this.name,
      property: property ?? this.property,
    );
  }
}

/// Details of an entity property.
class JqlQueryFieldEntityProperty {
  /// The object on which the property is set.
  final String entity;

  /// The key of the property.
  final String key;

  /// The path in the property value to query.
  final String path;

  /// The type of the property value extraction. Not available if the extraction
  /// for the property is not registered on the instance with the
  /// [Entity property](https://developer.atlassian.com/cloud/jira/platform/modules/entity-property/)
  /// module.
  final JqlQueryFieldEntityPropertyType? type;

  JqlQueryFieldEntityProperty(
      {required this.entity, required this.key, required this.path, this.type});

  factory JqlQueryFieldEntityProperty.fromJson(Map<String, Object?> json) {
    return JqlQueryFieldEntityProperty(
      entity: json[r'entity'] as String? ?? '',
      key: json[r'key'] as String? ?? '',
      path: json[r'path'] as String? ?? '',
      type: json[r'type'] != null
          ? JqlQueryFieldEntityPropertyType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var entity = this.entity;
    var key = this.key;
    var path = this.path;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'entity'] = entity;
    json[r'key'] = key;
    json[r'path'] = path;
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  JqlQueryFieldEntityProperty copyWith(
      {String? entity,
      String? key,
      String? path,
      JqlQueryFieldEntityPropertyType? type}) {
    return JqlQueryFieldEntityProperty(
      entity: entity ?? this.entity,
      key: key ?? this.key,
      path: path ?? this.path,
      type: type ?? this.type,
    );
  }
}

class JqlQueryFieldEntityPropertyType {
  static const number = JqlQueryFieldEntityPropertyType._('number');
  static const string = JqlQueryFieldEntityPropertyType._('string');
  static const text = JqlQueryFieldEntityPropertyType._('text');
  static const date = JqlQueryFieldEntityPropertyType._('date');
  static const user = JqlQueryFieldEntityPropertyType._('user');

  static const values = [
    number,
    string,
    text,
    date,
    user,
  ];
  final String value;

  const JqlQueryFieldEntityPropertyType._(this.value);

  static JqlQueryFieldEntityPropertyType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JqlQueryFieldEntityPropertyType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of the order-by JQL clause.
class JqlQueryOrderByClause {
  /// The list of order-by clause fields and their ordering directives.
  final List<JqlQueryOrderByClauseElement> fields;

  JqlQueryOrderByClause({required this.fields});

  factory JqlQueryOrderByClause.fromJson(Map<String, Object?> json) {
    return JqlQueryOrderByClause(
      fields: (json[r'fields'] as List<Object?>?)
              ?.map((i) => JqlQueryOrderByClauseElement.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var fields = this.fields;

    final json = <String, Object?>{};
    json[r'fields'] = fields.map((i) => i.toJson()).toList();
    return json;
  }

  JqlQueryOrderByClause copyWith({List<JqlQueryOrderByClauseElement>? fields}) {
    return JqlQueryOrderByClause(
      fields: fields ?? this.fields,
    );
  }
}

/// An element of the order-by JQL clause.
class JqlQueryOrderByClauseElement {
  /// The direction in which to order the results.
  final JqlQueryOrderByClauseElementDirection? direction;
  final JqlQueryField field;

  JqlQueryOrderByClauseElement({this.direction, required this.field});

  factory JqlQueryOrderByClauseElement.fromJson(Map<String, Object?> json) {
    return JqlQueryOrderByClauseElement(
      direction: json[r'direction'] != null
          ? JqlQueryOrderByClauseElementDirection.fromValue(
              json[r'direction']! as String)
          : null,
      field: JqlQueryField.fromJson(
          json[r'field'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var direction = this.direction;
    var field = this.field;

    final json = <String, Object?>{};
    if (direction != null) {
      json[r'direction'] = direction.value;
    }
    json[r'field'] = field.toJson();
    return json;
  }

  JqlQueryOrderByClauseElement copyWith(
      {JqlQueryOrderByClauseElementDirection? direction,
      JqlQueryField? field}) {
    return JqlQueryOrderByClauseElement(
      direction: direction ?? this.direction,
      field: field ?? this.field,
    );
  }
}

class JqlQueryOrderByClauseElementDirection {
  static const asc = JqlQueryOrderByClauseElementDirection._('asc');
  static const desc = JqlQueryOrderByClauseElementDirection._('desc');

  static const values = [
    asc,
    desc,
  ];
  final String value;

  const JqlQueryOrderByClauseElementDirection._(this.value);

  static JqlQueryOrderByClauseElementDirection fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JqlQueryOrderByClauseElementDirection._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The JQL query to sanitize for the account ID. If the account ID is null,
/// sanitizing is performed for an anonymous user.
class JqlQueryToSanitize {
  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
  final String? accountId;

  /// The query to sanitize.
  final String query;

  JqlQueryToSanitize({this.accountId, required this.query});

  factory JqlQueryToSanitize.fromJson(Map<String, Object?> json) {
    return JqlQueryToSanitize(
      accountId: json[r'accountId'] as String?,
      query: json[r'query'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var query = this.query;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    json[r'query'] = query;
    return json;
  }

  JqlQueryToSanitize copyWith({String? accountId, String? query}) {
    return JqlQueryToSanitize(
      accountId: accountId ?? this.accountId,
      query: query ?? this.query,
    );
  }
}

/// An operand that can be part of a list operand.
class JqlQueryUnitaryOperand {
  JqlQueryUnitaryOperand();

  factory JqlQueryUnitaryOperand.fromJson(Map<String, Object?> json) {
    return JqlQueryUnitaryOperand();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// A JSON object with custom content.
class JsonContextVariable {
  /// Type of custom context variable.
  final String type;

  /// A JSON object containing custom content.
  final Map<String, dynamic>? value;

  JsonContextVariable({required this.type, this.value});

  factory JsonContextVariable.fromJson(Map<String, Object?> json) {
    return JsonContextVariable(
      type: json[r'type'] as String? ?? '',
      value: json[r'value'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var type = this.type;
    var value = this.value;

    final json = <String, Object?>{};
    json[r'type'] = type;
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  JsonContextVariable copyWith({String? type, Map<String, dynamic>? value}) {
    return JsonContextVariable(
      type: type ?? this.type,
      value: value ?? this.value,
    );
  }
}

class JsonNode {
  final bool array;
  final bool bigDecimal;
  final bool bigInteger;
  final int? bigIntegerValue;
  final bool binary;
  final List<String> binaryValue;
  final bool boolean;
  final bool booleanValue;
  final bool containerNode;
  final num? decimalValue;
  final bool double$;
  final num? doubleValue;
  final Map<String, dynamic>? elements;
  final Map<String, dynamic>? fieldNames;
  final Map<String, dynamic>? fields;
  final bool floatingPointNumber;
  final bool int$;
  final int? intValue;
  final bool integralNumber;
  final bool long;
  final int? longValue;
  final bool missingNode;
  final bool null$;
  final bool number;
  final JsonNodeNumberType? numberType;
  final num? numberValue;
  final bool object;
  final bool pojo;
  final String? textValue;
  final bool textual;
  final bool valueAsBoolean;
  final num? valueAsDouble;
  final int? valueAsInt;
  final int? valueAsLong;
  final String? valueAsText;
  final bool valueNode;

  JsonNode(
      {bool? array,
      bool? bigDecimal,
      bool? bigInteger,
      this.bigIntegerValue,
      bool? binary,
      List<String>? binaryValue,
      bool? boolean,
      bool? booleanValue,
      bool? containerNode,
      this.decimalValue,
      bool? double$,
      this.doubleValue,
      this.elements,
      this.fieldNames,
      this.fields,
      bool? floatingPointNumber,
      bool? int$,
      this.intValue,
      bool? integralNumber,
      bool? long,
      this.longValue,
      bool? missingNode,
      bool? null$,
      bool? number,
      this.numberType,
      this.numberValue,
      bool? object,
      bool? pojo,
      this.textValue,
      bool? textual,
      bool? valueAsBoolean,
      this.valueAsDouble,
      this.valueAsInt,
      this.valueAsLong,
      this.valueAsText,
      bool? valueNode})
      : array = array ?? false,
        bigDecimal = bigDecimal ?? false,
        bigInteger = bigInteger ?? false,
        binary = binary ?? false,
        binaryValue = binaryValue ?? [],
        boolean = boolean ?? false,
        booleanValue = booleanValue ?? false,
        containerNode = containerNode ?? false,
        double$ = double$ ?? false,
        floatingPointNumber = floatingPointNumber ?? false,
        int$ = int$ ?? false,
        integralNumber = integralNumber ?? false,
        long = long ?? false,
        missingNode = missingNode ?? false,
        null$ = null$ ?? false,
        number = number ?? false,
        object = object ?? false,
        pojo = pojo ?? false,
        textual = textual ?? false,
        valueAsBoolean = valueAsBoolean ?? false,
        valueNode = valueNode ?? false;

  factory JsonNode.fromJson(Map<String, Object?> json) {
    return JsonNode(
      array: json[r'array'] as bool? ?? false,
      bigDecimal: json[r'bigDecimal'] as bool? ?? false,
      bigInteger: json[r'bigInteger'] as bool? ?? false,
      bigIntegerValue: (json[r'bigIntegerValue'] as num?)?.toInt(),
      binary: json[r'binary'] as bool? ?? false,
      binaryValue: (json[r'binaryValue'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      boolean: json[r'boolean'] as bool? ?? false,
      booleanValue: json[r'booleanValue'] as bool? ?? false,
      containerNode: json[r'containerNode'] as bool? ?? false,
      decimalValue: json[r'decimalValue'] as num?,
      double$: json[r'double'] as bool? ?? false,
      doubleValue: json[r'doubleValue'] as num?,
      elements: json[r'elements'] as Map<String, Object?>?,
      fieldNames: json[r'fieldNames'] as Map<String, Object?>?,
      fields: json[r'fields'] as Map<String, Object?>?,
      floatingPointNumber: json[r'floatingPointNumber'] as bool? ?? false,
      int$: json[r'int'] as bool? ?? false,
      intValue: (json[r'intValue'] as num?)?.toInt(),
      integralNumber: json[r'integralNumber'] as bool? ?? false,
      long: json[r'long'] as bool? ?? false,
      longValue: (json[r'longValue'] as num?)?.toInt(),
      missingNode: json[r'missingNode'] as bool? ?? false,
      null$: json[r'null'] as bool? ?? false,
      number: json[r'number'] as bool? ?? false,
      numberType: json[r'numberType'] != null
          ? JsonNodeNumberType.fromValue(json[r'numberType']! as String)
          : null,
      numberValue: json[r'numberValue'] as num?,
      object: json[r'object'] as bool? ?? false,
      pojo: json[r'pojo'] as bool? ?? false,
      textValue: json[r'textValue'] as String?,
      textual: json[r'textual'] as bool? ?? false,
      valueAsBoolean: json[r'valueAsBoolean'] as bool? ?? false,
      valueAsDouble: json[r'valueAsDouble'] as num?,
      valueAsInt: (json[r'valueAsInt'] as num?)?.toInt(),
      valueAsLong: (json[r'valueAsLong'] as num?)?.toInt(),
      valueAsText: json[r'valueAsText'] as String?,
      valueNode: json[r'valueNode'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var array = this.array;
    var bigDecimal = this.bigDecimal;
    var bigInteger = this.bigInteger;
    var bigIntegerValue = this.bigIntegerValue;
    var binary = this.binary;
    var binaryValue = this.binaryValue;
    var boolean = this.boolean;
    var booleanValue = this.booleanValue;
    var containerNode = this.containerNode;
    var decimalValue = this.decimalValue;
    var double$ = this.double$;
    var doubleValue = this.doubleValue;
    var elements = this.elements;
    var fieldNames = this.fieldNames;
    var fields = this.fields;
    var floatingPointNumber = this.floatingPointNumber;
    var int$ = this.int$;
    var intValue = this.intValue;
    var integralNumber = this.integralNumber;
    var long = this.long;
    var longValue = this.longValue;
    var missingNode = this.missingNode;
    var null$ = this.null$;
    var number = this.number;
    var numberType = this.numberType;
    var numberValue = this.numberValue;
    var object = this.object;
    var pojo = this.pojo;
    var textValue = this.textValue;
    var textual = this.textual;
    var valueAsBoolean = this.valueAsBoolean;
    var valueAsDouble = this.valueAsDouble;
    var valueAsInt = this.valueAsInt;
    var valueAsLong = this.valueAsLong;
    var valueAsText = this.valueAsText;
    var valueNode = this.valueNode;

    final json = <String, Object?>{};
    json[r'array'] = array;
    json[r'bigDecimal'] = bigDecimal;
    json[r'bigInteger'] = bigInteger;
    if (bigIntegerValue != null) {
      json[r'bigIntegerValue'] = bigIntegerValue;
    }
    json[r'binary'] = binary;
    json[r'binaryValue'] = binaryValue;
    json[r'boolean'] = boolean;
    json[r'booleanValue'] = booleanValue;
    json[r'containerNode'] = containerNode;
    if (decimalValue != null) {
      json[r'decimalValue'] = decimalValue;
    }
    json[r'double'] = double$;
    if (doubleValue != null) {
      json[r'doubleValue'] = doubleValue;
    }
    if (elements != null) {
      json[r'elements'] = elements;
    }
    if (fieldNames != null) {
      json[r'fieldNames'] = fieldNames;
    }
    if (fields != null) {
      json[r'fields'] = fields;
    }
    json[r'floatingPointNumber'] = floatingPointNumber;
    json[r'int'] = int$;
    if (intValue != null) {
      json[r'intValue'] = intValue;
    }
    json[r'integralNumber'] = integralNumber;
    json[r'long'] = long;
    if (longValue != null) {
      json[r'longValue'] = longValue;
    }
    json[r'missingNode'] = missingNode;
    json[r'null'] = null$;
    json[r'number'] = number;
    if (numberType != null) {
      json[r'numberType'] = numberType.value;
    }
    if (numberValue != null) {
      json[r'numberValue'] = numberValue;
    }
    json[r'object'] = object;
    json[r'pojo'] = pojo;
    if (textValue != null) {
      json[r'textValue'] = textValue;
    }
    json[r'textual'] = textual;
    json[r'valueAsBoolean'] = valueAsBoolean;
    if (valueAsDouble != null) {
      json[r'valueAsDouble'] = valueAsDouble;
    }
    if (valueAsInt != null) {
      json[r'valueAsInt'] = valueAsInt;
    }
    if (valueAsLong != null) {
      json[r'valueAsLong'] = valueAsLong;
    }
    if (valueAsText != null) {
      json[r'valueAsText'] = valueAsText;
    }
    json[r'valueNode'] = valueNode;
    return json;
  }

  JsonNode copyWith(
      {bool? array,
      bool? bigDecimal,
      bool? bigInteger,
      int? bigIntegerValue,
      bool? binary,
      List<String>? binaryValue,
      bool? boolean,
      bool? booleanValue,
      bool? containerNode,
      num? decimalValue,
      bool? double$,
      num? doubleValue,
      Map<String, dynamic>? elements,
      Map<String, dynamic>? fieldNames,
      Map<String, dynamic>? fields,
      bool? floatingPointNumber,
      bool? int$,
      int? intValue,
      bool? integralNumber,
      bool? long,
      int? longValue,
      bool? missingNode,
      bool? null$,
      bool? number,
      JsonNodeNumberType? numberType,
      num? numberValue,
      bool? object,
      bool? pojo,
      String? textValue,
      bool? textual,
      bool? valueAsBoolean,
      num? valueAsDouble,
      int? valueAsInt,
      int? valueAsLong,
      String? valueAsText,
      bool? valueNode}) {
    return JsonNode(
      array: array ?? this.array,
      bigDecimal: bigDecimal ?? this.bigDecimal,
      bigInteger: bigInteger ?? this.bigInteger,
      bigIntegerValue: bigIntegerValue ?? this.bigIntegerValue,
      binary: binary ?? this.binary,
      binaryValue: binaryValue ?? this.binaryValue,
      boolean: boolean ?? this.boolean,
      booleanValue: booleanValue ?? this.booleanValue,
      containerNode: containerNode ?? this.containerNode,
      decimalValue: decimalValue ?? this.decimalValue,
      double$: double$ ?? this.double$,
      doubleValue: doubleValue ?? this.doubleValue,
      elements: elements ?? this.elements,
      fieldNames: fieldNames ?? this.fieldNames,
      fields: fields ?? this.fields,
      floatingPointNumber: floatingPointNumber ?? this.floatingPointNumber,
      int$: int$ ?? this.int$,
      intValue: intValue ?? this.intValue,
      integralNumber: integralNumber ?? this.integralNumber,
      long: long ?? this.long,
      longValue: longValue ?? this.longValue,
      missingNode: missingNode ?? this.missingNode,
      null$: null$ ?? this.null$,
      number: number ?? this.number,
      numberType: numberType ?? this.numberType,
      numberValue: numberValue ?? this.numberValue,
      object: object ?? this.object,
      pojo: pojo ?? this.pojo,
      textValue: textValue ?? this.textValue,
      textual: textual ?? this.textual,
      valueAsBoolean: valueAsBoolean ?? this.valueAsBoolean,
      valueAsDouble: valueAsDouble ?? this.valueAsDouble,
      valueAsInt: valueAsInt ?? this.valueAsInt,
      valueAsLong: valueAsLong ?? this.valueAsLong,
      valueAsText: valueAsText ?? this.valueAsText,
      valueNode: valueNode ?? this.valueNode,
    );
  }
}

class JsonNodeNumberType {
  static const int$ = JsonNodeNumberType._('INT');
  static const long = JsonNodeNumberType._('LONG');
  static const bigInteger = JsonNodeNumberType._('BIG_INTEGER');
  static const float = JsonNodeNumberType._('FLOAT');
  static const double$ = JsonNodeNumberType._('DOUBLE');
  static const bigDecimal = JsonNodeNumberType._('BIG_DECIMAL');

  static const values = [
    int$,
    long,
    bigInteger,
    float,
    double$,
    bigDecimal,
  ];
  final String value;

  const JsonNodeNumberType._(this.value);

  static JsonNodeNumberType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => JsonNodeNumberType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The schema of a field.
class JsonTypeBean {
  /// If the field is a custom field, the configuration of the field.
  final Map<String, dynamic>? configuration;

  /// If the field is a custom field, the URI of the field.
  final String? custom;

  /// If the field is a custom field, the custom ID of the field.
  final int? customId;

  /// When the data type is an array, the name of the field items within the
  /// array.
  final String? items;

  /// If the field is a system field, the name of the field.
  final String? system;

  /// The data type of the field.
  final String type;

  JsonTypeBean(
      {this.configuration,
      this.custom,
      this.customId,
      this.items,
      this.system,
      required this.type});

  factory JsonTypeBean.fromJson(Map<String, Object?> json) {
    return JsonTypeBean(
      configuration: json[r'configuration'] as Map<String, Object?>?,
      custom: json[r'custom'] as String?,
      customId: (json[r'customId'] as num?)?.toInt(),
      items: json[r'items'] as String?,
      system: json[r'system'] as String?,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var configuration = this.configuration;
    var custom = this.custom;
    var customId = this.customId;
    var items = this.items;
    var system = this.system;
    var type = this.type;

    final json = <String, Object?>{};
    if (configuration != null) {
      json[r'configuration'] = configuration;
    }
    if (custom != null) {
      json[r'custom'] = custom;
    }
    if (customId != null) {
      json[r'customId'] = customId;
    }
    if (items != null) {
      json[r'items'] = items;
    }
    if (system != null) {
      json[r'system'] = system;
    }
    json[r'type'] = type;
    return json;
  }

  JsonTypeBean copyWith(
      {Map<String, dynamic>? configuration,
      String? custom,
      int? customId,
      String? items,
      String? system,
      String? type}) {
    return JsonTypeBean(
      configuration: configuration ?? this.configuration,
      custom: custom ?? this.custom,
      customId: customId ?? this.customId,
      items: items ?? this.items,
      system: system ?? this.system,
      type: type ?? this.type,
    );
  }
}

/// An operand that is a JQL keyword. See
/// [Advanced searching - keywords reference](https://confluence.atlassian.com/jiracorecloud/advanced-searching-keywords-reference-765593717.html#Advancedsearching-keywordsreference-EMPTYEMPTY)
/// for more information about operand keywords.
class KeywordOperand {
  /// The keyword that is the operand value.
  final KeywordOperandKeyword keyword;

  KeywordOperand({required this.keyword});

  factory KeywordOperand.fromJson(Map<String, Object?> json) {
    return KeywordOperand(
      keyword:
          KeywordOperandKeyword.fromValue(json[r'keyword'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var keyword = this.keyword;

    final json = <String, Object?>{};
    json[r'keyword'] = keyword.value;
    return json;
  }

  KeywordOperand copyWith({KeywordOperandKeyword? keyword}) {
    return KeywordOperand(
      keyword: keyword ?? this.keyword,
    );
  }
}

class KeywordOperandKeyword {
  static const empty = KeywordOperandKeyword._('empty');

  static const values = [
    empty,
  ];
  final String value;

  const KeywordOperandKeyword._(this.value);

  static KeywordOperandKeyword fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => KeywordOperandKeyword._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about a license for the Jira instance.
class License {
  /// The applications under this license.
  final List<LicensedApplication> applications;

  License({required this.applications});

  factory License.fromJson(Map<String, Object?> json) {
    return License(
      applications: (json[r'applications'] as List<Object?>?)
              ?.map((i) => LicensedApplication.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var applications = this.applications;

    final json = <String, Object?>{};
    json[r'applications'] = applications.map((i) => i.toJson()).toList();
    return json;
  }

  License copyWith({List<LicensedApplication>? applications}) {
    return License(
      applications: applications ?? this.applications,
    );
  }
}

/// A license metric
class LicenseMetric {
  /// The key of the license metric.
  final String? key;

  /// The value for the license metric.
  final String? value;

  LicenseMetric({this.key, this.value});

  factory LicenseMetric.fromJson(Map<String, Object?> json) {
    return LicenseMetric(
      key: json[r'key'] as String?,
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var value = this.value;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  LicenseMetric copyWith({String? key, String? value}) {
    return LicenseMetric(
      key: key ?? this.key,
      value: value ?? this.value,
    );
  }
}

/// Details about a licensed Jira application.
class LicensedApplication {
  /// The ID of the application.
  final String id;

  /// The licensing plan.
  final LicensedApplicationPlan plan;

  LicensedApplication({required this.id, required this.plan});

  factory LicensedApplication.fromJson(Map<String, Object?> json) {
    return LicensedApplication(
      id: json[r'id'] as String? ?? '',
      plan: LicensedApplicationPlan.fromValue(json[r'plan'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var plan = this.plan;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'plan'] = plan.value;
    return json;
  }

  LicensedApplication copyWith({String? id, LicensedApplicationPlan? plan}) {
    return LicensedApplication(
      id: id ?? this.id,
      plan: plan ?? this.plan,
    );
  }
}

class LicensedApplicationPlan {
  static const unlicensed = LicensedApplicationPlan._('UNLICENSED');
  static const free = LicensedApplicationPlan._('FREE');
  static const paid = LicensedApplicationPlan._('PAID');

  static const values = [
    unlicensed,
    free,
    paid,
  ];
  final String value;

  const LicensedApplicationPlan._(this.value);

  static LicensedApplicationPlan fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => LicensedApplicationPlan._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details a link group, which defines issue operations.
class LinkGroup {
  final List<LinkGroup> groups;
  final SimpleLink? header;
  final String? id;
  final List<SimpleLink> links;
  final String? styleClass;
  final int? weight;

  LinkGroup(
      {List<LinkGroup>? groups,
      this.header,
      this.id,
      List<SimpleLink>? links,
      this.styleClass,
      this.weight})
      : groups = groups ?? [],
        links = links ?? [];

  factory LinkGroup.fromJson(Map<String, Object?> json) {
    return LinkGroup(
      groups: (json[r'groups'] as List<Object?>?)
              ?.map((i) =>
                  LinkGroup.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      header: json[r'header'] != null
          ? SimpleLink.fromJson(json[r'header']! as Map<String, Object?>)
          : null,
      id: json[r'id'] as String?,
      links: (json[r'links'] as List<Object?>?)
              ?.map((i) =>
                  SimpleLink.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      styleClass: json[r'styleClass'] as String?,
      weight: (json[r'weight'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var groups = this.groups;
    var header = this.header;
    var id = this.id;
    var links = this.links;
    var styleClass = this.styleClass;
    var weight = this.weight;

    final json = <String, Object?>{};
    json[r'groups'] = groups.map((i) => i.toJson()).toList();
    if (header != null) {
      json[r'header'] = header.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'links'] = links.map((i) => i.toJson()).toList();
    if (styleClass != null) {
      json[r'styleClass'] = styleClass;
    }
    if (weight != null) {
      json[r'weight'] = weight;
    }
    return json;
  }

  LinkGroup copyWith(
      {List<LinkGroup>? groups,
      SimpleLink? header,
      String? id,
      List<SimpleLink>? links,
      String? styleClass,
      int? weight}) {
    return LinkGroup(
      groups: groups ?? this.groups,
      header: header ?? this.header,
      id: id ?? this.id,
      links: links ?? this.links,
      styleClass: styleClass ?? this.styleClass,
      weight: weight ?? this.weight,
    );
  }
}

class LinkIssueRequestJsonBean {
  final Comment? comment;
  final LinkedIssue inwardIssue;
  final LinkedIssue outwardIssue;
  final IssueLinkType type;

  LinkIssueRequestJsonBean(
      {this.comment,
      required this.inwardIssue,
      required this.outwardIssue,
      required this.type});

  factory LinkIssueRequestJsonBean.fromJson(Map<String, Object?> json) {
    return LinkIssueRequestJsonBean(
      comment: json[r'comment'] != null
          ? Comment.fromJson(json[r'comment']! as Map<String, Object?>)
          : null,
      inwardIssue: LinkedIssue.fromJson(
          json[r'inwardIssue'] as Map<String, Object?>? ?? const {}),
      outwardIssue: LinkedIssue.fromJson(
          json[r'outwardIssue'] as Map<String, Object?>? ?? const {}),
      type: IssueLinkType.fromJson(
          json[r'type'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var comment = this.comment;
    var inwardIssue = this.inwardIssue;
    var outwardIssue = this.outwardIssue;
    var type = this.type;

    final json = <String, Object?>{};
    if (comment != null) {
      json[r'comment'] = comment.toJson();
    }
    json[r'inwardIssue'] = inwardIssue.toJson();
    json[r'outwardIssue'] = outwardIssue.toJson();
    json[r'type'] = type.toJson();
    return json;
  }

  LinkIssueRequestJsonBean copyWith(
      {Comment? comment,
      LinkedIssue? inwardIssue,
      LinkedIssue? outwardIssue,
      IssueLinkType? type}) {
    return LinkIssueRequestJsonBean(
      comment: comment ?? this.comment,
      inwardIssue: inwardIssue ?? this.inwardIssue,
      outwardIssue: outwardIssue ?? this.outwardIssue,
      type: type ?? this.type,
    );
  }
}

/// The ID or key of a linked issue.
class LinkedIssue {
  /// The fields associated with the issue.
  final Fields? fields;

  /// The ID of an issue. Required if `key` isn't provided.
  final String? id;

  /// The key of an issue. Required if `id` isn't provided.
  final String? key;

  /// The URL of the issue.
  final String? self;

  LinkedIssue({this.fields, this.id, this.key, this.self});

  factory LinkedIssue.fromJson(Map<String, Object?> json) {
    return LinkedIssue(
      fields: json[r'fields'] != null
          ? Fields.fromJson(json[r'fields']! as Map<String, Object?>)
          : null,
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var fields = this.fields;
    var id = this.id;
    var key = this.key;
    var self = this.self;

    final json = <String, Object?>{};
    if (fields != null) {
      json[r'fields'] = fields.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  LinkedIssue copyWith(
      {Fields? fields, String? id, String? key, String? self}) {
    return LinkedIssue(
      fields: fields ?? this.fields,
      id: id ?? this.id,
      key: key ?? this.key,
      self: self ?? this.self,
    );
  }
}

/// An operand that is a list of values.
class ListOperand {
  /// Encoded operand, which can be used directly in a JQL query.
  final String? encodedOperand;

  /// The list of operand values.
  final List<JqlQueryUnitaryOperand> values;

  ListOperand({this.encodedOperand, required this.values});

  factory ListOperand.fromJson(Map<String, Object?> json) {
    return ListOperand(
      encodedOperand: json[r'encodedOperand'] as String?,
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => JqlQueryUnitaryOperand.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var encodedOperand = this.encodedOperand;
    var values = this.values;

    final json = <String, Object?>{};
    if (encodedOperand != null) {
      json[r'encodedOperand'] = encodedOperand;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  ListOperand copyWith(
      {String? encodedOperand, List<JqlQueryUnitaryOperand>? values}) {
    return ListOperand(
      encodedOperand: encodedOperand ?? this.encodedOperand,
      values: values ?? this.values,
    );
  }
}

class ListWrapperCallbackApplicationRole {
  ListWrapperCallbackApplicationRole();

  factory ListWrapperCallbackApplicationRole.fromJson(
      Map<String, Object?> json) {
    return ListWrapperCallbackApplicationRole();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

class ListWrapperCallbackGroupName {
  ListWrapperCallbackGroupName();

  factory ListWrapperCallbackGroupName.fromJson(Map<String, Object?> json) {
    return ListWrapperCallbackGroupName();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// Details of a locale.
class Locale {
  /// The locale code. The Java the locale format is used: a two character
  /// language code (ISO 639), an underscore, and two letter country code (ISO
  /// 3166). For example, en_US represents a locale of English (United States).
  /// Required on create.
  final String? locale;

  Locale({this.locale});

  factory Locale.fromJson(Map<String, Object?> json) {
    return Locale(
      locale: json[r'locale'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var locale = this.locale;

    final json = <String, Object?>{};
    if (locale != null) {
      json[r'locale'] = locale;
    }
    return json;
  }

  Locale copyWith({String? locale}) {
    return Locale(
      locale: locale ?? this.locale,
    );
  }
}

class MoveFieldBean {
  /// The ID of the screen tab field after which to place the moved screen tab
  /// field. Required if `position` isn't provided.
  final String? after;

  /// The named position to which the screen tab field should be moved. Required
  /// if `after` isn't provided.
  final MoveFieldBeanPosition? position;

  MoveFieldBean({this.after, this.position});

  factory MoveFieldBean.fromJson(Map<String, Object?> json) {
    return MoveFieldBean(
      after: json[r'after'] as String?,
      position: json[r'position'] != null
          ? MoveFieldBeanPosition.fromValue(json[r'position']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var after = this.after;
    var position = this.position;

    final json = <String, Object?>{};
    if (after != null) {
      json[r'after'] = after;
    }
    if (position != null) {
      json[r'position'] = position.value;
    }
    return json;
  }

  MoveFieldBean copyWith({String? after, MoveFieldBeanPosition? position}) {
    return MoveFieldBean(
      after: after ?? this.after,
      position: position ?? this.position,
    );
  }
}

class MoveFieldBeanPosition {
  static const earlier = MoveFieldBeanPosition._('Earlier');
  static const later = MoveFieldBeanPosition._('Later');
  static const first = MoveFieldBeanPosition._('First');
  static const last = MoveFieldBeanPosition._('Last');

  static const values = [
    earlier,
    later,
    first,
    last,
  ];
  final String value;

  const MoveFieldBeanPosition._(this.value);

  static MoveFieldBeanPosition fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => MoveFieldBeanPosition._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A list of issues and their respective properties to set or update. See
/// [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/)
/// for more information.
class MultiIssueEntityProperties {
  /// A list of issue IDs and their respective properties.
  final List<IssueEntityPropertiesForMultiUpdate> issues;

  MultiIssueEntityProperties(
      {List<IssueEntityPropertiesForMultiUpdate>? issues})
      : issues = issues ?? [];

  factory MultiIssueEntityProperties.fromJson(Map<String, Object?> json) {
    return MultiIssueEntityProperties(
      issues: (json[r'issues'] as List<Object?>?)
              ?.map((i) => IssueEntityPropertiesForMultiUpdate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issues = this.issues;

    final json = <String, Object?>{};
    json[r'issues'] = issues.map((i) => i.toJson()).toList();
    return json;
  }

  MultiIssueEntityProperties copyWith(
      {List<IssueEntityPropertiesForMultiUpdate>? issues}) {
    return MultiIssueEntityProperties(
      issues: issues ?? this.issues,
    );
  }
}

/// A custom field and its new value with a list of issue to update.
class MultipleCustomFieldValuesUpdate {
  /// The ID or key of the custom field. For example, `customfield_10010`.
  final String customField;

  /// The list of issue IDs.
  final List<int> issueIds;

  /// The value for the custom field. The value must be compatible with the
  /// [custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#data-types)
  /// as follows:
  ///
  ///  *  `string` the value must be a string.
  ///  *  `number` the value must be a number.
  ///  *  `datetime` the value must be a string that represents a date in the
  /// ISO format or the simplified extended ISO format. For example,
  /// `"2023-01-18T12:00:00-03:00"` or `"2023-01-18T12:00:00.000Z"`. However,
  /// the milliseconds part is ignored.
  ///  *  `user` the value must be an object that contains the `accountId`
  /// field.
  ///  *  `group` the value must be an object that contains the group `name` or
  /// `groupId` field. Because group names can change, we recommend using
  /// `groupId`.
  ///
  /// A list of appropriate values must be provided if the field is of the
  /// `list`
  /// [collection type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#collection-types).
  final dynamic value;

  MultipleCustomFieldValuesUpdate(
      {required this.customField, required this.issueIds, required this.value});

  factory MultipleCustomFieldValuesUpdate.fromJson(Map<String, Object?> json) {
    return MultipleCustomFieldValuesUpdate(
      customField: json[r'customField'] as String? ?? '',
      issueIds: (json[r'issueIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      value: json[r'value'],
    );
  }

  Map<String, Object?> toJson() {
    var customField = this.customField;
    var issueIds = this.issueIds;
    var value = this.value;

    final json = <String, Object?>{};
    json[r'customField'] = customField;
    json[r'issueIds'] = issueIds;
    json[r'value'] = value;
    return json;
  }

  MultipleCustomFieldValuesUpdate copyWith(
      {String? customField, List<int>? issueIds, dynamic value}) {
    return MultipleCustomFieldValuesUpdate(
      customField: customField ?? this.customField,
      issueIds: issueIds ?? this.issueIds,
      value: value ?? this.value,
    );
  }
}

/// List of updates for a custom fields.
class MultipleCustomFieldValuesUpdateDetails {
  final List<MultipleCustomFieldValuesUpdate> updates;

  MultipleCustomFieldValuesUpdateDetails(
      {List<MultipleCustomFieldValuesUpdate>? updates})
      : updates = updates ?? [];

  factory MultipleCustomFieldValuesUpdateDetails.fromJson(
      Map<String, Object?> json) {
    return MultipleCustomFieldValuesUpdateDetails(
      updates: (json[r'updates'] as List<Object?>?)
              ?.map((i) => MultipleCustomFieldValuesUpdate.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var updates = this.updates;

    final json = <String, Object?>{};
    json[r'updates'] = updates.map((i) => i.toJson()).toList();
    return json;
  }

  MultipleCustomFieldValuesUpdateDetails copyWith(
      {List<MultipleCustomFieldValuesUpdate>? updates}) {
    return MultipleCustomFieldValuesUpdateDetails(
      updates: updates ?? this.updates,
    );
  }
}

class NestedResponse {
  final ErrorCollection? errorCollection;
  final int? status;
  final WarningCollection? warningCollection;

  NestedResponse({this.errorCollection, this.status, this.warningCollection});

  factory NestedResponse.fromJson(Map<String, Object?> json) {
    return NestedResponse(
      errorCollection: json[r'errorCollection'] != null
          ? ErrorCollection.fromJson(
              json[r'errorCollection']! as Map<String, Object?>)
          : null,
      status: (json[r'status'] as num?)?.toInt(),
      warningCollection: json[r'warningCollection'] != null
          ? WarningCollection.fromJson(
              json[r'warningCollection']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var errorCollection = this.errorCollection;
    var status = this.status;
    var warningCollection = this.warningCollection;

    final json = <String, Object?>{};
    if (errorCollection != null) {
      json[r'errorCollection'] = errorCollection.toJson();
    }
    if (status != null) {
      json[r'status'] = status;
    }
    if (warningCollection != null) {
      json[r'warningCollection'] = warningCollection.toJson();
    }
    return json;
  }

  NestedResponse copyWith(
      {ErrorCollection? errorCollection,
      int? status,
      WarningCollection? warningCollection}) {
    return NestedResponse(
      errorCollection: errorCollection ?? this.errorCollection,
      status: status ?? this.status,
      warningCollection: warningCollection ?? this.warningCollection,
    );
  }
}

/// The user details.
class NewUserDetails {
  /// Deprecated, do not use.
  final List<String> applicationKeys;

  /// This property is no longer available. If the user has an Atlassian
  /// account, their display name is not changed. If the user does not have an
  /// Atlassian account, they are sent an email asking them set up an account.
  final String? displayName;

  /// The email address for the user.
  final String emailAddress;

  /// This property is no longer available. See the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? key;

  /// This property is no longer available. See the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? name;

  /// This property is no longer available. If the user has an Atlassian
  /// account, their password is not changed. If the user does not have an
  /// Atlassian account, they are sent an email asking them set up an account.
  final String? password;

  /// Products the new user has access to. Valid products are: jira-core,
  /// jira-servicedesk, jira-product-discovery, jira-software. If left empty,
  /// the user will get default product access. To create a user without product
  /// access, set this field to be an empty array.
  final List<String> products;

  /// The URL of the user.
  final String? self;

  NewUserDetails(
      {List<String>? applicationKeys,
      this.displayName,
      required this.emailAddress,
      this.key,
      this.name,
      this.password,
      List<String>? products,
      this.self})
      : applicationKeys = applicationKeys ?? [],
        products = products ?? [];

  factory NewUserDetails.fromJson(Map<String, Object?> json) {
    return NewUserDetails(
      applicationKeys: (json[r'applicationKeys'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      displayName: json[r'displayName'] as String?,
      emailAddress: json[r'emailAddress'] as String? ?? '',
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      password: json[r'password'] as String?,
      products: (json[r'products'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var applicationKeys = this.applicationKeys;
    var displayName = this.displayName;
    var emailAddress = this.emailAddress;
    var key = this.key;
    var name = this.name;
    var password = this.password;
    var products = this.products;
    var self = this.self;

    final json = <String, Object?>{};
    json[r'applicationKeys'] = applicationKeys;
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    json[r'emailAddress'] = emailAddress;
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (password != null) {
      json[r'password'] = password;
    }
    json[r'products'] = products;
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  NewUserDetails copyWith(
      {List<String>? applicationKeys,
      String? displayName,
      String? emailAddress,
      String? key,
      String? name,
      String? password,
      List<String>? products,
      String? self}) {
    return NewUserDetails(
      applicationKeys: applicationKeys ?? this.applicationKeys,
      displayName: displayName ?? this.displayName,
      emailAddress: emailAddress ?? this.emailAddress,
      key: key ?? this.key,
      name: name ?? this.name,
      password: password ?? this.password,
      products: products ?? this.products,
      self: self ?? this.self,
    );
  }
}

/// Details about a notification.
class Notification {
  /// The HTML body of the email notification for the issue.
  final String? htmlBody;

  /// Restricts the notifications to users with the specified permissions.
  final NotificationRecipientsRestrictions? restrict;

  /// The subject of the email notification for the issue. If this is not
  /// specified, then the subject is set to the issue key and summary.
  final String? subject;

  /// The plain text body of the email notification for the issue.
  final String? textBody;

  /// The recipients of the email notification for the issue.
  final NotificationRecipients? to;

  Notification(
      {this.htmlBody, this.restrict, this.subject, this.textBody, this.to});

  factory Notification.fromJson(Map<String, Object?> json) {
    return Notification(
      htmlBody: json[r'htmlBody'] as String?,
      restrict: json[r'restrict'] != null
          ? NotificationRecipientsRestrictions.fromJson(
              json[r'restrict']! as Map<String, Object?>)
          : null,
      subject: json[r'subject'] as String?,
      textBody: json[r'textBody'] as String?,
      to: json[r'to'] != null
          ? NotificationRecipients.fromJson(
              json[r'to']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var htmlBody = this.htmlBody;
    var restrict = this.restrict;
    var subject = this.subject;
    var textBody = this.textBody;
    var to = this.to;

    final json = <String, Object?>{};
    if (htmlBody != null) {
      json[r'htmlBody'] = htmlBody;
    }
    if (restrict != null) {
      json[r'restrict'] = restrict.toJson();
    }
    if (subject != null) {
      json[r'subject'] = subject;
    }
    if (textBody != null) {
      json[r'textBody'] = textBody;
    }
    if (to != null) {
      json[r'to'] = to.toJson();
    }
    return json;
  }

  Notification copyWith(
      {String? htmlBody,
      NotificationRecipientsRestrictions? restrict,
      String? subject,
      String? textBody,
      NotificationRecipients? to}) {
    return Notification(
      htmlBody: htmlBody ?? this.htmlBody,
      restrict: restrict ?? this.restrict,
      subject: subject ?? this.subject,
      textBody: textBody ?? this.textBody,
      to: to ?? this.to,
    );
  }
}

/// Details about a notification event.
class NotificationEvent {
  /// The description of the event.
  final String? description;

  /// The ID of the event. The event can be a
  /// [Jira system event](https://confluence.atlassian.com/x/8YdKLg#Creatinganotificationscheme-eventsEvents)
  /// or a [custom event](https://confluence.atlassian.com/x/AIlKLg).
  final int? id;

  /// The name of the event.
  final String? name;

  /// The template of the event. Only custom events configured by Jira
  /// administrators have template.
  final NotificationEvent? templateEvent;

  NotificationEvent({this.description, this.id, this.name, this.templateEvent});

  factory NotificationEvent.fromJson(Map<String, Object?> json) {
    return NotificationEvent(
      description: json[r'description'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      templateEvent: json[r'templateEvent'] != null
          ? NotificationEvent.fromJson(
              json[r'templateEvent']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var name = this.name;
    var templateEvent = this.templateEvent;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (templateEvent != null) {
      json[r'templateEvent'] = templateEvent.toJson();
    }
    return json;
  }

  NotificationEvent copyWith(
      {String? description,
      int? id,
      String? name,
      NotificationEvent? templateEvent}) {
    return NotificationEvent(
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
      templateEvent: templateEvent ?? this.templateEvent,
    );
  }
}

/// Details of the users and groups to receive the notification.
class NotificationRecipients {
  /// Whether the notification should be sent to the issue's assignees.
  final bool assignee;

  /// List of groupIds to receive the notification.
  final List<String> groupIds;

  /// List of groups to receive the notification.
  final List<GroupName> groups;

  /// Whether the notification should be sent to the issue's reporter.
  final bool reporter;

  /// List of users to receive the notification.
  final List<UserDetails> users;

  /// Whether the notification should be sent to the issue's voters.
  final bool voters;

  /// Whether the notification should be sent to the issue's watchers.
  final bool watchers;

  NotificationRecipients(
      {bool? assignee,
      List<String>? groupIds,
      List<GroupName>? groups,
      bool? reporter,
      List<UserDetails>? users,
      bool? voters,
      bool? watchers})
      : assignee = assignee ?? false,
        groupIds = groupIds ?? [],
        groups = groups ?? [],
        reporter = reporter ?? false,
        users = users ?? [],
        voters = voters ?? false,
        watchers = watchers ?? false;

  factory NotificationRecipients.fromJson(Map<String, Object?> json) {
    return NotificationRecipients(
      assignee: json[r'assignee'] as bool? ?? false,
      groupIds: (json[r'groupIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      groups: (json[r'groups'] as List<Object?>?)
              ?.map((i) =>
                  GroupName.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      reporter: json[r'reporter'] as bool? ?? false,
      users: (json[r'users'] as List<Object?>?)
              ?.map((i) =>
                  UserDetails.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      voters: json[r'voters'] as bool? ?? false,
      watchers: json[r'watchers'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var assignee = this.assignee;
    var groupIds = this.groupIds;
    var groups = this.groups;
    var reporter = this.reporter;
    var users = this.users;
    var voters = this.voters;
    var watchers = this.watchers;

    final json = <String, Object?>{};
    json[r'assignee'] = assignee;
    json[r'groupIds'] = groupIds;
    json[r'groups'] = groups.map((i) => i.toJson()).toList();
    json[r'reporter'] = reporter;
    json[r'users'] = users.map((i) => i.toJson()).toList();
    json[r'voters'] = voters;
    json[r'watchers'] = watchers;
    return json;
  }

  NotificationRecipients copyWith(
      {bool? assignee,
      List<String>? groupIds,
      List<GroupName>? groups,
      bool? reporter,
      List<UserDetails>? users,
      bool? voters,
      bool? watchers}) {
    return NotificationRecipients(
      assignee: assignee ?? this.assignee,
      groupIds: groupIds ?? this.groupIds,
      groups: groups ?? this.groups,
      reporter: reporter ?? this.reporter,
      users: users ?? this.users,
      voters: voters ?? this.voters,
      watchers: watchers ?? this.watchers,
    );
  }
}

/// Details of the group membership or permissions needed to receive the
/// notification.
class NotificationRecipientsRestrictions {
  /// List of groupId memberships required to receive the notification.
  final List<String> groupIds;

  /// List of group memberships required to receive the notification.
  final List<GroupName> groups;

  /// List of permissions required to receive the notification.
  final List<RestrictedPermission> permissions;

  NotificationRecipientsRestrictions(
      {List<String>? groupIds,
      List<GroupName>? groups,
      List<RestrictedPermission>? permissions})
      : groupIds = groupIds ?? [],
        groups = groups ?? [],
        permissions = permissions ?? [];

  factory NotificationRecipientsRestrictions.fromJson(
      Map<String, Object?> json) {
    return NotificationRecipientsRestrictions(
      groupIds: (json[r'groupIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      groups: (json[r'groups'] as List<Object?>?)
              ?.map((i) =>
                  GroupName.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      permissions: (json[r'permissions'] as List<Object?>?)
              ?.map((i) => RestrictedPermission.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var groupIds = this.groupIds;
    var groups = this.groups;
    var permissions = this.permissions;

    final json = <String, Object?>{};
    json[r'groupIds'] = groupIds;
    json[r'groups'] = groups.map((i) => i.toJson()).toList();
    json[r'permissions'] = permissions.map((i) => i.toJson()).toList();
    return json;
  }

  NotificationRecipientsRestrictions copyWith(
      {List<String>? groupIds,
      List<GroupName>? groups,
      List<RestrictedPermission>? permissions}) {
    return NotificationRecipientsRestrictions(
      groupIds: groupIds ?? this.groupIds,
      groups: groups ?? this.groups,
      permissions: permissions ?? this.permissions,
    );
  }
}

/// Details about a notification scheme.
class NotificationScheme {
  /// The description of the notification scheme.
  final String? description;

  /// Expand options that include additional notification scheme details in the
  /// response.
  final String? expand;

  /// The ID of the notification scheme.
  final int? id;

  /// The name of the notification scheme.
  final String? name;

  /// The notification events and associated recipients.
  final List<NotificationSchemeEvent> notificationSchemeEvents;

  /// The list of project IDs associated with the notification scheme.
  final List<int> projects;

  /// The scope of the notification scheme.
  final Scope? scope;
  final String? self;

  NotificationScheme(
      {this.description,
      this.expand,
      this.id,
      this.name,
      List<NotificationSchemeEvent>? notificationSchemeEvents,
      List<int>? projects,
      this.scope,
      this.self})
      : notificationSchemeEvents = notificationSchemeEvents ?? [],
        projects = projects ?? [];

  factory NotificationScheme.fromJson(Map<String, Object?> json) {
    return NotificationScheme(
      description: json[r'description'] as String?,
      expand: json[r'expand'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      notificationSchemeEvents:
          (json[r'notificationSchemeEvents'] as List<Object?>?)
                  ?.map((i) => NotificationSchemeEvent.fromJson(
                      i as Map<String, Object?>? ?? const {}))
                  .toList() ??
              [],
      projects: (json[r'projects'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var expand = this.expand;
    var id = this.id;
    var name = this.name;
    var notificationSchemeEvents = this.notificationSchemeEvents;
    var projects = this.projects;
    var scope = this.scope;
    var self = this.self;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'notificationSchemeEvents'] =
        notificationSchemeEvents.map((i) => i.toJson()).toList();
    json[r'projects'] = projects;
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  NotificationScheme copyWith(
      {String? description,
      String? expand,
      int? id,
      String? name,
      List<NotificationSchemeEvent>? notificationSchemeEvents,
      List<int>? projects,
      Scope? scope,
      String? self}) {
    return NotificationScheme(
      description: description ?? this.description,
      expand: expand ?? this.expand,
      id: id ?? this.id,
      name: name ?? this.name,
      notificationSchemeEvents:
          notificationSchemeEvents ?? this.notificationSchemeEvents,
      projects: projects ?? this.projects,
      scope: scope ?? this.scope,
      self: self ?? this.self,
    );
  }
}

class NotificationSchemeAndProjectMappingJsonBean {
  final String? notificationSchemeId;
  final String? projectId;

  NotificationSchemeAndProjectMappingJsonBean(
      {this.notificationSchemeId, this.projectId});

  factory NotificationSchemeAndProjectMappingJsonBean.fromJson(
      Map<String, Object?> json) {
    return NotificationSchemeAndProjectMappingJsonBean(
      notificationSchemeId: json[r'notificationSchemeId'] as String?,
      projectId: json[r'projectId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var notificationSchemeId = this.notificationSchemeId;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    if (notificationSchemeId != null) {
      json[r'notificationSchemeId'] = notificationSchemeId;
    }
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    return json;
  }

  NotificationSchemeAndProjectMappingJsonBean copyWith(
      {String? notificationSchemeId, String? projectId}) {
    return NotificationSchemeAndProjectMappingJsonBean(
      notificationSchemeId: notificationSchemeId ?? this.notificationSchemeId,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// Details about a notification scheme event.
class NotificationSchemeEvent {
  final NotificationEvent? event;
  final List<EventNotification> notifications;

  NotificationSchemeEvent({this.event, List<EventNotification>? notifications})
      : notifications = notifications ?? [];

  factory NotificationSchemeEvent.fromJson(Map<String, Object?> json) {
    return NotificationSchemeEvent(
      event: json[r'event'] != null
          ? NotificationEvent.fromJson(json[r'event']! as Map<String, Object?>)
          : null,
      notifications: (json[r'notifications'] as List<Object?>?)
              ?.map((i) => EventNotification.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var event = this.event;
    var notifications = this.notifications;

    final json = <String, Object?>{};
    if (event != null) {
      json[r'event'] = event.toJson();
    }
    json[r'notifications'] = notifications.map((i) => i.toJson()).toList();
    return json;
  }

  NotificationSchemeEvent copyWith(
      {NotificationEvent? event, List<EventNotification>? notifications}) {
    return NotificationSchemeEvent(
      event: event ?? this.event,
      notifications: notifications ?? this.notifications,
    );
  }
}

/// Details of a notification scheme event.
class NotificationSchemeEventDetails {
  /// The ID of the event.
  final NotificationSchemeEventTypeId event;

  /// The list of notifications mapped to a specified event.
  final List<NotificationSchemeNotificationDetails> notifications;

  NotificationSchemeEventDetails(
      {required this.event, required this.notifications});

  factory NotificationSchemeEventDetails.fromJson(Map<String, Object?> json) {
    return NotificationSchemeEventDetails(
      event: NotificationSchemeEventTypeId.fromJson(
          json[r'event'] as Map<String, Object?>? ?? const {}),
      notifications: (json[r'notifications'] as List<Object?>?)
              ?.map((i) => NotificationSchemeNotificationDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var event = this.event;
    var notifications = this.notifications;

    final json = <String, Object?>{};
    json[r'event'] = event.toJson();
    json[r'notifications'] = notifications.map((i) => i.toJson()).toList();
    return json;
  }

  NotificationSchemeEventDetails copyWith(
      {NotificationSchemeEventTypeId? event,
      List<NotificationSchemeNotificationDetails>? notifications}) {
    return NotificationSchemeEventDetails(
      event: event ?? this.event,
      notifications: notifications ?? this.notifications,
    );
  }
}

/// The ID of an event that is being mapped to notifications.
class NotificationSchemeEventTypeId {
  /// The ID of the notification scheme event.
  final String id;

  NotificationSchemeEventTypeId({required this.id});

  factory NotificationSchemeEventTypeId.fromJson(Map<String, Object?> json) {
    return NotificationSchemeEventTypeId(
      id: json[r'id'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  NotificationSchemeEventTypeId copyWith({String? id}) {
    return NotificationSchemeEventTypeId(
      id: id ?? this.id,
    );
  }
}

/// The ID of a notification scheme.
class NotificationSchemeId {
  /// The ID of a notification scheme.
  final String id;

  NotificationSchemeId({required this.id});

  factory NotificationSchemeId.fromJson(Map<String, Object?> json) {
    return NotificationSchemeId(
      id: json[r'id'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  NotificationSchemeId copyWith({String? id}) {
    return NotificationSchemeId(
      id: id ?? this.id,
    );
  }
}

/// Details of a notification within a notification scheme.
class NotificationSchemeNotificationDetails {
  /// The notification type, e.g `CurrentAssignee`, `Group`, `EmailAddress`.
  final String notificationType;

  /// The value corresponding to the specified notification type.
  final String? parameter;

  NotificationSchemeNotificationDetails(
      {required this.notificationType, this.parameter});

  factory NotificationSchemeNotificationDetails.fromJson(
      Map<String, Object?> json) {
    return NotificationSchemeNotificationDetails(
      notificationType: json[r'notificationType'] as String? ?? '',
      parameter: json[r'parameter'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var notificationType = this.notificationType;
    var parameter = this.parameter;

    final json = <String, Object?>{};
    json[r'notificationType'] = notificationType;
    if (parameter != null) {
      json[r'parameter'] = parameter;
    }
    return json;
  }

  NotificationSchemeNotificationDetails copyWith(
      {String? notificationType, String? parameter}) {
    return NotificationSchemeNotificationDetails(
      notificationType: notificationType ?? this.notificationType,
      parameter: parameter ?? this.parameter,
    );
  }
}

class OldToNewSecurityLevelMappingsBean {
  /// The new issue security level ID. Providing null will clear the assigned
  /// old level from issues.
  final String newLevelId;

  /// The old issue security level ID. Providing null will remap all issues
  /// without any assigned levels.
  final String oldLevelId;

  OldToNewSecurityLevelMappingsBean(
      {required this.newLevelId, required this.oldLevelId});

  factory OldToNewSecurityLevelMappingsBean.fromJson(
      Map<String, Object?> json) {
    return OldToNewSecurityLevelMappingsBean(
      newLevelId: json[r'newLevelId'] as String? ?? '',
      oldLevelId: json[r'oldLevelId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var newLevelId = this.newLevelId;
    var oldLevelId = this.oldLevelId;

    final json = <String, Object?>{};
    json[r'newLevelId'] = newLevelId;
    json[r'oldLevelId'] = oldLevelId;
    return json;
  }

  OldToNewSecurityLevelMappingsBean copyWith(
      {String? newLevelId, String? oldLevelId}) {
    return OldToNewSecurityLevelMappingsBean(
      newLevelId: newLevelId ?? this.newLevelId,
      oldLevelId: oldLevelId ?? this.oldLevelId,
    );
  }
}

class OperationMessage {
  /// The human-readable message that describes the result.
  final String message;

  /// The status code of the response.
  final int statusCode;

  OperationMessage({required this.message, required this.statusCode});

  factory OperationMessage.fromJson(Map<String, Object?> json) {
    return OperationMessage(
      message: json[r'message'] as String? ?? '',
      statusCode: (json[r'statusCode'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var message = this.message;
    var statusCode = this.statusCode;

    final json = <String, Object?>{};
    json[r'message'] = message;
    json[r'statusCode'] = statusCode;
    return json;
  }

  OperationMessage copyWith({String? message, int? statusCode}) {
    return OperationMessage(
      message: message ?? this.message,
      statusCode: statusCode ?? this.statusCode,
    );
  }
}

/// Details of the operations that can be performed on the issue.
class Operations {
  /// Details of the link groups defining issue operations.
  final List<LinkGroup> linkGroups;

  Operations({List<LinkGroup>? linkGroups}) : linkGroups = linkGroups ?? [];

  factory Operations.fromJson(Map<String, Object?> json) {
    return Operations(
      linkGroups: (json[r'linkGroups'] as List<Object?>?)
              ?.map((i) =>
                  LinkGroup.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var linkGroups = this.linkGroups;

    final json = <String, Object?>{};
    json[r'linkGroups'] = linkGroups.map((i) => i.toJson()).toList();
    return json;
  }

  Operations copyWith({List<LinkGroup>? linkGroups}) {
    return Operations(
      linkGroups: linkGroups ?? this.linkGroups,
    );
  }
}

/// An ordered list of custom field option IDs and information on where to move
/// them.
class OrderOfCustomFieldOptions {
  /// The ID of the custom field option or cascading option to place the moved
  /// options after. Required if `position` isn't provided.
  final String? after;

  /// A list of IDs of custom field options to move. The order of the custom
  /// field option IDs in the list is the order they are given after the move.
  /// The list must contain custom field options or cascading options, but not
  /// both.
  final List<String> customFieldOptionIds;

  /// The position the custom field options should be moved to. Required if
  /// `after` isn't provided.
  final OrderOfCustomFieldOptionsPosition? position;

  OrderOfCustomFieldOptions(
      {this.after, required this.customFieldOptionIds, this.position});

  factory OrderOfCustomFieldOptions.fromJson(Map<String, Object?> json) {
    return OrderOfCustomFieldOptions(
      after: json[r'after'] as String?,
      customFieldOptionIds: (json[r'customFieldOptionIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      position: json[r'position'] != null
          ? OrderOfCustomFieldOptionsPosition.fromValue(
              json[r'position']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var after = this.after;
    var customFieldOptionIds = this.customFieldOptionIds;
    var position = this.position;

    final json = <String, Object?>{};
    if (after != null) {
      json[r'after'] = after;
    }
    json[r'customFieldOptionIds'] = customFieldOptionIds;
    if (position != null) {
      json[r'position'] = position.value;
    }
    return json;
  }

  OrderOfCustomFieldOptions copyWith(
      {String? after,
      List<String>? customFieldOptionIds,
      OrderOfCustomFieldOptionsPosition? position}) {
    return OrderOfCustomFieldOptions(
      after: after ?? this.after,
      customFieldOptionIds: customFieldOptionIds ?? this.customFieldOptionIds,
      position: position ?? this.position,
    );
  }
}

class OrderOfCustomFieldOptionsPosition {
  static const first = OrderOfCustomFieldOptionsPosition._('First');
  static const last = OrderOfCustomFieldOptionsPosition._('Last');

  static const values = [
    first,
    last,
  ];
  final String value;

  const OrderOfCustomFieldOptionsPosition._(this.value);

  static OrderOfCustomFieldOptionsPosition fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => OrderOfCustomFieldOptionsPosition._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// An ordered list of issue type IDs and information about where to move them.
class OrderOfIssueTypes {
  /// The ID of the issue type to place the moved issue types after. Required if
  /// `position` isn't provided.
  final String? after;

  /// A list of the issue type IDs to move. The order of the issue type IDs in
  /// the list is the order they are given after the move.
  final List<String> issueTypeIds;

  /// The position the issue types should be moved to. Required if `after` isn't
  /// provided.
  final OrderOfIssueTypesPosition? position;

  OrderOfIssueTypes({this.after, required this.issueTypeIds, this.position});

  factory OrderOfIssueTypes.fromJson(Map<String, Object?> json) {
    return OrderOfIssueTypes(
      after: json[r'after'] as String?,
      issueTypeIds: (json[r'issueTypeIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      position: json[r'position'] != null
          ? OrderOfIssueTypesPosition.fromValue(json[r'position']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var after = this.after;
    var issueTypeIds = this.issueTypeIds;
    var position = this.position;

    final json = <String, Object?>{};
    if (after != null) {
      json[r'after'] = after;
    }
    json[r'issueTypeIds'] = issueTypeIds;
    if (position != null) {
      json[r'position'] = position.value;
    }
    return json;
  }

  OrderOfIssueTypes copyWith(
      {String? after,
      List<String>? issueTypeIds,
      OrderOfIssueTypesPosition? position}) {
    return OrderOfIssueTypes(
      after: after ?? this.after,
      issueTypeIds: issueTypeIds ?? this.issueTypeIds,
      position: position ?? this.position,
    );
  }
}

class OrderOfIssueTypesPosition {
  static const first = OrderOfIssueTypesPosition._('First');
  static const last = OrderOfIssueTypesPosition._('Last');

  static const values = [
    first,
    last,
  ];
  final String value;

  const OrderOfIssueTypesPosition._(this.value);

  static OrderOfIssueTypesPosition fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => OrderOfIssueTypesPosition._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A page of items.
class PageBeanChangelog {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<Changelog> values;

  PageBeanChangelog(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<Changelog>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanChangelog.fromJson(Map<String, Object?> json) {
    return PageBeanChangelog(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Changelog.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanChangelog copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<Changelog>? values}) {
    return PageBeanChangelog(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanComment {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<Comment> values;

  PageBeanComment(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<Comment>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanComment.fromJson(Map<String, Object?> json) {
    return PageBeanComment(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Comment.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanComment copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<Comment>? values}) {
    return PageBeanComment(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanComponentWithIssueCount {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<ComponentWithIssueCount> values;

  PageBeanComponentWithIssueCount(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<ComponentWithIssueCount>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanComponentWithIssueCount.fromJson(Map<String, Object?> json) {
    return PageBeanComponentWithIssueCount(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => ComponentWithIssueCount.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanComponentWithIssueCount copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<ComponentWithIssueCount>? values}) {
    return PageBeanComponentWithIssueCount(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanContext {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<Context> values;

  PageBeanContext(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<Context>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanContext.fromJson(Map<String, Object?> json) {
    return PageBeanContext(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Context.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanContext copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<Context>? values}) {
    return PageBeanContext(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanContextForProjectAndIssueType {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<ContextForProjectAndIssueType> values;

  PageBeanContextForProjectAndIssueType(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<ContextForProjectAndIssueType>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanContextForProjectAndIssueType.fromJson(
      Map<String, Object?> json) {
    return PageBeanContextForProjectAndIssueType(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => ContextForProjectAndIssueType.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanContextForProjectAndIssueType copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<ContextForProjectAndIssueType>? values}) {
    return PageBeanContextForProjectAndIssueType(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanContextualConfiguration {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<ContextualConfiguration> values;

  PageBeanContextualConfiguration(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<ContextualConfiguration>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanContextualConfiguration.fromJson(Map<String, Object?> json) {
    return PageBeanContextualConfiguration(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => ContextualConfiguration.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanContextualConfiguration copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<ContextualConfiguration>? values}) {
    return PageBeanContextualConfiguration(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanCustomFieldContext {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<CustomFieldContext> values;

  PageBeanCustomFieldContext(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<CustomFieldContext>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanCustomFieldContext.fromJson(Map<String, Object?> json) {
    return PageBeanCustomFieldContext(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => CustomFieldContext.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanCustomFieldContext copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<CustomFieldContext>? values}) {
    return PageBeanCustomFieldContext(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanCustomFieldContextDefaultValue {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<CustomFieldContextDefaultValue> values;

  PageBeanCustomFieldContextDefaultValue(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<CustomFieldContextDefaultValue>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanCustomFieldContextDefaultValue.fromJson(
      Map<String, Object?> json) {
    return PageBeanCustomFieldContextDefaultValue(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => CustomFieldContextDefaultValue.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanCustomFieldContextDefaultValue copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<CustomFieldContextDefaultValue>? values}) {
    return PageBeanCustomFieldContextDefaultValue(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanCustomFieldContextOption {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<CustomFieldContextOption> values;

  PageBeanCustomFieldContextOption(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<CustomFieldContextOption>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanCustomFieldContextOption.fromJson(Map<String, Object?> json) {
    return PageBeanCustomFieldContextOption(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => CustomFieldContextOption.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanCustomFieldContextOption copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<CustomFieldContextOption>? values}) {
    return PageBeanCustomFieldContextOption(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanCustomFieldContextProjectMapping {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<CustomFieldContextProjectMapping> values;

  PageBeanCustomFieldContextProjectMapping(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<CustomFieldContextProjectMapping>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanCustomFieldContextProjectMapping.fromJson(
      Map<String, Object?> json) {
    return PageBeanCustomFieldContextProjectMapping(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => CustomFieldContextProjectMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanCustomFieldContextProjectMapping copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<CustomFieldContextProjectMapping>? values}) {
    return PageBeanCustomFieldContextProjectMapping(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanDashboard {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<Dashboard> values;

  PageBeanDashboard(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<Dashboard>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanDashboard.fromJson(Map<String, Object?> json) {
    return PageBeanDashboard(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Dashboard.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanDashboard copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<Dashboard>? values}) {
    return PageBeanDashboard(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanField {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<Field> values;

  PageBeanField(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<Field>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanField.fromJson(Map<String, Object?> json) {
    return PageBeanField(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map(
                  (i) => Field.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanField copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<Field>? values}) {
    return PageBeanField(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanFieldConfigurationDetails {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<FieldConfigurationDetails> values;

  PageBeanFieldConfigurationDetails(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<FieldConfigurationDetails>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanFieldConfigurationDetails.fromJson(
      Map<String, Object?> json) {
    return PageBeanFieldConfigurationDetails(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FieldConfigurationDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanFieldConfigurationDetails copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<FieldConfigurationDetails>? values}) {
    return PageBeanFieldConfigurationDetails(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanFieldConfigurationIssueTypeItem {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<FieldConfigurationIssueTypeItem> values;

  PageBeanFieldConfigurationIssueTypeItem(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<FieldConfigurationIssueTypeItem>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanFieldConfigurationIssueTypeItem.fromJson(
      Map<String, Object?> json) {
    return PageBeanFieldConfigurationIssueTypeItem(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FieldConfigurationIssueTypeItem.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanFieldConfigurationIssueTypeItem copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<FieldConfigurationIssueTypeItem>? values}) {
    return PageBeanFieldConfigurationIssueTypeItem(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanFieldConfigurationItem {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<FieldConfigurationItem> values;

  PageBeanFieldConfigurationItem(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<FieldConfigurationItem>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanFieldConfigurationItem.fromJson(Map<String, Object?> json) {
    return PageBeanFieldConfigurationItem(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FieldConfigurationItem.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanFieldConfigurationItem copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<FieldConfigurationItem>? values}) {
    return PageBeanFieldConfigurationItem(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanFieldConfigurationScheme {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<FieldConfigurationScheme> values;

  PageBeanFieldConfigurationScheme(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<FieldConfigurationScheme>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanFieldConfigurationScheme.fromJson(Map<String, Object?> json) {
    return PageBeanFieldConfigurationScheme(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FieldConfigurationScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanFieldConfigurationScheme copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<FieldConfigurationScheme>? values}) {
    return PageBeanFieldConfigurationScheme(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanFieldConfigurationSchemeProjects {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<FieldConfigurationSchemeProjects> values;

  PageBeanFieldConfigurationSchemeProjects(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<FieldConfigurationSchemeProjects>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanFieldConfigurationSchemeProjects.fromJson(
      Map<String, Object?> json) {
    return PageBeanFieldConfigurationSchemeProjects(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FieldConfigurationSchemeProjects.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanFieldConfigurationSchemeProjects copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<FieldConfigurationSchemeProjects>? values}) {
    return PageBeanFieldConfigurationSchemeProjects(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanFilterDetails {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<FilterDetails> values;

  PageBeanFilterDetails(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<FilterDetails>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanFilterDetails.fromJson(Map<String, Object?> json) {
    return PageBeanFilterDetails(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => FilterDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanFilterDetails copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<FilterDetails>? values}) {
    return PageBeanFilterDetails(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanGroupDetails {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<GroupDetails> values;

  PageBeanGroupDetails(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<GroupDetails>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanGroupDetails.fromJson(Map<String, Object?> json) {
    return PageBeanGroupDetails(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  GroupDetails.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanGroupDetails copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<GroupDetails>? values}) {
    return PageBeanGroupDetails(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanIssueFieldOption {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<IssueFieldOption> values;

  PageBeanIssueFieldOption(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<IssueFieldOption>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueFieldOption.fromJson(Map<String, Object?> json) {
    return PageBeanIssueFieldOption(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueFieldOption.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueFieldOption copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<IssueFieldOption>? values}) {
    return PageBeanIssueFieldOption(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanIssueSecurityLevelMember {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<IssueSecurityLevelMember> values;

  PageBeanIssueSecurityLevelMember(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<IssueSecurityLevelMember>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueSecurityLevelMember.fromJson(Map<String, Object?> json) {
    return PageBeanIssueSecurityLevelMember(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueSecurityLevelMember.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueSecurityLevelMember copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<IssueSecurityLevelMember>? values}) {
    return PageBeanIssueSecurityLevelMember(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanIssueSecuritySchemeToProjectMapping {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<IssueSecuritySchemeToProjectMapping> values;

  PageBeanIssueSecuritySchemeToProjectMapping(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<IssueSecuritySchemeToProjectMapping>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueSecuritySchemeToProjectMapping.fromJson(
      Map<String, Object?> json) {
    return PageBeanIssueSecuritySchemeToProjectMapping(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueSecuritySchemeToProjectMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueSecuritySchemeToProjectMapping copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<IssueSecuritySchemeToProjectMapping>? values}) {
    return PageBeanIssueSecuritySchemeToProjectMapping(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeScheme {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<IssueTypeScheme> values;

  PageBeanIssueTypeScheme(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<IssueTypeScheme>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeScheme.fromJson(Map<String, Object?> json) {
    return PageBeanIssueTypeScheme(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeScheme copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<IssueTypeScheme>? values}) {
    return PageBeanIssueTypeScheme(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeSchemeMapping {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<IssueTypeSchemeMapping> values;

  PageBeanIssueTypeSchemeMapping(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<IssueTypeSchemeMapping>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeSchemeMapping.fromJson(Map<String, Object?> json) {
    return PageBeanIssueTypeSchemeMapping(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeSchemeMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeSchemeMapping copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<IssueTypeSchemeMapping>? values}) {
    return PageBeanIssueTypeSchemeMapping(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeSchemeProjects {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<IssueTypeSchemeProjects> values;

  PageBeanIssueTypeSchemeProjects(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<IssueTypeSchemeProjects>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeSchemeProjects.fromJson(Map<String, Object?> json) {
    return PageBeanIssueTypeSchemeProjects(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeSchemeProjects.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeSchemeProjects copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<IssueTypeSchemeProjects>? values}) {
    return PageBeanIssueTypeSchemeProjects(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeScreenScheme {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<IssueTypeScreenScheme> values;

  PageBeanIssueTypeScreenScheme(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<IssueTypeScreenScheme>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeScreenScheme.fromJson(Map<String, Object?> json) {
    return PageBeanIssueTypeScreenScheme(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeScreenScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeScreenScheme copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<IssueTypeScreenScheme>? values}) {
    return PageBeanIssueTypeScreenScheme(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeScreenSchemeItem {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<IssueTypeScreenSchemeItem> values;

  PageBeanIssueTypeScreenSchemeItem(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<IssueTypeScreenSchemeItem>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeScreenSchemeItem.fromJson(
      Map<String, Object?> json) {
    return PageBeanIssueTypeScreenSchemeItem(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeScreenSchemeItem.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeScreenSchemeItem copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<IssueTypeScreenSchemeItem>? values}) {
    return PageBeanIssueTypeScreenSchemeItem(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeScreenSchemesProjects {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<IssueTypeScreenSchemesProjects> values;

  PageBeanIssueTypeScreenSchemesProjects(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<IssueTypeScreenSchemesProjects>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeScreenSchemesProjects.fromJson(
      Map<String, Object?> json) {
    return PageBeanIssueTypeScreenSchemesProjects(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeScreenSchemesProjects.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeScreenSchemesProjects copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<IssueTypeScreenSchemesProjects>? values}) {
    return PageBeanIssueTypeScreenSchemesProjects(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanIssueTypeToContextMapping {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<IssueTypeToContextMapping> values;

  PageBeanIssueTypeToContextMapping(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<IssueTypeToContextMapping>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanIssueTypeToContextMapping.fromJson(
      Map<String, Object?> json) {
    return PageBeanIssueTypeToContextMapping(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => IssueTypeToContextMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanIssueTypeToContextMapping copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<IssueTypeToContextMapping>? values}) {
    return PageBeanIssueTypeToContextMapping(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanJqlFunctionPrecomputationBean {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<JqlFunctionPrecomputationBean> values;

  PageBeanJqlFunctionPrecomputationBean(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<JqlFunctionPrecomputationBean>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanJqlFunctionPrecomputationBean.fromJson(
      Map<String, Object?> json) {
    return PageBeanJqlFunctionPrecomputationBean(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => JqlFunctionPrecomputationBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanJqlFunctionPrecomputationBean copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<JqlFunctionPrecomputationBean>? values}) {
    return PageBeanJqlFunctionPrecomputationBean(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanNotificationScheme {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<NotificationScheme> values;

  PageBeanNotificationScheme(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<NotificationScheme>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanNotificationScheme.fromJson(Map<String, Object?> json) {
    return PageBeanNotificationScheme(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => NotificationScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanNotificationScheme copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<NotificationScheme>? values}) {
    return PageBeanNotificationScheme(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanNotificationSchemeAndProjectMappingJsonBean {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<NotificationSchemeAndProjectMappingJsonBean> values;

  PageBeanNotificationSchemeAndProjectMappingJsonBean(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<NotificationSchemeAndProjectMappingJsonBean>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanNotificationSchemeAndProjectMappingJsonBean.fromJson(
      Map<String, Object?> json) {
    return PageBeanNotificationSchemeAndProjectMappingJsonBean(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => NotificationSchemeAndProjectMappingJsonBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanNotificationSchemeAndProjectMappingJsonBean copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<NotificationSchemeAndProjectMappingJsonBean>? values}) {
    return PageBeanNotificationSchemeAndProjectMappingJsonBean(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanPriority {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<Priority> values;

  PageBeanPriority(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<Priority>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanPriority.fromJson(Map<String, Object?> json) {
    return PageBeanPriority(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Priority.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanPriority copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<Priority>? values}) {
    return PageBeanPriority(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanProject {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<Project> values;

  PageBeanProject(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<Project>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanProject.fromJson(Map<String, Object?> json) {
    return PageBeanProject(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Project.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanProject copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<Project>? values}) {
    return PageBeanProject(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanProjectDetails {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<ProjectDetails> values;

  PageBeanProjectDetails(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<ProjectDetails>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanProjectDetails.fromJson(Map<String, Object?> json) {
    return PageBeanProjectDetails(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => ProjectDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanProjectDetails copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<ProjectDetails>? values}) {
    return PageBeanProjectDetails(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanResolutionJsonBean {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<ResolutionJsonBean> values;

  PageBeanResolutionJsonBean(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<ResolutionJsonBean>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanResolutionJsonBean.fromJson(Map<String, Object?> json) {
    return PageBeanResolutionJsonBean(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => ResolutionJsonBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanResolutionJsonBean copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<ResolutionJsonBean>? values}) {
    return PageBeanResolutionJsonBean(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanScreen {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<Screen> values;

  PageBeanScreen(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<Screen>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanScreen.fromJson(Map<String, Object?> json) {
    return PageBeanScreen(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Screen.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanScreen copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<Screen>? values}) {
    return PageBeanScreen(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanScreenScheme {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<ScreenScheme> values;

  PageBeanScreenScheme(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<ScreenScheme>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanScreenScheme.fromJson(Map<String, Object?> json) {
    return PageBeanScreenScheme(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  ScreenScheme.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanScreenScheme copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<ScreenScheme>? values}) {
    return PageBeanScreenScheme(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanScreenWithTab {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<ScreenWithTab> values;

  PageBeanScreenWithTab(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<ScreenWithTab>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanScreenWithTab.fromJson(Map<String, Object?> json) {
    return PageBeanScreenWithTab(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => ScreenWithTab.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanScreenWithTab copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<ScreenWithTab>? values}) {
    return PageBeanScreenWithTab(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanSecurityLevel {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<SecurityLevel> values;

  PageBeanSecurityLevel(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<SecurityLevel>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanSecurityLevel.fromJson(Map<String, Object?> json) {
    return PageBeanSecurityLevel(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => SecurityLevel.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanSecurityLevel copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<SecurityLevel>? values}) {
    return PageBeanSecurityLevel(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanSecurityLevelMember {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<SecurityLevelMember> values;

  PageBeanSecurityLevelMember(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<SecurityLevelMember>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanSecurityLevelMember.fromJson(Map<String, Object?> json) {
    return PageBeanSecurityLevelMember(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => SecurityLevelMember.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanSecurityLevelMember copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<SecurityLevelMember>? values}) {
    return PageBeanSecurityLevelMember(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanSecuritySchemeWithProjects {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<SecuritySchemeWithProjects> values;

  PageBeanSecuritySchemeWithProjects(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<SecuritySchemeWithProjects>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanSecuritySchemeWithProjects.fromJson(
      Map<String, Object?> json) {
    return PageBeanSecuritySchemeWithProjects(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => SecuritySchemeWithProjects.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanSecuritySchemeWithProjects copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<SecuritySchemeWithProjects>? values}) {
    return PageBeanSecuritySchemeWithProjects(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanString {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<String> values;

  PageBeanString(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<String>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanString.fromJson(Map<String, Object?> json) {
    return PageBeanString(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values;
    return json;
  }

  PageBeanString copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<String>? values}) {
    return PageBeanString(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanUiModificationDetails {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<UiModificationDetails> values;

  PageBeanUiModificationDetails(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<UiModificationDetails>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanUiModificationDetails.fromJson(Map<String, Object?> json) {
    return PageBeanUiModificationDetails(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => UiModificationDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanUiModificationDetails copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<UiModificationDetails>? values}) {
    return PageBeanUiModificationDetails(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanUser {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<User> values;

  PageBeanUser(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<User>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanUser.fromJson(Map<String, Object?> json) {
    return PageBeanUser(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map(
                  (i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanUser copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<User>? values}) {
    return PageBeanUser(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanUserDetails {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<UserDetails> values;

  PageBeanUserDetails(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<UserDetails>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanUserDetails.fromJson(Map<String, Object?> json) {
    return PageBeanUserDetails(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  UserDetails.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanUserDetails copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<UserDetails>? values}) {
    return PageBeanUserDetails(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanUserKey {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<UserKey> values;

  PageBeanUserKey(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<UserKey>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanUserKey.fromJson(Map<String, Object?> json) {
    return PageBeanUserKey(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  UserKey.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanUserKey copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<UserKey>? values}) {
    return PageBeanUserKey(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanVersion {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<Version> values;

  PageBeanVersion(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<Version>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanVersion.fromJson(Map<String, Object?> json) {
    return PageBeanVersion(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Version.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanVersion copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<Version>? values}) {
    return PageBeanVersion(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanWebhook {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<Webhook> values;

  PageBeanWebhook(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<Webhook>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanWebhook.fromJson(Map<String, Object?> json) {
    return PageBeanWebhook(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Webhook.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanWebhook copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<Webhook>? values}) {
    return PageBeanWebhook(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanWorkflow {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<Workflow> values;

  PageBeanWorkflow(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<Workflow>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanWorkflow.fromJson(Map<String, Object?> json) {
    return PageBeanWorkflow(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  Workflow.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanWorkflow copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<Workflow>? values}) {
    return PageBeanWorkflow(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanWorkflowScheme {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<WorkflowScheme> values;

  PageBeanWorkflowScheme(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<WorkflowScheme>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanWorkflowScheme.fromJson(Map<String, Object?> json) {
    return PageBeanWorkflowScheme(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => WorkflowScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanWorkflowScheme copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<WorkflowScheme>? values}) {
    return PageBeanWorkflowScheme(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of items.
class PageBeanWorkflowTransitionRules {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// If there is another page of results, the URL of the next page.
  final String? nextPage;

  /// The URL of the page.
  final String? self;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  /// The list of items.
  final List<WorkflowTransitionRules> values;

  PageBeanWorkflowTransitionRules(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<WorkflowTransitionRules>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageBeanWorkflowTransitionRules.fromJson(Map<String, Object?> json) {
    return PageBeanWorkflowTransitionRules(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRules.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageBeanWorkflowTransitionRules copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<WorkflowTransitionRules>? values}) {
    return PageBeanWorkflowTransitionRules(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// A page of changelogs.
class PageOfChangelogs {
  /// The list of changelogs.
  final List<Changelog> histories;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The index of the first item returned on the page.
  final int? startAt;

  /// The number of results on the page.
  final int? total;

  PageOfChangelogs(
      {List<Changelog>? histories, this.maxResults, this.startAt, this.total})
      : histories = histories ?? [];

  factory PageOfChangelogs.fromJson(Map<String, Object?> json) {
    return PageOfChangelogs(
      histories: (json[r'histories'] as List<Object?>?)
              ?.map((i) =>
                  Changelog.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var histories = this.histories;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'histories'] = histories.map((i) => i.toJson()).toList();
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  PageOfChangelogs copyWith(
      {List<Changelog>? histories, int? maxResults, int? startAt, int? total}) {
    return PageOfChangelogs(
      histories: histories ?? this.histories,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
    );
  }
}

/// A page of comments.
class PageOfComments {
  /// The list of comments.
  final List<Comment> comments;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The index of the first item returned.
  final int? startAt;

  /// The number of items returned.
  final int? total;

  PageOfComments(
      {List<Comment>? comments, this.maxResults, this.startAt, this.total})
      : comments = comments ?? [];

  factory PageOfComments.fromJson(Map<String, Object?> json) {
    return PageOfComments(
      comments: (json[r'comments'] as List<Object?>?)
              ?.map((i) =>
                  Comment.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var comments = this.comments;
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'comments'] = comments.map((i) => i.toJson()).toList();
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  PageOfComments copyWith(
      {List<Comment>? comments, int? maxResults, int? startAt, int? total}) {
    return PageOfComments(
      comments: comments ?? this.comments,
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
    );
  }
}

/// A page containing dashboard details.
class PageOfDashboards {
  /// List of dashboards.
  final List<Dashboard> dashboards;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The URL of the next page of results, if any.
  final String? next;

  /// The URL of the previous page of results, if any.
  final String? prev;

  /// The index of the first item returned on the page.
  final int? startAt;

  /// The number of results on the page.
  final int? total;

  PageOfDashboards(
      {List<Dashboard>? dashboards,
      this.maxResults,
      this.next,
      this.prev,
      this.startAt,
      this.total})
      : dashboards = dashboards ?? [];

  factory PageOfDashboards.fromJson(Map<String, Object?> json) {
    return PageOfDashboards(
      dashboards: (json[r'dashboards'] as List<Object?>?)
              ?.map((i) =>
                  Dashboard.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      next: json[r'next'] as String?,
      prev: json[r'prev'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var dashboards = this.dashboards;
    var maxResults = this.maxResults;
    var next = this.next;
    var prev = this.prev;
    var startAt = this.startAt;
    var total = this.total;

    final json = <String, Object?>{};
    json[r'dashboards'] = dashboards.map((i) => i.toJson()).toList();
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (next != null) {
      json[r'next'] = next;
    }
    if (prev != null) {
      json[r'prev'] = prev;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  PageOfDashboards copyWith(
      {List<Dashboard>? dashboards,
      int? maxResults,
      String? next,
      String? prev,
      int? startAt,
      int? total}) {
    return PageOfDashboards(
      dashboards: dashboards ?? this.dashboards,
      maxResults: maxResults ?? this.maxResults,
      next: next ?? this.next,
      prev: prev ?? this.prev,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
    );
  }
}

class PageOfStatuses {
  /// Whether this is the last page.
  final bool isLast;

  /// The maximum number of items that could be returned.
  final int? maxResults;

  /// The URL of the next page of results, if any.
  final String? nextPage;

  /// The URL of this page.
  final String? self;

  /// The index of the first item returned on the page.
  final int? startAt;

  /// Number of items that satisfy the search.
  final int? total;

  /// The list of items.
  final List<JiraStatus> values;

  PageOfStatuses(
      {bool? isLast,
      this.maxResults,
      this.nextPage,
      this.self,
      this.startAt,
      this.total,
      List<JiraStatus>? values})
      : isLast = isLast ?? false,
        values = values ?? [];

  factory PageOfStatuses.fromJson(Map<String, Object?> json) {
    return PageOfStatuses(
      isLast: json[r'isLast'] as bool? ?? false,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      nextPage: json[r'nextPage'] as String?,
      self: json[r'self'] as String?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      values: (json[r'values'] as List<Object?>?)
              ?.map((i) =>
                  JiraStatus.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isLast = this.isLast;
    var maxResults = this.maxResults;
    var nextPage = this.nextPage;
    var self = this.self;
    var startAt = this.startAt;
    var total = this.total;
    var values = this.values;

    final json = <String, Object?>{};
    json[r'isLast'] = isLast;
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (nextPage != null) {
      json[r'nextPage'] = nextPage;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'values'] = values.map((i) => i.toJson()).toList();
    return json;
  }

  PageOfStatuses copyWith(
      {bool? isLast,
      int? maxResults,
      String? nextPage,
      String? self,
      int? startAt,
      int? total,
      List<JiraStatus>? values}) {
    return PageOfStatuses(
      isLast: isLast ?? this.isLast,
      maxResults: maxResults ?? this.maxResults,
      nextPage: nextPage ?? this.nextPage,
      self: self ?? this.self,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      values: values ?? this.values,
    );
  }
}

/// Paginated list of worklog details
class PageOfWorklogs {
  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The index of the first item returned on the page.
  final int? startAt;

  /// The number of results on the page.
  final int? total;

  /// List of worklogs.
  final List<Worklog> worklogs;

  PageOfWorklogs(
      {this.maxResults, this.startAt, this.total, List<Worklog>? worklogs})
      : worklogs = worklogs ?? [];

  factory PageOfWorklogs.fromJson(Map<String, Object?> json) {
    return PageOfWorklogs(
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      worklogs: (json[r'worklogs'] as List<Object?>?)
              ?.map((i) =>
                  Worklog.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var maxResults = this.maxResults;
    var startAt = this.startAt;
    var total = this.total;
    var worklogs = this.worklogs;

    final json = <String, Object?>{};
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'worklogs'] = worklogs.map((i) => i.toJson()).toList();
    return json;
  }

  PageOfWorklogs copyWith(
      {int? maxResults, int? startAt, int? total, List<Worklog>? worklogs}) {
    return PageOfWorklogs(
      maxResults: maxResults ?? this.maxResults,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      worklogs: worklogs ?? this.worklogs,
    );
  }
}

/// A paged list. To access additional details append `[start-index:end-index]`
/// to the expand request. For example, `?expand=sharedUsers[10:40]` returns a
/// list starting at item 10 and finishing at item 40.
class PagedListUserDetailsApplicationUser {
  /// The index of the last item returned on the page.
  final int? endIndex;

  /// The list of items.
  final List<UserDetails> items;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The number of items on the page.
  final int? size;

  /// The index of the first item returned on the page.
  final int? startIndex;

  PagedListUserDetailsApplicationUser(
      {this.endIndex,
      List<UserDetails>? items,
      this.maxResults,
      this.size,
      this.startIndex})
      : items = items ?? [];

  factory PagedListUserDetailsApplicationUser.fromJson(
      Map<String, Object?> json) {
    return PagedListUserDetailsApplicationUser(
      endIndex: (json[r'end-index'] as num?)?.toInt(),
      items: (json[r'items'] as List<Object?>?)
              ?.map((i) =>
                  UserDetails.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'max-results'] as num?)?.toInt(),
      size: (json[r'size'] as num?)?.toInt(),
      startIndex: (json[r'start-index'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var endIndex = this.endIndex;
    var items = this.items;
    var maxResults = this.maxResults;
    var size = this.size;
    var startIndex = this.startIndex;

    final json = <String, Object?>{};
    if (endIndex != null) {
      json[r'end-index'] = endIndex;
    }
    json[r'items'] = items.map((i) => i.toJson()).toList();
    if (maxResults != null) {
      json[r'max-results'] = maxResults;
    }
    if (size != null) {
      json[r'size'] = size;
    }
    if (startIndex != null) {
      json[r'start-index'] = startIndex;
    }
    return json;
  }

  PagedListUserDetailsApplicationUser copyWith(
      {int? endIndex,
      List<UserDetails>? items,
      int? maxResults,
      int? size,
      int? startIndex}) {
    return PagedListUserDetailsApplicationUser(
      endIndex: endIndex ?? this.endIndex,
      items: items ?? this.items,
      maxResults: maxResults ?? this.maxResults,
      size: size ?? this.size,
      startIndex: startIndex ?? this.startIndex,
    );
  }
}

class PaginatedResponseComment {
  final int? maxResults;
  final List<Comment> results;
  final int? startAt;
  final int? total;

  PaginatedResponseComment(
      {this.maxResults, List<Comment>? results, this.startAt, this.total})
      : results = results ?? [];

  factory PaginatedResponseComment.fromJson(Map<String, Object?> json) {
    return PaginatedResponseComment(
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      results: (json[r'results'] as List<Object?>?)
              ?.map((i) =>
                  Comment.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var maxResults = this.maxResults;
    var results = this.results;
    var startAt = this.startAt;
    var total = this.total;

    final json = <String, Object?>{};
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    json[r'results'] = results.map((i) => i.toJson()).toList();
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    return json;
  }

  PaginatedResponseComment copyWith(
      {int? maxResults, List<Comment>? results, int? startAt, int? total}) {
    return PaginatedResponseComment(
      maxResults: maxResults ?? this.maxResults,
      results: results ?? this.results,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
    );
  }
}

/// A list of parsed JQL queries.
class ParsedJqlQueries {
  /// A list of parsed JQL queries.
  final List<ParsedJqlQuery> queries;

  ParsedJqlQueries({required this.queries});

  factory ParsedJqlQueries.fromJson(Map<String, Object?> json) {
    return ParsedJqlQueries(
      queries: (json[r'queries'] as List<Object?>?)
              ?.map((i) => ParsedJqlQuery.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var queries = this.queries;

    final json = <String, Object?>{};
    json[r'queries'] = queries.map((i) => i.toJson()).toList();
    return json;
  }

  ParsedJqlQueries copyWith({List<ParsedJqlQuery>? queries}) {
    return ParsedJqlQueries(
      queries: queries ?? this.queries,
    );
  }
}

/// Details of a parsed JQL query.
class ParsedJqlQuery {
  /// The list of syntax or validation errors.
  final List<String> errors;

  /// The JQL query that was parsed and validated.
  final String query;

  /// The syntax tree of the query. Empty if the query was invalid.
  final JqlQuery? structure;

  ParsedJqlQuery({List<String>? errors, required this.query, this.structure})
      : errors = errors ?? [];

  factory ParsedJqlQuery.fromJson(Map<String, Object?> json) {
    return ParsedJqlQuery(
      errors: (json[r'errors'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      query: json[r'query'] as String? ?? '',
      structure: json[r'structure'] != null
          ? JqlQuery.fromJson(json[r'structure']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var errors = this.errors;
    var query = this.query;
    var structure = this.structure;

    final json = <String, Object?>{};
    json[r'errors'] = errors;
    json[r'query'] = query;
    if (structure != null) {
      json[r'structure'] = structure.toJson();
    }
    return json;
  }

  ParsedJqlQuery copyWith(
      {List<String>? errors, String? query, JqlQuery? structure}) {
    return ParsedJqlQuery(
      errors: errors ?? this.errors,
      query: query ?? this.query,
      structure: structure ?? this.structure,
    );
  }
}

/// Details about a permission granted to a user or group.
class PermissionGrant {
  /// The user or group being granted the permission. It consists of a `type`, a
  /// type-dependent `parameter` and a type-dependent `value`. See
  /// [Holder object](../api-group-permission-schemes/#holder-object) in *Get
  /// all permission schemes* for more information.
  final PermissionHolder? holder;

  /// The ID of the permission granted details.
  final int? id;

  /// The permission to grant. This permission can be one of the built-in
  /// permissions or a custom permission added by an app. See
  /// [Built-in permissions](../api-group-permission-schemes/#built-in-permissions)
  /// in *Get all permission schemes* for more information about the built-in
  /// permissions. See the
  /// [project permission](https://developer.atlassian.com/cloud/jira/platform/modules/project-permission/)
  /// and
  /// [global permission](https://developer.atlassian.com/cloud/jira/platform/modules/global-permission/)
  /// module documentation for more information about custom permissions.
  final String? permission;

  /// The URL of the permission granted details.
  final String? self;

  PermissionGrant({this.holder, this.id, this.permission, this.self});

  factory PermissionGrant.fromJson(Map<String, Object?> json) {
    return PermissionGrant(
      holder: json[r'holder'] != null
          ? PermissionHolder.fromJson(json[r'holder']! as Map<String, Object?>)
          : null,
      id: (json[r'id'] as num?)?.toInt(),
      permission: json[r'permission'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var holder = this.holder;
    var id = this.id;
    var permission = this.permission;
    var self = this.self;

    final json = <String, Object?>{};
    if (holder != null) {
      json[r'holder'] = holder.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (permission != null) {
      json[r'permission'] = permission;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  PermissionGrant copyWith(
      {PermissionHolder? holder, int? id, String? permission, String? self}) {
    return PermissionGrant(
      holder: holder ?? this.holder,
      id: id ?? this.id,
      permission: permission ?? this.permission,
      self: self ?? this.self,
    );
  }
}

/// List of permission grants.
class PermissionGrants {
  /// Expand options that include additional permission grant details in the
  /// response.
  final String? expand;

  /// Permission grants list.
  final List<PermissionGrant> permissions;

  PermissionGrants({this.expand, List<PermissionGrant>? permissions})
      : permissions = permissions ?? [];

  factory PermissionGrants.fromJson(Map<String, Object?> json) {
    return PermissionGrants(
      expand: json[r'expand'] as String?,
      permissions: (json[r'permissions'] as List<Object?>?)
              ?.map((i) => PermissionGrant.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var permissions = this.permissions;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    json[r'permissions'] = permissions.map((i) => i.toJson()).toList();
    return json;
  }

  PermissionGrants copyWith(
      {String? expand, List<PermissionGrant>? permissions}) {
    return PermissionGrants(
      expand: expand ?? this.expand,
      permissions: permissions ?? this.permissions,
    );
  }
}

/// Details of a user, group, field, or project role that holds a permission.
/// See [Holder object](../api-group-permission-schemes/#holder-object) in *Get
/// all permission schemes* for more information.
class PermissionHolder {
  /// Expand options that include additional permission holder details in the
  /// response.
  final String? expand;

  /// As a group's name can change, use of `value` is recommended. The
  /// identifier associated withthe `type` value that defines the holder of the
  /// permission.
  final String? parameter;

  /// The type of permission holder.
  final String type;

  /// The identifier associated with the `type` value that defines the holder of
  /// the permission.
  final String? value;

  PermissionHolder(
      {this.expand, this.parameter, required this.type, this.value});

  factory PermissionHolder.fromJson(Map<String, Object?> json) {
    return PermissionHolder(
      expand: json[r'expand'] as String?,
      parameter: json[r'parameter'] as String?,
      type: json[r'type'] as String? ?? '',
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var parameter = this.parameter;
    var type = this.type;
    var value = this.value;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (parameter != null) {
      json[r'parameter'] = parameter;
    }
    json[r'type'] = type;
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  PermissionHolder copyWith(
      {String? expand, String? parameter, String? type, String? value}) {
    return PermissionHolder(
      expand: expand ?? this.expand,
      parameter: parameter ?? this.parameter,
      type: type ?? this.type,
      value: value ?? this.value,
    );
  }
}

/// Details of a permission scheme.
class PermissionScheme {
  /// A description for the permission scheme.
  final String? description;

  /// The expand options available for the permission scheme.
  final String? expand;

  /// The ID of the permission scheme.
  final int? id;

  /// The name of the permission scheme. Must be unique.
  final String name;

  /// The permission scheme to create or update. See
  /// [About permission schemes and grants](../api-group-permission-schemes/#about-permission-schemes-and-grants)
  /// for more information.
  final List<PermissionGrant> permissions;

  /// The scope of the permission scheme.
  final Scope? scope;

  /// The URL of the permission scheme.
  final String? self;

  PermissionScheme(
      {this.description,
      this.expand,
      this.id,
      required this.name,
      List<PermissionGrant>? permissions,
      this.scope,
      this.self})
      : permissions = permissions ?? [];

  factory PermissionScheme.fromJson(Map<String, Object?> json) {
    return PermissionScheme(
      description: json[r'description'] as String?,
      expand: json[r'expand'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String? ?? '',
      permissions: (json[r'permissions'] as List<Object?>?)
              ?.map((i) => PermissionGrant.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var expand = this.expand;
    var id = this.id;
    var name = this.name;
    var permissions = this.permissions;
    var scope = this.scope;
    var self = this.self;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'name'] = name;
    json[r'permissions'] = permissions.map((i) => i.toJson()).toList();
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  PermissionScheme copyWith(
      {String? description,
      String? expand,
      int? id,
      String? name,
      List<PermissionGrant>? permissions,
      Scope? scope,
      String? self}) {
    return PermissionScheme(
      description: description ?? this.description,
      expand: expand ?? this.expand,
      id: id ?? this.id,
      name: name ?? this.name,
      permissions: permissions ?? this.permissions,
      scope: scope ?? this.scope,
      self: self ?? this.self,
    );
  }
}

/// List of all permission schemes.
class PermissionSchemes {
  /// Permission schemes list.
  final List<PermissionScheme> permissionSchemes;

  PermissionSchemes({List<PermissionScheme>? permissionSchemes})
      : permissionSchemes = permissionSchemes ?? [];

  factory PermissionSchemes.fromJson(Map<String, Object?> json) {
    return PermissionSchemes(
      permissionSchemes: (json[r'permissionSchemes'] as List<Object?>?)
              ?.map((i) => PermissionScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var permissionSchemes = this.permissionSchemes;

    final json = <String, Object?>{};
    json[r'permissionSchemes'] =
        permissionSchemes.map((i) => i.toJson()).toList();
    return json;
  }

  PermissionSchemes copyWith({List<PermissionScheme>? permissionSchemes}) {
    return PermissionSchemes(
      permissionSchemes: permissionSchemes ?? this.permissionSchemes,
    );
  }
}

/// Details about permissions.
class Permissions {
  /// List of permissions.
  final Map<String, dynamic>? permissions;

  Permissions({this.permissions});

  factory Permissions.fromJson(Map<String, Object?> json) {
    return Permissions(
      permissions: json[r'permissions'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var permissions = this.permissions;

    final json = <String, Object?>{};
    if (permissions != null) {
      json[r'permissions'] = permissions;
    }
    return json;
  }

  Permissions copyWith({Map<String, dynamic>? permissions}) {
    return Permissions(
      permissions: permissions ?? this.permissions,
    );
  }
}

class PermissionsKeysBean {
  /// A list of permission keys.
  final List<String> permissions;

  PermissionsKeysBean({required this.permissions});

  factory PermissionsKeysBean.fromJson(Map<String, Object?> json) {
    return PermissionsKeysBean(
      permissions: (json[r'permissions'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var permissions = this.permissions;

    final json = <String, Object?>{};
    json[r'permissions'] = permissions;
    return json;
  }

  PermissionsKeysBean copyWith({List<String>? permissions}) {
    return PermissionsKeysBean(
      permissions: permissions ?? this.permissions,
    );
  }
}

/// A list of projects in which a user is granted permissions.
class PermittedProjects {
  /// A list of projects.
  final List<ProjectIdentifierBean> projects;

  PermittedProjects({List<ProjectIdentifierBean>? projects})
      : projects = projects ?? [];

  factory PermittedProjects.fromJson(Map<String, Object?> json) {
    return PermittedProjects(
      projects: (json[r'projects'] as List<Object?>?)
              ?.map((i) => ProjectIdentifierBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var projects = this.projects;

    final json = <String, Object?>{};
    json[r'projects'] = projects.map((i) => i.toJson()).toList();
    return json;
  }

  PermittedProjects copyWith({List<ProjectIdentifierBean>? projects}) {
    return PermittedProjects(
      projects: projects ?? this.projects,
    );
  }
}

/// An issue priority.
class Priority {
  /// The description of the issue priority.
  final String? description;

  /// The URL of the icon for the issue priority.
  final String? iconUrl;

  /// The ID of the issue priority.
  final String? id;

  /// Whether this priority is the default.
  final bool isDefault;

  /// The name of the issue priority.
  final String? name;

  /// The URL of the issue priority.
  final String? self;

  /// The color used to indicate the issue priority.
  final String? statusColor;

  Priority(
      {this.description,
      this.iconUrl,
      this.id,
      bool? isDefault,
      this.name,
      this.self,
      this.statusColor})
      : isDefault = isDefault ?? false;

  factory Priority.fromJson(Map<String, Object?> json) {
    return Priority(
      description: json[r'description'] as String?,
      iconUrl: json[r'iconUrl'] as String?,
      id: json[r'id'] as String?,
      isDefault: json[r'isDefault'] as bool? ?? false,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
      statusColor: json[r'statusColor'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var iconUrl = this.iconUrl;
    var id = this.id;
    var isDefault = this.isDefault;
    var name = this.name;
    var self = this.self;
    var statusColor = this.statusColor;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (iconUrl != null) {
      json[r'iconUrl'] = iconUrl;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'isDefault'] = isDefault;
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (statusColor != null) {
      json[r'statusColor'] = statusColor;
    }
    return json;
  }

  Priority copyWith(
      {String? description,
      String? iconUrl,
      String? id,
      bool? isDefault,
      String? name,
      String? self,
      String? statusColor}) {
    return Priority(
      description: description ?? this.description,
      iconUrl: iconUrl ?? this.iconUrl,
      id: id ?? this.id,
      isDefault: isDefault ?? this.isDefault,
      name: name ?? this.name,
      self: self ?? this.self,
      statusColor: statusColor ?? this.statusColor,
    );
  }
}

/// The ID of an issue priority.
class PriorityId {
  /// The ID of the issue priority.
  final String id;

  PriorityId({required this.id});

  factory PriorityId.fromJson(Map<String, Object?> json) {
    return PriorityId(
      id: json[r'id'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  PriorityId copyWith({String? id}) {
    return PriorityId(
      id: id ?? this.id,
    );
  }
}

/// Details about a project.
class Project {
  /// Whether the project is archived.
  final bool archived;

  /// The user who archived the project.
  final User? archivedBy;

  /// The date when the project was archived.
  final DateTime? archivedDate;

  /// The default assignee when creating issues for this project.
  final ProjectAssigneeType? assigneeType;

  /// The URLs of the project's avatars.
  final AvatarUrlsBean? avatarUrls;

  /// List of the components contained in the project.
  final List<ProjectComponent> components;

  /// Whether the project is marked as deleted.
  final bool deleted;

  /// The user who marked the project as deleted.
  final User? deletedBy;

  /// The date when the project was marked as deleted.
  final DateTime? deletedDate;

  /// A brief description of the project.
  final String? description;

  /// An email address associated with the project.
  final String? email;

  /// Expand options that include additional project details in the response.
  final String? expand;

  /// Whether the project is selected as a favorite.
  final bool favourite;

  /// The ID of the project.
  final String? id;

  /// Insights about the project.
  final ProjectInsight? insight;

  /// Whether the project is private.
  final bool isPrivate;

  /// The issue type hierarchy for the project.
  final Hierarchy? issueTypeHierarchy;

  /// List of the issue types available in the project.
  final List<IssueTypeDetails> issueTypes;

  /// The key of the project.
  final String? key;

  /// The project landing page info.
  final ProjectLandingPageInfo? landingPageInfo;

  /// The username of the project lead.
  final User? lead;

  /// The name of the project.
  final String? name;

  /// User permissions on the project
  final ProjectPermissions? permissions;

  /// The category the project belongs to.
  final ProjectCategory? projectCategory;

  /// The
  /// [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes)
  /// of the project.
  final ProjectProjectTypeKey? projectTypeKey;

  /// Map of project properties
  final Map<String, dynamic>? properties;

  /// The date when the project is deleted permanently.
  final DateTime? retentionTillDate;

  /// The name and self URL for each role defined in the project. For more
  /// information, see [Create project role](#api-rest-api-3-role-post).
  final Map<String, dynamic>? roles;

  /// The URL of the project details.
  final String? self;

  /// Whether the project is simplified.
  final bool simplified;

  /// The type of the project.
  final ProjectStyle? style;

  /// A link to information about this project, such as project documentation.
  final String? url;

  /// Unique ID for next-gen projects.
  final String? uuid;

  /// The versions defined in the project. For more information, see
  /// [Create version](#api-rest-api-3-version-post).
  final List<Version> versions;

  Project(
      {bool? archived,
      this.archivedBy,
      this.archivedDate,
      this.assigneeType,
      this.avatarUrls,
      List<ProjectComponent>? components,
      bool? deleted,
      this.deletedBy,
      this.deletedDate,
      this.description,
      this.email,
      this.expand,
      bool? favourite,
      this.id,
      this.insight,
      bool? isPrivate,
      this.issueTypeHierarchy,
      List<IssueTypeDetails>? issueTypes,
      this.key,
      this.landingPageInfo,
      this.lead,
      this.name,
      this.permissions,
      this.projectCategory,
      this.projectTypeKey,
      this.properties,
      this.retentionTillDate,
      this.roles,
      this.self,
      bool? simplified,
      this.style,
      this.url,
      this.uuid,
      List<Version>? versions})
      : archived = archived ?? false,
        components = components ?? [],
        deleted = deleted ?? false,
        favourite = favourite ?? false,
        isPrivate = isPrivate ?? false,
        issueTypes = issueTypes ?? [],
        simplified = simplified ?? false,
        versions = versions ?? [];

  factory Project.fromJson(Map<String, Object?> json) {
    return Project(
      archived: json[r'archived'] as bool? ?? false,
      archivedBy: json[r'archivedBy'] != null
          ? User.fromJson(json[r'archivedBy']! as Map<String, Object?>)
          : null,
      archivedDate: DateTime.tryParse(json[r'archivedDate'] as String? ?? ''),
      assigneeType: json[r'assigneeType'] != null
          ? ProjectAssigneeType.fromValue(json[r'assigneeType']! as String)
          : null,
      avatarUrls: json[r'avatarUrls'] != null
          ? AvatarUrlsBean.fromJson(
              json[r'avatarUrls']! as Map<String, Object?>)
          : null,
      components: (json[r'components'] as List<Object?>?)
              ?.map((i) => ProjectComponent.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      deleted: json[r'deleted'] as bool? ?? false,
      deletedBy: json[r'deletedBy'] != null
          ? User.fromJson(json[r'deletedBy']! as Map<String, Object?>)
          : null,
      deletedDate: DateTime.tryParse(json[r'deletedDate'] as String? ?? ''),
      description: json[r'description'] as String?,
      email: json[r'email'] as String?,
      expand: json[r'expand'] as String?,
      favourite: json[r'favourite'] as bool? ?? false,
      id: json[r'id'] as String?,
      insight: json[r'insight'] != null
          ? ProjectInsight.fromJson(json[r'insight']! as Map<String, Object?>)
          : null,
      isPrivate: json[r'isPrivate'] as bool? ?? false,
      issueTypeHierarchy: json[r'issueTypeHierarchy'] != null
          ? Hierarchy.fromJson(
              json[r'issueTypeHierarchy']! as Map<String, Object?>)
          : null,
      issueTypes: (json[r'issueTypes'] as List<Object?>?)
              ?.map((i) => IssueTypeDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      key: json[r'key'] as String?,
      landingPageInfo: json[r'landingPageInfo'] != null
          ? ProjectLandingPageInfo.fromJson(
              json[r'landingPageInfo']! as Map<String, Object?>)
          : null,
      lead: json[r'lead'] != null
          ? User.fromJson(json[r'lead']! as Map<String, Object?>)
          : null,
      name: json[r'name'] as String?,
      permissions: json[r'permissions'] != null
          ? ProjectPermissions.fromJson(
              json[r'permissions']! as Map<String, Object?>)
          : null,
      projectCategory: json[r'projectCategory'] != null
          ? ProjectCategory.fromJson(
              json[r'projectCategory']! as Map<String, Object?>)
          : null,
      projectTypeKey: json[r'projectTypeKey'] != null
          ? ProjectProjectTypeKey.fromValue(json[r'projectTypeKey']! as String)
          : null,
      properties: json[r'properties'] as Map<String, Object?>?,
      retentionTillDate:
          DateTime.tryParse(json[r'retentionTillDate'] as String? ?? ''),
      roles: json[r'roles'] as Map<String, Object?>?,
      self: json[r'self'] as String?,
      simplified: json[r'simplified'] as bool? ?? false,
      style: json[r'style'] != null
          ? ProjectStyle.fromValue(json[r'style']! as String)
          : null,
      url: json[r'url'] as String?,
      uuid: json[r'uuid'] as String?,
      versions: (json[r'versions'] as List<Object?>?)
              ?.map((i) =>
                  Version.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var archived = this.archived;
    var archivedBy = this.archivedBy;
    var archivedDate = this.archivedDate;
    var assigneeType = this.assigneeType;
    var avatarUrls = this.avatarUrls;
    var components = this.components;
    var deleted = this.deleted;
    var deletedBy = this.deletedBy;
    var deletedDate = this.deletedDate;
    var description = this.description;
    var email = this.email;
    var expand = this.expand;
    var favourite = this.favourite;
    var id = this.id;
    var insight = this.insight;
    var isPrivate = this.isPrivate;
    var issueTypeHierarchy = this.issueTypeHierarchy;
    var issueTypes = this.issueTypes;
    var key = this.key;
    var landingPageInfo = this.landingPageInfo;
    var lead = this.lead;
    var name = this.name;
    var permissions = this.permissions;
    var projectCategory = this.projectCategory;
    var projectTypeKey = this.projectTypeKey;
    var properties = this.properties;
    var retentionTillDate = this.retentionTillDate;
    var roles = this.roles;
    var self = this.self;
    var simplified = this.simplified;
    var style = this.style;
    var url = this.url;
    var uuid = this.uuid;
    var versions = this.versions;

    final json = <String, Object?>{};
    json[r'archived'] = archived;
    if (archivedBy != null) {
      json[r'archivedBy'] = archivedBy.toJson();
    }
    if (archivedDate != null) {
      json[r'archivedDate'] = archivedDate.toIso8601String();
    }
    if (assigneeType != null) {
      json[r'assigneeType'] = assigneeType.value;
    }
    if (avatarUrls != null) {
      json[r'avatarUrls'] = avatarUrls.toJson();
    }
    json[r'components'] = components.map((i) => i.toJson()).toList();
    json[r'deleted'] = deleted;
    if (deletedBy != null) {
      json[r'deletedBy'] = deletedBy.toJson();
    }
    if (deletedDate != null) {
      json[r'deletedDate'] = deletedDate.toIso8601String();
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (email != null) {
      json[r'email'] = email;
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    json[r'favourite'] = favourite;
    if (id != null) {
      json[r'id'] = id;
    }
    if (insight != null) {
      json[r'insight'] = insight.toJson();
    }
    json[r'isPrivate'] = isPrivate;
    if (issueTypeHierarchy != null) {
      json[r'issueTypeHierarchy'] = issueTypeHierarchy.toJson();
    }
    json[r'issueTypes'] = issueTypes.map((i) => i.toJson()).toList();
    if (key != null) {
      json[r'key'] = key;
    }
    if (landingPageInfo != null) {
      json[r'landingPageInfo'] = landingPageInfo.toJson();
    }
    if (lead != null) {
      json[r'lead'] = lead.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (permissions != null) {
      json[r'permissions'] = permissions.toJson();
    }
    if (projectCategory != null) {
      json[r'projectCategory'] = projectCategory.toJson();
    }
    if (projectTypeKey != null) {
      json[r'projectTypeKey'] = projectTypeKey.value;
    }
    if (properties != null) {
      json[r'properties'] = properties;
    }
    if (retentionTillDate != null) {
      json[r'retentionTillDate'] = retentionTillDate.toIso8601String();
    }
    if (roles != null) {
      json[r'roles'] = roles;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'simplified'] = simplified;
    if (style != null) {
      json[r'style'] = style.value;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    if (uuid != null) {
      json[r'uuid'] = uuid;
    }
    json[r'versions'] = versions.map((i) => i.toJson()).toList();
    return json;
  }

  Project copyWith(
      {bool? archived,
      User? archivedBy,
      DateTime? archivedDate,
      ProjectAssigneeType? assigneeType,
      AvatarUrlsBean? avatarUrls,
      List<ProjectComponent>? components,
      bool? deleted,
      User? deletedBy,
      DateTime? deletedDate,
      String? description,
      String? email,
      String? expand,
      bool? favourite,
      String? id,
      ProjectInsight? insight,
      bool? isPrivate,
      Hierarchy? issueTypeHierarchy,
      List<IssueTypeDetails>? issueTypes,
      String? key,
      ProjectLandingPageInfo? landingPageInfo,
      User? lead,
      String? name,
      ProjectPermissions? permissions,
      ProjectCategory? projectCategory,
      ProjectProjectTypeKey? projectTypeKey,
      Map<String, dynamic>? properties,
      DateTime? retentionTillDate,
      Map<String, dynamic>? roles,
      String? self,
      bool? simplified,
      ProjectStyle? style,
      String? url,
      String? uuid,
      List<Version>? versions}) {
    return Project(
      archived: archived ?? this.archived,
      archivedBy: archivedBy ?? this.archivedBy,
      archivedDate: archivedDate ?? this.archivedDate,
      assigneeType: assigneeType ?? this.assigneeType,
      avatarUrls: avatarUrls ?? this.avatarUrls,
      components: components ?? this.components,
      deleted: deleted ?? this.deleted,
      deletedBy: deletedBy ?? this.deletedBy,
      deletedDate: deletedDate ?? this.deletedDate,
      description: description ?? this.description,
      email: email ?? this.email,
      expand: expand ?? this.expand,
      favourite: favourite ?? this.favourite,
      id: id ?? this.id,
      insight: insight ?? this.insight,
      isPrivate: isPrivate ?? this.isPrivate,
      issueTypeHierarchy: issueTypeHierarchy ?? this.issueTypeHierarchy,
      issueTypes: issueTypes ?? this.issueTypes,
      key: key ?? this.key,
      landingPageInfo: landingPageInfo ?? this.landingPageInfo,
      lead: lead ?? this.lead,
      name: name ?? this.name,
      permissions: permissions ?? this.permissions,
      projectCategory: projectCategory ?? this.projectCategory,
      projectTypeKey: projectTypeKey ?? this.projectTypeKey,
      properties: properties ?? this.properties,
      retentionTillDate: retentionTillDate ?? this.retentionTillDate,
      roles: roles ?? this.roles,
      self: self ?? this.self,
      simplified: simplified ?? this.simplified,
      style: style ?? this.style,
      url: url ?? this.url,
      uuid: uuid ?? this.uuid,
      versions: versions ?? this.versions,
    );
  }
}

class ProjectAssigneeType {
  static const projectLead = ProjectAssigneeType._('PROJECT_LEAD');
  static const unassigned = ProjectAssigneeType._('UNASSIGNED');

  static const values = [
    projectLead,
    unassigned,
  ];
  final String value;

  const ProjectAssigneeType._(this.value);

  static ProjectAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ProjectProjectTypeKey {
  static const software = ProjectProjectTypeKey._('software');
  static const serviceDesk = ProjectProjectTypeKey._('service_desk');
  static const business = ProjectProjectTypeKey._('business');

  static const values = [
    software,
    serviceDesk,
    business,
  ];
  final String value;

  const ProjectProjectTypeKey._(this.value);

  static ProjectProjectTypeKey fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectProjectTypeKey._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ProjectStyle {
  static const classic = ProjectStyle._('classic');
  static const nextGen = ProjectStyle._('next-gen');

  static const values = [
    classic,
    nextGen,
  ];
  final String value;

  const ProjectStyle._(this.value);

  static ProjectStyle fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => ProjectStyle._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// List of project avatars.
class ProjectAvatars {
  /// List of avatars added to Jira. These avatars may be deleted.
  final List<Avatar> custom;

  /// List of avatars included with Jira. These avatars cannot be deleted.
  final List<Avatar> system;

  ProjectAvatars({List<Avatar>? custom, List<Avatar>? system})
      : custom = custom ?? [],
        system = system ?? [];

  factory ProjectAvatars.fromJson(Map<String, Object?> json) {
    return ProjectAvatars(
      custom: (json[r'custom'] as List<Object?>?)
              ?.map((i) =>
                  Avatar.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      system: (json[r'system'] as List<Object?>?)
              ?.map((i) =>
                  Avatar.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var custom = this.custom;
    var system = this.system;

    final json = <String, Object?>{};
    json[r'custom'] = custom.map((i) => i.toJson()).toList();
    json[r'system'] = system.map((i) => i.toJson()).toList();
    return json;
  }

  ProjectAvatars copyWith({List<Avatar>? custom, List<Avatar>? system}) {
    return ProjectAvatars(
      custom: custom ?? this.custom,
      system: system ?? this.system,
    );
  }
}

/// A project category.
class ProjectCategory {
  /// The description of the project category.
  final String? description;

  /// The ID of the project category.
  final String? id;

  /// The name of the project category. Required on create, optional on update.
  final String? name;

  /// The URL of the project category.
  final String? self;

  ProjectCategory({this.description, this.id, this.name, this.self});

  factory ProjectCategory.fromJson(Map<String, Object?> json) {
    return ProjectCategory(
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var name = this.name;
    var self = this.self;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  ProjectCategory copyWith(
      {String? description, String? id, String? name, String? self}) {
    return ProjectCategory(
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
      self: self ?? this.self,
    );
  }
}

/// Details about a project component.
class ProjectComponent {
  /// The details of the user associated with `assigneeType`, if any. See
  /// `realAssignee` for details of the user assigned to issues created with
  /// this component.
  final User? assignee;

  /// The nominal user type used to determine the assignee for issues created
  /// with this component. See `realAssigneeType` for details on how the type of
  /// the user, and hence the user, assigned to issues is determined. Can take
  /// the following values:
  ///
  ///  *  `PROJECT_LEAD` the assignee to any issues created with this component
  /// is nominally the lead for the project the component is in.
  ///  *  `COMPONENT_LEAD` the assignee to any issues created with this
  /// component is nominally the lead for the component.
  ///  *  `UNASSIGNED` an assignee is not set for issues created with this
  /// component.
  ///  *  `PROJECT_DEFAULT` the assignee to any issues created with this
  /// component is nominally the default assignee for the project that the
  /// component is in.
  ///
  /// Default value: `PROJECT_DEFAULT`.
  /// Optional when creating or updating a component.
  final ProjectComponentAssigneeType? assigneeType;

  /// The description for the component. Optional when creating or updating a
  /// component.
  final String? description;

  /// The unique identifier for the component.
  final String? id;

  /// Whether a user is associated with `assigneeType`. For example, if the
  /// `assigneeType` is set to `COMPONENT_LEAD` but the component lead is not
  /// set, then `false` is returned.
  final bool isAssigneeTypeValid;

  /// The user details for the component's lead user.
  final User? lead;

  /// The accountId of the component's lead user. The accountId uniquely
  /// identifies the user across all Atlassian products. For example,
  /// *5b10ac8d82e05b22cc7d4ef5*.
  final String? leadAccountId;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? leadUserName;

  /// The unique name for the component in the project. Required when creating a
  /// component. Optional when updating a component. The maximum length is 255
  /// characters.
  final String? name;

  /// The key of the project the component is assigned to. Required when
  /// creating a component. Can't be updated.
  final String? project;

  /// The ID of the project the component is assigned to.
  final int? projectId;

  /// The user assigned to issues created with this component, when
  /// `assigneeType` does not identify a valid assignee.
  final User? realAssignee;

  /// The type of the assignee that is assigned to issues created with this
  /// component, when an assignee cannot be set from the `assigneeType`. For
  /// example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead
  /// is set. This property is set to one of the following values:
  ///
  ///  *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project
  /// lead has permission to be assigned issues in the project that the
  /// component is in.
  ///  *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the
  /// component lead has permission to be assigned issues in the project that
  /// the component is in.
  ///  *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is
  /// configured to allow unassigned issues.
  ///  *  `PROJECT_DEFAULT` when none of the preceding cases are true.
  final ProjectComponentRealAssigneeType? realAssigneeType;

  /// The URL of the component.
  final String? self;

  ProjectComponent(
      {this.assignee,
      this.assigneeType,
      this.description,
      this.id,
      bool? isAssigneeTypeValid,
      this.lead,
      this.leadAccountId,
      this.leadUserName,
      this.name,
      this.project,
      this.projectId,
      this.realAssignee,
      this.realAssigneeType,
      this.self})
      : isAssigneeTypeValid = isAssigneeTypeValid ?? false;

  factory ProjectComponent.fromJson(Map<String, Object?> json) {
    return ProjectComponent(
      assignee: json[r'assignee'] != null
          ? User.fromJson(json[r'assignee']! as Map<String, Object?>)
          : null,
      assigneeType: json[r'assigneeType'] != null
          ? ProjectComponentAssigneeType.fromValue(
              json[r'assigneeType']! as String)
          : null,
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      isAssigneeTypeValid: json[r'isAssigneeTypeValid'] as bool? ?? false,
      lead: json[r'lead'] != null
          ? User.fromJson(json[r'lead']! as Map<String, Object?>)
          : null,
      leadAccountId: json[r'leadAccountId'] as String?,
      leadUserName: json[r'leadUserName'] as String?,
      name: json[r'name'] as String?,
      project: json[r'project'] as String?,
      projectId: (json[r'projectId'] as num?)?.toInt(),
      realAssignee: json[r'realAssignee'] != null
          ? User.fromJson(json[r'realAssignee']! as Map<String, Object?>)
          : null,
      realAssigneeType: json[r'realAssigneeType'] != null
          ? ProjectComponentRealAssigneeType.fromValue(
              json[r'realAssigneeType']! as String)
          : null,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var assignee = this.assignee;
    var assigneeType = this.assigneeType;
    var description = this.description;
    var id = this.id;
    var isAssigneeTypeValid = this.isAssigneeTypeValid;
    var lead = this.lead;
    var leadAccountId = this.leadAccountId;
    var leadUserName = this.leadUserName;
    var name = this.name;
    var project = this.project;
    var projectId = this.projectId;
    var realAssignee = this.realAssignee;
    var realAssigneeType = this.realAssigneeType;
    var self = this.self;

    final json = <String, Object?>{};
    if (assignee != null) {
      json[r'assignee'] = assignee.toJson();
    }
    if (assigneeType != null) {
      json[r'assigneeType'] = assigneeType.value;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'isAssigneeTypeValid'] = isAssigneeTypeValid;
    if (lead != null) {
      json[r'lead'] = lead.toJson();
    }
    if (leadAccountId != null) {
      json[r'leadAccountId'] = leadAccountId;
    }
    if (leadUserName != null) {
      json[r'leadUserName'] = leadUserName;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (project != null) {
      json[r'project'] = project;
    }
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    if (realAssignee != null) {
      json[r'realAssignee'] = realAssignee.toJson();
    }
    if (realAssigneeType != null) {
      json[r'realAssigneeType'] = realAssigneeType.value;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  ProjectComponent copyWith(
      {User? assignee,
      ProjectComponentAssigneeType? assigneeType,
      String? description,
      String? id,
      bool? isAssigneeTypeValid,
      User? lead,
      String? leadAccountId,
      String? leadUserName,
      String? name,
      String? project,
      int? projectId,
      User? realAssignee,
      ProjectComponentRealAssigneeType? realAssigneeType,
      String? self}) {
    return ProjectComponent(
      assignee: assignee ?? this.assignee,
      assigneeType: assigneeType ?? this.assigneeType,
      description: description ?? this.description,
      id: id ?? this.id,
      isAssigneeTypeValid: isAssigneeTypeValid ?? this.isAssigneeTypeValid,
      lead: lead ?? this.lead,
      leadAccountId: leadAccountId ?? this.leadAccountId,
      leadUserName: leadUserName ?? this.leadUserName,
      name: name ?? this.name,
      project: project ?? this.project,
      projectId: projectId ?? this.projectId,
      realAssignee: realAssignee ?? this.realAssignee,
      realAssigneeType: realAssigneeType ?? this.realAssigneeType,
      self: self ?? this.self,
    );
  }
}

class ProjectComponentAssigneeType {
  static const projectDefault =
      ProjectComponentAssigneeType._('PROJECT_DEFAULT');
  static const componentLead = ProjectComponentAssigneeType._('COMPONENT_LEAD');
  static const projectLead = ProjectComponentAssigneeType._('PROJECT_LEAD');
  static const unassigned = ProjectComponentAssigneeType._('UNASSIGNED');

  static const values = [
    projectDefault,
    componentLead,
    projectLead,
    unassigned,
  ];
  final String value;

  const ProjectComponentAssigneeType._(this.value);

  static ProjectComponentAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectComponentAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class ProjectComponentRealAssigneeType {
  static const projectDefault =
      ProjectComponentRealAssigneeType._('PROJECT_DEFAULT');
  static const componentLead =
      ProjectComponentRealAssigneeType._('COMPONENT_LEAD');
  static const projectLead = ProjectComponentRealAssigneeType._('PROJECT_LEAD');
  static const unassigned = ProjectComponentRealAssigneeType._('UNASSIGNED');

  static const values = [
    projectDefault,
    componentLead,
    projectLead,
    unassigned,
  ];
  final String value;

  const ProjectComponentRealAssigneeType._(this.value);

  static ProjectComponentRealAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectComponentRealAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about a project.
class ProjectDetails {
  /// The URLs of the project's avatars.
  final AvatarUrlsBean? avatarUrls;

  /// The ID of the project.
  final String? id;

  /// The key of the project.
  final String? key;

  /// The name of the project.
  final String? name;

  /// The category the project belongs to.
  final UpdatedProjectCategory? projectCategory;

  /// The
  /// [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes)
  /// of the project.
  final ProjectDetailsProjectTypeKey? projectTypeKey;

  /// The URL of the project details.
  final String? self;

  /// Whether or not the project is simplified.
  final bool simplified;

  ProjectDetails(
      {this.avatarUrls,
      this.id,
      this.key,
      this.name,
      this.projectCategory,
      this.projectTypeKey,
      this.self,
      bool? simplified})
      : simplified = simplified ?? false;

  factory ProjectDetails.fromJson(Map<String, Object?> json) {
    return ProjectDetails(
      avatarUrls: json[r'avatarUrls'] != null
          ? AvatarUrlsBean.fromJson(
              json[r'avatarUrls']! as Map<String, Object?>)
          : null,
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      projectCategory: json[r'projectCategory'] != null
          ? UpdatedProjectCategory.fromJson(
              json[r'projectCategory']! as Map<String, Object?>)
          : null,
      projectTypeKey: json[r'projectTypeKey'] != null
          ? ProjectDetailsProjectTypeKey.fromValue(
              json[r'projectTypeKey']! as String)
          : null,
      self: json[r'self'] as String?,
      simplified: json[r'simplified'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var avatarUrls = this.avatarUrls;
    var id = this.id;
    var key = this.key;
    var name = this.name;
    var projectCategory = this.projectCategory;
    var projectTypeKey = this.projectTypeKey;
    var self = this.self;
    var simplified = this.simplified;

    final json = <String, Object?>{};
    if (avatarUrls != null) {
      json[r'avatarUrls'] = avatarUrls.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (projectCategory != null) {
      json[r'projectCategory'] = projectCategory.toJson();
    }
    if (projectTypeKey != null) {
      json[r'projectTypeKey'] = projectTypeKey.value;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'simplified'] = simplified;
    return json;
  }

  ProjectDetails copyWith(
      {AvatarUrlsBean? avatarUrls,
      String? id,
      String? key,
      String? name,
      UpdatedProjectCategory? projectCategory,
      ProjectDetailsProjectTypeKey? projectTypeKey,
      String? self,
      bool? simplified}) {
    return ProjectDetails(
      avatarUrls: avatarUrls ?? this.avatarUrls,
      id: id ?? this.id,
      key: key ?? this.key,
      name: name ?? this.name,
      projectCategory: projectCategory ?? this.projectCategory,
      projectTypeKey: projectTypeKey ?? this.projectTypeKey,
      self: self ?? this.self,
      simplified: simplified ?? this.simplified,
    );
  }
}

class ProjectDetailsProjectTypeKey {
  static const software = ProjectDetailsProjectTypeKey._('software');
  static const serviceDesk = ProjectDetailsProjectTypeKey._('service_desk');
  static const business = ProjectDetailsProjectTypeKey._('business');

  static const values = [
    software,
    serviceDesk,
    business,
  ];
  final String value;

  const ProjectDetailsProjectTypeKey._(this.value);

  static ProjectDetailsProjectTypeKey fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectDetailsProjectTypeKey._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A project's sender email address.
class ProjectEmailAddress {
  /// The email address.
  final String? emailAddress;

  /// When using a custom domain, the status of the email address.
  final List<String> emailAddressStatus;

  ProjectEmailAddress({this.emailAddress, List<String>? emailAddressStatus})
      : emailAddressStatus = emailAddressStatus ?? [];

  factory ProjectEmailAddress.fromJson(Map<String, Object?> json) {
    return ProjectEmailAddress(
      emailAddress: json[r'emailAddress'] as String?,
      emailAddressStatus: (json[r'emailAddressStatus'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var emailAddress = this.emailAddress;
    var emailAddressStatus = this.emailAddressStatus;

    final json = <String, Object?>{};
    if (emailAddress != null) {
      json[r'emailAddress'] = emailAddress;
    }
    json[r'emailAddressStatus'] = emailAddressStatus;
    return json;
  }

  ProjectEmailAddress copyWith(
      {String? emailAddress, List<String>? emailAddressStatus}) {
    return ProjectEmailAddress(
      emailAddress: emailAddress ?? this.emailAddress,
      emailAddressStatus: emailAddressStatus ?? this.emailAddressStatus,
    );
  }
}

/// Details of a project feature.
class ProjectFeature {
  /// The key of the feature.
  final String? feature;

  /// URI for the image representing the feature.
  final String? imageUri;

  /// Localized display description for the feature.
  final String? localisedDescription;

  /// Localized display name for the feature.
  final String? localisedName;

  /// List of keys of the features required to enable the feature.
  final List<String> prerequisites;

  /// The ID of the project.
  final int? projectId;

  /// The state of the feature. When updating the state of a feature, only
  /// ENABLED and DISABLED are supported. Responses can contain all values
  final ProjectFeatureStateEnum? state;

  /// Whether the state of the feature can be updated.
  final bool toggleLocked;

  ProjectFeature(
      {this.feature,
      this.imageUri,
      this.localisedDescription,
      this.localisedName,
      List<String>? prerequisites,
      this.projectId,
      this.state,
      bool? toggleLocked})
      : prerequisites = prerequisites ?? [],
        toggleLocked = toggleLocked ?? false;

  factory ProjectFeature.fromJson(Map<String, Object?> json) {
    return ProjectFeature(
      feature: json[r'feature'] as String?,
      imageUri: json[r'imageUri'] as String?,
      localisedDescription: json[r'localisedDescription'] as String?,
      localisedName: json[r'localisedName'] as String?,
      prerequisites: (json[r'prerequisites'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      projectId: (json[r'projectId'] as num?)?.toInt(),
      state: json[r'state'] != null
          ? ProjectFeatureStateEnum.fromValue(json[r'state']! as String)
          : null,
      toggleLocked: json[r'toggleLocked'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var feature = this.feature;
    var imageUri = this.imageUri;
    var localisedDescription = this.localisedDescription;
    var localisedName = this.localisedName;
    var prerequisites = this.prerequisites;
    var projectId = this.projectId;
    var state = this.state;
    var toggleLocked = this.toggleLocked;

    final json = <String, Object?>{};
    if (feature != null) {
      json[r'feature'] = feature;
    }
    if (imageUri != null) {
      json[r'imageUri'] = imageUri;
    }
    if (localisedDescription != null) {
      json[r'localisedDescription'] = localisedDescription;
    }
    if (localisedName != null) {
      json[r'localisedName'] = localisedName;
    }
    json[r'prerequisites'] = prerequisites;
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    if (state != null) {
      json[r'state'] = state.value;
    }
    json[r'toggleLocked'] = toggleLocked;
    return json;
  }

  ProjectFeature copyWith(
      {String? feature,
      String? imageUri,
      String? localisedDescription,
      String? localisedName,
      List<String>? prerequisites,
      int? projectId,
      ProjectFeatureStateEnum? state,
      bool? toggleLocked}) {
    return ProjectFeature(
      feature: feature ?? this.feature,
      imageUri: imageUri ?? this.imageUri,
      localisedDescription: localisedDescription ?? this.localisedDescription,
      localisedName: localisedName ?? this.localisedName,
      prerequisites: prerequisites ?? this.prerequisites,
      projectId: projectId ?? this.projectId,
      state: state ?? this.state,
      toggleLocked: toggleLocked ?? this.toggleLocked,
    );
  }
}

class ProjectFeatureStateEnum {
  static const enabled = ProjectFeatureStateEnum._('ENABLED');
  static const disabled = ProjectFeatureStateEnum._('DISABLED');
  static const comingSoon = ProjectFeatureStateEnum._('COMING_SOON');

  static const values = [
    enabled,
    disabled,
    comingSoon,
  ];
  final String value;

  const ProjectFeatureStateEnum._(this.value);

  static ProjectFeatureStateEnum fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectFeatureStateEnum._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of the feature state.
class ProjectFeatureState {
  /// The feature state.
  final ProjectFeatureStateState? state;

  ProjectFeatureState({this.state});

  factory ProjectFeatureState.fromJson(Map<String, Object?> json) {
    return ProjectFeatureState(
      state: json[r'state'] != null
          ? ProjectFeatureStateState.fromValue(json[r'state']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var state = this.state;

    final json = <String, Object?>{};
    if (state != null) {
      json[r'state'] = state.value;
    }
    return json;
  }

  ProjectFeatureState copyWith({ProjectFeatureStateState? state}) {
    return ProjectFeatureState(
      state: state ?? this.state,
    );
  }
}

class ProjectFeatureStateState {
  static const enabled = ProjectFeatureStateState._('ENABLED');
  static const disabled = ProjectFeatureStateState._('DISABLED');
  static const comingSoon = ProjectFeatureStateState._('COMING_SOON');

  static const values = [
    enabled,
    disabled,
    comingSoon,
  ];
  final String value;

  const ProjectFeatureStateState._(this.value);

  static ProjectFeatureStateState fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectFeatureStateState._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Project ID details.
class ProjectId {
  /// The ID of the project.
  final String id;

  ProjectId({required this.id});

  factory ProjectId.fromJson(Map<String, Object?> json) {
    return ProjectId(
      id: json[r'id'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  ProjectId copyWith({String? id}) {
    return ProjectId(
      id: id ?? this.id,
    );
  }
}

/// The identifiers for a project.
class ProjectIdentifierBean {
  /// The ID of the project.
  final int? id;

  /// The key of the project.
  final String? key;

  ProjectIdentifierBean({this.id, this.key});

  factory ProjectIdentifierBean.fromJson(Map<String, Object?> json) {
    return ProjectIdentifierBean(
      id: (json[r'id'] as num?)?.toInt(),
      key: json[r'key'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    return json;
  }

  ProjectIdentifierBean copyWith({int? id, String? key}) {
    return ProjectIdentifierBean(
      id: id ?? this.id,
      key: key ?? this.key,
    );
  }
}

/// Identifiers for a project.
class ProjectIdentifiers {
  /// The ID of the created project.
  final int id;

  /// The key of the created project.
  final String key;

  /// The URL of the created project.
  final String self;

  ProjectIdentifiers({required this.id, required this.key, required this.self});

  factory ProjectIdentifiers.fromJson(Map<String, Object?> json) {
    return ProjectIdentifiers(
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      key: json[r'key'] as String? ?? '',
      self: json[r'self'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;
    var self = this.self;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'key'] = key;
    json[r'self'] = self;
    return json;
  }

  ProjectIdentifiers copyWith({int? id, String? key, String? self}) {
    return ProjectIdentifiers(
      id: id ?? this.id,
      key: key ?? this.key,
      self: self ?? this.self,
    );
  }
}

/// A list of project IDs.
class ProjectIds {
  /// The IDs of projects.
  final List<String> projectIds;

  ProjectIds({required this.projectIds});

  factory ProjectIds.fromJson(Map<String, Object?> json) {
    return ProjectIds(
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var projectIds = this.projectIds;

    final json = <String, Object?>{};
    json[r'projectIds'] = projectIds;
    return json;
  }

  ProjectIds copyWith({List<String>? projectIds}) {
    return ProjectIds(
      projectIds: projectIds ?? this.projectIds,
    );
  }
}

/// Additional details about a project.
class ProjectInsight {
  /// The last issue update time.
  final DateTime? lastIssueUpdateTime;

  /// Total issue count.
  final int? totalIssueCount;

  ProjectInsight({this.lastIssueUpdateTime, this.totalIssueCount});

  factory ProjectInsight.fromJson(Map<String, Object?> json) {
    return ProjectInsight(
      lastIssueUpdateTime:
          DateTime.tryParse(json[r'lastIssueUpdateTime'] as String? ?? ''),
      totalIssueCount: (json[r'totalIssueCount'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var lastIssueUpdateTime = this.lastIssueUpdateTime;
    var totalIssueCount = this.totalIssueCount;

    final json = <String, Object?>{};
    if (lastIssueUpdateTime != null) {
      json[r'lastIssueUpdateTime'] = lastIssueUpdateTime.toIso8601String();
    }
    if (totalIssueCount != null) {
      json[r'totalIssueCount'] = totalIssueCount;
    }
    return json;
  }

  ProjectInsight copyWith(
      {DateTime? lastIssueUpdateTime, int? totalIssueCount}) {
    return ProjectInsight(
      lastIssueUpdateTime: lastIssueUpdateTime ?? this.lastIssueUpdateTime,
      totalIssueCount: totalIssueCount ?? this.totalIssueCount,
    );
  }
}

/// Details of the issue creation metadata for a project.
class ProjectIssueCreateMetadata {
  /// List of the project's avatars, returning the avatar size and associated
  /// URL.
  final AvatarUrlsBean? avatarUrls;

  /// Expand options that include additional project issue create metadata
  /// details in the response.
  final String? expand;

  /// The ID of the project.
  final String? id;

  /// List of the issue types supported by the project.
  final List<IssueTypeIssueCreateMetadata> issuetypes;

  /// The key of the project.
  final String? key;

  /// The name of the project.
  final String? name;

  /// The URL of the project.
  final String? self;

  ProjectIssueCreateMetadata(
      {this.avatarUrls,
      this.expand,
      this.id,
      List<IssueTypeIssueCreateMetadata>? issuetypes,
      this.key,
      this.name,
      this.self})
      : issuetypes = issuetypes ?? [];

  factory ProjectIssueCreateMetadata.fromJson(Map<String, Object?> json) {
    return ProjectIssueCreateMetadata(
      avatarUrls: json[r'avatarUrls'] != null
          ? AvatarUrlsBean.fromJson(
              json[r'avatarUrls']! as Map<String, Object?>)
          : null,
      expand: json[r'expand'] as String?,
      id: json[r'id'] as String?,
      issuetypes: (json[r'issuetypes'] as List<Object?>?)
              ?.map((i) => IssueTypeIssueCreateMetadata.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var avatarUrls = this.avatarUrls;
    var expand = this.expand;
    var id = this.id;
    var issuetypes = this.issuetypes;
    var key = this.key;
    var name = this.name;
    var self = this.self;

    final json = <String, Object?>{};
    if (avatarUrls != null) {
      json[r'avatarUrls'] = avatarUrls.toJson();
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'issuetypes'] = issuetypes.map((i) => i.toJson()).toList();
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  ProjectIssueCreateMetadata copyWith(
      {AvatarUrlsBean? avatarUrls,
      String? expand,
      String? id,
      List<IssueTypeIssueCreateMetadata>? issuetypes,
      String? key,
      String? name,
      String? self}) {
    return ProjectIssueCreateMetadata(
      avatarUrls: avatarUrls ?? this.avatarUrls,
      expand: expand ?? this.expand,
      id: id ?? this.id,
      issuetypes: issuetypes ?? this.issuetypes,
      key: key ?? this.key,
      name: name ?? this.name,
      self: self ?? this.self,
    );
  }
}

/// List of issue level security items in a project.
class ProjectIssueSecurityLevels {
  /// Issue level security items list.
  final List<SecurityLevel> levels;

  ProjectIssueSecurityLevels({required this.levels});

  factory ProjectIssueSecurityLevels.fromJson(Map<String, Object?> json) {
    return ProjectIssueSecurityLevels(
      levels: (json[r'levels'] as List<Object?>?)
              ?.map((i) => SecurityLevel.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var levels = this.levels;

    final json = <String, Object?>{};
    json[r'levels'] = levels.map((i) => i.toJson()).toList();
    return json;
  }

  ProjectIssueSecurityLevels copyWith({List<SecurityLevel>? levels}) {
    return ProjectIssueSecurityLevels(
      levels: levels ?? this.levels,
    );
  }
}

/// The hierarchy of issue types within a project.
class ProjectIssueTypeHierarchy {
  /// Details of an issue type hierarchy level.
  final List<ProjectIssueTypesHierarchyLevel> hierarchy;

  /// The ID of the project.
  final int? projectId;

  ProjectIssueTypeHierarchy(
      {List<ProjectIssueTypesHierarchyLevel>? hierarchy, this.projectId})
      : hierarchy = hierarchy ?? [];

  factory ProjectIssueTypeHierarchy.fromJson(Map<String, Object?> json) {
    return ProjectIssueTypeHierarchy(
      hierarchy: (json[r'hierarchy'] as List<Object?>?)
              ?.map((i) => ProjectIssueTypesHierarchyLevel.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      projectId: (json[r'projectId'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var hierarchy = this.hierarchy;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    json[r'hierarchy'] = hierarchy.map((i) => i.toJson()).toList();
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    return json;
  }

  ProjectIssueTypeHierarchy copyWith(
      {List<ProjectIssueTypesHierarchyLevel>? hierarchy, int? projectId}) {
    return ProjectIssueTypeHierarchy(
      hierarchy: hierarchy ?? this.hierarchy,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// The project and issue type mapping.
class ProjectIssueTypeMapping {
  /// The ID of the issue type.
  final String issueTypeId;

  /// The ID of the project.
  final String projectId;

  ProjectIssueTypeMapping({required this.issueTypeId, required this.projectId});

  factory ProjectIssueTypeMapping.fromJson(Map<String, Object?> json) {
    return ProjectIssueTypeMapping(
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
      projectId: json[r'projectId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeId = this.issueTypeId;
    var projectId = this.projectId;

    final json = <String, Object?>{};
    json[r'issueTypeId'] = issueTypeId;
    json[r'projectId'] = projectId;
    return json;
  }

  ProjectIssueTypeMapping copyWith({String? issueTypeId, String? projectId}) {
    return ProjectIssueTypeMapping(
      issueTypeId: issueTypeId ?? this.issueTypeId,
      projectId: projectId ?? this.projectId,
    );
  }
}

/// The project and issue type mappings.
class ProjectIssueTypeMappings {
  /// The project and issue type mappings.
  final List<ProjectIssueTypeMapping> mappings;

  ProjectIssueTypeMappings({required this.mappings});

  factory ProjectIssueTypeMappings.fromJson(Map<String, Object?> json) {
    return ProjectIssueTypeMappings(
      mappings: (json[r'mappings'] as List<Object?>?)
              ?.map((i) => ProjectIssueTypeMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var mappings = this.mappings;

    final json = <String, Object?>{};
    json[r'mappings'] = mappings.map((i) => i.toJson()).toList();
    return json;
  }

  ProjectIssueTypeMappings copyWith({List<ProjectIssueTypeMapping>? mappings}) {
    return ProjectIssueTypeMappings(
      mappings: mappings ?? this.mappings,
    );
  }
}

/// Projects and issue types where the status is used. Only available if the
/// `usages` expand is requested.
class ProjectIssueTypes {
  /// IDs of the issue types
  final List<String> issueTypes;
  final ProjectId? project;

  ProjectIssueTypes({List<String>? issueTypes, this.project})
      : issueTypes = issueTypes ?? [];

  factory ProjectIssueTypes.fromJson(Map<String, Object?> json) {
    return ProjectIssueTypes(
      issueTypes: (json[r'issueTypes'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      project: json[r'project'] != null
          ? ProjectId.fromJson(json[r'project']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var issueTypes = this.issueTypes;
    var project = this.project;

    final json = <String, Object?>{};
    json[r'issueTypes'] = issueTypes;
    if (project != null) {
      json[r'project'] = project.toJson();
    }
    return json;
  }

  ProjectIssueTypes copyWith({List<String>? issueTypes, ProjectId? project}) {
    return ProjectIssueTypes(
      issueTypes: issueTypes ?? this.issueTypes,
      project: project ?? this.project,
    );
  }
}

/// Details of an issue type hierarchy level.
class ProjectIssueTypesHierarchyLevel {
  /// The ID of the issue type hierarchy level. This property is deprecated, see
  /// [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final String? entityId;

  /// The list of issue types in the hierarchy level.
  final List<IssueTypeInfo> issueTypes;

  /// The level of the issue type hierarchy level.
  final int? level;

  /// The name of the issue type hierarchy level.
  final String? name;

  ProjectIssueTypesHierarchyLevel(
      {this.entityId, List<IssueTypeInfo>? issueTypes, this.level, this.name})
      : issueTypes = issueTypes ?? [];

  factory ProjectIssueTypesHierarchyLevel.fromJson(Map<String, Object?> json) {
    return ProjectIssueTypesHierarchyLevel(
      entityId: json[r'entityId'] as String?,
      issueTypes: (json[r'issueTypes'] as List<Object?>?)
              ?.map((i) => IssueTypeInfo.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      level: (json[r'level'] as num?)?.toInt(),
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var entityId = this.entityId;
    var issueTypes = this.issueTypes;
    var level = this.level;
    var name = this.name;

    final json = <String, Object?>{};
    if (entityId != null) {
      json[r'entityId'] = entityId;
    }
    json[r'issueTypes'] = issueTypes.map((i) => i.toJson()).toList();
    if (level != null) {
      json[r'level'] = level;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  ProjectIssueTypesHierarchyLevel copyWith(
      {String? entityId,
      List<IssueTypeInfo>? issueTypes,
      int? level,
      String? name}) {
    return ProjectIssueTypesHierarchyLevel(
      entityId: entityId ?? this.entityId,
      issueTypes: issueTypes ?? this.issueTypes,
      level: level ?? this.level,
      name: name ?? this.name,
    );
  }
}

class ProjectLandingPageInfo {
  final Map<String, dynamic>? attributes;
  final int? boardId;
  final String? boardName;
  final String? projectKey;
  final String? projectType;
  final String? queueCategory;
  final int? queueId;
  final String? queueName;
  final bool simpleBoard;
  final bool simplified;
  final String? url;

  ProjectLandingPageInfo(
      {this.attributes,
      this.boardId,
      this.boardName,
      this.projectKey,
      this.projectType,
      this.queueCategory,
      this.queueId,
      this.queueName,
      bool? simpleBoard,
      bool? simplified,
      this.url})
      : simpleBoard = simpleBoard ?? false,
        simplified = simplified ?? false;

  factory ProjectLandingPageInfo.fromJson(Map<String, Object?> json) {
    return ProjectLandingPageInfo(
      attributes: json[r'attributes'] as Map<String, Object?>?,
      boardId: (json[r'boardId'] as num?)?.toInt(),
      boardName: json[r'boardName'] as String?,
      projectKey: json[r'projectKey'] as String?,
      projectType: json[r'projectType'] as String?,
      queueCategory: json[r'queueCategory'] as String?,
      queueId: (json[r'queueId'] as num?)?.toInt(),
      queueName: json[r'queueName'] as String?,
      simpleBoard: json[r'simpleBoard'] as bool? ?? false,
      simplified: json[r'simplified'] as bool? ?? false,
      url: json[r'url'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var attributes = this.attributes;
    var boardId = this.boardId;
    var boardName = this.boardName;
    var projectKey = this.projectKey;
    var projectType = this.projectType;
    var queueCategory = this.queueCategory;
    var queueId = this.queueId;
    var queueName = this.queueName;
    var simpleBoard = this.simpleBoard;
    var simplified = this.simplified;
    var url = this.url;

    final json = <String, Object?>{};
    if (attributes != null) {
      json[r'attributes'] = attributes;
    }
    if (boardId != null) {
      json[r'boardId'] = boardId;
    }
    if (boardName != null) {
      json[r'boardName'] = boardName;
    }
    if (projectKey != null) {
      json[r'projectKey'] = projectKey;
    }
    if (projectType != null) {
      json[r'projectType'] = projectType;
    }
    if (queueCategory != null) {
      json[r'queueCategory'] = queueCategory;
    }
    if (queueId != null) {
      json[r'queueId'] = queueId;
    }
    if (queueName != null) {
      json[r'queueName'] = queueName;
    }
    json[r'simpleBoard'] = simpleBoard;
    json[r'simplified'] = simplified;
    if (url != null) {
      json[r'url'] = url;
    }
    return json;
  }

  ProjectLandingPageInfo copyWith(
      {Map<String, dynamic>? attributes,
      int? boardId,
      String? boardName,
      String? projectKey,
      String? projectType,
      String? queueCategory,
      int? queueId,
      String? queueName,
      bool? simpleBoard,
      bool? simplified,
      String? url}) {
    return ProjectLandingPageInfo(
      attributes: attributes ?? this.attributes,
      boardId: boardId ?? this.boardId,
      boardName: boardName ?? this.boardName,
      projectKey: projectKey ?? this.projectKey,
      projectType: projectType ?? this.projectType,
      queueCategory: queueCategory ?? this.queueCategory,
      queueId: queueId ?? this.queueId,
      queueName: queueName ?? this.queueName,
      simpleBoard: simpleBoard ?? this.simpleBoard,
      simplified: simplified ?? this.simplified,
      url: url ?? this.url,
    );
  }
}

/// Permissions which a user has on a project.
class ProjectPermissions {
  /// Whether the logged user can edit the project.
  final bool canEdit;

  ProjectPermissions({bool? canEdit}) : canEdit = canEdit ?? false;

  factory ProjectPermissions.fromJson(Map<String, Object?> json) {
    return ProjectPermissions(
      canEdit: json[r'canEdit'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var canEdit = this.canEdit;

    final json = <String, Object?>{};
    json[r'canEdit'] = canEdit;
    return json;
  }

  ProjectPermissions copyWith({bool? canEdit}) {
    return ProjectPermissions(
      canEdit: canEdit ?? this.canEdit,
    );
  }
}

/// Details about the roles in a project.
class ProjectRole {
  /// The list of users who act in this role.
  final List<RoleActor> actors;

  /// Whether this role is the admin role for the project.
  final bool admin;

  /// Whether the calling user is part of this role.
  final bool currentUserRole;

  /// Whether this role is the default role for the project
  final bool default$;

  /// The description of the project role.
  final String? description;

  /// The ID of the project role.
  final int? id;

  /// The name of the project role.
  final String? name;

  /// Whether the roles are configurable for this project.
  final bool roleConfigurable;

  /// The scope of the role. Indicated for roles associated with
  /// [next-gen projects](https://confluence.atlassian.com/x/loMyO).
  final Scope? scope;

  /// The URL the project role details.
  final String? self;

  /// The translated name of the project role.
  final String? translatedName;

  ProjectRole(
      {List<RoleActor>? actors,
      bool? admin,
      bool? currentUserRole,
      bool? default$,
      this.description,
      this.id,
      this.name,
      bool? roleConfigurable,
      this.scope,
      this.self,
      this.translatedName})
      : actors = actors ?? [],
        admin = admin ?? false,
        currentUserRole = currentUserRole ?? false,
        default$ = default$ ?? false,
        roleConfigurable = roleConfigurable ?? false;

  factory ProjectRole.fromJson(Map<String, Object?> json) {
    return ProjectRole(
      actors: (json[r'actors'] as List<Object?>?)
              ?.map((i) =>
                  RoleActor.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      admin: json[r'admin'] as bool? ?? false,
      currentUserRole: json[r'currentUserRole'] as bool? ?? false,
      default$: json[r'default'] as bool? ?? false,
      description: json[r'description'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      roleConfigurable: json[r'roleConfigurable'] as bool? ?? false,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      self: json[r'self'] as String?,
      translatedName: json[r'translatedName'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var actors = this.actors;
    var admin = this.admin;
    var currentUserRole = this.currentUserRole;
    var default$ = this.default$;
    var description = this.description;
    var id = this.id;
    var name = this.name;
    var roleConfigurable = this.roleConfigurable;
    var scope = this.scope;
    var self = this.self;
    var translatedName = this.translatedName;

    final json = <String, Object?>{};
    json[r'actors'] = actors.map((i) => i.toJson()).toList();
    json[r'admin'] = admin;
    json[r'currentUserRole'] = currentUserRole;
    json[r'default'] = default$;
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'roleConfigurable'] = roleConfigurable;
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (translatedName != null) {
      json[r'translatedName'] = translatedName;
    }
    return json;
  }

  ProjectRole copyWith(
      {List<RoleActor>? actors,
      bool? admin,
      bool? currentUserRole,
      bool? default$,
      String? description,
      int? id,
      String? name,
      bool? roleConfigurable,
      Scope? scope,
      String? self,
      String? translatedName}) {
    return ProjectRole(
      actors: actors ?? this.actors,
      admin: admin ?? this.admin,
      currentUserRole: currentUserRole ?? this.currentUserRole,
      default$: default$ ?? this.default$,
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
      roleConfigurable: roleConfigurable ?? this.roleConfigurable,
      scope: scope ?? this.scope,
      self: self ?? this.self,
      translatedName: translatedName ?? this.translatedName,
    );
  }
}

class ProjectRoleActorsUpdateBean {
  /// The actors to add to the project role.
  ///
  /// Add groups using:
  ///
  ///  *  `atlassian-group-role-actor` and a list of group names.
  ///  *  `atlassian-group-role-actor-id` and a list of group IDs.
  ///
  /// As a group's name can change, use of `atlassian-group-role-actor-id` is
  /// recommended. For example,
  /// `"atlassian-group-role-actor-id":["eef79f81-0b89-4fca-a736-4be531a10869","77f6ab39-e755-4570-a6ae-2d7a8df0bcb8"]`.
  ///
  /// Add users using `atlassian-user-role-actor` and a list of account IDs. For
  /// example,
  /// `"atlassian-user-role-actor":["12345678-9abc-def1-2345-6789abcdef12", "abcdef12-3456-789a-bcde-f123456789ab"]`.
  final Map<String, dynamic>? categorisedActors;

  /// The ID of the project role. Use
  /// [Get all project roles](#api-rest-api-3-role-get) to get a list of project
  /// role IDs.
  final int? id;

  ProjectRoleActorsUpdateBean({this.categorisedActors, this.id});

  factory ProjectRoleActorsUpdateBean.fromJson(Map<String, Object?> json) {
    return ProjectRoleActorsUpdateBean(
      categorisedActors: json[r'categorisedActors'] as Map<String, Object?>?,
      id: (json[r'id'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var categorisedActors = this.categorisedActors;
    var id = this.id;

    final json = <String, Object?>{};
    if (categorisedActors != null) {
      json[r'categorisedActors'] = categorisedActors;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    return json;
  }

  ProjectRoleActorsUpdateBean copyWith(
      {Map<String, dynamic>? categorisedActors, int? id}) {
    return ProjectRoleActorsUpdateBean(
      categorisedActors: categorisedActors ?? this.categorisedActors,
      id: id ?? this.id,
    );
  }
}

/// Details about a project role.
class ProjectRoleDetails {
  /// Whether this role is the admin role for the project.
  final bool admin;

  /// Whether this role is the default role for the project.
  final bool default$;

  /// The description of the project role.
  final String? description;

  /// The ID of the project role.
  final int? id;

  /// The name of the project role.
  final String? name;

  /// Whether the roles are configurable for this project.
  final bool roleConfigurable;

  /// The scope of the role. Indicated for roles associated with
  /// [next-gen projects](https://confluence.atlassian.com/x/loMyO).
  final Scope? scope;

  /// The URL the project role details.
  final String? self;

  /// The translated name of the project role.
  final String? translatedName;

  ProjectRoleDetails(
      {bool? admin,
      bool? default$,
      this.description,
      this.id,
      this.name,
      bool? roleConfigurable,
      this.scope,
      this.self,
      this.translatedName})
      : admin = admin ?? false,
        default$ = default$ ?? false,
        roleConfigurable = roleConfigurable ?? false;

  factory ProjectRoleDetails.fromJson(Map<String, Object?> json) {
    return ProjectRoleDetails(
      admin: json[r'admin'] as bool? ?? false,
      default$: json[r'default'] as bool? ?? false,
      description: json[r'description'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      roleConfigurable: json[r'roleConfigurable'] as bool? ?? false,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      self: json[r'self'] as String?,
      translatedName: json[r'translatedName'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var admin = this.admin;
    var default$ = this.default$;
    var description = this.description;
    var id = this.id;
    var name = this.name;
    var roleConfigurable = this.roleConfigurable;
    var scope = this.scope;
    var self = this.self;
    var translatedName = this.translatedName;

    final json = <String, Object?>{};
    json[r'admin'] = admin;
    json[r'default'] = default$;
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'roleConfigurable'] = roleConfigurable;
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (translatedName != null) {
      json[r'translatedName'] = translatedName;
    }
    return json;
  }

  ProjectRoleDetails copyWith(
      {bool? admin,
      bool? default$,
      String? description,
      int? id,
      String? name,
      bool? roleConfigurable,
      Scope? scope,
      String? self,
      String? translatedName}) {
    return ProjectRoleDetails(
      admin: admin ?? this.admin,
      default$: default$ ?? this.default$,
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
      roleConfigurable: roleConfigurable ?? this.roleConfigurable,
      scope: scope ?? this.scope,
      self: self ?? this.self,
      translatedName: translatedName ?? this.translatedName,
    );
  }
}

/// Details of the group associated with the role.
class ProjectRoleGroup {
  /// The display name of the group.
  final String? displayName;

  /// The ID of the group.
  final String? groupId;

  /// The name of the group. As a group's name can change, use of `groupId` is
  /// recommended to identify the group.
  final String? name;

  ProjectRoleGroup({this.displayName, this.groupId, this.name});

  factory ProjectRoleGroup.fromJson(Map<String, Object?> json) {
    return ProjectRoleGroup(
      displayName: json[r'displayName'] as String?,
      groupId: json[r'groupId'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var displayName = this.displayName;
    var groupId = this.groupId;
    var name = this.name;

    final json = <String, Object?>{};
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (groupId != null) {
      json[r'groupId'] = groupId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  ProjectRoleGroup copyWith(
      {String? displayName, String? groupId, String? name}) {
    return ProjectRoleGroup(
      displayName: displayName ?? this.displayName,
      groupId: groupId ?? this.groupId,
      name: name ?? this.name,
    );
  }
}

/// Details of the user associated with the role.
class ProjectRoleUser {
  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Returns
  /// *unknown* if the record is deleted and corrupted, for example, as the
  /// result of a server import.
  final String? accountId;

  ProjectRoleUser({this.accountId});

  factory ProjectRoleUser.fromJson(Map<String, Object?> json) {
    return ProjectRoleUser(
      accountId: json[r'accountId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    return json;
  }

  ProjectRoleUser copyWith({String? accountId}) {
    return ProjectRoleUser(
      accountId: accountId ?? this.accountId,
    );
  }
}

class ProjectScopeBean {
  /// Defines the behavior of the option in the project.If notSelectable is set,
  /// the option cannot be set as the field's value. This is useful for
  /// archiving an option that has previously been selected but shouldn't be
  /// used anymore.If defaultValue is set, the option is selected by default.
  final List<ProjectScopeBeanAttributes> attributes;

  /// The ID of the project that the option's behavior applies to.
  final int? id;

  ProjectScopeBean({List<ProjectScopeBeanAttributes>? attributes, this.id})
      : attributes = attributes ?? [];

  factory ProjectScopeBean.fromJson(Map<String, Object?> json) {
    return ProjectScopeBean(
      attributes: (json[r'attributes'] as List<Object?>?)
              ?.map((i) =>
                  ProjectScopeBeanAttributes.fromValue(i as String? ?? ''))
              .toList() ??
          [],
      id: (json[r'id'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var attributes = this.attributes;
    var id = this.id;

    final json = <String, Object?>{};
    json[r'attributes'] = attributes.map((i) => i.value).toList();
    if (id != null) {
      json[r'id'] = id;
    }
    return json;
  }

  ProjectScopeBean copyWith(
      {List<ProjectScopeBeanAttributes>? attributes, int? id}) {
    return ProjectScopeBean(
      attributes: attributes ?? this.attributes,
      id: id ?? this.id,
    );
  }
}

class ProjectScopeBeanAttributes {
  static const notSelectable = ProjectScopeBeanAttributes._('notSelectable');
  static const defaultValue = ProjectScopeBeanAttributes._('defaultValue');

  static const values = [
    notSelectable,
    defaultValue,
  ];
  final String value;

  const ProjectScopeBeanAttributes._(this.value);

  static ProjectScopeBeanAttributes fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => ProjectScopeBeanAttributes._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about a project type.
class ProjectType {
  /// The color of the project type.
  final String? color;

  /// The key of the project type's description.
  final String? descriptionI18nKey;

  /// The formatted key of the project type.
  final String? formattedKey;

  /// The icon of the project type.
  final String? icon;

  /// The key of the project type.
  final String? key;

  ProjectType(
      {this.color,
      this.descriptionI18nKey,
      this.formattedKey,
      this.icon,
      this.key});

  factory ProjectType.fromJson(Map<String, Object?> json) {
    return ProjectType(
      color: json[r'color'] as String?,
      descriptionI18nKey: json[r'descriptionI18nKey'] as String?,
      formattedKey: json[r'formattedKey'] as String?,
      icon: json[r'icon'] as String?,
      key: json[r'key'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var color = this.color;
    var descriptionI18nKey = this.descriptionI18nKey;
    var formattedKey = this.formattedKey;
    var icon = this.icon;
    var key = this.key;

    final json = <String, Object?>{};
    if (color != null) {
      json[r'color'] = color;
    }
    if (descriptionI18nKey != null) {
      json[r'descriptionI18nKey'] = descriptionI18nKey;
    }
    if (formattedKey != null) {
      json[r'formattedKey'] = formattedKey;
    }
    if (icon != null) {
      json[r'icon'] = icon;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    return json;
  }

  ProjectType copyWith(
      {String? color,
      String? descriptionI18nKey,
      String? formattedKey,
      String? icon,
      String? key}) {
    return ProjectType(
      color: color ?? this.color,
      descriptionI18nKey: descriptionI18nKey ?? this.descriptionI18nKey,
      formattedKey: formattedKey ?? this.formattedKey,
      icon: icon ?? this.icon,
      key: key ?? this.key,
    );
  }
}

/// Property key details.
class PropertyKey {
  /// The key of the property.
  final String? key;

  /// The URL of the property.
  final String? self;

  PropertyKey({this.key, this.self});

  factory PropertyKey.fromJson(Map<String, Object?> json) {
    return PropertyKey(
      key: json[r'key'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var self = this.self;

    final json = <String, Object?>{};
    if (key != null) {
      json[r'key'] = key;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  PropertyKey copyWith({String? key, String? self}) {
    return PropertyKey(
      key: key ?? this.key,
      self: self ?? this.self,
    );
  }
}

/// List of property keys.
class PropertyKeys {
  /// Property key details.
  final List<PropertyKey> keys;

  PropertyKeys({List<PropertyKey>? keys}) : keys = keys ?? [];

  factory PropertyKeys.fromJson(Map<String, Object?> json) {
    return PropertyKeys(
      keys: (json[r'keys'] as List<Object?>?)
              ?.map((i) =>
                  PropertyKey.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var keys = this.keys;

    final json = <String, Object?>{};
    json[r'keys'] = keys.map((i) => i.toJson()).toList();
    return json;
  }

  PropertyKeys copyWith({List<PropertyKey>? keys}) {
    return PropertyKeys(
      keys: keys ?? this.keys,
    );
  }
}

/// Details about the status mappings for publishing a draft workflow scheme.
class PublishDraftWorkflowScheme {
  /// Mappings of statuses to new statuses for issue types.
  final List<StatusMapping> statusMappings;

  PublishDraftWorkflowScheme({List<StatusMapping>? statusMappings})
      : statusMappings = statusMappings ?? [];

  factory PublishDraftWorkflowScheme.fromJson(Map<String, Object?> json) {
    return PublishDraftWorkflowScheme(
      statusMappings: (json[r'statusMappings'] as List<Object?>?)
              ?.map((i) => StatusMapping.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var statusMappings = this.statusMappings;

    final json = <String, Object?>{};
    json[r'statusMappings'] = statusMappings.map((i) => i.toJson()).toList();
    return json;
  }

  PublishDraftWorkflowScheme copyWith({List<StatusMapping>? statusMappings}) {
    return PublishDraftWorkflowScheme(
      statusMappings: statusMappings ?? this.statusMappings,
    );
  }
}

/// Properties that identify a published workflow.
class PublishedWorkflowId {
  /// The entity ID of the workflow.
  final String? entityId;

  /// The name of the workflow.
  final String name;

  PublishedWorkflowId({this.entityId, required this.name});

  factory PublishedWorkflowId.fromJson(Map<String, Object?> json) {
    return PublishedWorkflowId(
      entityId: json[r'entityId'] as String?,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var entityId = this.entityId;
    var name = this.name;

    final json = <String, Object?>{};
    if (entityId != null) {
      json[r'entityId'] = entityId;
    }
    json[r'name'] = name;
    return json;
  }

  PublishedWorkflowId copyWith({String? entityId, String? name}) {
    return PublishedWorkflowId(
      entityId: entityId ?? this.entityId,
      name: name ?? this.name,
    );
  }
}

/// ID of a registered webhook or error messages explaining why a webhook wasn't
/// registered.
class RegisteredWebhook {
  /// The ID of the webhook. Returned if the webhook is created.
  final int? createdWebhookId;

  /// Error messages specifying why the webhook creation failed.
  final List<String> errors;

  RegisteredWebhook({this.createdWebhookId, List<String>? errors})
      : errors = errors ?? [];

  factory RegisteredWebhook.fromJson(Map<String, Object?> json) {
    return RegisteredWebhook(
      createdWebhookId: (json[r'createdWebhookId'] as num?)?.toInt(),
      errors: (json[r'errors'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var createdWebhookId = this.createdWebhookId;
    var errors = this.errors;

    final json = <String, Object?>{};
    if (createdWebhookId != null) {
      json[r'createdWebhookId'] = createdWebhookId;
    }
    json[r'errors'] = errors;
    return json;
  }

  RegisteredWebhook copyWith({int? createdWebhookId, List<String>? errors}) {
    return RegisteredWebhook(
      createdWebhookId: createdWebhookId ?? this.createdWebhookId,
      errors: errors ?? this.errors,
    );
  }
}

/// Details of an issue remote link.
class RemoteIssueLink {
  /// Details of the remote application the linked item is in.
  final Application? application;

  /// The global ID of the link, such as the ID of the item on the remote
  /// system.
  final String? globalId;

  /// The ID of the link.
  final int? id;

  /// Details of the item linked to.
  final RemoteObject? object;

  /// Description of the relationship between the issue and the linked item.
  final String? relationship;

  /// The URL of the link.
  final String? self;

  RemoteIssueLink(
      {this.application,
      this.globalId,
      this.id,
      this.object,
      this.relationship,
      this.self});

  factory RemoteIssueLink.fromJson(Map<String, Object?> json) {
    return RemoteIssueLink(
      application: json[r'application'] != null
          ? Application.fromJson(json[r'application']! as Map<String, Object?>)
          : null,
      globalId: json[r'globalId'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      object: json[r'object'] != null
          ? RemoteObject.fromJson(json[r'object']! as Map<String, Object?>)
          : null,
      relationship: json[r'relationship'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var application = this.application;
    var globalId = this.globalId;
    var id = this.id;
    var object = this.object;
    var relationship = this.relationship;
    var self = this.self;

    final json = <String, Object?>{};
    if (application != null) {
      json[r'application'] = application.toJson();
    }
    if (globalId != null) {
      json[r'globalId'] = globalId;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (object != null) {
      json[r'object'] = object.toJson();
    }
    if (relationship != null) {
      json[r'relationship'] = relationship;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  RemoteIssueLink copyWith(
      {Application? application,
      String? globalId,
      int? id,
      RemoteObject? object,
      String? relationship,
      String? self}) {
    return RemoteIssueLink(
      application: application ?? this.application,
      globalId: globalId ?? this.globalId,
      id: id ?? this.id,
      object: object ?? this.object,
      relationship: relationship ?? this.relationship,
      self: self ?? this.self,
    );
  }
}

/// Details of the identifiers for a created or updated remote issue link.
class RemoteIssueLinkIdentifies {
  /// The ID of the remote issue link, such as the ID of the item on the remote
  /// system.
  final int? id;

  /// The URL of the remote issue link.
  final String? self;

  RemoteIssueLinkIdentifies({this.id, this.self});

  factory RemoteIssueLinkIdentifies.fromJson(Map<String, Object?> json) {
    return RemoteIssueLinkIdentifies(
      id: (json[r'id'] as num?)?.toInt(),
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var self = this.self;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  RemoteIssueLinkIdentifies copyWith({int? id, String? self}) {
    return RemoteIssueLinkIdentifies(
      id: id ?? this.id,
      self: self ?? this.self,
    );
  }
}

/// Details of a remote issue link.
class RemoteIssueLinkRequest {
  /// Details of the remote application the linked item is in. For example,
  /// trello.
  final Application? application;

  /// An identifier for the remote item in the remote system. For example, the
  /// global ID for a remote item in Confluence would consist of the app ID and
  /// page ID, like this: `appId=456&pageId=123`.
  ///
  /// Setting this field enables the remote issue link details to be updated or
  /// deleted using remote system and item details as the record identifier,
  /// rather than using the record's Jira ID.
  ///
  /// The maximum length is 255 characters.
  final String? globalId;

  /// Details of the item linked to.
  final RemoteObject object;

  /// Description of the relationship between the issue and the linked item. If
  /// not set, the relationship description "links to" is used in Jira.
  final String? relationship;

  RemoteIssueLinkRequest(
      {this.application,
      this.globalId,
      required this.object,
      this.relationship});

  factory RemoteIssueLinkRequest.fromJson(Map<String, Object?> json) {
    return RemoteIssueLinkRequest(
      application: json[r'application'] != null
          ? Application.fromJson(json[r'application']! as Map<String, Object?>)
          : null,
      globalId: json[r'globalId'] as String?,
      object: RemoteObject.fromJson(
          json[r'object'] as Map<String, Object?>? ?? const {}),
      relationship: json[r'relationship'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var application = this.application;
    var globalId = this.globalId;
    var object = this.object;
    var relationship = this.relationship;

    final json = <String, Object?>{};
    if (application != null) {
      json[r'application'] = application.toJson();
    }
    if (globalId != null) {
      json[r'globalId'] = globalId;
    }
    json[r'object'] = object.toJson();
    if (relationship != null) {
      json[r'relationship'] = relationship;
    }
    return json;
  }

  RemoteIssueLinkRequest copyWith(
      {Application? application,
      String? globalId,
      RemoteObject? object,
      String? relationship}) {
    return RemoteIssueLinkRequest(
      application: application ?? this.application,
      globalId: globalId ?? this.globalId,
      object: object ?? this.object,
      relationship: relationship ?? this.relationship,
    );
  }
}

/// The linked item.
class RemoteObject {
  /// Details of the icon for the item. If no icon is defined, the default link
  /// icon is used in Jira.
  final Icon? icon;

  /// The status of the item.
  final Status? status;

  /// The summary details of the item.
  final String? summary;

  /// The title of the item.
  final String title;

  /// The URL of the item.
  final String url;

  RemoteObject(
      {this.icon,
      this.status,
      this.summary,
      required this.title,
      required this.url});

  factory RemoteObject.fromJson(Map<String, Object?> json) {
    return RemoteObject(
      icon: json[r'icon'] != null
          ? Icon.fromJson(json[r'icon']! as Map<String, Object?>)
          : null,
      status: json[r'status'] != null
          ? Status.fromJson(json[r'status']! as Map<String, Object?>)
          : null,
      summary: json[r'summary'] as String?,
      title: json[r'title'] as String? ?? '',
      url: json[r'url'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var icon = this.icon;
    var status = this.status;
    var summary = this.summary;
    var title = this.title;
    var url = this.url;

    final json = <String, Object?>{};
    if (icon != null) {
      json[r'icon'] = icon.toJson();
    }
    if (status != null) {
      json[r'status'] = status.toJson();
    }
    if (summary != null) {
      json[r'summary'] = summary;
    }
    json[r'title'] = title;
    json[r'url'] = url;
    return json;
  }

  RemoteObject copyWith(
      {Icon? icon,
      Status? status,
      String? summary,
      String? title,
      String? url}) {
    return RemoteObject(
      icon: icon ?? this.icon,
      status: status ?? this.status,
      summary: summary ?? this.summary,
      title: title ?? this.title,
      url: url ?? this.url,
    );
  }
}

class RemoveOptionFromIssuesResult {
  /// A collection of errors related to unchanged issues. The collection size is
  /// limited, which means not all errors may be returned.
  final SimpleErrorCollection? errors;

  /// The IDs of the modified issues.
  final List<int> modifiedIssues;

  /// The IDs of the unchanged issues, those issues where errors prevent
  /// modification.
  final List<int> unmodifiedIssues;

  RemoveOptionFromIssuesResult(
      {this.errors, List<int>? modifiedIssues, List<int>? unmodifiedIssues})
      : modifiedIssues = modifiedIssues ?? [],
        unmodifiedIssues = unmodifiedIssues ?? [];

  factory RemoveOptionFromIssuesResult.fromJson(Map<String, Object?> json) {
    return RemoveOptionFromIssuesResult(
      errors: json[r'errors'] != null
          ? SimpleErrorCollection.fromJson(
              json[r'errors']! as Map<String, Object?>)
          : null,
      modifiedIssues: (json[r'modifiedIssues'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      unmodifiedIssues: (json[r'unmodifiedIssues'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var errors = this.errors;
    var modifiedIssues = this.modifiedIssues;
    var unmodifiedIssues = this.unmodifiedIssues;

    final json = <String, Object?>{};
    if (errors != null) {
      json[r'errors'] = errors.toJson();
    }
    json[r'modifiedIssues'] = modifiedIssues;
    json[r'unmodifiedIssues'] = unmodifiedIssues;
    return json;
  }

  RemoveOptionFromIssuesResult copyWith(
      {SimpleErrorCollection? errors,
      List<int>? modifiedIssues,
      List<int>? unmodifiedIssues}) {
    return RemoveOptionFromIssuesResult(
      errors: errors ?? this.errors,
      modifiedIssues: modifiedIssues ?? this.modifiedIssues,
      unmodifiedIssues: unmodifiedIssues ?? this.unmodifiedIssues,
    );
  }
}

/// Change the order of issue priorities.
class ReorderIssuePriorities {
  /// The ID of the priority. Required if `position` isn't provided.
  final String? after;

  /// The list of issue IDs to be reordered. Cannot contain duplicates nor after
  /// ID.
  final List<String> ids;

  /// The position for issue priorities to be moved to. Required if `after`
  /// isn't provided.
  final String? position;

  ReorderIssuePriorities({this.after, required this.ids, this.position});

  factory ReorderIssuePriorities.fromJson(Map<String, Object?> json) {
    return ReorderIssuePriorities(
      after: json[r'after'] as String?,
      ids: (json[r'ids'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      position: json[r'position'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var after = this.after;
    var ids = this.ids;
    var position = this.position;

    final json = <String, Object?>{};
    if (after != null) {
      json[r'after'] = after;
    }
    json[r'ids'] = ids;
    if (position != null) {
      json[r'position'] = position;
    }
    return json;
  }

  ReorderIssuePriorities copyWith(
      {String? after, List<String>? ids, String? position}) {
    return ReorderIssuePriorities(
      after: after ?? this.after,
      ids: ids ?? this.ids,
      position: position ?? this.position,
    );
  }
}

/// Change the order of issue resolutions.
class ReorderIssueResolutionsRequest {
  /// The ID of the resolution. Required if `position` isn't provided.
  final String? after;

  /// The list of resolution IDs to be reordered. Cannot contain duplicates nor
  /// after ID.
  final List<String> ids;

  /// The position for issue resolutions to be moved to. Required if `after`
  /// isn't provided.
  final String? position;

  ReorderIssueResolutionsRequest(
      {this.after, required this.ids, this.position});

  factory ReorderIssueResolutionsRequest.fromJson(Map<String, Object?> json) {
    return ReorderIssueResolutionsRequest(
      after: json[r'after'] as String?,
      ids: (json[r'ids'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      position: json[r'position'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var after = this.after;
    var ids = this.ids;
    var position = this.position;

    final json = <String, Object?>{};
    if (after != null) {
      json[r'after'] = after;
    }
    json[r'ids'] = ids;
    if (position != null) {
      json[r'position'] = position;
    }
    return json;
  }

  ReorderIssueResolutionsRequest copyWith(
      {String? after, List<String>? ids, String? position}) {
    return ReorderIssueResolutionsRequest(
      after: after ?? this.after,
      ids: ids ?? this.ids,
      position: position ?? this.position,
    );
  }
}

/// Details of an issue resolution.
class Resolution {
  /// The description of the issue resolution.
  final String? description;

  /// The ID of the issue resolution.
  final String? id;

  /// The name of the issue resolution.
  final String? name;

  /// The URL of the issue resolution.
  final String? self;

  Resolution({this.description, this.id, this.name, this.self});

  factory Resolution.fromJson(Map<String, Object?> json) {
    return Resolution(
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var name = this.name;
    var self = this.self;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  Resolution copyWith(
      {String? description, String? id, String? name, String? self}) {
    return Resolution(
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
      self: self ?? this.self,
    );
  }
}

/// The ID of an issue resolution.
class ResolutionId {
  /// The ID of the issue resolution.
  final String id;

  ResolutionId({required this.id});

  factory ResolutionId.fromJson(Map<String, Object?> json) {
    return ResolutionId(
      id: json[r'id'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  ResolutionId copyWith({String? id}) {
    return ResolutionId(
      id: id ?? this.id,
    );
  }
}

class ResolutionJsonBean {
  final bool default$;
  final String? description;
  final String? iconUrl;
  final String? id;
  final String? name;
  final String? self;

  ResolutionJsonBean(
      {bool? default$,
      this.description,
      this.iconUrl,
      this.id,
      this.name,
      this.self})
      : default$ = default$ ?? false;

  factory ResolutionJsonBean.fromJson(Map<String, Object?> json) {
    return ResolutionJsonBean(
      default$: json[r'default'] as bool? ?? false,
      description: json[r'description'] as String?,
      iconUrl: json[r'iconUrl'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var default$ = this.default$;
    var description = this.description;
    var iconUrl = this.iconUrl;
    var id = this.id;
    var name = this.name;
    var self = this.self;

    final json = <String, Object?>{};
    json[r'default'] = default$;
    if (description != null) {
      json[r'description'] = description;
    }
    if (iconUrl != null) {
      json[r'iconUrl'] = iconUrl;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  ResolutionJsonBean copyWith(
      {bool? default$,
      String? description,
      String? iconUrl,
      String? id,
      String? name,
      String? self}) {
    return ResolutionJsonBean(
      default$: default$ ?? this.default$,
      description: description ?? this.description,
      iconUrl: iconUrl ?? this.iconUrl,
      id: id ?? this.id,
      name: name ?? this.name,
      self: self ?? this.self,
    );
  }
}

/// Details of the permission.
class RestrictedPermission {
  /// The ID of the permission. Either `id` or `key` must be specified. Use
  /// [Get all permissions](#api-rest-api-3-permissions-get) to get the list of
  /// permissions.
  final String? id;

  /// The key of the permission. Either `id` or `key` must be specified. Use
  /// [Get all permissions](#api-rest-api-3-permissions-get) to get the list of
  /// permissions.
  final String? key;

  RestrictedPermission({this.id, this.key});

  factory RestrictedPermission.fromJson(Map<String, Object?> json) {
    return RestrictedPermission(
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    return json;
  }

  RestrictedPermission copyWith({String? id, String? key}) {
    return RestrictedPermission(
      id: id ?? this.id,
      key: key ?? this.key,
    );
  }
}

class RichText {
  final bool empty;
  final bool emptyAdf;
  final bool finalised;
  final bool valueSet;

  RichText({bool? empty, bool? emptyAdf, bool? finalised, bool? valueSet})
      : empty = empty ?? false,
        emptyAdf = emptyAdf ?? false,
        finalised = finalised ?? false,
        valueSet = valueSet ?? false;

  factory RichText.fromJson(Map<String, Object?> json) {
    return RichText(
      empty: json[r'empty'] as bool? ?? false,
      emptyAdf: json[r'emptyAdf'] as bool? ?? false,
      finalised: json[r'finalised'] as bool? ?? false,
      valueSet: json[r'valueSet'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var empty = this.empty;
    var emptyAdf = this.emptyAdf;
    var finalised = this.finalised;
    var valueSet = this.valueSet;

    final json = <String, Object?>{};
    json[r'empty'] = empty;
    json[r'emptyAdf'] = emptyAdf;
    json[r'finalised'] = finalised;
    json[r'valueSet'] = valueSet;
    return json;
  }

  RichText copyWith(
      {bool? empty, bool? emptyAdf, bool? finalised, bool? valueSet}) {
    return RichText(
      empty: empty ?? this.empty,
      emptyAdf: emptyAdf ?? this.emptyAdf,
      finalised: finalised ?? this.finalised,
      valueSet: valueSet ?? this.valueSet,
    );
  }
}

/// Details about a user assigned to a project role.
class RoleActor {
  final ProjectRoleGroup? actorGroup;
  final ProjectRoleUser? actorUser;

  /// The avatar of the role actor.
  final String? avatarUrl;

  /// The display name of the role actor. For users, depending on the user’s
  /// privacy setting, this may return an alternative value for the user's name.
  final String? displayName;

  /// The ID of the role actor.
  final int? id;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? name;

  /// The type of role actor.
  final RoleActorType? type;

  RoleActor(
      {this.actorGroup,
      this.actorUser,
      this.avatarUrl,
      this.displayName,
      this.id,
      this.name,
      this.type});

  factory RoleActor.fromJson(Map<String, Object?> json) {
    return RoleActor(
      actorGroup: json[r'actorGroup'] != null
          ? ProjectRoleGroup.fromJson(
              json[r'actorGroup']! as Map<String, Object?>)
          : null,
      actorUser: json[r'actorUser'] != null
          ? ProjectRoleUser.fromJson(
              json[r'actorUser']! as Map<String, Object?>)
          : null,
      avatarUrl: json[r'avatarUrl'] as String?,
      displayName: json[r'displayName'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? RoleActorType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var actorGroup = this.actorGroup;
    var actorUser = this.actorUser;
    var avatarUrl = this.avatarUrl;
    var displayName = this.displayName;
    var id = this.id;
    var name = this.name;
    var type = this.type;

    final json = <String, Object?>{};
    if (actorGroup != null) {
      json[r'actorGroup'] = actorGroup.toJson();
    }
    if (actorUser != null) {
      json[r'actorUser'] = actorUser.toJson();
    }
    if (avatarUrl != null) {
      json[r'avatarUrl'] = avatarUrl;
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  RoleActor copyWith(
      {ProjectRoleGroup? actorGroup,
      ProjectRoleUser? actorUser,
      String? avatarUrl,
      String? displayName,
      int? id,
      String? name,
      RoleActorType? type}) {
    return RoleActor(
      actorGroup: actorGroup ?? this.actorGroup,
      actorUser: actorUser ?? this.actorUser,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      displayName: displayName ?? this.displayName,
      id: id ?? this.id,
      name: name ?? this.name,
      type: type ?? this.type,
    );
  }
}

class RoleActorType {
  static const atlassianGroupRoleActor =
      RoleActorType._('atlassian-group-role-actor');
  static const atlassianUserRoleActor =
      RoleActorType._('atlassian-user-role-actor');

  static const values = [
    atlassianGroupRoleActor,
    atlassianUserRoleActor,
  ];
  final String value;

  const RoleActorType._(this.value);

  static RoleActorType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => RoleActorType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A rule configuration.
class RuleConfiguration {
  /// EXPERIMENTAL: Whether the rule is disabled.
  final bool disabled;

  /// EXPERIMENTAL: A tag used to filter rules in
  /// [Get workflow transition rule configurations](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-workflow-transition-rules/#api-rest-api-3-workflow-rule-config-get).
  final String? tag;

  /// Configuration of the rule, as it is stored by the Connect or the Forge app
  /// on the rule configuration page.
  final String value;

  RuleConfiguration({bool? disabled, this.tag, required this.value})
      : disabled = disabled ?? false;

  factory RuleConfiguration.fromJson(Map<String, Object?> json) {
    return RuleConfiguration(
      disabled: json[r'disabled'] as bool? ?? false,
      tag: json[r'tag'] as String?,
      value: json[r'value'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var disabled = this.disabled;
    var tag = this.tag;
    var value = this.value;

    final json = <String, Object?>{};
    json[r'disabled'] = disabled;
    if (tag != null) {
      json[r'tag'] = tag;
    }
    json[r'value'] = value;
    return json;
  }

  RuleConfiguration copyWith({bool? disabled, String? tag, String? value}) {
    return RuleConfiguration(
      disabled: disabled ?? this.disabled,
      tag: tag ?? this.tag,
      value: value ?? this.value,
    );
  }
}

/// The sanitized JQL queries for the given account IDs.
class SanitizedJqlQueries {
  /// The list of sanitized JQL queries.
  final List<SanitizedJqlQuery> queries;

  SanitizedJqlQueries({List<SanitizedJqlQuery>? queries})
      : queries = queries ?? [];

  factory SanitizedJqlQueries.fromJson(Map<String, Object?> json) {
    return SanitizedJqlQueries(
      queries: (json[r'queries'] as List<Object?>?)
              ?.map((i) => SanitizedJqlQuery.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var queries = this.queries;

    final json = <String, Object?>{};
    json[r'queries'] = queries.map((i) => i.toJson()).toList();
    return json;
  }

  SanitizedJqlQueries copyWith({List<SanitizedJqlQuery>? queries}) {
    return SanitizedJqlQueries(
      queries: queries ?? this.queries,
    );
  }
}

/// Details of the sanitized JQL query.
class SanitizedJqlQuery {
  /// The account ID of the user for whom sanitization was performed.
  final String? accountId;

  /// The list of errors.
  final ErrorCollection? errors;

  /// The initial query.
  final String? initialQuery;

  /// The sanitized query, if there were no errors.
  final String? sanitizedQuery;

  SanitizedJqlQuery(
      {this.accountId, this.errors, this.initialQuery, this.sanitizedQuery});

  factory SanitizedJqlQuery.fromJson(Map<String, Object?> json) {
    return SanitizedJqlQuery(
      accountId: json[r'accountId'] as String?,
      errors: json[r'errors'] != null
          ? ErrorCollection.fromJson(json[r'errors']! as Map<String, Object?>)
          : null,
      initialQuery: json[r'initialQuery'] as String?,
      sanitizedQuery: json[r'sanitizedQuery'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var errors = this.errors;
    var initialQuery = this.initialQuery;
    var sanitizedQuery = this.sanitizedQuery;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (errors != null) {
      json[r'errors'] = errors.toJson();
    }
    if (initialQuery != null) {
      json[r'initialQuery'] = initialQuery;
    }
    if (sanitizedQuery != null) {
      json[r'sanitizedQuery'] = sanitizedQuery;
    }
    return json;
  }

  SanitizedJqlQuery copyWith(
      {String? accountId,
      ErrorCollection? errors,
      String? initialQuery,
      String? sanitizedQuery}) {
    return SanitizedJqlQuery(
      accountId: accountId ?? this.accountId,
      errors: errors ?? this.errors,
      initialQuery: initialQuery ?? this.initialQuery,
      sanitizedQuery: sanitizedQuery ?? this.sanitizedQuery,
    );
  }
}

/// The projects the item is associated with. Indicated for items associated
/// with [next-gen projects](https://confluence.atlassian.com/x/loMyO).
class Scope {
  /// The project the item has scope in.
  final ProjectDetails? project;

  /// The type of scope.
  final ScopeType? type;

  Scope({this.project, this.type});

  factory Scope.fromJson(Map<String, Object?> json) {
    return Scope(
      project: json[r'project'] != null
          ? ProjectDetails.fromJson(json[r'project']! as Map<String, Object?>)
          : null,
      type: json[r'type'] != null
          ? ScopeType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var project = this.project;
    var type = this.type;

    final json = <String, Object?>{};
    if (project != null) {
      json[r'project'] = project.toJson();
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  Scope copyWith({ProjectDetails? project, ScopeType? type}) {
    return Scope(
      project: project ?? this.project,
      type: type ?? this.type,
    );
  }
}

class ScopeType {
  static const project = ScopeType._('PROJECT');
  static const template = ScopeType._('TEMPLATE');

  static const values = [
    project,
    template,
  ];
  final String value;

  const ScopeType._(this.value);

  static ScopeType fromValue(String value) => values
      .firstWhere((e) => e.value == value, orElse: () => ScopeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A screen.
class Screen {
  /// The description of the screen.
  final String? description;

  /// The ID of the screen.
  final int? id;

  /// The name of the screen.
  final String? name;

  /// The scope of the screen.
  final Scope? scope;

  Screen({this.description, this.id, this.name, this.scope});

  factory Screen.fromJson(Map<String, Object?> json) {
    return Screen(
      description: json[r'description'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var name = this.name;
    var scope = this.scope;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    return json;
  }

  Screen copyWith({String? description, int? id, String? name, Scope? scope}) {
    return Screen(
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
      scope: scope ?? this.scope,
    );
  }
}

/// Details of a screen.
class ScreenDetails {
  /// The description of the screen. The maximum length is 255 characters.
  final String? description;

  /// The name of the screen. The name must be unique. The maximum length is 255
  /// characters.
  final String name;

  ScreenDetails({this.description, required this.name});

  factory ScreenDetails.fromJson(Map<String, Object?> json) {
    return ScreenDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'name'] = name;
    return json;
  }

  ScreenDetails copyWith({String? description, String? name}) {
    return ScreenDetails(
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// A screen scheme.
class ScreenScheme {
  /// The description of the screen scheme.
  final String? description;

  /// The ID of the screen scheme.
  final int? id;

  /// Details of the issue type screen schemes associated with the screen
  /// scheme.
  final PageBeanIssueTypeScreenScheme? issueTypeScreenSchemes;

  /// The name of the screen scheme.
  final String? name;

  /// The IDs of the screens for the screen types of the screen scheme.
  final ScreenTypes? screens;

  ScreenScheme(
      {this.description,
      this.id,
      this.issueTypeScreenSchemes,
      this.name,
      this.screens});

  factory ScreenScheme.fromJson(Map<String, Object?> json) {
    return ScreenScheme(
      description: json[r'description'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      issueTypeScreenSchemes: json[r'issueTypeScreenSchemes'] != null
          ? PageBeanIssueTypeScreenScheme.fromJson(
              json[r'issueTypeScreenSchemes']! as Map<String, Object?>)
          : null,
      name: json[r'name'] as String?,
      screens: json[r'screens'] != null
          ? ScreenTypes.fromJson(json[r'screens']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var issueTypeScreenSchemes = this.issueTypeScreenSchemes;
    var name = this.name;
    var screens = this.screens;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (issueTypeScreenSchemes != null) {
      json[r'issueTypeScreenSchemes'] = issueTypeScreenSchemes.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (screens != null) {
      json[r'screens'] = screens.toJson();
    }
    return json;
  }

  ScreenScheme copyWith(
      {String? description,
      int? id,
      PageBeanIssueTypeScreenScheme? issueTypeScreenSchemes,
      String? name,
      ScreenTypes? screens}) {
    return ScreenScheme(
      description: description ?? this.description,
      id: id ?? this.id,
      issueTypeScreenSchemes:
          issueTypeScreenSchemes ?? this.issueTypeScreenSchemes,
      name: name ?? this.name,
      screens: screens ?? this.screens,
    );
  }
}

/// Details of a screen scheme.
class ScreenSchemeDetails {
  /// The description of the screen scheme. The maximum length is 255
  /// characters.
  final String? description;

  /// The name of the screen scheme. The name must be unique. The maximum length
  /// is 255 characters.
  final String name;

  /// The IDs of the screens for the screen types of the screen scheme. Only
  /// screens used in classic projects are accepted.
  final ScreenTypes screens;

  ScreenSchemeDetails(
      {this.description, required this.name, required this.screens});

  factory ScreenSchemeDetails.fromJson(Map<String, Object?> json) {
    return ScreenSchemeDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String? ?? '',
      screens: ScreenTypes.fromJson(
          json[r'screens'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;
    var screens = this.screens;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'name'] = name;
    json[r'screens'] = screens.toJson();
    return json;
  }

  ScreenSchemeDetails copyWith(
      {String? description, String? name, ScreenTypes? screens}) {
    return ScreenSchemeDetails(
      description: description ?? this.description,
      name: name ?? this.name,
      screens: screens ?? this.screens,
    );
  }
}

/// The ID of a screen scheme.
class ScreenSchemeId {
  /// The ID of the screen scheme.
  final int id;

  ScreenSchemeId({required this.id});

  factory ScreenSchemeId.fromJson(Map<String, Object?> json) {
    return ScreenSchemeId(
      id: (json[r'id'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  ScreenSchemeId copyWith({int? id}) {
    return ScreenSchemeId(
      id: id ?? this.id,
    );
  }
}

/// The IDs of the screens for the screen types of the screen scheme.
class ScreenTypes {
  /// The ID of the create screen.
  final int? create;

  /// The ID of the default screen. Required when creating a screen scheme.
  final int? default$;

  /// The ID of the edit screen.
  final int? edit;

  /// The ID of the view screen.
  final int? view;

  ScreenTypes({this.create, this.default$, this.edit, this.view});

  factory ScreenTypes.fromJson(Map<String, Object?> json) {
    return ScreenTypes(
      create: (json[r'create'] as num?)?.toInt(),
      default$: (json[r'default'] as num?)?.toInt(),
      edit: (json[r'edit'] as num?)?.toInt(),
      view: (json[r'view'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var create = this.create;
    var default$ = this.default$;
    var edit = this.edit;
    var view = this.view;

    final json = <String, Object?>{};
    if (create != null) {
      json[r'create'] = create;
    }
    if (default$ != null) {
      json[r'default'] = default$;
    }
    if (edit != null) {
      json[r'edit'] = edit;
    }
    if (view != null) {
      json[r'view'] = view;
    }
    return json;
  }

  ScreenTypes copyWith({int? create, int? default$, int? edit, int? view}) {
    return ScreenTypes(
      create: create ?? this.create,
      default$: default$ ?? this.default$,
      edit: edit ?? this.edit,
      view: view ?? this.view,
    );
  }
}

/// A screen with tab details.
class ScreenWithTab {
  /// The description of the screen.
  final String? description;

  /// The ID of the screen.
  final int? id;

  /// The name of the screen.
  final String? name;

  /// The scope of the screen.
  final Scope? scope;

  /// The tab for the screen.
  final ScreenableTab? tab;

  ScreenWithTab({this.description, this.id, this.name, this.scope, this.tab});

  factory ScreenWithTab.fromJson(Map<String, Object?> json) {
    return ScreenWithTab(
      description: json[r'description'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      scope: json[r'scope'] != null
          ? Scope.fromJson(json[r'scope']! as Map<String, Object?>)
          : null,
      tab: json[r'tab'] != null
          ? ScreenableTab.fromJson(json[r'tab']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var name = this.name;
    var scope = this.scope;
    var tab = this.tab;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (scope != null) {
      json[r'scope'] = scope.toJson();
    }
    if (tab != null) {
      json[r'tab'] = tab.toJson();
    }
    return json;
  }

  ScreenWithTab copyWith(
      {String? description,
      int? id,
      String? name,
      Scope? scope,
      ScreenableTab? tab}) {
    return ScreenWithTab(
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
      scope: scope ?? this.scope,
      tab: tab ?? this.tab,
    );
  }
}

/// A screen tab field.
class ScreenableField {
  /// The ID of the screen tab field.
  final String? id;

  /// The name of the screen tab field. Required on create and update. The
  /// maximum length is 255 characters.
  final String? name;

  ScreenableField({this.id, this.name});

  factory ScreenableField.fromJson(Map<String, Object?> json) {
    return ScreenableField(
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  ScreenableField copyWith({String? id, String? name}) {
    return ScreenableField(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// A screen tab.
class ScreenableTab {
  /// The ID of the screen tab.
  final int? id;

  /// The name of the screen tab. The maximum length is 255 characters.
  final String name;

  ScreenableTab({this.id, required this.name});

  factory ScreenableTab.fromJson(Map<String, Object?> json) {
    return ScreenableTab(
      id: (json[r'id'] as num?)?.toInt(),
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'name'] = name;
    return json;
  }

  ScreenableTab copyWith({int? id, String? name}) {
    return ScreenableTab(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// Details of how to filter and list search auto complete information.
class SearchAutoCompleteFilter {
  /// Include collapsed fields for fields that have non-unique names.
  final bool includeCollapsedFields;

  /// List of project IDs used to filter the visible field details returned.
  final List<int> projectIds;

  SearchAutoCompleteFilter(
      {bool? includeCollapsedFields, List<int>? projectIds})
      : includeCollapsedFields = includeCollapsedFields ?? false,
        projectIds = projectIds ?? [];

  factory SearchAutoCompleteFilter.fromJson(Map<String, Object?> json) {
    return SearchAutoCompleteFilter(
      includeCollapsedFields: json[r'includeCollapsedFields'] as bool? ?? false,
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var includeCollapsedFields = this.includeCollapsedFields;
    var projectIds = this.projectIds;

    final json = <String, Object?>{};
    json[r'includeCollapsedFields'] = includeCollapsedFields;
    json[r'projectIds'] = projectIds;
    return json;
  }

  SearchAutoCompleteFilter copyWith(
      {bool? includeCollapsedFields, List<int>? projectIds}) {
    return SearchAutoCompleteFilter(
      includeCollapsedFields:
          includeCollapsedFields ?? this.includeCollapsedFields,
      projectIds: projectIds ?? this.projectIds,
    );
  }
}

class SearchRequestBean {
  /// Use [expand](em>#expansion) to include additional information about issues
  /// in the response. Note that, unlike the majority of instances where
  /// `expand` is specified, `expand` is defined as a list of values. The expand
  /// options are:
  ///
  ///  *  `renderedFields` Returns field values rendered in HTML format.
  ///  *  `names` Returns the display name of each field.
  ///  *  `schema` Returns the schema describing a field type.
  ///  *  `transitions` Returns all possible transitions for the issue.
  ///  *  `operations` Returns all possible operations for the issue.
  ///  *  `editmeta` Returns information about how each field can be edited.
  ///  *  `changelog` Returns a list of recent updates to an issue, sorted by
  /// date, starting from the most recent.
  ///  *  `versionedRepresentations` Instead of `fields`, returns
  /// `versionedRepresentations` a JSON array containing each version of a
  /// field's value, with the highest numbered item representing the most recent
  /// version.
  final List<String> expand;

  /// A list of fields to return for each issue, use it to retrieve a subset of
  /// fields. This parameter accepts a comma-separated list. Expand options
  /// include:
  ///
  ///  *  `*all` Returns all fields.
  ///  *  `*navigable` Returns navigable fields.
  ///  *  Any issue field, prefixed with a minus to exclude.
  ///
  /// The default is `*navigable`.
  ///
  /// Examples:
  ///
  ///  *  `summary,comment` Returns the summary and comments fields only.
  ///  *  `-description` Returns all navigable (default) fields except
  /// description.
  ///  *  `*all,-comment` Returns all fields except comments.
  ///
  /// Multiple `fields` parameters can be included in a request.
  ///
  /// Note: All navigable fields are returned by default. This differs from
  /// [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is
  /// all fields.
  final List<String> fields;

  /// Reference fields by their key (rather than ID). The default is `false`.
  final bool fieldsByKeys;

  /// A [JQL](https://confluence.atlassian.com/x/egORLQ) expression.
  final String? jql;

  /// The maximum number of items to return per page.
  final int? maxResults;

  /// A list of up to 5 issue properties to include in the results. This
  /// parameter accepts a comma-separated list.
  final List<String> properties;

  /// The index of the first item to return in the page of results (page
  /// offset). The base index is `0`.
  final int? startAt;

  /// Determines how to validate the JQL query and treat the validation results.
  /// Supported values:
  ///
  ///  *  `strict` Returns a 400 response code if any errors are found, along
  /// with a list of all errors (and warnings).
  ///  *  `warn` Returns all errors as warnings.
  ///  *  `none` No validation is performed.
  ///  *  `true` *Deprecated* A legacy synonym for `strict`.
  ///  *  `false` *Deprecated* A legacy synonym for `warn`.
  ///
  /// The default is `strict`.
  ///
  /// Note: If the JQL is not correctly formed a 400 response code is returned,
  /// regardless of the `validateQuery` value.
  final SearchRequestBeanValidateQuery? validateQuery;

  SearchRequestBean(
      {List<String>? expand,
      List<String>? fields,
      bool? fieldsByKeys,
      this.jql,
      this.maxResults,
      List<String>? properties,
      this.startAt,
      this.validateQuery})
      : expand = expand ?? [],
        fields = fields ?? [],
        fieldsByKeys = fieldsByKeys ?? false,
        properties = properties ?? [];

  factory SearchRequestBean.fromJson(Map<String, Object?> json) {
    return SearchRequestBean(
      expand: (json[r'expand'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      fields: (json[r'fields'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      fieldsByKeys: json[r'fieldsByKeys'] as bool? ?? false,
      jql: json[r'jql'] as String?,
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      properties: (json[r'properties'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      startAt: (json[r'startAt'] as num?)?.toInt(),
      validateQuery: json[r'validateQuery'] != null
          ? SearchRequestBeanValidateQuery.fromValue(
              json[r'validateQuery']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var fields = this.fields;
    var fieldsByKeys = this.fieldsByKeys;
    var jql = this.jql;
    var maxResults = this.maxResults;
    var properties = this.properties;
    var startAt = this.startAt;
    var validateQuery = this.validateQuery;

    final json = <String, Object?>{};
    json[r'expand'] = expand;
    json[r'fields'] = fields;
    json[r'fieldsByKeys'] = fieldsByKeys;
    if (jql != null) {
      json[r'jql'] = jql;
    }
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    json[r'properties'] = properties;
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (validateQuery != null) {
      json[r'validateQuery'] = validateQuery.value;
    }
    return json;
  }

  SearchRequestBean copyWith(
      {List<String>? expand,
      List<String>? fields,
      bool? fieldsByKeys,
      String? jql,
      int? maxResults,
      List<String>? properties,
      int? startAt,
      SearchRequestBeanValidateQuery? validateQuery}) {
    return SearchRequestBean(
      expand: expand ?? this.expand,
      fields: fields ?? this.fields,
      fieldsByKeys: fieldsByKeys ?? this.fieldsByKeys,
      jql: jql ?? this.jql,
      maxResults: maxResults ?? this.maxResults,
      properties: properties ?? this.properties,
      startAt: startAt ?? this.startAt,
      validateQuery: validateQuery ?? this.validateQuery,
    );
  }
}

class SearchRequestBeanValidateQuery {
  static const strict = SearchRequestBeanValidateQuery._('strict');
  static const warn = SearchRequestBeanValidateQuery._('warn');
  static const none = SearchRequestBeanValidateQuery._('none');
  static const true$ = SearchRequestBeanValidateQuery._('true');
  static const false$ = SearchRequestBeanValidateQuery._('false');

  static const values = [
    strict,
    warn,
    none,
    true$,
    false$,
  ];
  final String value;

  const SearchRequestBeanValidateQuery._(this.value);

  static SearchRequestBeanValidateQuery fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => SearchRequestBeanValidateQuery._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The result of a JQL search.
class SearchResults {
  /// Expand options that include additional search result details in the
  /// response.
  final String? expand;

  /// The list of issues found by the search.
  final List<IssueBean> issues;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The ID and name of each field in the search results.
  final Map<String, dynamic>? names;

  /// The schema describing the field types in the search results.
  final Map<String, dynamic>? schema;

  /// The index of the first item returned on the page.
  final int? startAt;

  /// The number of results on the page.
  final int? total;

  /// Any warnings related to the JQL query.
  final List<String> warningMessages;

  SearchResults(
      {this.expand,
      List<IssueBean>? issues,
      this.maxResults,
      this.names,
      this.schema,
      this.startAt,
      this.total,
      List<String>? warningMessages})
      : issues = issues ?? [],
        warningMessages = warningMessages ?? [];

  factory SearchResults.fromJson(Map<String, Object?> json) {
    return SearchResults(
      expand: json[r'expand'] as String?,
      issues: (json[r'issues'] as List<Object?>?)
              ?.map((i) =>
                  IssueBean.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'maxResults'] as num?)?.toInt(),
      names: json[r'names'] as Map<String, Object?>?,
      schema: json[r'schema'] as Map<String, Object?>?,
      startAt: (json[r'startAt'] as num?)?.toInt(),
      total: (json[r'total'] as num?)?.toInt(),
      warningMessages: (json[r'warningMessages'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var issues = this.issues;
    var maxResults = this.maxResults;
    var names = this.names;
    var schema = this.schema;
    var startAt = this.startAt;
    var total = this.total;
    var warningMessages = this.warningMessages;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    json[r'issues'] = issues.map((i) => i.toJson()).toList();
    if (maxResults != null) {
      json[r'maxResults'] = maxResults;
    }
    if (names != null) {
      json[r'names'] = names;
    }
    if (schema != null) {
      json[r'schema'] = schema;
    }
    if (startAt != null) {
      json[r'startAt'] = startAt;
    }
    if (total != null) {
      json[r'total'] = total;
    }
    json[r'warningMessages'] = warningMessages;
    return json;
  }

  SearchResults copyWith(
      {String? expand,
      List<IssueBean>? issues,
      int? maxResults,
      Map<String, dynamic>? names,
      Map<String, dynamic>? schema,
      int? startAt,
      int? total,
      List<String>? warningMessages}) {
    return SearchResults(
      expand: expand ?? this.expand,
      issues: issues ?? this.issues,
      maxResults: maxResults ?? this.maxResults,
      names: names ?? this.names,
      schema: schema ?? this.schema,
      startAt: startAt ?? this.startAt,
      total: total ?? this.total,
      warningMessages: warningMessages ?? this.warningMessages,
    );
  }
}

/// Details of an issue level security item.
class SecurityLevel {
  /// The description of the issue level security item.
  final String? description;

  /// The ID of the issue level security item.
  final String? id;

  /// Whether the issue level security item is the default.
  final bool isDefault;

  /// The ID of the issue level security scheme.
  final String? issueSecuritySchemeId;

  /// The name of the issue level security item.
  final String? name;

  /// The URL of the issue level security item.
  final String? self;

  SecurityLevel(
      {this.description,
      this.id,
      bool? isDefault,
      this.issueSecuritySchemeId,
      this.name,
      this.self})
      : isDefault = isDefault ?? false;

  factory SecurityLevel.fromJson(Map<String, Object?> json) {
    return SecurityLevel(
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      isDefault: json[r'isDefault'] as bool? ?? false,
      issueSecuritySchemeId: json[r'issueSecuritySchemeId'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var isDefault = this.isDefault;
    var issueSecuritySchemeId = this.issueSecuritySchemeId;
    var name = this.name;
    var self = this.self;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'isDefault'] = isDefault;
    if (issueSecuritySchemeId != null) {
      json[r'issueSecuritySchemeId'] = issueSecuritySchemeId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  SecurityLevel copyWith(
      {String? description,
      String? id,
      bool? isDefault,
      String? issueSecuritySchemeId,
      String? name,
      String? self}) {
    return SecurityLevel(
      description: description ?? this.description,
      id: id ?? this.id,
      isDefault: isDefault ?? this.isDefault,
      issueSecuritySchemeId:
          issueSecuritySchemeId ?? this.issueSecuritySchemeId,
      name: name ?? this.name,
      self: self ?? this.self,
    );
  }
}

/// Issue security level member.
class SecurityLevelMember {
  /// The user or group being granted the permission. It consists of a `type`
  /// and a type-dependent `parameter`. See
  /// [Holder object](../api-group-permission-schemes/#holder-object) in *Get
  /// all permission schemes* for more information.
  final PermissionHolder holder;

  /// The ID of the issue security level member.
  final String id;

  /// The ID of the issue security level.
  final String issueSecurityLevelId;

  /// The ID of the issue security scheme.
  final String issueSecuritySchemeId;

  SecurityLevelMember(
      {required this.holder,
      required this.id,
      required this.issueSecurityLevelId,
      required this.issueSecuritySchemeId});

  factory SecurityLevelMember.fromJson(Map<String, Object?> json) {
    return SecurityLevelMember(
      holder: PermissionHolder.fromJson(
          json[r'holder'] as Map<String, Object?>? ?? const {}),
      id: json[r'id'] as String? ?? '',
      issueSecurityLevelId: json[r'issueSecurityLevelId'] as String? ?? '',
      issueSecuritySchemeId: json[r'issueSecuritySchemeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var holder = this.holder;
    var id = this.id;
    var issueSecurityLevelId = this.issueSecurityLevelId;
    var issueSecuritySchemeId = this.issueSecuritySchemeId;

    final json = <String, Object?>{};
    json[r'holder'] = holder.toJson();
    json[r'id'] = id;
    json[r'issueSecurityLevelId'] = issueSecurityLevelId;
    json[r'issueSecuritySchemeId'] = issueSecuritySchemeId;
    return json;
  }

  SecurityLevelMember copyWith(
      {PermissionHolder? holder,
      String? id,
      String? issueSecurityLevelId,
      String? issueSecuritySchemeId}) {
    return SecurityLevelMember(
      holder: holder ?? this.holder,
      id: id ?? this.id,
      issueSecurityLevelId: issueSecurityLevelId ?? this.issueSecurityLevelId,
      issueSecuritySchemeId:
          issueSecuritySchemeId ?? this.issueSecuritySchemeId,
    );
  }
}

/// Details about a security scheme.
class SecurityScheme {
  /// The ID of the default security level.
  final int? defaultSecurityLevelId;

  /// The description of the issue security scheme.
  final String? description;

  /// The ID of the issue security scheme.
  final int? id;
  final List<SecurityLevel> levels;

  /// The name of the issue security scheme.
  final String? name;

  /// The URL of the issue security scheme.
  final String? self;

  SecurityScheme(
      {this.defaultSecurityLevelId,
      this.description,
      this.id,
      List<SecurityLevel>? levels,
      this.name,
      this.self})
      : levels = levels ?? [];

  factory SecurityScheme.fromJson(Map<String, Object?> json) {
    return SecurityScheme(
      defaultSecurityLevelId:
          (json[r'defaultSecurityLevelId'] as num?)?.toInt(),
      description: json[r'description'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      levels: (json[r'levels'] as List<Object?>?)
              ?.map((i) => SecurityLevel.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var defaultSecurityLevelId = this.defaultSecurityLevelId;
    var description = this.description;
    var id = this.id;
    var levels = this.levels;
    var name = this.name;
    var self = this.self;

    final json = <String, Object?>{};
    if (defaultSecurityLevelId != null) {
      json[r'defaultSecurityLevelId'] = defaultSecurityLevelId;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'levels'] = levels.map((i) => i.toJson()).toList();
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  SecurityScheme copyWith(
      {int? defaultSecurityLevelId,
      String? description,
      int? id,
      List<SecurityLevel>? levels,
      String? name,
      String? self}) {
    return SecurityScheme(
      defaultSecurityLevelId:
          defaultSecurityLevelId ?? this.defaultSecurityLevelId,
      description: description ?? this.description,
      id: id ?? this.id,
      levels: levels ?? this.levels,
      name: name ?? this.name,
      self: self ?? this.self,
    );
  }
}

/// The ID of the issue security scheme.
class SecuritySchemeId {
  /// The ID of the issue security scheme.
  final String id;

  SecuritySchemeId({required this.id});

  factory SecuritySchemeId.fromJson(Map<String, Object?> json) {
    return SecuritySchemeId(
      id: json[r'id'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  SecuritySchemeId copyWith({String? id}) {
    return SecuritySchemeId(
      id: id ?? this.id,
    );
  }
}

class SecuritySchemeLevelBean {
  /// The description of the issue security scheme level.
  final String? description;

  /// Specifies whether the level is the default level. False by default.
  final bool isDefault;

  /// The list of level members which should be added to the issue security
  /// scheme level.
  final List<SecuritySchemeLevelMemberBean> members;

  /// The name of the issue security scheme level. Must be unique.
  final String name;

  SecuritySchemeLevelBean(
      {this.description,
      bool? isDefault,
      List<SecuritySchemeLevelMemberBean>? members,
      required this.name})
      : isDefault = isDefault ?? false,
        members = members ?? [];

  factory SecuritySchemeLevelBean.fromJson(Map<String, Object?> json) {
    return SecuritySchemeLevelBean(
      description: json[r'description'] as String?,
      isDefault: json[r'isDefault'] as bool? ?? false,
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) => SecuritySchemeLevelMemberBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var isDefault = this.isDefault;
    var members = this.members;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'isDefault'] = isDefault;
    json[r'members'] = members.map((i) => i.toJson()).toList();
    json[r'name'] = name;
    return json;
  }

  SecuritySchemeLevelBean copyWith(
      {String? description,
      bool? isDefault,
      List<SecuritySchemeLevelMemberBean>? members,
      String? name}) {
    return SecuritySchemeLevelBean(
      description: description ?? this.description,
      isDefault: isDefault ?? this.isDefault,
      members: members ?? this.members,
      name: name ?? this.name,
    );
  }
}

class SecuritySchemeLevelMemberBean {
  /// The value corresponding to the specified member type.
  final String? parameter;

  /// The issue security level member type, e.g `reporter`, `group`, `user`.
  final String type;

  SecuritySchemeLevelMemberBean({this.parameter, required this.type});

  factory SecuritySchemeLevelMemberBean.fromJson(Map<String, Object?> json) {
    return SecuritySchemeLevelMemberBean(
      parameter: json[r'parameter'] as String?,
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var parameter = this.parameter;
    var type = this.type;

    final json = <String, Object?>{};
    if (parameter != null) {
      json[r'parameter'] = parameter;
    }
    json[r'type'] = type;
    return json;
  }

  SecuritySchemeLevelMemberBean copyWith({String? parameter, String? type}) {
    return SecuritySchemeLevelMemberBean(
      parameter: parameter ?? this.parameter,
      type: type ?? this.type,
    );
  }
}

/// Details of issue security scheme level new members.
class SecuritySchemeMembersRequest {
  /// The list of level members which should be added to the issue security
  /// scheme level.
  final List<SecuritySchemeLevelMemberBean> members;

  SecuritySchemeMembersRequest({List<SecuritySchemeLevelMemberBean>? members})
      : members = members ?? [];

  factory SecuritySchemeMembersRequest.fromJson(Map<String, Object?> json) {
    return SecuritySchemeMembersRequest(
      members: (json[r'members'] as List<Object?>?)
              ?.map((i) => SecuritySchemeLevelMemberBean.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var members = this.members;

    final json = <String, Object?>{};
    json[r'members'] = members.map((i) => i.toJson()).toList();
    return json;
  }

  SecuritySchemeMembersRequest copyWith(
      {List<SecuritySchemeLevelMemberBean>? members}) {
    return SecuritySchemeMembersRequest(
      members: members ?? this.members,
    );
  }
}

/// Details about an issue security scheme.
class SecuritySchemeWithProjects {
  /// The default level ID of the issue security scheme.
  final int? defaultLevel;

  /// The description of the issue security scheme.
  final String? description;

  /// The ID of the issue security scheme.
  final int id;

  /// The name of the issue security scheme.
  final String name;

  /// The list of project IDs associated with the issue security scheme.
  final List<int> projectIds;

  /// The URL of the issue security scheme.
  final String self;

  SecuritySchemeWithProjects(
      {this.defaultLevel,
      this.description,
      required this.id,
      required this.name,
      List<int>? projectIds,
      required this.self})
      : projectIds = projectIds ?? [];

  factory SecuritySchemeWithProjects.fromJson(Map<String, Object?> json) {
    return SecuritySchemeWithProjects(
      defaultLevel: (json[r'defaultLevel'] as num?)?.toInt(),
      description: json[r'description'] as String?,
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      name: json[r'name'] as String? ?? '',
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      self: json[r'self'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var defaultLevel = this.defaultLevel;
    var description = this.description;
    var id = this.id;
    var name = this.name;
    var projectIds = this.projectIds;
    var self = this.self;

    final json = <String, Object?>{};
    if (defaultLevel != null) {
      json[r'defaultLevel'] = defaultLevel;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'id'] = id;
    json[r'name'] = name;
    json[r'projectIds'] = projectIds;
    json[r'self'] = self;
    return json;
  }

  SecuritySchemeWithProjects copyWith(
      {int? defaultLevel,
      String? description,
      int? id,
      String? name,
      List<int>? projectIds,
      String? self}) {
    return SecuritySchemeWithProjects(
      defaultLevel: defaultLevel ?? this.defaultLevel,
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
      projectIds: projectIds ?? this.projectIds,
      self: self ?? this.self,
    );
  }
}

/// List of security schemes.
class SecuritySchemes {
  /// List of security schemes.
  final List<SecurityScheme> issueSecuritySchemes;

  SecuritySchemes({List<SecurityScheme>? issueSecuritySchemes})
      : issueSecuritySchemes = issueSecuritySchemes ?? [];

  factory SecuritySchemes.fromJson(Map<String, Object?> json) {
    return SecuritySchemes(
      issueSecuritySchemes: (json[r'issueSecuritySchemes'] as List<Object?>?)
              ?.map((i) => SecurityScheme.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var issueSecuritySchemes = this.issueSecuritySchemes;

    final json = <String, Object?>{};
    json[r'issueSecuritySchemes'] =
        issueSecuritySchemes.map((i) => i.toJson()).toList();
    return json;
  }

  SecuritySchemes copyWith({List<SecurityScheme>? issueSecuritySchemes}) {
    return SecuritySchemes(
      issueSecuritySchemes: issueSecuritySchemes ?? this.issueSecuritySchemes,
    );
  }
}

/// Details about the Jira instance.
class ServerInformation {
  /// The base URL of the Jira instance.
  final String? baseUrl;

  /// The timestamp when the Jira version was built.
  final DateTime? buildDate;

  /// The build number of the Jira version.
  final int? buildNumber;

  /// The type of server deployment. This is always returned as *Cloud*.
  final String? deploymentType;

  /// Jira instance health check results. Deprecated and no longer returned.
  final List<HealthCheckResult> healthChecks;

  /// The unique identifier of the Jira version.
  final String? scmInfo;

  /// The time in Jira when this request was responded to.
  final DateTime? serverTime;

  /// The name of the Jira instance.
  final String? serverTitle;

  /// The version of Jira.
  final String? version;

  /// The major, minor, and revision version numbers of the Jira version.
  final List<int> versionNumbers;

  ServerInformation(
      {this.baseUrl,
      this.buildDate,
      this.buildNumber,
      this.deploymentType,
      List<HealthCheckResult>? healthChecks,
      this.scmInfo,
      this.serverTime,
      this.serverTitle,
      this.version,
      List<int>? versionNumbers})
      : healthChecks = healthChecks ?? [],
        versionNumbers = versionNumbers ?? [];

  factory ServerInformation.fromJson(Map<String, Object?> json) {
    return ServerInformation(
      baseUrl: json[r'baseUrl'] as String?,
      buildDate: DateTime.tryParse(json[r'buildDate'] as String? ?? ''),
      buildNumber: (json[r'buildNumber'] as num?)?.toInt(),
      deploymentType: json[r'deploymentType'] as String?,
      healthChecks: (json[r'healthChecks'] as List<Object?>?)
              ?.map((i) => HealthCheckResult.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      scmInfo: json[r'scmInfo'] as String?,
      serverTime: DateTime.tryParse(json[r'serverTime'] as String? ?? ''),
      serverTitle: json[r'serverTitle'] as String?,
      version: json[r'version'] as String?,
      versionNumbers: (json[r'versionNumbers'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var baseUrl = this.baseUrl;
    var buildDate = this.buildDate;
    var buildNumber = this.buildNumber;
    var deploymentType = this.deploymentType;
    var healthChecks = this.healthChecks;
    var scmInfo = this.scmInfo;
    var serverTime = this.serverTime;
    var serverTitle = this.serverTitle;
    var version = this.version;
    var versionNumbers = this.versionNumbers;

    final json = <String, Object?>{};
    if (baseUrl != null) {
      json[r'baseUrl'] = baseUrl;
    }
    if (buildDate != null) {
      json[r'buildDate'] = buildDate.toIso8601String();
    }
    if (buildNumber != null) {
      json[r'buildNumber'] = buildNumber;
    }
    if (deploymentType != null) {
      json[r'deploymentType'] = deploymentType;
    }
    json[r'healthChecks'] = healthChecks.map((i) => i.toJson()).toList();
    if (scmInfo != null) {
      json[r'scmInfo'] = scmInfo;
    }
    if (serverTime != null) {
      json[r'serverTime'] = serverTime.toIso8601String();
    }
    if (serverTitle != null) {
      json[r'serverTitle'] = serverTitle;
    }
    if (version != null) {
      json[r'version'] = version;
    }
    json[r'versionNumbers'] = versionNumbers;
    return json;
  }

  ServerInformation copyWith(
      {String? baseUrl,
      DateTime? buildDate,
      int? buildNumber,
      String? deploymentType,
      List<HealthCheckResult>? healthChecks,
      String? scmInfo,
      DateTime? serverTime,
      String? serverTitle,
      String? version,
      List<int>? versionNumbers}) {
    return ServerInformation(
      baseUrl: baseUrl ?? this.baseUrl,
      buildDate: buildDate ?? this.buildDate,
      buildNumber: buildNumber ?? this.buildNumber,
      deploymentType: deploymentType ?? this.deploymentType,
      healthChecks: healthChecks ?? this.healthChecks,
      scmInfo: scmInfo ?? this.scmInfo,
      serverTime: serverTime ?? this.serverTime,
      serverTitle: serverTitle ?? this.serverTitle,
      version: version ?? this.version,
      versionNumbers: versionNumbers ?? this.versionNumbers,
    );
  }
}

class ServiceManagementNavigationInfo {
  final String? queueCategory;
  final int? queueId;
  final String? queueName;

  ServiceManagementNavigationInfo(
      {this.queueCategory, this.queueId, this.queueName});

  factory ServiceManagementNavigationInfo.fromJson(Map<String, Object?> json) {
    return ServiceManagementNavigationInfo(
      queueCategory: json[r'queueCategory'] as String?,
      queueId: (json[r'queueId'] as num?)?.toInt(),
      queueName: json[r'queueName'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var queueCategory = this.queueCategory;
    var queueId = this.queueId;
    var queueName = this.queueName;

    final json = <String, Object?>{};
    if (queueCategory != null) {
      json[r'queueCategory'] = queueCategory;
    }
    if (queueId != null) {
      json[r'queueId'] = queueId;
    }
    if (queueName != null) {
      json[r'queueName'] = queueName;
    }
    return json;
  }

  ServiceManagementNavigationInfo copyWith(
      {String? queueCategory, int? queueId, String? queueName}) {
    return ServiceManagementNavigationInfo(
      queueCategory: queueCategory ?? this.queueCategory,
      queueId: queueId ?? this.queueId,
      queueName: queueName ?? this.queueName,
    );
  }
}

/// Details of new default levels.
class SetDefaultLevelsRequest {
  /// List of objects with issue security scheme ID and new default level ID.
  final List<DefaultLevelValue> defaultValues;

  SetDefaultLevelsRequest({required this.defaultValues});

  factory SetDefaultLevelsRequest.fromJson(Map<String, Object?> json) {
    return SetDefaultLevelsRequest(
      defaultValues: (json[r'defaultValues'] as List<Object?>?)
              ?.map((i) => DefaultLevelValue.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var defaultValues = this.defaultValues;

    final json = <String, Object?>{};
    json[r'defaultValues'] = defaultValues.map((i) => i.toJson()).toList();
    return json;
  }

  SetDefaultLevelsRequest copyWith({List<DefaultLevelValue>? defaultValues}) {
    return SetDefaultLevelsRequest(
      defaultValues: defaultValues ?? this.defaultValues,
    );
  }
}

/// The new default issue priority.
class SetDefaultPriorityRequest {
  /// The ID of the new default issue priority. Must be an existing ID or null.
  /// Setting this to null erases the default priority setting.
  final String id;

  SetDefaultPriorityRequest({required this.id});

  factory SetDefaultPriorityRequest.fromJson(Map<String, Object?> json) {
    return SetDefaultPriorityRequest(
      id: json[r'id'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  SetDefaultPriorityRequest copyWith({String? id}) {
    return SetDefaultPriorityRequest(
      id: id ?? this.id,
    );
  }
}

/// The new default issue resolution.
class SetDefaultResolutionRequest {
  /// The ID of the new default issue resolution. Must be an existing ID or
  /// null. Setting this to null erases the default resolution setting.
  final String id;

  SetDefaultResolutionRequest({required this.id});

  factory SetDefaultResolutionRequest.fromJson(Map<String, Object?> json) {
    return SetDefaultResolutionRequest(
      id: json[r'id'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;

    final json = <String, Object?>{};
    json[r'id'] = id;
    return json;
  }

  SetDefaultResolutionRequest copyWith({String? id}) {
    return SetDefaultResolutionRequest(
      id: id ?? this.id,
    );
  }
}

/// Details of a share permission for the filter.
class SharePermission {
  /// The group that the filter is shared with. For a request, specify the
  /// `groupId` or `name` property for the group. As a group's name can change,
  /// use of `groupId` is recommended.
  final GroupName? group;

  /// The unique identifier of the share permission.
  final int? id;

  /// The project that the filter is shared with. This is similar to the project
  /// object returned by
  /// [Get project](#api-rest-api-3-project-projectIdOrKey-get) but it contains
  /// a subset of the properties, which are: `self`, `id`, `key`,
  /// `assigneeType`, `name`, `roles`, `avatarUrls`, `projectType`,
  /// `simplified`.
  /// For a request, specify the `id` for the project.
  final Project? project;

  /// The project role that the filter is shared with.
  /// For a request, specify the `id` for the role. You must also specify the
  /// `project` object and `id` for the project that the role is in.
  final ProjectRole? role;

  /// The type of share permission:
  ///
  ///  *  `user` Shared with a user.
  ///  *  `group` Shared with a group. If set in a request, then specify
  /// `sharePermission.group` as well.
  ///  *  `project` Shared with a project. If set in a request, then specify
  /// `sharePermission.project` as well.
  ///  *  `projectRole` Share with a project role in a project. This value is
  /// not returned in responses. It is used in requests, where it needs to be
  /// specify with `projectId` and `projectRoleId`.
  ///  *  `global` Shared globally. If set in a request, no other
  /// `sharePermission` properties need to be specified.
  ///  *  `loggedin` Shared with all logged-in users. Note: This value is set in
  /// a request by specifying `authenticated` as the `type`.
  ///  *  `project-unknown` Shared with a project that the user does not have
  /// access to. Cannot be set in a request.
  final SharePermissionType type;

  /// The user account ID that the filter is shared with. For a request, specify
  /// the `accountId` property for the user.
  final UserBean? user;

  SharePermission(
      {this.group,
      this.id,
      this.project,
      this.role,
      required this.type,
      this.user});

  factory SharePermission.fromJson(Map<String, Object?> json) {
    return SharePermission(
      group: json[r'group'] != null
          ? GroupName.fromJson(json[r'group']! as Map<String, Object?>)
          : null,
      id: (json[r'id'] as num?)?.toInt(),
      project: json[r'project'] != null
          ? Project.fromJson(json[r'project']! as Map<String, Object?>)
          : null,
      role: json[r'role'] != null
          ? ProjectRole.fromJson(json[r'role']! as Map<String, Object?>)
          : null,
      type: SharePermissionType.fromValue(json[r'type'] as String? ?? ''),
      user: json[r'user'] != null
          ? UserBean.fromJson(json[r'user']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var group = this.group;
    var id = this.id;
    var project = this.project;
    var role = this.role;
    var type = this.type;
    var user = this.user;

    final json = <String, Object?>{};
    if (group != null) {
      json[r'group'] = group.toJson();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (project != null) {
      json[r'project'] = project.toJson();
    }
    if (role != null) {
      json[r'role'] = role.toJson();
    }
    json[r'type'] = type.value;
    if (user != null) {
      json[r'user'] = user.toJson();
    }
    return json;
  }

  SharePermission copyWith(
      {GroupName? group,
      int? id,
      Project? project,
      ProjectRole? role,
      SharePermissionType? type,
      UserBean? user}) {
    return SharePermission(
      group: group ?? this.group,
      id: id ?? this.id,
      project: project ?? this.project,
      role: role ?? this.role,
      type: type ?? this.type,
      user: user ?? this.user,
    );
  }
}

class SharePermissionType {
  static const user = SharePermissionType._('user');
  static const group = SharePermissionType._('group');
  static const project = SharePermissionType._('project');
  static const projectRole = SharePermissionType._('projectRole');
  static const global = SharePermissionType._('global');
  static const loggedin = SharePermissionType._('loggedin');
  static const authenticated = SharePermissionType._('authenticated');
  static const projectUnknown = SharePermissionType._('project-unknown');

  static const values = [
    user,
    group,
    project,
    projectRole,
    global,
    loggedin,
    authenticated,
    projectUnknown,
  ];
  final String value;

  const SharePermissionType._(this.value);

  static SharePermissionType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => SharePermissionType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class SharePermissionInputBean {
  /// The user account ID that the filter is shared with. For a request, specify
  /// the `accountId` property for the user.
  final String? accountId;

  /// The ID of the group, which uniquely identifies the group across all
  /// Atlassian products.For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.
  /// Cannot be provided with `groupname`.
  final String? groupId;

  /// The name of the group to share the filter with. Set `type` to `group`.
  /// Please note that the name of a group is mutable, to reliably identify a
  /// group use `groupId`.
  final String? groupname;

  /// The ID of the project to share the filter with. Set `type` to `project`.
  final String? projectId;

  /// The ID of the project role to share the filter with. Set `type` to
  /// `projectRole` and the `projectId` for the project that the role is in.
  final String? projectRoleId;

  /// The rights for the share permission.
  final int? rights;

  /// The type of the share permission.Specify the type as follows:
  ///
  ///  *  `user` Share with a user.
  ///  *  `group` Share with a group. Specify `groupname` as well.
  ///  *  `project` Share with a project. Specify `projectId` as well.
  ///  *  `projectRole` Share with a project role in a project. Specify
  /// `projectId` and `projectRoleId` as well.
  ///  *  `global` Share globally, including anonymous users. If set, this type
  /// overrides all existing share permissions and must be deleted before any
  /// non-global share permissions is set.
  ///  *  `authenticated` Share with all logged-in users. This shows as
  /// `loggedin` in the response. If set, this type overrides all existing share
  /// permissions and must be deleted before any non-global share permissions is
  /// set.
  final SharePermissionInputBeanType type;

  SharePermissionInputBean(
      {this.accountId,
      this.groupId,
      this.groupname,
      this.projectId,
      this.projectRoleId,
      this.rights,
      required this.type});

  factory SharePermissionInputBean.fromJson(Map<String, Object?> json) {
    return SharePermissionInputBean(
      accountId: json[r'accountId'] as String?,
      groupId: json[r'groupId'] as String?,
      groupname: json[r'groupname'] as String?,
      projectId: json[r'projectId'] as String?,
      projectRoleId: json[r'projectRoleId'] as String?,
      rights: (json[r'rights'] as num?)?.toInt(),
      type: SharePermissionInputBeanType.fromValue(
          json[r'type'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var groupId = this.groupId;
    var groupname = this.groupname;
    var projectId = this.projectId;
    var projectRoleId = this.projectRoleId;
    var rights = this.rights;
    var type = this.type;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (groupId != null) {
      json[r'groupId'] = groupId;
    }
    if (groupname != null) {
      json[r'groupname'] = groupname;
    }
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    if (projectRoleId != null) {
      json[r'projectRoleId'] = projectRoleId;
    }
    if (rights != null) {
      json[r'rights'] = rights;
    }
    json[r'type'] = type.value;
    return json;
  }

  SharePermissionInputBean copyWith(
      {String? accountId,
      String? groupId,
      String? groupname,
      String? projectId,
      String? projectRoleId,
      int? rights,
      SharePermissionInputBeanType? type}) {
    return SharePermissionInputBean(
      accountId: accountId ?? this.accountId,
      groupId: groupId ?? this.groupId,
      groupname: groupname ?? this.groupname,
      projectId: projectId ?? this.projectId,
      projectRoleId: projectRoleId ?? this.projectRoleId,
      rights: rights ?? this.rights,
      type: type ?? this.type,
    );
  }
}

class SharePermissionInputBeanType {
  static const user = SharePermissionInputBeanType._('user');
  static const project = SharePermissionInputBeanType._('project');
  static const group = SharePermissionInputBeanType._('group');
  static const projectRole = SharePermissionInputBeanType._('projectRole');
  static const global = SharePermissionInputBeanType._('global');
  static const authenticated = SharePermissionInputBeanType._('authenticated');

  static const values = [
    user,
    project,
    group,
    projectRole,
    global,
    authenticated,
  ];
  final String value;

  const SharePermissionInputBeanType._(this.value);

  static SharePermissionInputBeanType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => SharePermissionInputBeanType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class SimpleApplicationPropertyBean {
  /// The ID of the application property.
  final String? id;

  /// The new value.
  final String? value;

  SimpleApplicationPropertyBean({this.id, this.value});

  factory SimpleApplicationPropertyBean.fromJson(Map<String, Object?> json) {
    return SimpleApplicationPropertyBean(
      id: json[r'id'] as String?,
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var value = this.value;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  SimpleApplicationPropertyBean copyWith({String? id, String? value}) {
    return SimpleApplicationPropertyBean(
      id: id ?? this.id,
      value: value ?? this.value,
    );
  }
}

class SimpleErrorCollection {
  /// The list of error messages produced by this operation. For example, "input
  /// parameter 'key' must be provided"
  final List<String> errorMessages;

  /// The list of errors by parameter returned by the operation. For
  /// example,"projectKey": "Project keys must start with an uppercase letter,
  /// followed by one or more uppercase alphanumeric characters."
  final Map<String, dynamic>? errors;
  final int? httpStatusCode;

  SimpleErrorCollection(
      {List<String>? errorMessages, this.errors, this.httpStatusCode})
      : errorMessages = errorMessages ?? [];

  factory SimpleErrorCollection.fromJson(Map<String, Object?> json) {
    return SimpleErrorCollection(
      errorMessages: (json[r'errorMessages'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      errors: json[r'errors'] as Map<String, Object?>?,
      httpStatusCode: (json[r'httpStatusCode'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var errorMessages = this.errorMessages;
    var errors = this.errors;
    var httpStatusCode = this.httpStatusCode;

    final json = <String, Object?>{};
    json[r'errorMessages'] = errorMessages;
    if (errors != null) {
      json[r'errors'] = errors;
    }
    if (httpStatusCode != null) {
      json[r'httpStatusCode'] = httpStatusCode;
    }
    return json;
  }

  SimpleErrorCollection copyWith(
      {List<String>? errorMessages,
      Map<String, dynamic>? errors,
      int? httpStatusCode}) {
    return SimpleErrorCollection(
      errorMessages: errorMessages ?? this.errorMessages,
      errors: errors ?? this.errors,
      httpStatusCode: httpStatusCode ?? this.httpStatusCode,
    );
  }
}

/// Details about the operations available in this version.
class SimpleLink {
  final String? href;
  final String? iconClass;
  final String? id;
  final String? label;
  final String? styleClass;
  final String? title;
  final int? weight;

  SimpleLink(
      {this.href,
      this.iconClass,
      this.id,
      this.label,
      this.styleClass,
      this.title,
      this.weight});

  factory SimpleLink.fromJson(Map<String, Object?> json) {
    return SimpleLink(
      href: json[r'href'] as String?,
      iconClass: json[r'iconClass'] as String?,
      id: json[r'id'] as String?,
      label: json[r'label'] as String?,
      styleClass: json[r'styleClass'] as String?,
      title: json[r'title'] as String?,
      weight: (json[r'weight'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var href = this.href;
    var iconClass = this.iconClass;
    var id = this.id;
    var label = this.label;
    var styleClass = this.styleClass;
    var title = this.title;
    var weight = this.weight;

    final json = <String, Object?>{};
    if (href != null) {
      json[r'href'] = href;
    }
    if (iconClass != null) {
      json[r'iconClass'] = iconClass;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (label != null) {
      json[r'label'] = label;
    }
    if (styleClass != null) {
      json[r'styleClass'] = styleClass;
    }
    if (title != null) {
      json[r'title'] = title;
    }
    if (weight != null) {
      json[r'weight'] = weight;
    }
    return json;
  }

  SimpleLink copyWith(
      {String? href,
      String? iconClass,
      String? id,
      String? label,
      String? styleClass,
      String? title,
      int? weight}) {
    return SimpleLink(
      href: href ?? this.href,
      iconClass: iconClass ?? this.iconClass,
      id: id ?? this.id,
      label: label ?? this.label,
      styleClass: styleClass ?? this.styleClass,
      title: title ?? this.title,
      weight: weight ?? this.weight,
    );
  }
}

class SimpleListWrapperApplicationRole {
  final ListWrapperCallbackApplicationRole? callback;
  final List<ApplicationRole> items;
  final int? maxResults;
  final ListWrapperCallbackApplicationRole? pagingCallback;
  final int? size;

  SimpleListWrapperApplicationRole(
      {this.callback,
      List<ApplicationRole>? items,
      this.maxResults,
      this.pagingCallback,
      this.size})
      : items = items ?? [];

  factory SimpleListWrapperApplicationRole.fromJson(Map<String, Object?> json) {
    return SimpleListWrapperApplicationRole(
      callback: json[r'callback'] != null
          ? ListWrapperCallbackApplicationRole.fromJson(
              json[r'callback']! as Map<String, Object?>)
          : null,
      items: (json[r'items'] as List<Object?>?)
              ?.map((i) => ApplicationRole.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'max-results'] as num?)?.toInt(),
      pagingCallback: json[r'pagingCallback'] != null
          ? ListWrapperCallbackApplicationRole.fromJson(
              json[r'pagingCallback']! as Map<String, Object?>)
          : null,
      size: (json[r'size'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var callback = this.callback;
    var items = this.items;
    var maxResults = this.maxResults;
    var pagingCallback = this.pagingCallback;
    var size = this.size;

    final json = <String, Object?>{};
    if (callback != null) {
      json[r'callback'] = callback.toJson();
    }
    json[r'items'] = items.map((i) => i.toJson()).toList();
    if (maxResults != null) {
      json[r'max-results'] = maxResults;
    }
    if (pagingCallback != null) {
      json[r'pagingCallback'] = pagingCallback.toJson();
    }
    if (size != null) {
      json[r'size'] = size;
    }
    return json;
  }

  SimpleListWrapperApplicationRole copyWith(
      {ListWrapperCallbackApplicationRole? callback,
      List<ApplicationRole>? items,
      int? maxResults,
      ListWrapperCallbackApplicationRole? pagingCallback,
      int? size}) {
    return SimpleListWrapperApplicationRole(
      callback: callback ?? this.callback,
      items: items ?? this.items,
      maxResults: maxResults ?? this.maxResults,
      pagingCallback: pagingCallback ?? this.pagingCallback,
      size: size ?? this.size,
    );
  }
}

class SimpleListWrapperGroupName {
  final ListWrapperCallbackGroupName? callback;
  final List<GroupName> items;
  final int? maxResults;
  final ListWrapperCallbackGroupName? pagingCallback;
  final int? size;

  SimpleListWrapperGroupName(
      {this.callback,
      List<GroupName>? items,
      this.maxResults,
      this.pagingCallback,
      this.size})
      : items = items ?? [];

  factory SimpleListWrapperGroupName.fromJson(Map<String, Object?> json) {
    return SimpleListWrapperGroupName(
      callback: json[r'callback'] != null
          ? ListWrapperCallbackGroupName.fromJson(
              json[r'callback']! as Map<String, Object?>)
          : null,
      items: (json[r'items'] as List<Object?>?)
              ?.map((i) =>
                  GroupName.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'max-results'] as num?)?.toInt(),
      pagingCallback: json[r'pagingCallback'] != null
          ? ListWrapperCallbackGroupName.fromJson(
              json[r'pagingCallback']! as Map<String, Object?>)
          : null,
      size: (json[r'size'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var callback = this.callback;
    var items = this.items;
    var maxResults = this.maxResults;
    var pagingCallback = this.pagingCallback;
    var size = this.size;

    final json = <String, Object?>{};
    if (callback != null) {
      json[r'callback'] = callback.toJson();
    }
    json[r'items'] = items.map((i) => i.toJson()).toList();
    if (maxResults != null) {
      json[r'max-results'] = maxResults;
    }
    if (pagingCallback != null) {
      json[r'pagingCallback'] = pagingCallback.toJson();
    }
    if (size != null) {
      json[r'size'] = size;
    }
    return json;
  }

  SimpleListWrapperGroupName copyWith(
      {ListWrapperCallbackGroupName? callback,
      List<GroupName>? items,
      int? maxResults,
      ListWrapperCallbackGroupName? pagingCallback,
      int? size}) {
    return SimpleListWrapperGroupName(
      callback: callback ?? this.callback,
      items: items ?? this.items,
      maxResults: maxResults ?? this.maxResults,
      pagingCallback: pagingCallback ?? this.pagingCallback,
      size: size ?? this.size,
    );
  }
}

class SimplifiedHierarchyLevel {
  /// The ID of the level above this one in the hierarchy. This property is
  /// deprecated, see
  /// [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final int? aboveLevelId;

  /// The ID of the level below this one in the hierarchy. This property is
  /// deprecated, see
  /// [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final int? belowLevelId;

  /// The external UUID of the hierarchy level. This property is deprecated, see
  /// [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final String? externalUuid;
  final int? hierarchyLevelNumber;

  /// The ID of the hierarchy level. This property is deprecated, see
  /// [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final int? id;

  /// The issue types available in this hierarchy level.
  final List<int> issueTypeIds;

  /// The level of this item in the hierarchy.
  final int? level;

  /// The name of this hierarchy level.
  final String? name;

  /// The ID of the project configuration. This property is deprecated, see
  /// [Change oticen: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).
  final int? projectConfigurationId;

  SimplifiedHierarchyLevel(
      {this.aboveLevelId,
      this.belowLevelId,
      this.externalUuid,
      this.hierarchyLevelNumber,
      this.id,
      List<int>? issueTypeIds,
      this.level,
      this.name,
      this.projectConfigurationId})
      : issueTypeIds = issueTypeIds ?? [];

  factory SimplifiedHierarchyLevel.fromJson(Map<String, Object?> json) {
    return SimplifiedHierarchyLevel(
      aboveLevelId: (json[r'aboveLevelId'] as num?)?.toInt(),
      belowLevelId: (json[r'belowLevelId'] as num?)?.toInt(),
      externalUuid: json[r'externalUuid'] as String?,
      hierarchyLevelNumber: (json[r'hierarchyLevelNumber'] as num?)?.toInt(),
      id: (json[r'id'] as num?)?.toInt(),
      issueTypeIds: (json[r'issueTypeIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
      level: (json[r'level'] as num?)?.toInt(),
      name: json[r'name'] as String?,
      projectConfigurationId:
          (json[r'projectConfigurationId'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var aboveLevelId = this.aboveLevelId;
    var belowLevelId = this.belowLevelId;
    var externalUuid = this.externalUuid;
    var hierarchyLevelNumber = this.hierarchyLevelNumber;
    var id = this.id;
    var issueTypeIds = this.issueTypeIds;
    var level = this.level;
    var name = this.name;
    var projectConfigurationId = this.projectConfigurationId;

    final json = <String, Object?>{};
    if (aboveLevelId != null) {
      json[r'aboveLevelId'] = aboveLevelId;
    }
    if (belowLevelId != null) {
      json[r'belowLevelId'] = belowLevelId;
    }
    if (externalUuid != null) {
      json[r'externalUuid'] = externalUuid;
    }
    if (hierarchyLevelNumber != null) {
      json[r'hierarchyLevelNumber'] = hierarchyLevelNumber;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'issueTypeIds'] = issueTypeIds;
    if (level != null) {
      json[r'level'] = level;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (projectConfigurationId != null) {
      json[r'projectConfigurationId'] = projectConfigurationId;
    }
    return json;
  }

  SimplifiedHierarchyLevel copyWith(
      {int? aboveLevelId,
      int? belowLevelId,
      String? externalUuid,
      int? hierarchyLevelNumber,
      int? id,
      List<int>? issueTypeIds,
      int? level,
      String? name,
      int? projectConfigurationId}) {
    return SimplifiedHierarchyLevel(
      aboveLevelId: aboveLevelId ?? this.aboveLevelId,
      belowLevelId: belowLevelId ?? this.belowLevelId,
      externalUuid: externalUuid ?? this.externalUuid,
      hierarchyLevelNumber: hierarchyLevelNumber ?? this.hierarchyLevelNumber,
      id: id ?? this.id,
      issueTypeIds: issueTypeIds ?? this.issueTypeIds,
      level: level ?? this.level,
      name: name ?? this.name,
      projectConfigurationId:
          projectConfigurationId ?? this.projectConfigurationId,
    );
  }
}

class SoftwareNavigationInfo {
  final int? boardId;
  final String? boardName;
  final bool simpleBoard;
  final int? totalBoardsInProject;

  SoftwareNavigationInfo(
      {this.boardId,
      this.boardName,
      bool? simpleBoard,
      this.totalBoardsInProject})
      : simpleBoard = simpleBoard ?? false;

  factory SoftwareNavigationInfo.fromJson(Map<String, Object?> json) {
    return SoftwareNavigationInfo(
      boardId: (json[r'boardId'] as num?)?.toInt(),
      boardName: json[r'boardName'] as String?,
      simpleBoard: json[r'simpleBoard'] as bool? ?? false,
      totalBoardsInProject: (json[r'totalBoardsInProject'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var boardId = this.boardId;
    var boardName = this.boardName;
    var simpleBoard = this.simpleBoard;
    var totalBoardsInProject = this.totalBoardsInProject;

    final json = <String, Object?>{};
    if (boardId != null) {
      json[r'boardId'] = boardId;
    }
    if (boardName != null) {
      json[r'boardName'] = boardName;
    }
    json[r'simpleBoard'] = simpleBoard;
    if (totalBoardsInProject != null) {
      json[r'totalBoardsInProject'] = totalBoardsInProject;
    }
    return json;
  }

  SoftwareNavigationInfo copyWith(
      {int? boardId,
      String? boardName,
      bool? simpleBoard,
      int? totalBoardsInProject}) {
    return SoftwareNavigationInfo(
      boardId: boardId ?? this.boardId,
      boardName: boardName ?? this.boardName,
      simpleBoard: simpleBoard ?? this.simpleBoard,
      totalBoardsInProject: totalBoardsInProject ?? this.totalBoardsInProject,
    );
  }
}

/// The status of the item.
class Status {
  /// Details of the icon representing the status. If not provided, no status
  /// icon displays in Jira.
  final Icon? icon;

  /// Whether the item is resolved. If set to "true", the link to the issue is
  /// displayed in a strikethrough font, otherwise the link displays in normal
  /// font.
  final bool resolved;

  Status({this.icon, bool? resolved}) : resolved = resolved ?? false;

  factory Status.fromJson(Map<String, Object?> json) {
    return Status(
      icon: json[r'icon'] != null
          ? Icon.fromJson(json[r'icon']! as Map<String, Object?>)
          : null,
      resolved: json[r'resolved'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var icon = this.icon;
    var resolved = this.resolved;

    final json = <String, Object?>{};
    if (icon != null) {
      json[r'icon'] = icon.toJson();
    }
    json[r'resolved'] = resolved;
    return json;
  }

  Status copyWith({Icon? icon, bool? resolved}) {
    return Status(
      icon: icon ?? this.icon,
      resolved: resolved ?? this.resolved,
    );
  }
}

/// A status category.
class StatusCategory {
  /// The name of the color used to represent the status category.
  final String? colorName;

  /// The ID of the status category.
  final int? id;

  /// The key of the status category.
  final String? key;

  /// The name of the status category.
  final String? name;

  /// The URL of the status category.
  final String? self;

  StatusCategory({this.colorName, this.id, this.key, this.name, this.self});

  factory StatusCategory.fromJson(Map<String, Object?> json) {
    return StatusCategory(
      colorName: json[r'colorName'] as String?,
      id: (json[r'id'] as num?)?.toInt(),
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var colorName = this.colorName;
    var id = this.id;
    var key = this.key;
    var name = this.name;
    var self = this.self;

    final json = <String, Object?>{};
    if (colorName != null) {
      json[r'colorName'] = colorName;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  StatusCategory copyWith(
      {String? colorName, int? id, String? key, String? name, String? self}) {
    return StatusCategory(
      colorName: colorName ?? this.colorName,
      id: id ?? this.id,
      key: key ?? this.key,
      name: name ?? this.name,
      self: self ?? this.self,
    );
  }
}

/// Details of the status being created.
class StatusCreate {
  /// The description of the status.
  final String? description;

  /// The name of the status.
  final String name;

  /// The category of the status.
  final StatusCreateStatusCategory statusCategory;

  StatusCreate(
      {this.description, required this.name, required this.statusCategory});

  factory StatusCreate.fromJson(Map<String, Object?> json) {
    return StatusCreate(
      description: json[r'description'] as String?,
      name: json[r'name'] as String? ?? '',
      statusCategory: StatusCreateStatusCategory.fromValue(
          json[r'statusCategory'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;
    var statusCategory = this.statusCategory;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'name'] = name;
    json[r'statusCategory'] = statusCategory.value;
    return json;
  }

  StatusCreate copyWith(
      {String? description,
      String? name,
      StatusCreateStatusCategory? statusCategory}) {
    return StatusCreate(
      description: description ?? this.description,
      name: name ?? this.name,
      statusCategory: statusCategory ?? this.statusCategory,
    );
  }
}

class StatusCreateStatusCategory {
  static const todo = StatusCreateStatusCategory._('TODO');
  static const inProgress = StatusCreateStatusCategory._('IN_PROGRESS');
  static const done = StatusCreateStatusCategory._('DONE');

  static const values = [
    todo,
    inProgress,
    done,
  ];
  final String value;

  const StatusCreateStatusCategory._(this.value);

  static StatusCreateStatusCategory fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => StatusCreateStatusCategory._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of the statuses being created and their scope.
class StatusCreateRequest {
  final StatusScope scope;

  /// Details of the statuses being created.
  final List<StatusCreate> statuses;

  StatusCreateRequest({required this.scope, required this.statuses});

  factory StatusCreateRequest.fromJson(Map<String, Object?> json) {
    return StatusCreateRequest(
      scope: StatusScope.fromJson(
          json[r'scope'] as Map<String, Object?>? ?? const {}),
      statuses: (json[r'statuses'] as List<Object?>?)
              ?.map((i) =>
                  StatusCreate.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var scope = this.scope;
    var statuses = this.statuses;

    final json = <String, Object?>{};
    json[r'scope'] = scope.toJson();
    json[r'statuses'] = statuses.map((i) => i.toJson()).toList();
    return json;
  }

  StatusCreateRequest copyWith(
      {StatusScope? scope, List<StatusCreate>? statuses}) {
    return StatusCreateRequest(
      scope: scope ?? this.scope,
      statuses: statuses ?? this.statuses,
    );
  }
}

/// A status.
class StatusDetails {
  /// The description of the status.
  final String? description;

  /// The URL of the icon used to represent the status.
  final String? iconUrl;

  /// The ID of the status.
  final String? id;

  /// The name of the status.
  final String? name;

  /// The URL of the status.
  final String? self;

  /// The category assigned to the status.
  final StatusCategory? statusCategory;

  StatusDetails(
      {this.description,
      this.iconUrl,
      this.id,
      this.name,
      this.self,
      this.statusCategory});

  factory StatusDetails.fromJson(Map<String, Object?> json) {
    return StatusDetails(
      description: json[r'description'] as String?,
      iconUrl: json[r'iconUrl'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
      statusCategory: json[r'statusCategory'] != null
          ? StatusCategory.fromJson(
              json[r'statusCategory']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var iconUrl = this.iconUrl;
    var id = this.id;
    var name = this.name;
    var self = this.self;
    var statusCategory = this.statusCategory;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (iconUrl != null) {
      json[r'iconUrl'] = iconUrl;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (statusCategory != null) {
      json[r'statusCategory'] = statusCategory.toJson();
    }
    return json;
  }

  StatusDetails copyWith(
      {String? description,
      String? iconUrl,
      String? id,
      String? name,
      String? self,
      StatusCategory? statusCategory}) {
    return StatusDetails(
      description: description ?? this.description,
      iconUrl: iconUrl ?? this.iconUrl,
      id: id ?? this.id,
      name: name ?? this.name,
      self: self ?? this.self,
      statusCategory: statusCategory ?? this.statusCategory,
    );
  }
}

/// Details about the mapping from a status to a new status for an issue type.
class StatusMapping {
  /// The ID of the issue type.
  final String issueTypeId;

  /// The ID of the new status.
  final String newStatusId;

  /// The ID of the status.
  final String statusId;

  StatusMapping(
      {required this.issueTypeId,
      required this.newStatusId,
      required this.statusId});

  factory StatusMapping.fromJson(Map<String, Object?> json) {
    return StatusMapping(
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
      newStatusId: json[r'newStatusId'] as String? ?? '',
      statusId: json[r'statusId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var issueTypeId = this.issueTypeId;
    var newStatusId = this.newStatusId;
    var statusId = this.statusId;

    final json = <String, Object?>{};
    json[r'issueTypeId'] = issueTypeId;
    json[r'newStatusId'] = newStatusId;
    json[r'statusId'] = statusId;
    return json;
  }

  StatusMapping copyWith(
      {String? issueTypeId, String? newStatusId, String? statusId}) {
    return StatusMapping(
      issueTypeId: issueTypeId ?? this.issueTypeId,
      newStatusId: newStatusId ?? this.newStatusId,
      statusId: statusId ?? this.statusId,
    );
  }
}

/// The scope of the status.
class StatusScope {
  final ProjectId? project;

  /// The scope of the status. `GLOBAL` for company-managed projects and
  /// `PROJECT` for team-managed projects.
  final StatusScopeType type;

  StatusScope({this.project, required this.type});

  factory StatusScope.fromJson(Map<String, Object?> json) {
    return StatusScope(
      project: json[r'project'] != null
          ? ProjectId.fromJson(json[r'project']! as Map<String, Object?>)
          : null,
      type: StatusScopeType.fromValue(json[r'type'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var project = this.project;
    var type = this.type;

    final json = <String, Object?>{};
    if (project != null) {
      json[r'project'] = project.toJson();
    }
    json[r'type'] = type.value;
    return json;
  }

  StatusScope copyWith({ProjectId? project, StatusScopeType? type}) {
    return StatusScope(
      project: project ?? this.project,
      type: type ?? this.type,
    );
  }
}

class StatusScopeType {
  static const project = StatusScopeType._('PROJECT');
  static const global = StatusScopeType._('GLOBAL');

  static const values = [
    project,
    global,
  ];
  final String value;

  const StatusScopeType._(this.value);

  static StatusScopeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => StatusScopeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of the status being updated.
class StatusUpdate {
  /// The description of the status.
  final String? description;

  /// The ID of the status.
  final String id;

  /// The name of the status.
  final String name;

  /// The category of the status.
  final StatusUpdateStatusCategory statusCategory;

  StatusUpdate(
      {this.description,
      required this.id,
      required this.name,
      required this.statusCategory});

  factory StatusUpdate.fromJson(Map<String, Object?> json) {
    return StatusUpdate(
      description: json[r'description'] as String?,
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      statusCategory: StatusUpdateStatusCategory.fromValue(
          json[r'statusCategory'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var name = this.name;
    var statusCategory = this.statusCategory;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'id'] = id;
    json[r'name'] = name;
    json[r'statusCategory'] = statusCategory.value;
    return json;
  }

  StatusUpdate copyWith(
      {String? description,
      String? id,
      String? name,
      StatusUpdateStatusCategory? statusCategory}) {
    return StatusUpdate(
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
      statusCategory: statusCategory ?? this.statusCategory,
    );
  }
}

class StatusUpdateStatusCategory {
  static const todo = StatusUpdateStatusCategory._('TODO');
  static const inProgress = StatusUpdateStatusCategory._('IN_PROGRESS');
  static const done = StatusUpdateStatusCategory._('DONE');

  static const values = [
    todo,
    inProgress,
    done,
  ];
  final String value;

  const StatusUpdateStatusCategory._(this.value);

  static StatusUpdateStatusCategory fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => StatusUpdateStatusCategory._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The list of statuses that will be updated.
class StatusUpdateRequest {
  /// The list of statuses that will be updated.
  final List<StatusUpdate> statuses;

  StatusUpdateRequest({List<StatusUpdate>? statuses})
      : statuses = statuses ?? [];

  factory StatusUpdateRequest.fromJson(Map<String, Object?> json) {
    return StatusUpdateRequest(
      statuses: (json[r'statuses'] as List<Object?>?)
              ?.map((i) =>
                  StatusUpdate.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var statuses = this.statuses;

    final json = <String, Object?>{};
    json[r'statuses'] = statuses.map((i) => i.toJson()).toList();
    return json;
  }

  StatusUpdateRequest copyWith({List<StatusUpdate>? statuses}) {
    return StatusUpdateRequest(
      statuses: statuses ?? this.statuses,
    );
  }
}

class StringList {
  StringList();

  factory StringList.fromJson(Map<String, Object?> json) {
    return StringList();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// An issue suggested for use in the issue picker auto-completion.
class SuggestedIssue {
  /// The ID of the issue.
  final int? id;

  /// The URL of the issue type's avatar.
  final String? img;

  /// The key of the issue.
  final String? key;

  /// The key of the issue in HTML format.
  final String? keyHtml;

  /// The phrase containing the query string in HTML format, with the string
  /// highlighted with HTML bold tags.
  final String? summary;

  /// The phrase containing the query string, as plain text.
  final String? summaryText;

  SuggestedIssue(
      {this.id,
      this.img,
      this.key,
      this.keyHtml,
      this.summary,
      this.summaryText});

  factory SuggestedIssue.fromJson(Map<String, Object?> json) {
    return SuggestedIssue(
      id: (json[r'id'] as num?)?.toInt(),
      img: json[r'img'] as String?,
      key: json[r'key'] as String?,
      keyHtml: json[r'keyHtml'] as String?,
      summary: json[r'summary'] as String?,
      summaryText: json[r'summaryText'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var img = this.img;
    var key = this.key;
    var keyHtml = this.keyHtml;
    var summary = this.summary;
    var summaryText = this.summaryText;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (img != null) {
      json[r'img'] = img;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (keyHtml != null) {
      json[r'keyHtml'] = keyHtml;
    }
    if (summary != null) {
      json[r'summary'] = summary;
    }
    if (summaryText != null) {
      json[r'summaryText'] = summaryText;
    }
    return json;
  }

  SuggestedIssue copyWith(
      {int? id,
      String? img,
      String? key,
      String? keyHtml,
      String? summary,
      String? summaryText}) {
    return SuggestedIssue(
      id: id ?? this.id,
      img: img ?? this.img,
      key: key ?? this.key,
      keyHtml: keyHtml ?? this.keyHtml,
      summary: summary ?? this.summary,
      summaryText: summaryText ?? this.summaryText,
    );
  }
}

/// List of system avatars.
class SystemAvatars {
  /// A list of avatar details.
  final List<Avatar> system;

  SystemAvatars({List<Avatar>? system}) : system = system ?? [];

  factory SystemAvatars.fromJson(Map<String, Object?> json) {
    return SystemAvatars(
      system: (json[r'system'] as List<Object?>?)
              ?.map((i) =>
                  Avatar.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var system = this.system;

    final json = <String, Object?>{};
    json[r'system'] = system.map((i) => i.toJson()).toList();
    return json;
  }

  SystemAvatars copyWith({List<Avatar>? system}) {
    return SystemAvatars(
      system: system ?? this.system,
    );
  }
}

/// Details about a task.
class TaskProgressBeanObject {
  /// The description of the task.
  final String? description;

  /// The execution time of the task, in milliseconds.
  final int elapsedRuntime;

  /// A timestamp recording when the task was finished.
  final int? finished;

  /// The ID of the task.
  final String id;

  /// A timestamp recording when the task progress was last updated.
  final int lastUpdate;

  /// Information about the progress of the task.
  final String? message;

  /// The progress of the task, as a percentage complete.
  final int progress;

  /// The result of the task execution.
  final dynamic result;

  /// The URL of the task.
  final String self;

  /// A timestamp recording when the task was started.
  final int? started;

  /// The status of the task.
  final TaskProgressBeanObjectStatus status;

  /// A timestamp recording when the task was submitted.
  final int submitted;

  /// The ID of the user who submitted the task.
  final int submittedBy;

  TaskProgressBeanObject(
      {this.description,
      required this.elapsedRuntime,
      this.finished,
      required this.id,
      required this.lastUpdate,
      this.message,
      required this.progress,
      this.result,
      required this.self,
      this.started,
      required this.status,
      required this.submitted,
      required this.submittedBy});

  factory TaskProgressBeanObject.fromJson(Map<String, Object?> json) {
    return TaskProgressBeanObject(
      description: json[r'description'] as String?,
      elapsedRuntime: (json[r'elapsedRuntime'] as num?)?.toInt() ?? 0,
      finished: (json[r'finished'] as num?)?.toInt(),
      id: json[r'id'] as String? ?? '',
      lastUpdate: (json[r'lastUpdate'] as num?)?.toInt() ?? 0,
      message: json[r'message'] as String?,
      progress: (json[r'progress'] as num?)?.toInt() ?? 0,
      result: json[r'result'],
      self: json[r'self'] as String? ?? '',
      started: (json[r'started'] as num?)?.toInt(),
      status: TaskProgressBeanObjectStatus.fromValue(
          json[r'status'] as String? ?? ''),
      submitted: (json[r'submitted'] as num?)?.toInt() ?? 0,
      submittedBy: (json[r'submittedBy'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var elapsedRuntime = this.elapsedRuntime;
    var finished = this.finished;
    var id = this.id;
    var lastUpdate = this.lastUpdate;
    var message = this.message;
    var progress = this.progress;
    var result = this.result;
    var self = this.self;
    var started = this.started;
    var status = this.status;
    var submitted = this.submitted;
    var submittedBy = this.submittedBy;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'elapsedRuntime'] = elapsedRuntime;
    if (finished != null) {
      json[r'finished'] = finished;
    }
    json[r'id'] = id;
    json[r'lastUpdate'] = lastUpdate;
    if (message != null) {
      json[r'message'] = message;
    }
    json[r'progress'] = progress;
    if (result != null) {
      json[r'result'] = result;
    }
    json[r'self'] = self;
    if (started != null) {
      json[r'started'] = started;
    }
    json[r'status'] = status.value;
    json[r'submitted'] = submitted;
    json[r'submittedBy'] = submittedBy;
    return json;
  }

  TaskProgressBeanObject copyWith(
      {String? description,
      int? elapsedRuntime,
      int? finished,
      String? id,
      int? lastUpdate,
      String? message,
      int? progress,
      dynamic result,
      String? self,
      int? started,
      TaskProgressBeanObjectStatus? status,
      int? submitted,
      int? submittedBy}) {
    return TaskProgressBeanObject(
      description: description ?? this.description,
      elapsedRuntime: elapsedRuntime ?? this.elapsedRuntime,
      finished: finished ?? this.finished,
      id: id ?? this.id,
      lastUpdate: lastUpdate ?? this.lastUpdate,
      message: message ?? this.message,
      progress: progress ?? this.progress,
      result: result ?? this.result,
      self: self ?? this.self,
      started: started ?? this.started,
      status: status ?? this.status,
      submitted: submitted ?? this.submitted,
      submittedBy: submittedBy ?? this.submittedBy,
    );
  }
}

class TaskProgressBeanObjectStatus {
  static const enqueued = TaskProgressBeanObjectStatus._('ENQUEUED');
  static const running = TaskProgressBeanObjectStatus._('RUNNING');
  static const complete = TaskProgressBeanObjectStatus._('COMPLETE');
  static const failed = TaskProgressBeanObjectStatus._('FAILED');
  static const cancelRequested =
      TaskProgressBeanObjectStatus._('CANCEL_REQUESTED');
  static const cancelled = TaskProgressBeanObjectStatus._('CANCELLED');
  static const dead = TaskProgressBeanObjectStatus._('DEAD');

  static const values = [
    enqueued,
    running,
    complete,
    failed,
    cancelRequested,
    cancelled,
    dead,
  ];
  final String value;

  const TaskProgressBeanObjectStatus._(this.value);

  static TaskProgressBeanObjectStatus fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => TaskProgressBeanObjectStatus._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about a task.
class TaskProgressBeanRemoveOptionFromIssuesResult {
  /// The description of the task.
  final String? description;

  /// The execution time of the task, in milliseconds.
  final int elapsedRuntime;

  /// A timestamp recording when the task was finished.
  final int? finished;

  /// The ID of the task.
  final String id;

  /// A timestamp recording when the task progress was last updated.
  final int lastUpdate;

  /// Information about the progress of the task.
  final String? message;

  /// The progress of the task, as a percentage complete.
  final int progress;

  /// The result of the task execution.
  final RemoveOptionFromIssuesResult? result;

  /// The URL of the task.
  final String self;

  /// A timestamp recording when the task was started.
  final int? started;

  /// The status of the task.
  final TaskProgressBeanRemoveOptionFromIssuesResultStatus status;

  /// A timestamp recording when the task was submitted.
  final int submitted;

  /// The ID of the user who submitted the task.
  final int submittedBy;

  TaskProgressBeanRemoveOptionFromIssuesResult(
      {this.description,
      required this.elapsedRuntime,
      this.finished,
      required this.id,
      required this.lastUpdate,
      this.message,
      required this.progress,
      this.result,
      required this.self,
      this.started,
      required this.status,
      required this.submitted,
      required this.submittedBy});

  factory TaskProgressBeanRemoveOptionFromIssuesResult.fromJson(
      Map<String, Object?> json) {
    return TaskProgressBeanRemoveOptionFromIssuesResult(
      description: json[r'description'] as String?,
      elapsedRuntime: (json[r'elapsedRuntime'] as num?)?.toInt() ?? 0,
      finished: (json[r'finished'] as num?)?.toInt(),
      id: json[r'id'] as String? ?? '',
      lastUpdate: (json[r'lastUpdate'] as num?)?.toInt() ?? 0,
      message: json[r'message'] as String?,
      progress: (json[r'progress'] as num?)?.toInt() ?? 0,
      result: json[r'result'] != null
          ? RemoveOptionFromIssuesResult.fromJson(
              json[r'result']! as Map<String, Object?>)
          : null,
      self: json[r'self'] as String? ?? '',
      started: (json[r'started'] as num?)?.toInt(),
      status: TaskProgressBeanRemoveOptionFromIssuesResultStatus.fromValue(
          json[r'status'] as String? ?? ''),
      submitted: (json[r'submitted'] as num?)?.toInt() ?? 0,
      submittedBy: (json[r'submittedBy'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var elapsedRuntime = this.elapsedRuntime;
    var finished = this.finished;
    var id = this.id;
    var lastUpdate = this.lastUpdate;
    var message = this.message;
    var progress = this.progress;
    var result = this.result;
    var self = this.self;
    var started = this.started;
    var status = this.status;
    var submitted = this.submitted;
    var submittedBy = this.submittedBy;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'elapsedRuntime'] = elapsedRuntime;
    if (finished != null) {
      json[r'finished'] = finished;
    }
    json[r'id'] = id;
    json[r'lastUpdate'] = lastUpdate;
    if (message != null) {
      json[r'message'] = message;
    }
    json[r'progress'] = progress;
    if (result != null) {
      json[r'result'] = result.toJson();
    }
    json[r'self'] = self;
    if (started != null) {
      json[r'started'] = started;
    }
    json[r'status'] = status.value;
    json[r'submitted'] = submitted;
    json[r'submittedBy'] = submittedBy;
    return json;
  }

  TaskProgressBeanRemoveOptionFromIssuesResult copyWith(
      {String? description,
      int? elapsedRuntime,
      int? finished,
      String? id,
      int? lastUpdate,
      String? message,
      int? progress,
      RemoveOptionFromIssuesResult? result,
      String? self,
      int? started,
      TaskProgressBeanRemoveOptionFromIssuesResultStatus? status,
      int? submitted,
      int? submittedBy}) {
    return TaskProgressBeanRemoveOptionFromIssuesResult(
      description: description ?? this.description,
      elapsedRuntime: elapsedRuntime ?? this.elapsedRuntime,
      finished: finished ?? this.finished,
      id: id ?? this.id,
      lastUpdate: lastUpdate ?? this.lastUpdate,
      message: message ?? this.message,
      progress: progress ?? this.progress,
      result: result ?? this.result,
      self: self ?? this.self,
      started: started ?? this.started,
      status: status ?? this.status,
      submitted: submitted ?? this.submitted,
      submittedBy: submittedBy ?? this.submittedBy,
    );
  }
}

class TaskProgressBeanRemoveOptionFromIssuesResultStatus {
  static const enqueued =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('ENQUEUED');
  static const running =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('RUNNING');
  static const complete =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('COMPLETE');
  static const failed =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('FAILED');
  static const cancelRequested =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('CANCEL_REQUESTED');
  static const cancelled =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('CANCELLED');
  static const dead =
      TaskProgressBeanRemoveOptionFromIssuesResultStatus._('DEAD');

  static const values = [
    enqueued,
    running,
    complete,
    failed,
    cancelRequested,
    cancelled,
    dead,
  ];
  final String value;

  const TaskProgressBeanRemoveOptionFromIssuesResultStatus._(this.value);

  static TaskProgressBeanRemoveOptionFromIssuesResultStatus fromValue(
          String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              TaskProgressBeanRemoveOptionFromIssuesResultStatus._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of the time tracking configuration.
class TimeTrackingConfiguration {
  /// The default unit of time applied to logged time.
  final TimeTrackingConfigurationDefaultUnit defaultUnit;

  /// The format that will appear on an issue's *Time Spent* field.
  final TimeTrackingConfigurationTimeFormat timeFormat;

  /// The number of days in a working week.
  final num workingDaysPerWeek;

  /// The number of hours in a working day.
  final num workingHoursPerDay;

  TimeTrackingConfiguration(
      {required this.defaultUnit,
      required this.timeFormat,
      required this.workingDaysPerWeek,
      required this.workingHoursPerDay});

  factory TimeTrackingConfiguration.fromJson(Map<String, Object?> json) {
    return TimeTrackingConfiguration(
      defaultUnit: TimeTrackingConfigurationDefaultUnit.fromValue(
          json[r'defaultUnit'] as String? ?? ''),
      timeFormat: TimeTrackingConfigurationTimeFormat.fromValue(
          json[r'timeFormat'] as String? ?? ''),
      workingDaysPerWeek: json[r'workingDaysPerWeek'] as num? ?? 0,
      workingHoursPerDay: json[r'workingHoursPerDay'] as num? ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var defaultUnit = this.defaultUnit;
    var timeFormat = this.timeFormat;
    var workingDaysPerWeek = this.workingDaysPerWeek;
    var workingHoursPerDay = this.workingHoursPerDay;

    final json = <String, Object?>{};
    json[r'defaultUnit'] = defaultUnit.value;
    json[r'timeFormat'] = timeFormat.value;
    json[r'workingDaysPerWeek'] = workingDaysPerWeek;
    json[r'workingHoursPerDay'] = workingHoursPerDay;
    return json;
  }

  TimeTrackingConfiguration copyWith(
      {TimeTrackingConfigurationDefaultUnit? defaultUnit,
      TimeTrackingConfigurationTimeFormat? timeFormat,
      num? workingDaysPerWeek,
      num? workingHoursPerDay}) {
    return TimeTrackingConfiguration(
      defaultUnit: defaultUnit ?? this.defaultUnit,
      timeFormat: timeFormat ?? this.timeFormat,
      workingDaysPerWeek: workingDaysPerWeek ?? this.workingDaysPerWeek,
      workingHoursPerDay: workingHoursPerDay ?? this.workingHoursPerDay,
    );
  }
}

class TimeTrackingConfigurationDefaultUnit {
  static const minute = TimeTrackingConfigurationDefaultUnit._('minute');
  static const hour = TimeTrackingConfigurationDefaultUnit._('hour');
  static const day = TimeTrackingConfigurationDefaultUnit._('day');
  static const week = TimeTrackingConfigurationDefaultUnit._('week');

  static const values = [
    minute,
    hour,
    day,
    week,
  ];
  final String value;

  const TimeTrackingConfigurationDefaultUnit._(this.value);

  static TimeTrackingConfigurationDefaultUnit fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => TimeTrackingConfigurationDefaultUnit._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class TimeTrackingConfigurationTimeFormat {
  static const pretty = TimeTrackingConfigurationTimeFormat._('pretty');
  static const days = TimeTrackingConfigurationTimeFormat._('days');
  static const hours = TimeTrackingConfigurationTimeFormat._('hours');

  static const values = [
    pretty,
    days,
    hours,
  ];
  final String value;

  const TimeTrackingConfigurationTimeFormat._(this.value);

  static TimeTrackingConfigurationTimeFormat fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => TimeTrackingConfigurationTimeFormat._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Time tracking details.
class TimeTrackingDetails {
  /// The original estimate of time needed for this issue in readable format.
  final String? originalEstimate;

  /// The original estimate of time needed for this issue in seconds.
  final int? originalEstimateSeconds;

  /// The remaining estimate of time needed for this issue in readable format.
  final String? remainingEstimate;

  /// The remaining estimate of time needed for this issue in seconds.
  final int? remainingEstimateSeconds;

  /// Time worked on this issue in readable format.
  final String? timeSpent;

  /// Time worked on this issue in seconds.
  final int? timeSpentSeconds;

  TimeTrackingDetails(
      {this.originalEstimate,
      this.originalEstimateSeconds,
      this.remainingEstimate,
      this.remainingEstimateSeconds,
      this.timeSpent,
      this.timeSpentSeconds});

  factory TimeTrackingDetails.fromJson(Map<String, Object?> json) {
    return TimeTrackingDetails(
      originalEstimate: json[r'originalEstimate'] as String?,
      originalEstimateSeconds:
          (json[r'originalEstimateSeconds'] as num?)?.toInt(),
      remainingEstimate: json[r'remainingEstimate'] as String?,
      remainingEstimateSeconds:
          (json[r'remainingEstimateSeconds'] as num?)?.toInt(),
      timeSpent: json[r'timeSpent'] as String?,
      timeSpentSeconds: (json[r'timeSpentSeconds'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var originalEstimate = this.originalEstimate;
    var originalEstimateSeconds = this.originalEstimateSeconds;
    var remainingEstimate = this.remainingEstimate;
    var remainingEstimateSeconds = this.remainingEstimateSeconds;
    var timeSpent = this.timeSpent;
    var timeSpentSeconds = this.timeSpentSeconds;

    final json = <String, Object?>{};
    if (originalEstimate != null) {
      json[r'originalEstimate'] = originalEstimate;
    }
    if (originalEstimateSeconds != null) {
      json[r'originalEstimateSeconds'] = originalEstimateSeconds;
    }
    if (remainingEstimate != null) {
      json[r'remainingEstimate'] = remainingEstimate;
    }
    if (remainingEstimateSeconds != null) {
      json[r'remainingEstimateSeconds'] = remainingEstimateSeconds;
    }
    if (timeSpent != null) {
      json[r'timeSpent'] = timeSpent;
    }
    if (timeSpentSeconds != null) {
      json[r'timeSpentSeconds'] = timeSpentSeconds;
    }
    return json;
  }

  TimeTrackingDetails copyWith(
      {String? originalEstimate,
      int? originalEstimateSeconds,
      String? remainingEstimate,
      int? remainingEstimateSeconds,
      String? timeSpent,
      int? timeSpentSeconds}) {
    return TimeTrackingDetails(
      originalEstimate: originalEstimate ?? this.originalEstimate,
      originalEstimateSeconds:
          originalEstimateSeconds ?? this.originalEstimateSeconds,
      remainingEstimate: remainingEstimate ?? this.remainingEstimate,
      remainingEstimateSeconds:
          remainingEstimateSeconds ?? this.remainingEstimateSeconds,
      timeSpent: timeSpent ?? this.timeSpent,
      timeSpentSeconds: timeSpentSeconds ?? this.timeSpentSeconds,
    );
  }
}

/// Details about the time tracking provider.
class TimeTrackingProvider {
  /// The key for the time tracking provider. For example, *JIRA*.
  final String key;

  /// The name of the time tracking provider. For example, *JIRA provided time
  /// tracking*.
  final String? name;

  /// The URL of the configuration page for the time tracking provider app. For
  /// example, */example/config/url*. This property is only returned if the
  /// `adminPageKey` property is set in the module descriptor of the time
  /// tracking provider app.
  final String? url;

  TimeTrackingProvider({required this.key, this.name, this.url});

  factory TimeTrackingProvider.fromJson(Map<String, Object?> json) {
    return TimeTrackingProvider(
      key: json[r'key'] as String? ?? '',
      name: json[r'name'] as String?,
      url: json[r'url'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var key = this.key;
    var name = this.name;
    var url = this.url;

    final json = <String, Object?>{};
    json[r'key'] = key;
    if (name != null) {
      json[r'name'] = name;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    return json;
  }

  TimeTrackingProvider copyWith({String? key, String? name, String? url}) {
    return TimeTrackingProvider(
      key: key ?? this.key,
      name: name ?? this.name,
      url: url ?? this.url,
    );
  }
}

/// Details of a workflow transition.
class Transition {
  /// The description of the transition.
  final String description;

  /// The statuses the transition can start from.
  final List<String> from;

  /// The ID of the transition.
  final String id;

  /// The name of the transition.
  final String name;

  /// The properties of the transition.
  final Map<String, dynamic>? properties;
  final WorkflowRules? rules;
  final TransitionScreenDetails? screen;

  /// The status the transition goes to.
  final String to;

  /// The type of the transition.
  final TransitionType type;

  Transition(
      {required this.description,
      required this.from,
      required this.id,
      required this.name,
      this.properties,
      this.rules,
      this.screen,
      required this.to,
      required this.type});

  factory Transition.fromJson(Map<String, Object?> json) {
    return Transition(
      description: json[r'description'] as String? ?? '',
      from: (json[r'from'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      properties: json[r'properties'] as Map<String, Object?>?,
      rules: json[r'rules'] != null
          ? WorkflowRules.fromJson(json[r'rules']! as Map<String, Object?>)
          : null,
      screen: json[r'screen'] != null
          ? TransitionScreenDetails.fromJson(
              json[r'screen']! as Map<String, Object?>)
          : null,
      to: json[r'to'] as String? ?? '',
      type: TransitionType.fromValue(json[r'type'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var from = this.from;
    var id = this.id;
    var name = this.name;
    var properties = this.properties;
    var rules = this.rules;
    var screen = this.screen;
    var to = this.to;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'description'] = description;
    json[r'from'] = from;
    json[r'id'] = id;
    json[r'name'] = name;
    if (properties != null) {
      json[r'properties'] = properties;
    }
    if (rules != null) {
      json[r'rules'] = rules.toJson();
    }
    if (screen != null) {
      json[r'screen'] = screen.toJson();
    }
    json[r'to'] = to;
    json[r'type'] = type.value;
    return json;
  }

  Transition copyWith(
      {String? description,
      List<String>? from,
      String? id,
      String? name,
      Map<String, dynamic>? properties,
      WorkflowRules? rules,
      TransitionScreenDetails? screen,
      String? to,
      TransitionType? type}) {
    return Transition(
      description: description ?? this.description,
      from: from ?? this.from,
      id: id ?? this.id,
      name: name ?? this.name,
      properties: properties ?? this.properties,
      rules: rules ?? this.rules,
      screen: screen ?? this.screen,
      to: to ?? this.to,
      type: type ?? this.type,
    );
  }
}

class TransitionType {
  static const global = TransitionType._('global');
  static const initial = TransitionType._('initial');
  static const directed = TransitionType._('directed');

  static const values = [
    global,
    initial,
    directed,
  ];
  final String value;

  const TransitionType._(this.value);

  static TransitionType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => TransitionType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The details of a transition screen.
class TransitionScreenDetails {
  /// The ID of the screen.
  final String id;

  /// The name of the screen.
  final String? name;

  TransitionScreenDetails({required this.id, this.name});

  factory TransitionScreenDetails.fromJson(Map<String, Object?> json) {
    return TransitionScreenDetails(
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    json[r'id'] = id;
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  TransitionScreenDetails copyWith({String? id, String? name}) {
    return TransitionScreenDetails(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// List of issue transitions.
class Transitions {
  /// Expand options that include additional transitions details in the
  /// response.
  final String? expand;

  /// List of issue transitions.
  final List<IssueTransition> transitions;

  Transitions({this.expand, List<IssueTransition>? transitions})
      : transitions = transitions ?? [];

  factory Transitions.fromJson(Map<String, Object?> json) {
    return Transitions(
      expand: json[r'expand'] as String?,
      transitions: (json[r'transitions'] as List<Object?>?)
              ?.map((i) => IssueTransition.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var transitions = this.transitions;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    json[r'transitions'] = transitions.map((i) => i.toJson()).toList();
    return json;
  }

  Transitions copyWith({String? expand, List<IssueTransition>? transitions}) {
    return Transitions(
      expand: expand ?? this.expand,
      transitions: transitions ?? this.transitions,
    );
  }
}

/// The details of a UI modification's context, which define where to activate
/// the UI modification.
class UiModificationContextDetails {
  /// The ID of the UI modification context.
  final String? id;

  /// Whether a context is available. For example, when a project is deleted the
  /// context becomes unavailable.
  final bool isAvailable;

  /// The issue type ID of the context.
  final String issueTypeId;

  /// The project ID of the context.
  final String projectId;

  /// The view type of the context. Only `GIC` (Global Issue Create) is
  /// supported.
  final String viewType;

  UiModificationContextDetails(
      {this.id,
      bool? isAvailable,
      required this.issueTypeId,
      required this.projectId,
      required this.viewType})
      : isAvailable = isAvailable ?? false;

  factory UiModificationContextDetails.fromJson(Map<String, Object?> json) {
    return UiModificationContextDetails(
      id: json[r'id'] as String?,
      isAvailable: json[r'isAvailable'] as bool? ?? false,
      issueTypeId: json[r'issueTypeId'] as String? ?? '',
      projectId: json[r'projectId'] as String? ?? '',
      viewType: json[r'viewType'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var isAvailable = this.isAvailable;
    var issueTypeId = this.issueTypeId;
    var projectId = this.projectId;
    var viewType = this.viewType;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    json[r'isAvailable'] = isAvailable;
    json[r'issueTypeId'] = issueTypeId;
    json[r'projectId'] = projectId;
    json[r'viewType'] = viewType;
    return json;
  }

  UiModificationContextDetails copyWith(
      {String? id,
      bool? isAvailable,
      String? issueTypeId,
      String? projectId,
      String? viewType}) {
    return UiModificationContextDetails(
      id: id ?? this.id,
      isAvailable: isAvailable ?? this.isAvailable,
      issueTypeId: issueTypeId ?? this.issueTypeId,
      projectId: projectId ?? this.projectId,
      viewType: viewType ?? this.viewType,
    );
  }
}

/// The details of a UI modification.
class UiModificationDetails {
  /// List of contexts of the UI modification. The maximum number of contexts is
  /// 1000.
  final List<UiModificationContextDetails> contexts;

  /// The data of the UI modification. The maximum size of the data is 50000
  /// characters.
  final String? data;

  /// The description of the UI modification. The maximum length is 255
  /// characters.
  final String? description;

  /// The ID of the UI modification.
  final String id;

  /// The name of the UI modification. The maximum length is 255 characters.
  final String name;

  /// The URL of the UI modification.
  final String self;

  UiModificationDetails(
      {List<UiModificationContextDetails>? contexts,
      this.data,
      this.description,
      required this.id,
      required this.name,
      required this.self})
      : contexts = contexts ?? [];

  factory UiModificationDetails.fromJson(Map<String, Object?> json) {
    return UiModificationDetails(
      contexts: (json[r'contexts'] as List<Object?>?)
              ?.map((i) => UiModificationContextDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      data: json[r'data'] as String?,
      description: json[r'description'] as String?,
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      self: json[r'self'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var contexts = this.contexts;
    var data = this.data;
    var description = this.description;
    var id = this.id;
    var name = this.name;
    var self = this.self;

    final json = <String, Object?>{};
    json[r'contexts'] = contexts.map((i) => i.toJson()).toList();
    if (data != null) {
      json[r'data'] = data;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'id'] = id;
    json[r'name'] = name;
    json[r'self'] = self;
    return json;
  }

  UiModificationDetails copyWith(
      {List<UiModificationContextDetails>? contexts,
      String? data,
      String? description,
      String? id,
      String? name,
      String? self}) {
    return UiModificationDetails(
      contexts: contexts ?? this.contexts,
      data: data ?? this.data,
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
      self: self ?? this.self,
    );
  }
}

/// Identifiers for a UI modification.
class UiModificationIdentifiers {
  /// The ID of the UI modification.
  final String id;

  /// The URL of the UI modification.
  final String self;

  UiModificationIdentifiers({required this.id, required this.self});

  factory UiModificationIdentifiers.fromJson(Map<String, Object?> json) {
    return UiModificationIdentifiers(
      id: json[r'id'] as String? ?? '',
      self: json[r'self'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var self = this.self;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'self'] = self;
    return json;
  }

  UiModificationIdentifiers copyWith({String? id, String? self}) {
    return UiModificationIdentifiers(
      id: id ?? this.id,
      self: self ?? this.self,
    );
  }
}

class UnrestrictedUserEmail {
  /// The accountId of the user
  final String? accountId;

  /// The email of the user
  final String? email;

  UnrestrictedUserEmail({this.accountId, this.email});

  factory UnrestrictedUserEmail.fromJson(Map<String, Object?> json) {
    return UnrestrictedUserEmail(
      accountId: json[r'accountId'] as String?,
      email: json[r'email'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var email = this.email;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (email != null) {
      json[r'email'] = email;
    }
    return json;
  }

  UnrestrictedUserEmail copyWith({String? accountId, String? email}) {
    return UnrestrictedUserEmail(
      accountId: accountId ?? this.accountId,
      email: email ?? this.email,
    );
  }
}

/// Details of a custom field.
class UpdateCustomFieldDetails {
  /// The description of the custom field. The maximum length is 40000
  /// characters.
  final String? description;

  /// The name of the custom field. It doesn't have to be unique. The maximum
  /// length is 255 characters.
  final String? name;

  /// The searcher that defines the way the field is searched in Jira. It can be
  /// set to `null`, otherwise you must specify the valid searcher for the field
  /// type, as listed below (abbreviated values shown):
  ///
  ///  *  `cascadingselect`: `cascadingselectsearcher`
  ///  *  `datepicker`: `daterange`
  ///  *  `datetime`: `datetimerange`
  ///  *  `float`: `exactnumber` or `numberrange`
  ///  *  `grouppicker`: `grouppickersearcher`
  ///  *  `importid`: `exactnumber` or `numberrange`
  ///  *  `labels`: `labelsearcher`
  ///  *  `multicheckboxes`: `multiselectsearcher`
  ///  *  `multigrouppicker`: `multiselectsearcher`
  ///  *  `multiselect`: `multiselectsearcher`
  ///  *  `multiuserpicker`: `userpickergroupsearcher`
  ///  *  `multiversion`: `versionsearcher`
  ///  *  `project`: `projectsearcher`
  ///  *  `radiobuttons`: `multiselectsearcher`
  ///  *  `readonlyfield`: `textsearcher`
  ///  *  `select`: `multiselectsearcher`
  ///  *  `textarea`: `textsearcher`
  ///  *  `textfield`: `textsearcher`
  ///  *  `url`: `exacttextsearcher`
  ///  *  `userpicker`: `userpickergroupsearcher`
  ///  *  `version`: `versionsearcher`
  final UpdateCustomFieldDetailsSearcherKey? searcherKey;

  UpdateCustomFieldDetails({this.description, this.name, this.searcherKey});

  factory UpdateCustomFieldDetails.fromJson(Map<String, Object?> json) {
    return UpdateCustomFieldDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
      searcherKey: json[r'searcherKey'] != null
          ? UpdateCustomFieldDetailsSearcherKey.fromValue(
              json[r'searcherKey']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;
    var searcherKey = this.searcherKey;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (searcherKey != null) {
      json[r'searcherKey'] = searcherKey.value;
    }
    return json;
  }

  UpdateCustomFieldDetails copyWith(
      {String? description,
      String? name,
      UpdateCustomFieldDetailsSearcherKey? searcherKey}) {
    return UpdateCustomFieldDetails(
      description: description ?? this.description,
      name: name ?? this.name,
      searcherKey: searcherKey ?? this.searcherKey,
    );
  }
}

class UpdateCustomFieldDetailsSearcherKey {
  static const comAtlassianJiraPluginSystemCustomfieldtypesCascadingselectsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:cascadingselectsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesDaterange =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:daterange');
  static const comAtlassianJiraPluginSystemCustomfieldtypesDatetimerange =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:datetimerange');
  static const comAtlassianJiraPluginSystemCustomfieldtypesExactnumber =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:exactnumber');
  static const comAtlassianJiraPluginSystemCustomfieldtypesExacttextsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:exacttextsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesGrouppickersearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesLabelsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:labelsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesMultiselectsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesNumberrange =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:numberrange');
  static const comAtlassianJiraPluginSystemCustomfieldtypesProjectsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:projectsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesTextsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:textsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesUserpickergroupsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:userpickergroupsearcher');
  static const comAtlassianJiraPluginSystemCustomfieldtypesVersionsearcher =
      UpdateCustomFieldDetailsSearcherKey._(
          'com.atlassian.jira.plugin.system.customfieldtypes:versionsearcher');

  static const values = [
    comAtlassianJiraPluginSystemCustomfieldtypesCascadingselectsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesDaterange,
    comAtlassianJiraPluginSystemCustomfieldtypesDatetimerange,
    comAtlassianJiraPluginSystemCustomfieldtypesExactnumber,
    comAtlassianJiraPluginSystemCustomfieldtypesExacttextsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesGrouppickersearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesLabelsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesMultiselectsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesNumberrange,
    comAtlassianJiraPluginSystemCustomfieldtypesProjectsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesTextsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesUserpickergroupsearcher,
    comAtlassianJiraPluginSystemCustomfieldtypesVersionsearcher,
  ];
  final String value;

  const UpdateCustomFieldDetailsSearcherKey._(this.value);

  static UpdateCustomFieldDetailsSearcherKey fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UpdateCustomFieldDetailsSearcherKey._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The ID of a screen scheme.
class UpdateDefaultScreenScheme {
  /// The ID of the screen scheme.
  final String screenSchemeId;

  UpdateDefaultScreenScheme({required this.screenSchemeId});

  factory UpdateDefaultScreenScheme.fromJson(Map<String, Object?> json) {
    return UpdateDefaultScreenScheme(
      screenSchemeId: json[r'screenSchemeId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var screenSchemeId = this.screenSchemeId;

    final json = <String, Object?>{};
    json[r'screenSchemeId'] = screenSchemeId;
    return json;
  }

  UpdateDefaultScreenScheme copyWith({String? screenSchemeId}) {
    return UpdateDefaultScreenScheme(
      screenSchemeId: screenSchemeId ?? this.screenSchemeId,
    );
  }
}

/// The details of the field configuration scheme.
class UpdateFieldConfigurationSchemeDetails {
  /// The description of the field configuration scheme.
  final String? description;

  /// The name of the field configuration scheme. The name must be unique.
  final String name;

  UpdateFieldConfigurationSchemeDetails({this.description, required this.name});

  factory UpdateFieldConfigurationSchemeDetails.fromJson(
      Map<String, Object?> json) {
    return UpdateFieldConfigurationSchemeDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'name'] = name;
    return json;
  }

  UpdateFieldConfigurationSchemeDetails copyWith(
      {String? description, String? name}) {
    return UpdateFieldConfigurationSchemeDetails(
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// Details of issue security scheme level.
class UpdateIssueSecurityLevelDetails {
  /// The description of the issue security scheme level.
  final String? description;

  /// The name of the issue security scheme level. Must be unique.
  final String? name;

  UpdateIssueSecurityLevelDetails({this.description, this.name});

  factory UpdateIssueSecurityLevelDetails.fromJson(Map<String, Object?> json) {
    return UpdateIssueSecurityLevelDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  UpdateIssueSecurityLevelDetails copyWith(
      {String? description, String? name}) {
    return UpdateIssueSecurityLevelDetails(
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

class UpdateIssueSecuritySchemeRequestBean {
  /// The description of the security scheme scheme.
  final String? description;

  /// The name of the security scheme scheme. Must be unique.
  final String? name;

  UpdateIssueSecuritySchemeRequestBean({this.description, this.name});

  factory UpdateIssueSecuritySchemeRequestBean.fromJson(
      Map<String, Object?> json) {
    return UpdateIssueSecuritySchemeRequestBean(
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  UpdateIssueSecuritySchemeRequestBean copyWith(
      {String? description, String? name}) {
    return UpdateIssueSecuritySchemeRequestBean(
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// Details of a notification scheme.
class UpdateNotificationSchemeDetails {
  /// The description of the notification scheme.
  final String? description;

  /// The name of the notification scheme. Must be unique.
  final String? name;

  UpdateNotificationSchemeDetails({this.description, this.name});

  factory UpdateNotificationSchemeDetails.fromJson(Map<String, Object?> json) {
    return UpdateNotificationSchemeDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  UpdateNotificationSchemeDetails copyWith(
      {String? description, String? name}) {
    return UpdateNotificationSchemeDetails(
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// Details of an issue priority.
class UpdatePriorityDetails {
  /// The description of the priority.
  final String? description;

  /// The URL of an icon for the priority. Accepted protocols are HTTP and
  /// HTTPS. Built in icons can also be used.
  final UpdatePriorityDetailsIconUrl? iconUrl;

  /// The name of the priority. Must be unique.
  final String? name;

  /// The status color of the priority in 3-digit or 6-digit hexadecimal format.
  final String? statusColor;

  UpdatePriorityDetails(
      {this.description, this.iconUrl, this.name, this.statusColor});

  factory UpdatePriorityDetails.fromJson(Map<String, Object?> json) {
    return UpdatePriorityDetails(
      description: json[r'description'] as String?,
      iconUrl: json[r'iconUrl'] != null
          ? UpdatePriorityDetailsIconUrl.fromValue(json[r'iconUrl']! as String)
          : null,
      name: json[r'name'] as String?,
      statusColor: json[r'statusColor'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var iconUrl = this.iconUrl;
    var name = this.name;
    var statusColor = this.statusColor;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (iconUrl != null) {
      json[r'iconUrl'] = iconUrl.value;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (statusColor != null) {
      json[r'statusColor'] = statusColor;
    }
    return json;
  }

  UpdatePriorityDetails copyWith(
      {String? description,
      UpdatePriorityDetailsIconUrl? iconUrl,
      String? name,
      String? statusColor}) {
    return UpdatePriorityDetails(
      description: description ?? this.description,
      iconUrl: iconUrl ?? this.iconUrl,
      name: name ?? this.name,
      statusColor: statusColor ?? this.statusColor,
    );
  }
}

class UpdatePriorityDetailsIconUrl {
  static const imagesIconsPrioritiesBlockerPng =
      UpdatePriorityDetailsIconUrl._('/images/icons/priorities/blocker.png');
  static const imagesIconsPrioritiesCriticalPng =
      UpdatePriorityDetailsIconUrl._('/images/icons/priorities/critical.png');
  static const imagesIconsPrioritiesHighPng =
      UpdatePriorityDetailsIconUrl._('/images/icons/priorities/high.png');
  static const imagesIconsPrioritiesHighestPng =
      UpdatePriorityDetailsIconUrl._('/images/icons/priorities/highest.png');
  static const imagesIconsPrioritiesLowPng =
      UpdatePriorityDetailsIconUrl._('/images/icons/priorities/low.png');
  static const imagesIconsPrioritiesLowestPng =
      UpdatePriorityDetailsIconUrl._('/images/icons/priorities/lowest.png');
  static const imagesIconsPrioritiesMajorPng =
      UpdatePriorityDetailsIconUrl._('/images/icons/priorities/major.png');
  static const imagesIconsPrioritiesMediumPng =
      UpdatePriorityDetailsIconUrl._('/images/icons/priorities/medium.png');
  static const imagesIconsPrioritiesMinorPng =
      UpdatePriorityDetailsIconUrl._('/images/icons/priorities/minor.png');
  static const imagesIconsPrioritiesTrivialPng =
      UpdatePriorityDetailsIconUrl._('/images/icons/priorities/trivial.png');

  static const values = [
    imagesIconsPrioritiesBlockerPng,
    imagesIconsPrioritiesCriticalPng,
    imagesIconsPrioritiesHighPng,
    imagesIconsPrioritiesHighestPng,
    imagesIconsPrioritiesLowPng,
    imagesIconsPrioritiesLowestPng,
    imagesIconsPrioritiesMajorPng,
    imagesIconsPrioritiesMediumPng,
    imagesIconsPrioritiesMinorPng,
    imagesIconsPrioritiesTrivialPng,
  ];
  final String value;

  const UpdatePriorityDetailsIconUrl._(this.value);

  static UpdatePriorityDetailsIconUrl fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UpdatePriorityDetailsIconUrl._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details about the project.
class UpdateProjectDetails {
  /// The default assignee when creating issues for this project.
  final UpdateProjectDetailsAssigneeType? assigneeType;

  /// An integer value for the project's avatar.
  final int? avatarId;

  /// The ID of the project's category. A complete list of category IDs is found
  /// using the
  /// [Get all project categories](#api-rest-api-3-projectCategory-get)
  /// operation. To remove the project category from the project, set the value
  /// to `-1.`
  final int? categoryId;

  /// A brief description of the project.
  final String? description;

  /// The ID of the issue security scheme for the project, which enables you to
  /// control who can and cannot view issues. Use the
  /// [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get)
  /// resource to get all issue security scheme IDs.
  final int? issueSecurityScheme;

  /// Project keys must be unique and start with an uppercase letter followed by
  /// one or more uppercase alphanumeric characters. The maximum length is 10
  /// characters.
  final String? key;

  /// This parameter is deprecated because of privacy changes. Use
  /// `leadAccountId` instead. See the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details. The user name of the project lead. Cannot be provided with
  /// `leadAccountId`.
  final String? lead;

  /// The account ID of the project lead. Cannot be provided with `lead`.
  final String? leadAccountId;

  /// The name of the project.
  final String? name;

  /// The ID of the notification scheme for the project. Use the
  /// [Get notification schemes](#api-rest-api-3-notificationscheme-get)
  /// resource to get a list of notification scheme IDs.
  final int? notificationScheme;

  /// The ID of the permission scheme for the project. Use the
  /// [Get all permission schemes](#api-rest-api-3-permissionscheme-get)
  /// resource to see a list of all permission scheme IDs.
  final int? permissionScheme;

  /// A link to information about this project, such as project documentation
  final String? url;

  UpdateProjectDetails(
      {this.assigneeType,
      this.avatarId,
      this.categoryId,
      this.description,
      this.issueSecurityScheme,
      this.key,
      this.lead,
      this.leadAccountId,
      this.name,
      this.notificationScheme,
      this.permissionScheme,
      this.url});

  factory UpdateProjectDetails.fromJson(Map<String, Object?> json) {
    return UpdateProjectDetails(
      assigneeType: json[r'assigneeType'] != null
          ? UpdateProjectDetailsAssigneeType.fromValue(
              json[r'assigneeType']! as String)
          : null,
      avatarId: (json[r'avatarId'] as num?)?.toInt(),
      categoryId: (json[r'categoryId'] as num?)?.toInt(),
      description: json[r'description'] as String?,
      issueSecurityScheme: (json[r'issueSecurityScheme'] as num?)?.toInt(),
      key: json[r'key'] as String?,
      lead: json[r'lead'] as String?,
      leadAccountId: json[r'leadAccountId'] as String?,
      name: json[r'name'] as String?,
      notificationScheme: (json[r'notificationScheme'] as num?)?.toInt(),
      permissionScheme: (json[r'permissionScheme'] as num?)?.toInt(),
      url: json[r'url'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var assigneeType = this.assigneeType;
    var avatarId = this.avatarId;
    var categoryId = this.categoryId;
    var description = this.description;
    var issueSecurityScheme = this.issueSecurityScheme;
    var key = this.key;
    var lead = this.lead;
    var leadAccountId = this.leadAccountId;
    var name = this.name;
    var notificationScheme = this.notificationScheme;
    var permissionScheme = this.permissionScheme;
    var url = this.url;

    final json = <String, Object?>{};
    if (assigneeType != null) {
      json[r'assigneeType'] = assigneeType.value;
    }
    if (avatarId != null) {
      json[r'avatarId'] = avatarId;
    }
    if (categoryId != null) {
      json[r'categoryId'] = categoryId;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (issueSecurityScheme != null) {
      json[r'issueSecurityScheme'] = issueSecurityScheme;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (lead != null) {
      json[r'lead'] = lead;
    }
    if (leadAccountId != null) {
      json[r'leadAccountId'] = leadAccountId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (notificationScheme != null) {
      json[r'notificationScheme'] = notificationScheme;
    }
    if (permissionScheme != null) {
      json[r'permissionScheme'] = permissionScheme;
    }
    if (url != null) {
      json[r'url'] = url;
    }
    return json;
  }

  UpdateProjectDetails copyWith(
      {UpdateProjectDetailsAssigneeType? assigneeType,
      int? avatarId,
      int? categoryId,
      String? description,
      int? issueSecurityScheme,
      String? key,
      String? lead,
      String? leadAccountId,
      String? name,
      int? notificationScheme,
      int? permissionScheme,
      String? url}) {
    return UpdateProjectDetails(
      assigneeType: assigneeType ?? this.assigneeType,
      avatarId: avatarId ?? this.avatarId,
      categoryId: categoryId ?? this.categoryId,
      description: description ?? this.description,
      issueSecurityScheme: issueSecurityScheme ?? this.issueSecurityScheme,
      key: key ?? this.key,
      lead: lead ?? this.lead,
      leadAccountId: leadAccountId ?? this.leadAccountId,
      name: name ?? this.name,
      notificationScheme: notificationScheme ?? this.notificationScheme,
      permissionScheme: permissionScheme ?? this.permissionScheme,
      url: url ?? this.url,
    );
  }
}

class UpdateProjectDetailsAssigneeType {
  static const projectLead = UpdateProjectDetailsAssigneeType._('PROJECT_LEAD');
  static const unassigned = UpdateProjectDetailsAssigneeType._('UNASSIGNED');

  static const values = [
    projectLead,
    unassigned,
  ];
  final String value;

  const UpdateProjectDetailsAssigneeType._(this.value);

  static UpdateProjectDetailsAssigneeType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UpdateProjectDetailsAssigneeType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of an issue resolution.
class UpdateResolutionDetails {
  /// The description of the resolution.
  final String? description;

  /// The name of the resolution. Must be unique.
  final String name;

  UpdateResolutionDetails({this.description, required this.name});

  factory UpdateResolutionDetails.fromJson(Map<String, Object?> json) {
    return UpdateResolutionDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'name'] = name;
    return json;
  }

  UpdateResolutionDetails copyWith({String? description, String? name}) {
    return UpdateResolutionDetails(
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// Details of a screen.
class UpdateScreenDetails {
  /// The description of the screen. The maximum length is 255 characters.
  final String? description;

  /// The name of the screen. The name must be unique. The maximum length is 255
  /// characters.
  final String? name;

  UpdateScreenDetails({this.description, this.name});

  factory UpdateScreenDetails.fromJson(Map<String, Object?> json) {
    return UpdateScreenDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  UpdateScreenDetails copyWith({String? description, String? name}) {
    return UpdateScreenDetails(
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

/// Details of a screen scheme.
class UpdateScreenSchemeDetails {
  /// The description of the screen scheme. The maximum length is 255
  /// characters.
  final String? description;

  /// The name of the screen scheme. The name must be unique. The maximum length
  /// is 255 characters.
  final String? name;

  /// The IDs of the screens for the screen types of the screen scheme. Only
  /// screens used in classic projects are accepted.
  final UpdateScreenTypes? screens;

  UpdateScreenSchemeDetails({this.description, this.name, this.screens});

  factory UpdateScreenSchemeDetails.fromJson(Map<String, Object?> json) {
    return UpdateScreenSchemeDetails(
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
      screens: json[r'screens'] != null
          ? UpdateScreenTypes.fromJson(
              json[r'screens']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var name = this.name;
    var screens = this.screens;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (screens != null) {
      json[r'screens'] = screens.toJson();
    }
    return json;
  }

  UpdateScreenSchemeDetails copyWith(
      {String? description, String? name, UpdateScreenTypes? screens}) {
    return UpdateScreenSchemeDetails(
      description: description ?? this.description,
      name: name ?? this.name,
      screens: screens ?? this.screens,
    );
  }
}

/// The IDs of the screens for the screen types of the screen scheme.
class UpdateScreenTypes {
  /// The ID of the create screen. To remove the screen association, pass a
  /// null.
  final String? create;

  /// The ID of the default screen. When specified, must include a screen ID as
  /// a default screen is required.
  final String? default$;

  /// The ID of the edit screen. To remove the screen association, pass a null.
  final String? edit;

  /// The ID of the view screen. To remove the screen association, pass a null.
  final String? view;

  UpdateScreenTypes({this.create, this.default$, this.edit, this.view});

  factory UpdateScreenTypes.fromJson(Map<String, Object?> json) {
    return UpdateScreenTypes(
      create: json[r'create'] as String?,
      default$: json[r'default'] as String?,
      edit: json[r'edit'] as String?,
      view: json[r'view'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var create = this.create;
    var default$ = this.default$;
    var edit = this.edit;
    var view = this.view;

    final json = <String, Object?>{};
    if (create != null) {
      json[r'create'] = create;
    }
    if (default$ != null) {
      json[r'default'] = default$;
    }
    if (edit != null) {
      json[r'edit'] = edit;
    }
    if (view != null) {
      json[r'view'] = view;
    }
    return json;
  }

  UpdateScreenTypes copyWith(
      {String? create, String? default$, String? edit, String? view}) {
    return UpdateScreenTypes(
      create: create ?? this.create,
      default$: default$ ?? this.default$,
      edit: edit ?? this.edit,
      view: view ?? this.view,
    );
  }
}

/// The details of a UI modification.
class UpdateUiModificationDetails {
  /// List of contexts of the UI modification. The maximum number of contexts is
  /// 1000. If provided, replaces all existing contexts.
  final List<UiModificationContextDetails> contexts;

  /// The data of the UI modification. The maximum size of the data is 50000
  /// characters.
  final String? data;

  /// The description of the UI modification. The maximum length is 255
  /// characters.
  final String? description;

  /// The name of the UI modification. The maximum length is 255 characters.
  final String? name;

  UpdateUiModificationDetails(
      {List<UiModificationContextDetails>? contexts,
      this.data,
      this.description,
      this.name})
      : contexts = contexts ?? [];

  factory UpdateUiModificationDetails.fromJson(Map<String, Object?> json) {
    return UpdateUiModificationDetails(
      contexts: (json[r'contexts'] as List<Object?>?)
              ?.map((i) => UiModificationContextDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      data: json[r'data'] as String?,
      description: json[r'description'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var contexts = this.contexts;
    var data = this.data;
    var description = this.description;
    var name = this.name;

    final json = <String, Object?>{};
    json[r'contexts'] = contexts.map((i) => i.toJson()).toList();
    if (data != null) {
      json[r'data'] = data;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  UpdateUiModificationDetails copyWith(
      {List<UiModificationContextDetails>? contexts,
      String? data,
      String? description,
      String? name}) {
    return UpdateUiModificationDetails(
      contexts: contexts ?? this.contexts,
      data: data ?? this.data,
      description: description ?? this.description,
      name: name ?? this.name,
    );
  }
}

class UpdateUserToGroupBean {
  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
  final String? accountId;

  /// This property is no longer available. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? name;

  UpdateUserToGroupBean({this.accountId, this.name});

  factory UpdateUserToGroupBean.fromJson(Map<String, Object?> json) {
    return UpdateUserToGroupBean(
      accountId: json[r'accountId'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var name = this.name;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  UpdateUserToGroupBean copyWith({String? accountId, String? name}) {
    return UpdateUserToGroupBean(
      accountId: accountId ?? this.accountId,
      name: name ?? this.name,
    );
  }
}

/// A project category.
class UpdatedProjectCategory {
  /// The name of the project category.
  final String? description;

  /// The ID of the project category.
  final String? id;

  /// The description of the project category.
  final String? name;

  /// The URL of the project category.
  final String? self;

  UpdatedProjectCategory({this.description, this.id, this.name, this.self});

  factory UpdatedProjectCategory.fromJson(Map<String, Object?> json) {
    return UpdatedProjectCategory(
      description: json[r'description'] as String?,
      id: json[r'id'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var description = this.description;
    var id = this.id;
    var name = this.name;
    var self = this.self;

    final json = <String, Object?>{};
    if (description != null) {
      json[r'description'] = description;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  UpdatedProjectCategory copyWith(
      {String? description, String? id, String? name, String? self}) {
    return UpdatedProjectCategory(
      description: description ?? this.description,
      id: id ?? this.id,
      name: name ?? this.name,
      self: self ?? this.self,
    );
  }
}

/// A user with details as permitted by the user's Atlassian Account privacy
/// settings. However, be aware of these exceptions:
///
///  *  User record deleted from Atlassian: This occurs as the result of a right
/// to be forgotten request. In this case, `displayName` provides an indication
/// and other parameters have default values or are blank (for example, email is
/// blank).
///  *  User record corrupted: This occurs as a results of events such as a
/// server import and can only happen to deleted users. In this case,
/// `accountId` returns *unknown* and all other parameters have fallback values.
///  *  User record unavailable: This usually occurs due to an internal service
/// outage. In this case, all parameters have fallback values.
class User {
  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Required in
  /// requests.
  final String? accountId;

  /// The user account type. Can take the following values:
  ///
  ///  *  `atlassian` regular Atlassian user account
  ///  *  `app` system account used for Connect applications and OAuth to
  /// represent external systems
  ///  *  `customer` Jira Service Desk account representing an external service
  /// desk
  final UserAccountType? accountType;

  /// Whether the user is active.
  final bool active;

  /// The application roles the user is assigned to.
  final SimpleListWrapperApplicationRole? applicationRoles;

  /// The avatars of the user.
  final AvatarUrlsBean? avatarUrls;

  /// The display name of the user. Depending on the user’s privacy setting,
  /// this may return an alternative value.
  final String? displayName;

  /// The email address of the user. Depending on the user’s privacy setting,
  /// this may be returned as null.
  final String? emailAddress;

  /// Expand options that include additional user details in the response.
  final String? expand;

  /// The groups that the user belongs to.
  final SimpleListWrapperGroupName? groups;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? key;

  /// The locale of the user. Depending on the user’s privacy setting, this may
  /// be returned as null.
  final String? locale;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? name;

  /// The URL of the user.
  final String? self;

  /// The time zone specified in the user's profile. Depending on the user’s
  /// privacy setting, this may be returned as null.
  final String? timeZone;

  User(
      {this.accountId,
      this.accountType,
      bool? active,
      this.applicationRoles,
      this.avatarUrls,
      this.displayName,
      this.emailAddress,
      this.expand,
      this.groups,
      this.key,
      this.locale,
      this.name,
      this.self,
      this.timeZone})
      : active = active ?? false;

  factory User.fromJson(Map<String, Object?> json) {
    return User(
      accountId: json[r'accountId'] as String?,
      accountType: json[r'accountType'] != null
          ? UserAccountType.fromValue(json[r'accountType']! as String)
          : null,
      active: json[r'active'] as bool? ?? false,
      applicationRoles: json[r'applicationRoles'] != null
          ? SimpleListWrapperApplicationRole.fromJson(
              json[r'applicationRoles']! as Map<String, Object?>)
          : null,
      avatarUrls: json[r'avatarUrls'] != null
          ? AvatarUrlsBean.fromJson(
              json[r'avatarUrls']! as Map<String, Object?>)
          : null,
      displayName: json[r'displayName'] as String?,
      emailAddress: json[r'emailAddress'] as String?,
      expand: json[r'expand'] as String?,
      groups: json[r'groups'] != null
          ? SimpleListWrapperGroupName.fromJson(
              json[r'groups']! as Map<String, Object?>)
          : null,
      key: json[r'key'] as String?,
      locale: json[r'locale'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
      timeZone: json[r'timeZone'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var accountType = this.accountType;
    var active = this.active;
    var applicationRoles = this.applicationRoles;
    var avatarUrls = this.avatarUrls;
    var displayName = this.displayName;
    var emailAddress = this.emailAddress;
    var expand = this.expand;
    var groups = this.groups;
    var key = this.key;
    var locale = this.locale;
    var name = this.name;
    var self = this.self;
    var timeZone = this.timeZone;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (accountType != null) {
      json[r'accountType'] = accountType.value;
    }
    json[r'active'] = active;
    if (applicationRoles != null) {
      json[r'applicationRoles'] = applicationRoles.toJson();
    }
    if (avatarUrls != null) {
      json[r'avatarUrls'] = avatarUrls.toJson();
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (emailAddress != null) {
      json[r'emailAddress'] = emailAddress;
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (groups != null) {
      json[r'groups'] = groups.toJson();
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (locale != null) {
      json[r'locale'] = locale;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (timeZone != null) {
      json[r'timeZone'] = timeZone;
    }
    return json;
  }

  User copyWith(
      {String? accountId,
      UserAccountType? accountType,
      bool? active,
      SimpleListWrapperApplicationRole? applicationRoles,
      AvatarUrlsBean? avatarUrls,
      String? displayName,
      String? emailAddress,
      String? expand,
      SimpleListWrapperGroupName? groups,
      String? key,
      String? locale,
      String? name,
      String? self,
      String? timeZone}) {
    return User(
      accountId: accountId ?? this.accountId,
      accountType: accountType ?? this.accountType,
      active: active ?? this.active,
      applicationRoles: applicationRoles ?? this.applicationRoles,
      avatarUrls: avatarUrls ?? this.avatarUrls,
      displayName: displayName ?? this.displayName,
      emailAddress: emailAddress ?? this.emailAddress,
      expand: expand ?? this.expand,
      groups: groups ?? this.groups,
      key: key ?? this.key,
      locale: locale ?? this.locale,
      name: name ?? this.name,
      self: self ?? this.self,
      timeZone: timeZone ?? this.timeZone,
    );
  }
}

class UserAccountType {
  static const atlassian = UserAccountType._('atlassian');
  static const app = UserAccountType._('app');
  static const customer = UserAccountType._('customer');
  static const unknown = UserAccountType._('unknown');

  static const values = [
    atlassian,
    app,
    customer,
    unknown,
  ];
  final String value;

  const UserAccountType._(this.value);

  static UserAccountType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UserAccountType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

class UserBean {
  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
  final String? accountId;

  /// Whether the user is active.
  final bool active;

  /// The avatars of the user.
  final UserBeanAvatarUrls? avatarUrls;

  /// The display name of the user. Depending on the user’s privacy setting,
  /// this may return an alternative value.
  final String? displayName;

  /// This property is deprecated in favor of `accountId` because of privacy
  /// changes. See the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  /// The key of the user.
  final String? key;

  /// This property is deprecated in favor of `accountId` because of privacy
  /// changes. See the
  /// [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  /// The username of the user.
  final String? name;

  /// The URL of the user.
  final String? self;

  UserBean(
      {this.accountId,
      bool? active,
      this.avatarUrls,
      this.displayName,
      this.key,
      this.name,
      this.self})
      : active = active ?? false;

  factory UserBean.fromJson(Map<String, Object?> json) {
    return UserBean(
      accountId: json[r'accountId'] as String?,
      active: json[r'active'] as bool? ?? false,
      avatarUrls: json[r'avatarUrls'] != null
          ? UserBeanAvatarUrls.fromJson(
              json[r'avatarUrls']! as Map<String, Object?>)
          : null,
      displayName: json[r'displayName'] as String?,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var active = this.active;
    var avatarUrls = this.avatarUrls;
    var displayName = this.displayName;
    var key = this.key;
    var name = this.name;
    var self = this.self;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    json[r'active'] = active;
    if (avatarUrls != null) {
      json[r'avatarUrls'] = avatarUrls.toJson();
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  UserBean copyWith(
      {String? accountId,
      bool? active,
      UserBeanAvatarUrls? avatarUrls,
      String? displayName,
      String? key,
      String? name,
      String? self}) {
    return UserBean(
      accountId: accountId ?? this.accountId,
      active: active ?? this.active,
      avatarUrls: avatarUrls ?? this.avatarUrls,
      displayName: displayName ?? this.displayName,
      key: key ?? this.key,
      name: name ?? this.name,
      self: self ?? this.self,
    );
  }
}

class UserBeanAvatarUrls {
  /// The URL of the user's 16x16 pixel avatar.
  final String? $16X16;

  /// The URL of the user's 24x24 pixel avatar.
  final String? $24X24;

  /// The URL of the user's 32x32 pixel avatar.
  final String? $32X32;

  /// The URL of the user's 48x48 pixel avatar.
  final String? $48X48;

  UserBeanAvatarUrls({this.$16X16, this.$24X24, this.$32X32, this.$48X48});

  factory UserBeanAvatarUrls.fromJson(Map<String, Object?> json) {
    return UserBeanAvatarUrls(
      $16X16: json[r'16x16'] as String?,
      $24X24: json[r'24x24'] as String?,
      $32X32: json[r'32x32'] as String?,
      $48X48: json[r'48x48'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var $16X16 = this.$16X16;
    var $24X24 = this.$24X24;
    var $32X32 = this.$32X32;
    var $48X48 = this.$48X48;

    final json = <String, Object?>{};
    if ($16X16 != null) {
      json[r'16x16'] = $16X16;
    }
    if ($24X24 != null) {
      json[r'24x24'] = $24X24;
    }
    if ($32X32 != null) {
      json[r'32x32'] = $32X32;
    }
    if ($48X48 != null) {
      json[r'48x48'] = $48X48;
    }
    return json;
  }

  UserBeanAvatarUrls copyWith(
      {String? $16X16, String? $24X24, String? $32X32, String? $48X48}) {
    return UserBeanAvatarUrls(
      $16X16: $16X16 ?? this.$16X16,
      $24X24: $24X24 ?? this.$24X24,
      $32X32: $32X32 ?? this.$32X32,
      $48X48: $48X48 ?? this.$48X48,
    );
  }
}

/// A
/// [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user)
/// specified as an Atlassian account ID.
class UserContextVariable {
  /// The account ID of the user.
  final String accountId;

  /// Type of custom context variable.
  final String type;

  UserContextVariable({required this.accountId, required this.type});

  factory UserContextVariable.fromJson(Map<String, Object?> json) {
    return UserContextVariable(
      accountId: json[r'accountId'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'accountId'] = accountId;
    json[r'type'] = type;
    return json;
  }

  UserContextVariable copyWith({String? accountId, String? type}) {
    return UserContextVariable(
      accountId: accountId ?? this.accountId,
      type: type ?? this.type,
    );
  }
}

/// User details permitted by the user's Atlassian Account privacy settings.
/// However, be aware of these exceptions:
///
///  *  User record deleted from Atlassian: This occurs as the result of a right
/// to be forgotten request. In this case, `displayName` provides an indication
/// and other parameters have default values or are blank (for example, email is
/// blank).
///  *  User record corrupted: This occurs as a results of events such as a
/// server import and can only happen to deleted users. In this case,
/// `accountId` returns *unknown* and all other parameters have fallback values.
///  *  User record unavailable: This usually occurs due to an internal service
/// outage. In this case, all parameters have fallback values.
class UserDetails {
  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
  final String? accountId;

  /// The type of account represented by this user. This will be one of
  /// 'atlassian' (normal users), 'app' (application user) or 'customer' (Jira
  /// Service Desk customer user)
  final String? accountType;

  /// Whether the user is active.
  final bool active;

  /// The avatars of the user.
  final AvatarUrlsBean? avatarUrls;

  /// The display name of the user. Depending on the user’s privacy settings,
  /// this may return an alternative value.
  final String? displayName;

  /// The email address of the user. Depending on the user’s privacy settings,
  /// this may be returned as null.
  final String? emailAddress;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? key;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? name;

  /// The URL of the user.
  final String? self;

  /// The time zone specified in the user's profile. Depending on the user’s
  /// privacy settings, this may be returned as null.
  final String? timeZone;

  UserDetails(
      {this.accountId,
      this.accountType,
      bool? active,
      this.avatarUrls,
      this.displayName,
      this.emailAddress,
      this.key,
      this.name,
      this.self,
      this.timeZone})
      : active = active ?? false;

  factory UserDetails.fromJson(Map<String, Object?> json) {
    return UserDetails(
      accountId: json[r'accountId'] as String?,
      accountType: json[r'accountType'] as String?,
      active: json[r'active'] as bool? ?? false,
      avatarUrls: json[r'avatarUrls'] != null
          ? AvatarUrlsBean.fromJson(
              json[r'avatarUrls']! as Map<String, Object?>)
          : null,
      displayName: json[r'displayName'] as String?,
      emailAddress: json[r'emailAddress'] as String?,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      self: json[r'self'] as String?,
      timeZone: json[r'timeZone'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var accountType = this.accountType;
    var active = this.active;
    var avatarUrls = this.avatarUrls;
    var displayName = this.displayName;
    var emailAddress = this.emailAddress;
    var key = this.key;
    var name = this.name;
    var self = this.self;
    var timeZone = this.timeZone;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (accountType != null) {
      json[r'accountType'] = accountType;
    }
    json[r'active'] = active;
    if (avatarUrls != null) {
      json[r'avatarUrls'] = avatarUrls.toJson();
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (emailAddress != null) {
      json[r'emailAddress'] = emailAddress;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    if (timeZone != null) {
      json[r'timeZone'] = timeZone;
    }
    return json;
  }

  UserDetails copyWith(
      {String? accountId,
      String? accountType,
      bool? active,
      AvatarUrlsBean? avatarUrls,
      String? displayName,
      String? emailAddress,
      String? key,
      String? name,
      String? self,
      String? timeZone}) {
    return UserDetails(
      accountId: accountId ?? this.accountId,
      accountType: accountType ?? this.accountType,
      active: active ?? this.active,
      avatarUrls: avatarUrls ?? this.avatarUrls,
      displayName: displayName ?? this.displayName,
      emailAddress: emailAddress ?? this.emailAddress,
      key: key ?? this.key,
      name: name ?? this.name,
      self: self ?? this.self,
      timeZone: timeZone ?? this.timeZone,
    );
  }
}

/// Filter for a User Picker (single) custom field.
class UserFilter {
  /// Whether the filter is enabled.
  final bool enabled;

  /// User groups autocomplete suggestion users must belong to. If not provided,
  /// the default values are used. A maximum of 10 groups can be provided.
  final List<String> groups;

  /// Roles that autocomplete suggestion users must belong to. If not provided,
  /// the default values are used. A maximum of 10 roles can be provided.
  final List<int> roleIds;

  UserFilter({required this.enabled, List<String>? groups, List<int>? roleIds})
      : groups = groups ?? [],
        roleIds = roleIds ?? [];

  factory UserFilter.fromJson(Map<String, Object?> json) {
    return UserFilter(
      enabled: json[r'enabled'] as bool? ?? false,
      groups: (json[r'groups'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      roleIds: (json[r'roleIds'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var enabled = this.enabled;
    var groups = this.groups;
    var roleIds = this.roleIds;

    final json = <String, Object?>{};
    json[r'enabled'] = enabled;
    json[r'groups'] = groups;
    json[r'roleIds'] = roleIds;
    return json;
  }

  UserFilter copyWith(
      {bool? enabled, List<String>? groups, List<int>? roleIds}) {
    return UserFilter(
      enabled: enabled ?? this.enabled,
      groups: groups ?? this.groups,
      roleIds: roleIds ?? this.roleIds,
    );
  }
}

/// List of user account IDs.
class UserKey {
  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Returns
  /// *unknown* if the record is deleted and corrupted, for example, as the
  /// result of a server import.
  final String? accountId;

  /// This property is no longer available and will be removed from the
  /// documentation soon. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? key;

  UserKey({this.accountId, this.key});

  factory UserKey.fromJson(Map<String, Object?> json) {
    return UserKey(
      accountId: json[r'accountId'] as String?,
      key: json[r'key'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var key = this.key;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    return json;
  }

  UserKey copyWith({String? accountId, String? key}) {
    return UserKey(
      accountId: accountId ?? this.accountId,
      key: key ?? this.key,
    );
  }
}

/// A paginated list of users sharing the filter. This includes users that are
/// members of the groups or can browse the projects that the filter is shared
/// with.
class UserList {
  /// The index of the last item returned on the page.
  final int? endIndex;

  /// The list of items.
  final List<User> items;

  /// The maximum number of results that could be on the page.
  final int? maxResults;

  /// The number of items on the page.
  final int? size;

  /// The index of the first item returned on the page.
  final int? startIndex;

  UserList(
      {this.endIndex,
      List<User>? items,
      this.maxResults,
      this.size,
      this.startIndex})
      : items = items ?? [];

  factory UserList.fromJson(Map<String, Object?> json) {
    return UserList(
      endIndex: (json[r'end-index'] as num?)?.toInt(),
      items: (json[r'items'] as List<Object?>?)
              ?.map(
                  (i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      maxResults: (json[r'max-results'] as num?)?.toInt(),
      size: (json[r'size'] as num?)?.toInt(),
      startIndex: (json[r'start-index'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var endIndex = this.endIndex;
    var items = this.items;
    var maxResults = this.maxResults;
    var size = this.size;
    var startIndex = this.startIndex;

    final json = <String, Object?>{};
    if (endIndex != null) {
      json[r'end-index'] = endIndex;
    }
    json[r'items'] = items.map((i) => i.toJson()).toList();
    if (maxResults != null) {
      json[r'max-results'] = maxResults;
    }
    if (size != null) {
      json[r'size'] = size;
    }
    if (startIndex != null) {
      json[r'start-index'] = startIndex;
    }
    return json;
  }

  UserList copyWith(
      {int? endIndex,
      List<User>? items,
      int? maxResults,
      int? size,
      int? startIndex}) {
    return UserList(
      endIndex: endIndex ?? this.endIndex,
      items: items ?? this.items,
      maxResults: maxResults ?? this.maxResults,
      size: size ?? this.size,
      startIndex: startIndex ?? this.startIndex,
    );
  }
}

class UserMigrationBean {
  final String? accountId;
  final String? key;
  final String? username;

  UserMigrationBean({this.accountId, this.key, this.username});

  factory UserMigrationBean.fromJson(Map<String, Object?> json) {
    return UserMigrationBean(
      accountId: json[r'accountId'] as String?,
      key: json[r'key'] as String?,
      username: json[r'username'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var key = this.key;
    var username = this.username;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (username != null) {
      json[r'username'] = username;
    }
    return json;
  }

  UserMigrationBean copyWith(
      {String? accountId, String? key, String? username}) {
    return UserMigrationBean(
      accountId: accountId ?? this.accountId,
      key: key ?? this.key,
      username: username ?? this.username,
    );
  }
}

/// Details of a permission and its availability to a user.
class UserPermission {
  /// Indicate whether the permission key is deprecated. Note that deprecated
  /// keys cannot be used in the `permissions parameter of Get my permissions.
  /// Deprecated keys are not returned by Get all permissions.`
  final bool deprecatedKey;

  /// The description of the permission.
  final String? description;

  /// Whether the permission is available to the user in the queried context.
  final bool havePermission;

  /// The ID of the permission. Either `id` or `key` must be specified. Use
  /// [Get all permissions](#api-rest-api-3-permissions-get) to get the list of
  /// permissions.
  final String? id;

  /// The key of the permission. Either `id` or `key` must be specified. Use
  /// [Get all permissions](#api-rest-api-3-permissions-get) to get the list of
  /// permissions.
  final String? key;

  /// The name of the permission.
  final String? name;

  /// The type of the permission.
  final UserPermissionType? type;

  UserPermission(
      {bool? deprecatedKey,
      this.description,
      bool? havePermission,
      this.id,
      this.key,
      this.name,
      this.type})
      : deprecatedKey = deprecatedKey ?? false,
        havePermission = havePermission ?? false;

  factory UserPermission.fromJson(Map<String, Object?> json) {
    return UserPermission(
      deprecatedKey: json[r'deprecatedKey'] as bool? ?? false,
      description: json[r'description'] as String?,
      havePermission: json[r'havePermission'] as bool? ?? false,
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
      type: json[r'type'] != null
          ? UserPermissionType.fromValue(json[r'type']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var deprecatedKey = this.deprecatedKey;
    var description = this.description;
    var havePermission = this.havePermission;
    var id = this.id;
    var key = this.key;
    var name = this.name;
    var type = this.type;

    final json = <String, Object?>{};
    json[r'deprecatedKey'] = deprecatedKey;
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'havePermission'] = havePermission;
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    return json;
  }

  UserPermission copyWith(
      {bool? deprecatedKey,
      String? description,
      bool? havePermission,
      String? id,
      String? key,
      String? name,
      UserPermissionType? type}) {
    return UserPermission(
      deprecatedKey: deprecatedKey ?? this.deprecatedKey,
      description: description ?? this.description,
      havePermission: havePermission ?? this.havePermission,
      id: id ?? this.id,
      key: key ?? this.key,
      name: name ?? this.name,
      type: type ?? this.type,
    );
  }
}

class UserPermissionType {
  static const global = UserPermissionType._('GLOBAL');
  static const project = UserPermissionType._('PROJECT');

  static const values = [
    global,
    project,
  ];
  final String value;

  const UserPermissionType._(this.value);

  static UserPermissionType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => UserPermissionType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A user found in a search.
class UserPickerUser {
  /// The account ID of the user, which uniquely identifies the user across all
  /// Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
  final String? accountId;

  /// The avatar URL of the user.
  final String? avatarUrl;

  /// The display name of the user. Depending on the user’s privacy setting,
  /// this may be returned as null.
  final String? displayName;

  /// The display name, email address, and key of the user with the matched
  /// query string highlighted with the HTML bold tag.
  final String? html;

  /// This property is no longer available. See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? key;

  /// This property is no longer available . See the
  /// [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/)
  /// for details.
  final String? name;

  UserPickerUser(
      {this.accountId,
      this.avatarUrl,
      this.displayName,
      this.html,
      this.key,
      this.name});

  factory UserPickerUser.fromJson(Map<String, Object?> json) {
    return UserPickerUser(
      accountId: json[r'accountId'] as String?,
      avatarUrl: json[r'avatarUrl'] as String?,
      displayName: json[r'displayName'] as String?,
      html: json[r'html'] as String?,
      key: json[r'key'] as String?,
      name: json[r'name'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var accountId = this.accountId;
    var avatarUrl = this.avatarUrl;
    var displayName = this.displayName;
    var html = this.html;
    var key = this.key;
    var name = this.name;

    final json = <String, Object?>{};
    if (accountId != null) {
      json[r'accountId'] = accountId;
    }
    if (avatarUrl != null) {
      json[r'avatarUrl'] = avatarUrl;
    }
    if (displayName != null) {
      json[r'displayName'] = displayName;
    }
    if (html != null) {
      json[r'html'] = html;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    return json;
  }

  UserPickerUser copyWith(
      {String? accountId,
      String? avatarUrl,
      String? displayName,
      String? html,
      String? key,
      String? name}) {
    return UserPickerUser(
      accountId: accountId ?? this.accountId,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      displayName: displayName ?? this.displayName,
      html: html ?? this.html,
      key: key ?? this.key,
      name: name ?? this.name,
    );
  }
}

/// An operand that is a user-provided value.
class ValueOperand {
  /// Encoded value, which can be used directly in a JQL query.
  final String? encodedValue;

  /// The operand value.
  final String value;

  ValueOperand({this.encodedValue, required this.value});

  factory ValueOperand.fromJson(Map<String, Object?> json) {
    return ValueOperand(
      encodedValue: json[r'encodedValue'] as String?,
      value: json[r'value'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var encodedValue = this.encodedValue;
    var value = this.value;

    final json = <String, Object?>{};
    if (encodedValue != null) {
      json[r'encodedValue'] = encodedValue;
    }
    json[r'value'] = value;
    return json;
  }

  ValueOperand copyWith({String? encodedValue, String? value}) {
    return ValueOperand(
      encodedValue: encodedValue ?? this.encodedValue,
      value: value ?? this.value,
    );
  }
}

/// Details about a project version.
class Version {
  /// Indicates that the version is archived. Optional when creating or updating
  /// a version.
  final bool archived;

  /// The description of the version. Optional when creating or updating a
  /// version.
  final String? description;

  /// Use [expand](em>#expansion) to include additional information about
  /// version in the response. This parameter accepts a comma-separated list.
  /// Expand options include:
  ///
  ///  *  `operations` Returns the list of operations available for this
  /// version.
  ///  *  `issuesstatus` Returns the count of issues in this version for each of
  /// the status categories *to do*, *in progress*, *done*, and *unmapped*. The
  /// *unmapped* property contains a count of issues with a status other than
  /// *to do*, *in progress*, and *done*.
  ///
  /// Optional for create and update.
  final String? expand;

  /// The ID of the version.
  final String? id;

  /// If the expand option `issuesstatus` is used, returns the count of issues
  /// in this version for each of the status categories *to do*, *in progress*,
  /// *done*, and *unmapped*. The *unmapped* property contains a count of issues
  /// with a status other than *to do*, *in progress*, and *done*.
  final VersionIssuesStatus? issuesStatusForFixVersion;

  /// The URL of the self link to the version to which all unfixed issues are
  /// moved when a version is released. Not applicable when creating a version.
  /// Optional when updating a version.
  final String? moveUnfixedIssuesTo;

  /// The unique name of the version. Required when creating a version. Optional
  /// when updating a version. The maximum length is 255 characters.
  final String? name;

  /// If the expand option `operations` is used, returns the list of operations
  /// available for this version.
  final List<SimpleLink> operations;

  /// Indicates that the version is overdue.
  final bool overdue;

  /// Deprecated. Use `projectId`.
  final String? project;

  /// The ID of the project to which this version is attached. Required when
  /// creating a version. Not applicable when updating a version.
  final int? projectId;

  /// The release date of the version. Expressed in ISO 8601 format
  /// (yyyy-mm-dd). Optional when creating or updating a version.
  final String? releaseDate;

  /// Indicates that the version is released. If the version is released a
  /// request to release again is ignored. Not applicable when creating a
  /// version. Optional when updating a version.
  final bool released;

  /// The URL of the version.
  final String? self;

  /// The start date of the version. Expressed in ISO 8601 format (yyyy-mm-dd).
  /// Optional when creating or updating a version.
  final String? startDate;

  /// The date on which work on this version is expected to finish, expressed in
  /// the instance's *Day/Month/Year Format* date format.
  final String? userReleaseDate;

  /// The date on which work on this version is expected to start, expressed in
  /// the instance's *Day/Month/Year Format* date format.
  final String? userStartDate;

  Version(
      {bool? archived,
      this.description,
      this.expand,
      this.id,
      this.issuesStatusForFixVersion,
      this.moveUnfixedIssuesTo,
      this.name,
      List<SimpleLink>? operations,
      bool? overdue,
      this.project,
      this.projectId,
      this.releaseDate,
      bool? released,
      this.self,
      this.startDate,
      this.userReleaseDate,
      this.userStartDate})
      : archived = archived ?? false,
        operations = operations ?? [],
        overdue = overdue ?? false,
        released = released ?? false;

  factory Version.fromJson(Map<String, Object?> json) {
    return Version(
      archived: json[r'archived'] as bool? ?? false,
      description: json[r'description'] as String?,
      expand: json[r'expand'] as String?,
      id: json[r'id'] as String?,
      issuesStatusForFixVersion: json[r'issuesStatusForFixVersion'] != null
          ? VersionIssuesStatus.fromJson(
              json[r'issuesStatusForFixVersion']! as Map<String, Object?>)
          : null,
      moveUnfixedIssuesTo: json[r'moveUnfixedIssuesTo'] as String?,
      name: json[r'name'] as String?,
      operations: (json[r'operations'] as List<Object?>?)
              ?.map((i) =>
                  SimpleLink.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      overdue: json[r'overdue'] as bool? ?? false,
      project: json[r'project'] as String?,
      projectId: (json[r'projectId'] as num?)?.toInt(),
      releaseDate: json[r'releaseDate'] as String?,
      released: json[r'released'] as bool? ?? false,
      self: json[r'self'] as String?,
      startDate: json[r'startDate'] as String?,
      userReleaseDate: json[r'userReleaseDate'] as String?,
      userStartDate: json[r'userStartDate'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var archived = this.archived;
    var description = this.description;
    var expand = this.expand;
    var id = this.id;
    var issuesStatusForFixVersion = this.issuesStatusForFixVersion;
    var moveUnfixedIssuesTo = this.moveUnfixedIssuesTo;
    var name = this.name;
    var operations = this.operations;
    var overdue = this.overdue;
    var project = this.project;
    var projectId = this.projectId;
    var releaseDate = this.releaseDate;
    var released = this.released;
    var self = this.self;
    var startDate = this.startDate;
    var userReleaseDate = this.userReleaseDate;
    var userStartDate = this.userStartDate;

    final json = <String, Object?>{};
    json[r'archived'] = archived;
    if (description != null) {
      json[r'description'] = description;
    }
    if (expand != null) {
      json[r'expand'] = expand;
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (issuesStatusForFixVersion != null) {
      json[r'issuesStatusForFixVersion'] = issuesStatusForFixVersion.toJson();
    }
    if (moveUnfixedIssuesTo != null) {
      json[r'moveUnfixedIssuesTo'] = moveUnfixedIssuesTo;
    }
    if (name != null) {
      json[r'name'] = name;
    }
    json[r'operations'] = operations.map((i) => i.toJson()).toList();
    json[r'overdue'] = overdue;
    if (project != null) {
      json[r'project'] = project;
    }
    if (projectId != null) {
      json[r'projectId'] = projectId;
    }
    if (releaseDate != null) {
      json[r'releaseDate'] = releaseDate;
    }
    json[r'released'] = released;
    if (self != null) {
      json[r'self'] = self;
    }
    if (startDate != null) {
      json[r'startDate'] = startDate;
    }
    if (userReleaseDate != null) {
      json[r'userReleaseDate'] = userReleaseDate;
    }
    if (userStartDate != null) {
      json[r'userStartDate'] = userStartDate;
    }
    return json;
  }

  Version copyWith(
      {bool? archived,
      String? description,
      String? expand,
      String? id,
      VersionIssuesStatus? issuesStatusForFixVersion,
      String? moveUnfixedIssuesTo,
      String? name,
      List<SimpleLink>? operations,
      bool? overdue,
      String? project,
      int? projectId,
      String? releaseDate,
      bool? released,
      String? self,
      String? startDate,
      String? userReleaseDate,
      String? userStartDate}) {
    return Version(
      archived: archived ?? this.archived,
      description: description ?? this.description,
      expand: expand ?? this.expand,
      id: id ?? this.id,
      issuesStatusForFixVersion:
          issuesStatusForFixVersion ?? this.issuesStatusForFixVersion,
      moveUnfixedIssuesTo: moveUnfixedIssuesTo ?? this.moveUnfixedIssuesTo,
      name: name ?? this.name,
      operations: operations ?? this.operations,
      overdue: overdue ?? this.overdue,
      project: project ?? this.project,
      projectId: projectId ?? this.projectId,
      releaseDate: releaseDate ?? this.releaseDate,
      released: released ?? this.released,
      self: self ?? this.self,
      startDate: startDate ?? this.startDate,
      userReleaseDate: userReleaseDate ?? this.userReleaseDate,
      userStartDate: userStartDate ?? this.userStartDate,
    );
  }
}

/// Various counts of issues within a version.
class VersionIssueCounts {
  /// List of custom fields using the version.
  final List<VersionUsageInCustomField> customFieldUsage;

  /// Count of issues where a version custom field is set to the version.
  final int? issueCountWithCustomFieldsShowingVersion;

  /// Count of issues where the `affectedVersion` is set to the version.
  final int? issuesAffectedCount;

  /// Count of issues where the `fixVersion` is set to the version.
  final int? issuesFixedCount;

  /// The URL of these count details.
  final String? self;

  VersionIssueCounts(
      {List<VersionUsageInCustomField>? customFieldUsage,
      this.issueCountWithCustomFieldsShowingVersion,
      this.issuesAffectedCount,
      this.issuesFixedCount,
      this.self})
      : customFieldUsage = customFieldUsage ?? [];

  factory VersionIssueCounts.fromJson(Map<String, Object?> json) {
    return VersionIssueCounts(
      customFieldUsage: (json[r'customFieldUsage'] as List<Object?>?)
              ?.map((i) => VersionUsageInCustomField.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      issueCountWithCustomFieldsShowingVersion:
          (json[r'issueCountWithCustomFieldsShowingVersion'] as num?)?.toInt(),
      issuesAffectedCount: (json[r'issuesAffectedCount'] as num?)?.toInt(),
      issuesFixedCount: (json[r'issuesFixedCount'] as num?)?.toInt(),
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var customFieldUsage = this.customFieldUsage;
    var issueCountWithCustomFieldsShowingVersion =
        this.issueCountWithCustomFieldsShowingVersion;
    var issuesAffectedCount = this.issuesAffectedCount;
    var issuesFixedCount = this.issuesFixedCount;
    var self = this.self;

    final json = <String, Object?>{};
    json[r'customFieldUsage'] =
        customFieldUsage.map((i) => i.toJson()).toList();
    if (issueCountWithCustomFieldsShowingVersion != null) {
      json[r'issueCountWithCustomFieldsShowingVersion'] =
          issueCountWithCustomFieldsShowingVersion;
    }
    if (issuesAffectedCount != null) {
      json[r'issuesAffectedCount'] = issuesAffectedCount;
    }
    if (issuesFixedCount != null) {
      json[r'issuesFixedCount'] = issuesFixedCount;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  VersionIssueCounts copyWith(
      {List<VersionUsageInCustomField>? customFieldUsage,
      int? issueCountWithCustomFieldsShowingVersion,
      int? issuesAffectedCount,
      int? issuesFixedCount,
      String? self}) {
    return VersionIssueCounts(
      customFieldUsage: customFieldUsage ?? this.customFieldUsage,
      issueCountWithCustomFieldsShowingVersion:
          issueCountWithCustomFieldsShowingVersion ??
              this.issueCountWithCustomFieldsShowingVersion,
      issuesAffectedCount: issuesAffectedCount ?? this.issuesAffectedCount,
      issuesFixedCount: issuesFixedCount ?? this.issuesFixedCount,
      self: self ?? this.self,
    );
  }
}

/// Counts of the number of issues in various statuses.
class VersionIssuesStatus {
  /// Count of issues with status *done*.
  final int? done;

  /// Count of issues with status *in progress*.
  final int? inProgress;

  /// Count of issues with status *to do*.
  final int? toDo;

  /// Count of issues with a status other than *to do*, *in progress*, and
  /// *done*.
  final int? unmapped;

  VersionIssuesStatus({this.done, this.inProgress, this.toDo, this.unmapped});

  factory VersionIssuesStatus.fromJson(Map<String, Object?> json) {
    return VersionIssuesStatus(
      done: (json[r'done'] as num?)?.toInt(),
      inProgress: (json[r'inProgress'] as num?)?.toInt(),
      toDo: (json[r'toDo'] as num?)?.toInt(),
      unmapped: (json[r'unmapped'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var done = this.done;
    var inProgress = this.inProgress;
    var toDo = this.toDo;
    var unmapped = this.unmapped;

    final json = <String, Object?>{};
    if (done != null) {
      json[r'done'] = done;
    }
    if (inProgress != null) {
      json[r'inProgress'] = inProgress;
    }
    if (toDo != null) {
      json[r'toDo'] = toDo;
    }
    if (unmapped != null) {
      json[r'unmapped'] = unmapped;
    }
    return json;
  }

  VersionIssuesStatus copyWith(
      {int? done, int? inProgress, int? toDo, int? unmapped}) {
    return VersionIssuesStatus(
      done: done ?? this.done,
      inProgress: inProgress ?? this.inProgress,
      toDo: toDo ?? this.toDo,
      unmapped: unmapped ?? this.unmapped,
    );
  }
}

class VersionMoveBean {
  /// The URL (self link) of the version after which to place the moved version.
  /// Cannot be used with `position`.
  final String? after;

  /// An absolute position in which to place the moved version. Cannot be used
  /// with `after`.
  final VersionMoveBeanPosition? position;

  VersionMoveBean({this.after, this.position});

  factory VersionMoveBean.fromJson(Map<String, Object?> json) {
    return VersionMoveBean(
      after: json[r'after'] as String?,
      position: json[r'position'] != null
          ? VersionMoveBeanPosition.fromValue(json[r'position']! as String)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var after = this.after;
    var position = this.position;

    final json = <String, Object?>{};
    if (after != null) {
      json[r'after'] = after;
    }
    if (position != null) {
      json[r'position'] = position.value;
    }
    return json;
  }

  VersionMoveBean copyWith({String? after, VersionMoveBeanPosition? position}) {
    return VersionMoveBean(
      after: after ?? this.after,
      position: position ?? this.position,
    );
  }
}

class VersionMoveBeanPosition {
  static const earlier = VersionMoveBeanPosition._('Earlier');
  static const later = VersionMoveBeanPosition._('Later');
  static const first = VersionMoveBeanPosition._('First');
  static const last = VersionMoveBeanPosition._('Last');

  static const values = [
    earlier,
    later,
    first,
    last,
  ];
  final String value;

  const VersionMoveBeanPosition._(this.value);

  static VersionMoveBeanPosition fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => VersionMoveBeanPosition._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Count of a version's unresolved issues.
class VersionUnresolvedIssuesCount {
  /// Count of issues.
  final int? issuesCount;

  /// Count of unresolved issues.
  final int? issuesUnresolvedCount;

  /// The URL of these count details.
  final String? self;

  VersionUnresolvedIssuesCount(
      {this.issuesCount, this.issuesUnresolvedCount, this.self});

  factory VersionUnresolvedIssuesCount.fromJson(Map<String, Object?> json) {
    return VersionUnresolvedIssuesCount(
      issuesCount: (json[r'issuesCount'] as num?)?.toInt(),
      issuesUnresolvedCount: (json[r'issuesUnresolvedCount'] as num?)?.toInt(),
      self: json[r'self'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var issuesCount = this.issuesCount;
    var issuesUnresolvedCount = this.issuesUnresolvedCount;
    var self = this.self;

    final json = <String, Object?>{};
    if (issuesCount != null) {
      json[r'issuesCount'] = issuesCount;
    }
    if (issuesUnresolvedCount != null) {
      json[r'issuesUnresolvedCount'] = issuesUnresolvedCount;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    return json;
  }

  VersionUnresolvedIssuesCount copyWith(
      {int? issuesCount, int? issuesUnresolvedCount, String? self}) {
    return VersionUnresolvedIssuesCount(
      issuesCount: issuesCount ?? this.issuesCount,
      issuesUnresolvedCount:
          issuesUnresolvedCount ?? this.issuesUnresolvedCount,
      self: self ?? this.self,
    );
  }
}

/// List of custom fields using the version.
class VersionUsageInCustomField {
  /// The ID of the custom field.
  final int? customFieldId;

  /// The name of the custom field.
  final String? fieldName;

  /// Count of the issues where the custom field contains the version.
  final int? issueCountWithVersionInCustomField;

  VersionUsageInCustomField(
      {this.customFieldId,
      this.fieldName,
      this.issueCountWithVersionInCustomField});

  factory VersionUsageInCustomField.fromJson(Map<String, Object?> json) {
    return VersionUsageInCustomField(
      customFieldId: (json[r'customFieldId'] as num?)?.toInt(),
      fieldName: json[r'fieldName'] as String?,
      issueCountWithVersionInCustomField:
          (json[r'issueCountWithVersionInCustomField'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var customFieldId = this.customFieldId;
    var fieldName = this.fieldName;
    var issueCountWithVersionInCustomField =
        this.issueCountWithVersionInCustomField;

    final json = <String, Object?>{};
    if (customFieldId != null) {
      json[r'customFieldId'] = customFieldId;
    }
    if (fieldName != null) {
      json[r'fieldName'] = fieldName;
    }
    if (issueCountWithVersionInCustomField != null) {
      json[r'issueCountWithVersionInCustomField'] =
          issueCountWithVersionInCustomField;
    }
    return json;
  }

  VersionUsageInCustomField copyWith(
      {int? customFieldId,
      String? fieldName,
      int? issueCountWithVersionInCustomField}) {
    return VersionUsageInCustomField(
      customFieldId: customFieldId ?? this.customFieldId,
      fieldName: fieldName ?? this.fieldName,
      issueCountWithVersionInCustomField: issueCountWithVersionInCustomField ??
          this.issueCountWithVersionInCustomField,
    );
  }
}

/// The group or role to which this item is visible.
class Visibility {
  /// The ID of the group or the name of the role that visibility of this item
  /// is restricted to.
  final String? identifier;

  /// Whether visibility of this item is restricted to a group or role.
  final VisibilityType? type;

  /// The name of the group or role that visibility of this item is restricted
  /// to. Please note that the name of a group is mutable, to reliably identify
  /// a group use `identifier`.
  final String? value;

  Visibility({this.identifier, this.type, this.value});

  factory Visibility.fromJson(Map<String, Object?> json) {
    return Visibility(
      identifier: json[r'identifier'] as String?,
      type: json[r'type'] != null
          ? VisibilityType.fromValue(json[r'type']! as String)
          : null,
      value: json[r'value'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var identifier = this.identifier;
    var type = this.type;
    var value = this.value;

    final json = <String, Object?>{};
    if (identifier != null) {
      json[r'identifier'] = identifier;
    }
    if (type != null) {
      json[r'type'] = type.value;
    }
    if (value != null) {
      json[r'value'] = value;
    }
    return json;
  }

  Visibility copyWith(
      {String? identifier, VisibilityType? type, String? value}) {
    return Visibility(
      identifier: identifier ?? this.identifier,
      type: type ?? this.type,
      value: value ?? this.value,
    );
  }
}

class VisibilityType {
  static const group = VisibilityType._('group');
  static const role = VisibilityType._('role');

  static const values = [
    group,
    role,
  ];
  final String value;

  const VisibilityType._(this.value);

  static VisibilityType fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => VisibilityType._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The details of votes on an issue.
class Votes {
  /// Whether the user making this request has voted on the issue.
  final bool hasVoted;

  /// The URL of these issue vote details.
  final String? self;

  /// List of the users who have voted on this issue. An empty list is returned
  /// when the calling user doesn't have the *View voters and watchers* project
  /// permission.
  final List<User> voters;

  /// The number of votes on the issue.
  final int? votes;

  Votes({bool? hasVoted, this.self, List<User>? voters, this.votes})
      : hasVoted = hasVoted ?? false,
        voters = voters ?? [];

  factory Votes.fromJson(Map<String, Object?> json) {
    return Votes(
      hasVoted: json[r'hasVoted'] as bool? ?? false,
      self: json[r'self'] as String?,
      voters: (json[r'voters'] as List<Object?>?)
              ?.map(
                  (i) => User.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      votes: (json[r'votes'] as num?)?.toInt(),
    );
  }

  Map<String, Object?> toJson() {
    var hasVoted = this.hasVoted;
    var self = this.self;
    var voters = this.voters;
    var votes = this.votes;

    final json = <String, Object?>{};
    json[r'hasVoted'] = hasVoted;
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'voters'] = voters.map((i) => i.toJson()).toList();
    if (votes != null) {
      json[r'votes'] = votes;
    }
    return json;
  }

  Votes copyWith(
      {bool? hasVoted, String? self, List<User>? voters, int? votes}) {
    return Votes(
      hasVoted: hasVoted ?? this.hasVoted,
      self: self ?? this.self,
      voters: voters ?? this.voters,
      votes: votes ?? this.votes,
    );
  }
}

class WarningCollection {
  final List<String> warnings;

  WarningCollection({List<String>? warnings}) : warnings = warnings ?? [];

  factory WarningCollection.fromJson(Map<String, Object?> json) {
    return WarningCollection(
      warnings: (json[r'warnings'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var warnings = this.warnings;

    final json = <String, Object?>{};
    json[r'warnings'] = warnings;
    return json;
  }

  WarningCollection copyWith({List<String>? warnings}) {
    return WarningCollection(
      warnings: warnings ?? this.warnings,
    );
  }
}

/// The details of watchers on an issue.
class Watchers {
  /// Whether the calling user is watching this issue.
  final bool isWatching;

  /// The URL of these issue watcher details.
  final String? self;

  /// The number of users watching this issue.
  final int? watchCount;

  /// Details of the users watching this issue.
  final List<UserDetails> watchers;

  Watchers(
      {bool? isWatching,
      this.self,
      this.watchCount,
      List<UserDetails>? watchers})
      : isWatching = isWatching ?? false,
        watchers = watchers ?? [];

  factory Watchers.fromJson(Map<String, Object?> json) {
    return Watchers(
      isWatching: json[r'isWatching'] as bool? ?? false,
      self: json[r'self'] as String?,
      watchCount: (json[r'watchCount'] as num?)?.toInt(),
      watchers: (json[r'watchers'] as List<Object?>?)
              ?.map((i) =>
                  UserDetails.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var isWatching = this.isWatching;
    var self = this.self;
    var watchCount = this.watchCount;
    var watchers = this.watchers;

    final json = <String, Object?>{};
    json[r'isWatching'] = isWatching;
    if (self != null) {
      json[r'self'] = self;
    }
    if (watchCount != null) {
      json[r'watchCount'] = watchCount;
    }
    json[r'watchers'] = watchers.map((i) => i.toJson()).toList();
    return json;
  }

  Watchers copyWith(
      {bool? isWatching,
      String? self,
      int? watchCount,
      List<UserDetails>? watchers}) {
    return Watchers(
      isWatching: isWatching ?? this.isWatching,
      self: self ?? this.self,
      watchCount: watchCount ?? this.watchCount,
      watchers: watchers ?? this.watchers,
    );
  }
}

/// A webhook.
class Webhook {
  /// The Jira events that trigger the webhook.
  final List<WebhookEvents> events;

  /// The date after which the webhook is no longer sent. Use
  /// [Extend webhook life](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-webhooks/#api-rest-api-3-webhook-refresh-put)
  /// to extend the date.
  final int? expirationDate;

  /// A list of field IDs. When the issue changelog contains any of the fields,
  /// the webhook `jira:issue_updated` is sent. If this parameter is not
  /// present, the app is notified about all field updates.
  final List<String> fieldIdsFilter;

  /// The ID of the webhook.
  final int id;

  /// A list of issue property keys. A change of those issue properties triggers
  /// the `issue_property_set` or `issue_property_deleted` webhooks. If this
  /// parameter is not present, the app is notified about all issue property
  /// updates.
  final List<String> issuePropertyKeysFilter;

  /// The JQL filter that specifies which issues the webhook is sent for.
  final String jqlFilter;

  Webhook(
      {required this.events,
      this.expirationDate,
      List<String>? fieldIdsFilter,
      required this.id,
      List<String>? issuePropertyKeysFilter,
      required this.jqlFilter})
      : fieldIdsFilter = fieldIdsFilter ?? [],
        issuePropertyKeysFilter = issuePropertyKeysFilter ?? [];

  factory Webhook.fromJson(Map<String, Object?> json) {
    return Webhook(
      events: (json[r'events'] as List<Object?>?)
              ?.map((i) => WebhookEvents.fromValue(i as String? ?? ''))
              .toList() ??
          [],
      expirationDate: (json[r'expirationDate'] as num?)?.toInt(),
      fieldIdsFilter: (json[r'fieldIdsFilter'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      issuePropertyKeysFilter:
          (json[r'issuePropertyKeysFilter'] as List<Object?>?)
                  ?.map((i) => i as String? ?? '')
                  .toList() ??
              [],
      jqlFilter: json[r'jqlFilter'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var events = this.events;
    var expirationDate = this.expirationDate;
    var fieldIdsFilter = this.fieldIdsFilter;
    var id = this.id;
    var issuePropertyKeysFilter = this.issuePropertyKeysFilter;
    var jqlFilter = this.jqlFilter;

    final json = <String, Object?>{};
    json[r'events'] = events.map((i) => i.value).toList();
    if (expirationDate != null) {
      json[r'expirationDate'] = expirationDate;
    }
    json[r'fieldIdsFilter'] = fieldIdsFilter;
    json[r'id'] = id;
    json[r'issuePropertyKeysFilter'] = issuePropertyKeysFilter;
    json[r'jqlFilter'] = jqlFilter;
    return json;
  }

  Webhook copyWith(
      {List<WebhookEvents>? events,
      int? expirationDate,
      List<String>? fieldIdsFilter,
      int? id,
      List<String>? issuePropertyKeysFilter,
      String? jqlFilter}) {
    return Webhook(
      events: events ?? this.events,
      expirationDate: expirationDate ?? this.expirationDate,
      fieldIdsFilter: fieldIdsFilter ?? this.fieldIdsFilter,
      id: id ?? this.id,
      issuePropertyKeysFilter:
          issuePropertyKeysFilter ?? this.issuePropertyKeysFilter,
      jqlFilter: jqlFilter ?? this.jqlFilter,
    );
  }
}

class WebhookEvents {
  static const jiraIssueCreated = WebhookEvents._('jira:issue_created');
  static const jiraIssueUpdated = WebhookEvents._('jira:issue_updated');
  static const jiraIssueDeleted = WebhookEvents._('jira:issue_deleted');
  static const commentCreated = WebhookEvents._('comment_created');
  static const commentUpdated = WebhookEvents._('comment_updated');
  static const commentDeleted = WebhookEvents._('comment_deleted');
  static const issuePropertySet = WebhookEvents._('issue_property_set');
  static const issuePropertyDeleted = WebhookEvents._('issue_property_deleted');

  static const values = [
    jiraIssueCreated,
    jiraIssueUpdated,
    jiraIssueDeleted,
    commentCreated,
    commentUpdated,
    commentDeleted,
    issuePropertySet,
    issuePropertyDeleted,
  ];
  final String value;

  const WebhookEvents._(this.value);

  static WebhookEvents fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => WebhookEvents._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// A list of webhooks.
class WebhookDetails {
  /// The Jira events that trigger the webhook.
  final List<WebhookDetailsEvents> events;

  /// A list of field IDs. When the issue changelog contains any of the fields,
  /// the webhook `jira:issue_updated` is sent. If this parameter is not
  /// present, the app is notified about all field updates.
  final List<String> fieldIdsFilter;

  /// A list of issue property keys. A change of those issue properties triggers
  /// the `issue_property_set` or `issue_property_deleted` webhooks. If this
  /// parameter is not present, the app is notified about all issue property
  /// updates.
  final List<String> issuePropertyKeysFilter;

  /// The JQL filter that specifies which issues the webhook is sent for. Only a
  /// subset of JQL can be used. The supported elements are:
  ///
  ///  *  Fields: `issueKey`, `project`, `issuetype`, `status`, `assignee`,
  /// `reporter`, `issue.property`, and `cf[id]`. For custom fields (`cf[id]`),
  /// only the epic label custom field is supported.".
  ///  *  Operators: `=`, `!=`, `IN`, and `NOT IN`.
  final String jqlFilter;

  WebhookDetails(
      {required this.events,
      List<String>? fieldIdsFilter,
      List<String>? issuePropertyKeysFilter,
      required this.jqlFilter})
      : fieldIdsFilter = fieldIdsFilter ?? [],
        issuePropertyKeysFilter = issuePropertyKeysFilter ?? [];

  factory WebhookDetails.fromJson(Map<String, Object?> json) {
    return WebhookDetails(
      events: (json[r'events'] as List<Object?>?)
              ?.map((i) => WebhookDetailsEvents.fromValue(i as String? ?? ''))
              .toList() ??
          [],
      fieldIdsFilter: (json[r'fieldIdsFilter'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      issuePropertyKeysFilter:
          (json[r'issuePropertyKeysFilter'] as List<Object?>?)
                  ?.map((i) => i as String? ?? '')
                  .toList() ??
              [],
      jqlFilter: json[r'jqlFilter'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var events = this.events;
    var fieldIdsFilter = this.fieldIdsFilter;
    var issuePropertyKeysFilter = this.issuePropertyKeysFilter;
    var jqlFilter = this.jqlFilter;

    final json = <String, Object?>{};
    json[r'events'] = events.map((i) => i.value).toList();
    json[r'fieldIdsFilter'] = fieldIdsFilter;
    json[r'issuePropertyKeysFilter'] = issuePropertyKeysFilter;
    json[r'jqlFilter'] = jqlFilter;
    return json;
  }

  WebhookDetails copyWith(
      {List<WebhookDetailsEvents>? events,
      List<String>? fieldIdsFilter,
      List<String>? issuePropertyKeysFilter,
      String? jqlFilter}) {
    return WebhookDetails(
      events: events ?? this.events,
      fieldIdsFilter: fieldIdsFilter ?? this.fieldIdsFilter,
      issuePropertyKeysFilter:
          issuePropertyKeysFilter ?? this.issuePropertyKeysFilter,
      jqlFilter: jqlFilter ?? this.jqlFilter,
    );
  }
}

class WebhookDetailsEvents {
  static const jiraIssueCreated = WebhookDetailsEvents._('jira:issue_created');
  static const jiraIssueUpdated = WebhookDetailsEvents._('jira:issue_updated');
  static const jiraIssueDeleted = WebhookDetailsEvents._('jira:issue_deleted');
  static const commentCreated = WebhookDetailsEvents._('comment_created');
  static const commentUpdated = WebhookDetailsEvents._('comment_updated');
  static const commentDeleted = WebhookDetailsEvents._('comment_deleted');
  static const issuePropertySet = WebhookDetailsEvents._('issue_property_set');
  static const issuePropertyDeleted =
      WebhookDetailsEvents._('issue_property_deleted');

  static const values = [
    jiraIssueCreated,
    jiraIssueUpdated,
    jiraIssueDeleted,
    commentCreated,
    commentUpdated,
    commentDeleted,
    issuePropertySet,
    issuePropertyDeleted,
  ];
  final String value;

  const WebhookDetailsEvents._(this.value);

  static WebhookDetailsEvents fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => WebhookDetailsEvents._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// Details of webhooks to register.
class WebhookRegistrationDetails {
  /// The URL that specifies where to send the webhooks. This URL must use the
  /// same base URL as the Connect app. Only a single URL per app is allowed to
  /// be registered.
  final String url;

  /// A list of webhooks.
  final List<WebhookDetails> webhooks;

  WebhookRegistrationDetails({required this.url, required this.webhooks});

  factory WebhookRegistrationDetails.fromJson(Map<String, Object?> json) {
    return WebhookRegistrationDetails(
      url: json[r'url'] as String? ?? '',
      webhooks: (json[r'webhooks'] as List<Object?>?)
              ?.map((i) => WebhookDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var url = this.url;
    var webhooks = this.webhooks;

    final json = <String, Object?>{};
    json[r'url'] = url;
    json[r'webhooks'] = webhooks.map((i) => i.toJson()).toList();
    return json;
  }

  WebhookRegistrationDetails copyWith(
      {String? url, List<WebhookDetails>? webhooks}) {
    return WebhookRegistrationDetails(
      url: url ?? this.url,
      webhooks: webhooks ?? this.webhooks,
    );
  }
}

/// The date the refreshed webhooks expire.
class WebhooksExpirationDate {
  /// The expiration date of all the refreshed webhooks.
  final int expirationDate;

  WebhooksExpirationDate({required this.expirationDate});

  factory WebhooksExpirationDate.fromJson(Map<String, Object?> json) {
    return WebhooksExpirationDate(
      expirationDate: (json[r'expirationDate'] as num?)?.toInt() ?? 0,
    );
  }

  Map<String, Object?> toJson() {
    var expirationDate = this.expirationDate;

    final json = <String, Object?>{};
    json[r'expirationDate'] = expirationDate;
    return json;
  }

  WebhooksExpirationDate copyWith({int? expirationDate}) {
    return WebhooksExpirationDate(
      expirationDate: expirationDate ?? this.expirationDate,
    );
  }
}

class WorkManagementNavigationInfo {
  final String? boardName;

  WorkManagementNavigationInfo({this.boardName});

  factory WorkManagementNavigationInfo.fromJson(Map<String, Object?> json) {
    return WorkManagementNavigationInfo(
      boardName: json[r'boardName'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var boardName = this.boardName;

    final json = <String, Object?>{};
    if (boardName != null) {
      json[r'boardName'] = boardName;
    }
    return json;
  }

  WorkManagementNavigationInfo copyWith({String? boardName}) {
    return WorkManagementNavigationInfo(
      boardName: boardName ?? this.boardName,
    );
  }
}

/// Details about a workflow.
class Workflow {
  /// The creation date of the workflow.
  final DateTime? created;

  /// The description of the workflow.
  final String description;

  /// Whether the workflow has a draft version.
  final bool hasDraftWorkflow;
  final PublishedWorkflowId id;

  /// Whether this is the default workflow.
  final bool isDefault;
  final WorkflowOperations? operations;

  /// The projects the workflow is assigned to, through workflow schemes.
  final List<ProjectDetails> projects;

  /// The workflow schemes the workflow is assigned to.
  final List<WorkflowSchemeIdName> schemes;

  /// The statuses of the workflow.
  final List<WorkflowStatus> statuses;

  /// The transitions of the workflow.
  final List<Transition> transitions;

  /// The last edited date of the workflow.
  final DateTime? updated;

  Workflow(
      {this.created,
      required this.description,
      bool? hasDraftWorkflow,
      required this.id,
      bool? isDefault,
      this.operations,
      List<ProjectDetails>? projects,
      List<WorkflowSchemeIdName>? schemes,
      List<WorkflowStatus>? statuses,
      List<Transition>? transitions,
      this.updated})
      : hasDraftWorkflow = hasDraftWorkflow ?? false,
        isDefault = isDefault ?? false,
        projects = projects ?? [],
        schemes = schemes ?? [],
        statuses = statuses ?? [],
        transitions = transitions ?? [];

  factory Workflow.fromJson(Map<String, Object?> json) {
    return Workflow(
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      description: json[r'description'] as String? ?? '',
      hasDraftWorkflow: json[r'hasDraftWorkflow'] as bool? ?? false,
      id: PublishedWorkflowId.fromJson(
          json[r'id'] as Map<String, Object?>? ?? const {}),
      isDefault: json[r'isDefault'] as bool? ?? false,
      operations: json[r'operations'] != null
          ? WorkflowOperations.fromJson(
              json[r'operations']! as Map<String, Object?>)
          : null,
      projects: (json[r'projects'] as List<Object?>?)
              ?.map((i) => ProjectDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      schemes: (json[r'schemes'] as List<Object?>?)
              ?.map((i) => WorkflowSchemeIdName.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      statuses: (json[r'statuses'] as List<Object?>?)
              ?.map((i) => WorkflowStatus.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      transitions: (json[r'transitions'] as List<Object?>?)
              ?.map((i) =>
                  Transition.fromJson(i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      updated: DateTime.tryParse(json[r'updated'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var created = this.created;
    var description = this.description;
    var hasDraftWorkflow = this.hasDraftWorkflow;
    var id = this.id;
    var isDefault = this.isDefault;
    var operations = this.operations;
    var projects = this.projects;
    var schemes = this.schemes;
    var statuses = this.statuses;
    var transitions = this.transitions;
    var updated = this.updated;

    final json = <String, Object?>{};
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    json[r'description'] = description;
    json[r'hasDraftWorkflow'] = hasDraftWorkflow;
    json[r'id'] = id.toJson();
    json[r'isDefault'] = isDefault;
    if (operations != null) {
      json[r'operations'] = operations.toJson();
    }
    json[r'projects'] = projects.map((i) => i.toJson()).toList();
    json[r'schemes'] = schemes.map((i) => i.toJson()).toList();
    json[r'statuses'] = statuses.map((i) => i.toJson()).toList();
    json[r'transitions'] = transitions.map((i) => i.toJson()).toList();
    if (updated != null) {
      json[r'updated'] = updated.toIso8601String();
    }
    return json;
  }

  Workflow copyWith(
      {DateTime? created,
      String? description,
      bool? hasDraftWorkflow,
      PublishedWorkflowId? id,
      bool? isDefault,
      WorkflowOperations? operations,
      List<ProjectDetails>? projects,
      List<WorkflowSchemeIdName>? schemes,
      List<WorkflowStatus>? statuses,
      List<Transition>? transitions,
      DateTime? updated}) {
    return Workflow(
      created: created ?? this.created,
      description: description ?? this.description,
      hasDraftWorkflow: hasDraftWorkflow ?? this.hasDraftWorkflow,
      id: id ?? this.id,
      isDefault: isDefault ?? this.isDefault,
      operations: operations ?? this.operations,
      projects: projects ?? this.projects,
      schemes: schemes ?? this.schemes,
      statuses: statuses ?? this.statuses,
      transitions: transitions ?? this.transitions,
      updated: updated ?? this.updated,
    );
  }
}

/// A compound workflow transition rule condition. This object returns
/// `nodeType` as `compound`.
class WorkflowCompoundCondition {
  /// The list of workflow conditions.
  final List<WorkflowCondition> conditions;
  final String nodeType;

  /// The compound condition operator.
  final WorkflowCompoundConditionOperator operator$;

  WorkflowCompoundCondition(
      {required this.conditions,
      required this.nodeType,
      required this.operator$});

  factory WorkflowCompoundCondition.fromJson(Map<String, Object?> json) {
    return WorkflowCompoundCondition(
      conditions: (json[r'conditions'] as List<Object?>?)
              ?.map((i) => WorkflowCondition.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      nodeType: json[r'nodeType'] as String? ?? '',
      operator$: WorkflowCompoundConditionOperator.fromValue(
          json[r'operator'] as String? ?? ''),
    );
  }

  Map<String, Object?> toJson() {
    var conditions = this.conditions;
    var nodeType = this.nodeType;
    var operator$ = this.operator$;

    final json = <String, Object?>{};
    json[r'conditions'] = conditions.map((i) => i.toJson()).toList();
    json[r'nodeType'] = nodeType;
    json[r'operator'] = operator$.value;
    return json;
  }

  WorkflowCompoundCondition copyWith(
      {List<WorkflowCondition>? conditions,
      String? nodeType,
      WorkflowCompoundConditionOperator? operator$}) {
    return WorkflowCompoundCondition(
      conditions: conditions ?? this.conditions,
      nodeType: nodeType ?? this.nodeType,
      operator$: operator$ ?? this.operator$,
    );
  }
}

class WorkflowCompoundConditionOperator {
  static const and = WorkflowCompoundConditionOperator._('AND');
  static const or = WorkflowCompoundConditionOperator._('OR');

  static const values = [
    and,
    or,
  ];
  final String value;

  const WorkflowCompoundConditionOperator._(this.value);

  static WorkflowCompoundConditionOperator fromValue(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => WorkflowCompoundConditionOperator._(value));

  /// An enum received from the server but this version of the client doesn't recognize it.
  bool get isUnknown => values.every((v) => v.value != value);

  @override
  String toString() => value;
}

/// The workflow transition rule conditions tree.
class WorkflowCondition {
  WorkflowCondition();

  factory WorkflowCondition.fromJson(Map<String, Object?> json) {
    return WorkflowCondition();
  }

  Map<String, Object?> toJson() {
    final json = <String, Object?>{};
    return json;
  }
}

/// The classic workflow identifiers.
class WorkflowIDs {
  /// The entity ID of the workflow.
  final String? entityId;

  /// The name of the workflow.
  final String name;

  WorkflowIDs({this.entityId, required this.name});

  factory WorkflowIDs.fromJson(Map<String, Object?> json) {
    return WorkflowIDs(
      entityId: json[r'entityId'] as String?,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var entityId = this.entityId;
    var name = this.name;

    final json = <String, Object?>{};
    if (entityId != null) {
      json[r'entityId'] = entityId;
    }
    json[r'name'] = name;
    return json;
  }

  WorkflowIDs copyWith({String? entityId, String? name}) {
    return WorkflowIDs(
      entityId: entityId ?? this.entityId,
      name: name ?? this.name,
    );
  }
}

/// Properties that identify a workflow.
class WorkflowId {
  /// Whether the workflow is in the draft state.
  final bool draft;

  /// The name of the workflow.
  final String name;

  WorkflowId({required this.draft, required this.name});

  factory WorkflowId.fromJson(Map<String, Object?> json) {
    return WorkflowId(
      draft: json[r'draft'] as bool? ?? false,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var draft = this.draft;
    var name = this.name;

    final json = <String, Object?>{};
    json[r'draft'] = draft;
    json[r'name'] = name;
    return json;
  }

  WorkflowId copyWith({bool? draft, String? name}) {
    return WorkflowId(
      draft: draft ?? this.draft,
      name: name ?? this.name,
    );
  }
}

/// Operations allowed on a workflow
class WorkflowOperations {
  /// Whether the workflow can be deleted.
  final bool canDelete;

  /// Whether the workflow can be updated.
  final bool canEdit;

  WorkflowOperations({required this.canDelete, required this.canEdit});

  factory WorkflowOperations.fromJson(Map<String, Object?> json) {
    return WorkflowOperations(
      canDelete: json[r'canDelete'] as bool? ?? false,
      canEdit: json[r'canEdit'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var canDelete = this.canDelete;
    var canEdit = this.canEdit;

    final json = <String, Object?>{};
    json[r'canDelete'] = canDelete;
    json[r'canEdit'] = canEdit;
    return json;
  }

  WorkflowOperations copyWith({bool? canDelete, bool? canEdit}) {
    return WorkflowOperations(
      canDelete: canDelete ?? this.canDelete,
      canEdit: canEdit ?? this.canEdit,
    );
  }
}

/// A collection of transition rules.
class WorkflowRules {
  final WorkflowCondition? conditionsTree;

  /// The workflow post functions.
  final List<WorkflowTransitionRule> postFunctions;

  /// The workflow validators.
  final List<WorkflowTransitionRule> validators;

  WorkflowRules(
      {this.conditionsTree,
      List<WorkflowTransitionRule>? postFunctions,
      List<WorkflowTransitionRule>? validators})
      : postFunctions = postFunctions ?? [],
        validators = validators ?? [];

  factory WorkflowRules.fromJson(Map<String, Object?> json) {
    return WorkflowRules(
      conditionsTree: json[r'conditionsTree'] != null
          ? WorkflowCondition.fromJson(
              json[r'conditionsTree']! as Map<String, Object?>)
          : null,
      postFunctions: (json[r'postFunctions'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      validators: (json[r'validators'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var conditionsTree = this.conditionsTree;
    var postFunctions = this.postFunctions;
    var validators = this.validators;

    final json = <String, Object?>{};
    if (conditionsTree != null) {
      json[r'conditionsTree'] = conditionsTree.toJson();
    }
    json[r'postFunctions'] = postFunctions.map((i) => i.toJson()).toList();
    json[r'validators'] = validators.map((i) => i.toJson()).toList();
    return json;
  }

  WorkflowRules copyWith(
      {WorkflowCondition? conditionsTree,
      List<WorkflowTransitionRule>? postFunctions,
      List<WorkflowTransitionRule>? validators}) {
    return WorkflowRules(
      conditionsTree: conditionsTree ?? this.conditionsTree,
      postFunctions: postFunctions ?? this.postFunctions,
      validators: validators ?? this.validators,
    );
  }
}

/// Details of the workflow and its transition rules.
class WorkflowRulesSearch {
  /// Use expand to include additional information in the response. This
  /// parameter accepts `transition` which, for each rule, returns information
  /// about the transition the rule is assigned to.
  final String? expand;

  /// The list of workflow rule IDs.
  final List<String> ruleIds;

  /// The workflow ID.
  final String workflowEntityId;

  WorkflowRulesSearch(
      {this.expand, required this.ruleIds, required this.workflowEntityId});

  factory WorkflowRulesSearch.fromJson(Map<String, Object?> json) {
    return WorkflowRulesSearch(
      expand: json[r'expand'] as String?,
      ruleIds: (json[r'ruleIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      workflowEntityId: json[r'workflowEntityId'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var expand = this.expand;
    var ruleIds = this.ruleIds;
    var workflowEntityId = this.workflowEntityId;

    final json = <String, Object?>{};
    if (expand != null) {
      json[r'expand'] = expand;
    }
    json[r'ruleIds'] = ruleIds;
    json[r'workflowEntityId'] = workflowEntityId;
    return json;
  }

  WorkflowRulesSearch copyWith(
      {String? expand, List<String>? ruleIds, String? workflowEntityId}) {
    return WorkflowRulesSearch(
      expand: expand ?? this.expand,
      ruleIds: ruleIds ?? this.ruleIds,
      workflowEntityId: workflowEntityId ?? this.workflowEntityId,
    );
  }
}

/// Details of workflow transition rules.
class WorkflowRulesSearchDetails {
  /// List of workflow rule IDs that do not belong to the workflow or can not be
  /// found.
  final List<String> invalidRules;

  /// List of valid workflow transition rules.
  final List<WorkflowTransitionRules> validRules;

  /// The workflow ID.
  final String? workflowEntityId;

  WorkflowRulesSearchDetails(
      {List<String>? invalidRules,
      List<WorkflowTransitionRules>? validRules,
      this.workflowEntityId})
      : invalidRules = invalidRules ?? [],
        validRules = validRules ?? [];

  factory WorkflowRulesSearchDetails.fromJson(Map<String, Object?> json) {
    return WorkflowRulesSearchDetails(
      invalidRules: (json[r'invalidRules'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      validRules: (json[r'validRules'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRules.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      workflowEntityId: json[r'workflowEntityId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var invalidRules = this.invalidRules;
    var validRules = this.validRules;
    var workflowEntityId = this.workflowEntityId;

    final json = <String, Object?>{};
    json[r'invalidRules'] = invalidRules;
    json[r'validRules'] = validRules.map((i) => i.toJson()).toList();
    if (workflowEntityId != null) {
      json[r'workflowEntityId'] = workflowEntityId;
    }
    return json;
  }

  WorkflowRulesSearchDetails copyWith(
      {List<String>? invalidRules,
      List<WorkflowTransitionRules>? validRules,
      String? workflowEntityId}) {
    return WorkflowRulesSearchDetails(
      invalidRules: invalidRules ?? this.invalidRules,
      validRules: validRules ?? this.validRules,
      workflowEntityId: workflowEntityId ?? this.workflowEntityId,
    );
  }
}

/// Details about a workflow scheme.
class WorkflowScheme {
  /// The name of the default workflow for the workflow scheme. The default
  /// workflow has *All Unassigned Issue Types* assigned to it in Jira. If
  /// `defaultWorkflow` is not specified when creating a workflow scheme, it is
  /// set to *Jira Workflow (jira)*.
  final String? defaultWorkflow;

  /// The description of the workflow scheme.
  final String? description;

  /// Whether the workflow scheme is a draft or not.
  final bool draft;

  /// The ID of the workflow scheme.
  final int? id;

  /// The issue type to workflow mappings, where each mapping is an issue type
  /// ID and workflow name pair. Note that an issue type can only be mapped to
  /// one workflow in a workflow scheme.
  final Map<String, dynamic>? issueTypeMappings;

  /// The issue types available in Jira.
  final Map<String, dynamic>? issueTypes;

  /// The date-time that the draft workflow scheme was last modified. A
  /// modification is a change to the issue type-project mappings only. This
  /// property does not apply to non-draft workflows.
  final String? lastModified;

  /// The user that last modified the draft workflow scheme. A modification is a
  /// change to the issue type-project mappings only. This property does not
  /// apply to non-draft workflows.
  final User? lastModifiedUser;

  /// The name of the workflow scheme. The name must be unique. The maximum
  /// length is 255 characters. Required when creating a workflow scheme.
  final String? name;

  /// For draft workflow schemes, this property is the name of the default
  /// workflow for the original workflow scheme. The default workflow has *All
  /// Unassigned Issue Types* assigned to it in Jira.
  final String? originalDefaultWorkflow;

  /// For draft workflow schemes, this property is the issue type to workflow
  /// mappings for the original workflow scheme, where each mapping is an issue
  /// type ID and workflow name pair. Note that an issue type can only be mapped
  /// to one workflow in a workflow scheme.
  final Map<String, dynamic>? originalIssueTypeMappings;
  final String? self;

  /// Whether to create or update a draft workflow scheme when updating an
  /// active workflow scheme. An active workflow scheme is a workflow scheme
  /// that is used by at least one project. The following examples show how this
  /// property works:
  ///
  ///  *  Update an active workflow scheme with `updateDraftIfNeeded` set to
  /// `true`: If a draft workflow scheme exists, it is updated. Otherwise, a
  /// draft workflow scheme is created.
  ///  *  Update an active workflow scheme with `updateDraftIfNeeded` set to
  /// `false`: An error is returned, as active workflow schemes cannot be
  /// updated.
  ///  *  Update an inactive workflow scheme with `updateDraftIfNeeded` set to
  /// `true`: The workflow scheme is updated, as inactive workflow schemes do
  /// not require drafts to update.
  ///
  /// Defaults to `false`.
  final bool updateDraftIfNeeded;

  WorkflowScheme(
      {this.defaultWorkflow,
      this.description,
      bool? draft,
      this.id,
      this.issueTypeMappings,
      this.issueTypes,
      this.lastModified,
      this.lastModifiedUser,
      this.name,
      this.originalDefaultWorkflow,
      this.originalIssueTypeMappings,
      this.self,
      bool? updateDraftIfNeeded})
      : draft = draft ?? false,
        updateDraftIfNeeded = updateDraftIfNeeded ?? false;

  factory WorkflowScheme.fromJson(Map<String, Object?> json) {
    return WorkflowScheme(
      defaultWorkflow: json[r'defaultWorkflow'] as String?,
      description: json[r'description'] as String?,
      draft: json[r'draft'] as bool? ?? false,
      id: (json[r'id'] as num?)?.toInt(),
      issueTypeMappings: json[r'issueTypeMappings'] as Map<String, Object?>?,
      issueTypes: json[r'issueTypes'] as Map<String, Object?>?,
      lastModified: json[r'lastModified'] as String?,
      lastModifiedUser: json[r'lastModifiedUser'] != null
          ? User.fromJson(json[r'lastModifiedUser']! as Map<String, Object?>)
          : null,
      name: json[r'name'] as String?,
      originalDefaultWorkflow: json[r'originalDefaultWorkflow'] as String?,
      originalIssueTypeMappings:
          json[r'originalIssueTypeMappings'] as Map<String, Object?>?,
      self: json[r'self'] as String?,
      updateDraftIfNeeded: json[r'updateDraftIfNeeded'] as bool? ?? false,
    );
  }

  Map<String, Object?> toJson() {
    var defaultWorkflow = this.defaultWorkflow;
    var description = this.description;
    var draft = this.draft;
    var id = this.id;
    var issueTypeMappings = this.issueTypeMappings;
    var issueTypes = this.issueTypes;
    var lastModified = this.lastModified;
    var lastModifiedUser = this.lastModifiedUser;
    var name = this.name;
    var originalDefaultWorkflow = this.originalDefaultWorkflow;
    var originalIssueTypeMappings = this.originalIssueTypeMappings;
    var self = this.self;
    var updateDraftIfNeeded = this.updateDraftIfNeeded;

    final json = <String, Object?>{};
    if (defaultWorkflow != null) {
      json[r'defaultWorkflow'] = defaultWorkflow;
    }
    if (description != null) {
      json[r'description'] = description;
    }
    json[r'draft'] = draft;
    if (id != null) {
      json[r'id'] = id;
    }
    if (issueTypeMappings != null) {
      json[r'issueTypeMappings'] = issueTypeMappings;
    }
    if (issueTypes != null) {
      json[r'issueTypes'] = issueTypes;
    }
    if (lastModified != null) {
      json[r'lastModified'] = lastModified;
    }
    if (lastModifiedUser != null) {
      json[r'lastModifiedUser'] = lastModifiedUser.toJson();
    }
    if (name != null) {
      json[r'name'] = name;
    }
    if (originalDefaultWorkflow != null) {
      json[r'originalDefaultWorkflow'] = originalDefaultWorkflow;
    }
    if (originalIssueTypeMappings != null) {
      json[r'originalIssueTypeMappings'] = originalIssueTypeMappings;
    }
    if (self != null) {
      json[r'self'] = self;
    }
    json[r'updateDraftIfNeeded'] = updateDraftIfNeeded;
    return json;
  }

  WorkflowScheme copyWith(
      {String? defaultWorkflow,
      String? description,
      bool? draft,
      int? id,
      Map<String, dynamic>? issueTypeMappings,
      Map<String, dynamic>? issueTypes,
      String? lastModified,
      User? lastModifiedUser,
      String? name,
      String? originalDefaultWorkflow,
      Map<String, dynamic>? originalIssueTypeMappings,
      String? self,
      bool? updateDraftIfNeeded}) {
    return WorkflowScheme(
      defaultWorkflow: defaultWorkflow ?? this.defaultWorkflow,
      description: description ?? this.description,
      draft: draft ?? this.draft,
      id: id ?? this.id,
      issueTypeMappings: issueTypeMappings ?? this.issueTypeMappings,
      issueTypes: issueTypes ?? this.issueTypes,
      lastModified: lastModified ?? this.lastModified,
      lastModifiedUser: lastModifiedUser ?? this.lastModifiedUser,
      name: name ?? this.name,
      originalDefaultWorkflow:
          originalDefaultWorkflow ?? this.originalDefaultWorkflow,
      originalIssueTypeMappings:
          originalIssueTypeMappings ?? this.originalIssueTypeMappings,
      self: self ?? this.self,
      updateDraftIfNeeded: updateDraftIfNeeded ?? this.updateDraftIfNeeded,
    );
  }
}

/// A workflow scheme along with a list of projects that use it.
class WorkflowSchemeAssociations {
  /// The list of projects that use the workflow scheme.
  final List<String> projectIds;

  /// The workflow scheme.
  final WorkflowScheme workflowScheme;

  WorkflowSchemeAssociations(
      {required this.projectIds, required this.workflowScheme});

  factory WorkflowSchemeAssociations.fromJson(Map<String, Object?> json) {
    return WorkflowSchemeAssociations(
      projectIds: (json[r'projectIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      workflowScheme: WorkflowScheme.fromJson(
          json[r'workflowScheme'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var projectIds = this.projectIds;
    var workflowScheme = this.workflowScheme;

    final json = <String, Object?>{};
    json[r'projectIds'] = projectIds;
    json[r'workflowScheme'] = workflowScheme.toJson();
    return json;
  }

  WorkflowSchemeAssociations copyWith(
      {List<String>? projectIds, WorkflowScheme? workflowScheme}) {
    return WorkflowSchemeAssociations(
      projectIds: projectIds ?? this.projectIds,
      workflowScheme: workflowScheme ?? this.workflowScheme,
    );
  }
}

/// The ID and the name of the workflow scheme.
class WorkflowSchemeIdName {
  /// The ID of the workflow scheme.
  final String id;

  /// The name of the workflow scheme.
  final String name;

  WorkflowSchemeIdName({required this.id, required this.name});

  factory WorkflowSchemeIdName.fromJson(Map<String, Object?> json) {
    return WorkflowSchemeIdName(
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    return json;
  }

  WorkflowSchemeIdName copyWith({String? id, String? name}) {
    return WorkflowSchemeIdName(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// An associated workflow scheme and project.
class WorkflowSchemeProjectAssociation {
  /// The ID of the project.
  final String projectId;

  /// The ID of the workflow scheme. If the workflow scheme ID is `null`, the
  /// operation assigns the default workflow scheme.
  final String? workflowSchemeId;

  WorkflowSchemeProjectAssociation(
      {required this.projectId, this.workflowSchemeId});

  factory WorkflowSchemeProjectAssociation.fromJson(Map<String, Object?> json) {
    return WorkflowSchemeProjectAssociation(
      projectId: json[r'projectId'] as String? ?? '',
      workflowSchemeId: json[r'workflowSchemeId'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var projectId = this.projectId;
    var workflowSchemeId = this.workflowSchemeId;

    final json = <String, Object?>{};
    json[r'projectId'] = projectId;
    if (workflowSchemeId != null) {
      json[r'workflowSchemeId'] = workflowSchemeId;
    }
    return json;
  }

  WorkflowSchemeProjectAssociation copyWith(
      {String? projectId, String? workflowSchemeId}) {
    return WorkflowSchemeProjectAssociation(
      projectId: projectId ?? this.projectId,
      workflowSchemeId: workflowSchemeId ?? this.workflowSchemeId,
    );
  }
}

/// A workflow transition rule condition. This object returns `nodeType` as
/// `simple`.
class WorkflowSimpleCondition {
  /// EXPERIMENTAL. The configuration of the transition rule.
  final Map<String, dynamic>? configuration;
  final String nodeType;

  /// The type of the transition rule.
  final String type;

  WorkflowSimpleCondition(
      {this.configuration, required this.nodeType, required this.type});

  factory WorkflowSimpleCondition.fromJson(Map<String, Object?> json) {
    return WorkflowSimpleCondition(
      configuration: json[r'configuration'] as Map<String, Object?>?,
      nodeType: json[r'nodeType'] as String? ?? '',
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var configuration = this.configuration;
    var nodeType = this.nodeType;
    var type = this.type;

    final json = <String, Object?>{};
    if (configuration != null) {
      json[r'configuration'] = configuration;
    }
    json[r'nodeType'] = nodeType;
    json[r'type'] = type;
    return json;
  }

  WorkflowSimpleCondition copyWith(
      {Map<String, dynamic>? configuration, String? nodeType, String? type}) {
    return WorkflowSimpleCondition(
      configuration: configuration ?? this.configuration,
      nodeType: nodeType ?? this.nodeType,
      type: type ?? this.type,
    );
  }
}

/// Details of a workflow status.
class WorkflowStatus {
  /// The ID of the issue status.
  final String id;

  /// The name of the status in the workflow.
  final String name;

  /// Additional properties that modify the behavior of issues in this status.
  /// Supports the properties `jira.issue.editable` and `issueEditable`
  /// (deprecated) that indicate whether issues are editable.
  final Map<String, dynamic>? properties;

  WorkflowStatus({required this.id, required this.name, this.properties});

  factory WorkflowStatus.fromJson(Map<String, Object?> json) {
    return WorkflowStatus(
      id: json[r'id'] as String? ?? '',
      name: json[r'name'] as String? ?? '',
      properties: json[r'properties'] as Map<String, Object?>?,
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;
    var properties = this.properties;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    if (properties != null) {
      json[r'properties'] = properties;
    }
    return json;
  }

  WorkflowStatus copyWith(
      {String? id, String? name, Map<String, dynamic>? properties}) {
    return WorkflowStatus(
      id: id ?? this.id,
      name: name ?? this.name,
      properties: properties ?? this.properties,
    );
  }
}

/// A workflow transition.
class WorkflowTransition {
  /// The transition ID.
  final int id;

  /// The transition name.
  final String name;

  WorkflowTransition({required this.id, required this.name});

  factory WorkflowTransition.fromJson(Map<String, Object?> json) {
    return WorkflowTransition(
      id: (json[r'id'] as num?)?.toInt() ?? 0,
      name: json[r'name'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var name = this.name;

    final json = <String, Object?>{};
    json[r'id'] = id;
    json[r'name'] = name;
    return json;
  }

  WorkflowTransition copyWith({int? id, String? name}) {
    return WorkflowTransition(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// Details about the server Jira is running on.
class WorkflowTransitionProperty {
  /// The ID of the transition property.
  final String? id;

  /// The key of the transition property. Also known as the name of the
  /// transition property.
  final String? key;

  /// The value of the transition property.
  final String value;

  WorkflowTransitionProperty({this.id, this.key, required this.value});

  factory WorkflowTransitionProperty.fromJson(Map<String, Object?> json) {
    return WorkflowTransitionProperty(
      id: json[r'id'] as String?,
      key: json[r'key'] as String?,
      value: json[r'value'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var id = this.id;
    var key = this.key;
    var value = this.value;

    final json = <String, Object?>{};
    if (id != null) {
      json[r'id'] = id;
    }
    if (key != null) {
      json[r'key'] = key;
    }
    json[r'value'] = value;
    return json;
  }

  WorkflowTransitionProperty copyWith(
      {String? id, String? key, String? value}) {
    return WorkflowTransitionProperty(
      id: id ?? this.id,
      key: key ?? this.key,
      value: value ?? this.value,
    );
  }
}

/// A workflow transition rule.
class WorkflowTransitionRule {
  /// EXPERIMENTAL. The configuration of the transition rule.
  final dynamic configuration;

  /// The type of the transition rule.
  final String type;

  WorkflowTransitionRule({this.configuration, required this.type});

  factory WorkflowTransitionRule.fromJson(Map<String, Object?> json) {
    return WorkflowTransitionRule(
      configuration: json[r'configuration'],
      type: json[r'type'] as String? ?? '',
    );
  }

  Map<String, Object?> toJson() {
    var configuration = this.configuration;
    var type = this.type;

    final json = <String, Object?>{};
    if (configuration != null) {
      json[r'configuration'] = configuration;
    }
    json[r'type'] = type;
    return json;
  }

  WorkflowTransitionRule copyWith({dynamic configuration, String? type}) {
    return WorkflowTransitionRule(
      configuration: configuration ?? this.configuration,
      type: type ?? this.type,
    );
  }
}

/// A workflow with transition rules.
class WorkflowTransitionRules {
  /// The list of conditions within the workflow.
  final List<AppWorkflowTransitionRule> conditions;

  /// The list of post functions within the workflow.
  final List<AppWorkflowTransitionRule> postFunctions;

  /// The list of validators within the workflow.
  final List<AppWorkflowTransitionRule> validators;
  final WorkflowId workflowId;

  WorkflowTransitionRules(
      {List<AppWorkflowTransitionRule>? conditions,
      List<AppWorkflowTransitionRule>? postFunctions,
      List<AppWorkflowTransitionRule>? validators,
      required this.workflowId})
      : conditions = conditions ?? [],
        postFunctions = postFunctions ?? [],
        validators = validators ?? [];

  factory WorkflowTransitionRules.fromJson(Map<String, Object?> json) {
    return WorkflowTransitionRules(
      conditions: (json[r'conditions'] as List<Object?>?)
              ?.map((i) => AppWorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      postFunctions: (json[r'postFunctions'] as List<Object?>?)
              ?.map((i) => AppWorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      validators: (json[r'validators'] as List<Object?>?)
              ?.map((i) => AppWorkflowTransitionRule.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      workflowId: WorkflowId.fromJson(
          json[r'workflowId'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var conditions = this.conditions;
    var postFunctions = this.postFunctions;
    var validators = this.validators;
    var workflowId = this.workflowId;

    final json = <String, Object?>{};
    json[r'conditions'] = conditions.map((i) => i.toJson()).toList();
    json[r'postFunctions'] = postFunctions.map((i) => i.toJson()).toList();
    json[r'validators'] = validators.map((i) => i.toJson()).toList();
    json[r'workflowId'] = workflowId.toJson();
    return json;
  }

  WorkflowTransitionRules copyWith(
      {List<AppWorkflowTransitionRule>? conditions,
      List<AppWorkflowTransitionRule>? postFunctions,
      List<AppWorkflowTransitionRule>? validators,
      WorkflowId? workflowId}) {
    return WorkflowTransitionRules(
      conditions: conditions ?? this.conditions,
      postFunctions: postFunctions ?? this.postFunctions,
      validators: validators ?? this.validators,
      workflowId: workflowId ?? this.workflowId,
    );
  }
}

/// Details about a workflow configuration update request.
class WorkflowTransitionRulesDetails {
  final WorkflowId workflowId;

  /// The list of connect workflow rule IDs.
  final List<String> workflowRuleIds;

  WorkflowTransitionRulesDetails(
      {required this.workflowId, required this.workflowRuleIds});

  factory WorkflowTransitionRulesDetails.fromJson(Map<String, Object?> json) {
    return WorkflowTransitionRulesDetails(
      workflowId: WorkflowId.fromJson(
          json[r'workflowId'] as Map<String, Object?>? ?? const {}),
      workflowRuleIds: (json[r'workflowRuleIds'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var workflowId = this.workflowId;
    var workflowRuleIds = this.workflowRuleIds;

    final json = <String, Object?>{};
    json[r'workflowId'] = workflowId.toJson();
    json[r'workflowRuleIds'] = workflowRuleIds;
    return json;
  }

  WorkflowTransitionRulesDetails copyWith(
      {WorkflowId? workflowId, List<String>? workflowRuleIds}) {
    return WorkflowTransitionRulesDetails(
      workflowId: workflowId ?? this.workflowId,
      workflowRuleIds: workflowRuleIds ?? this.workflowRuleIds,
    );
  }
}

/// Details about a workflow configuration update request.
class WorkflowTransitionRulesUpdate {
  /// The list of workflows with transition rules to update.
  final List<WorkflowTransitionRules> workflows;

  WorkflowTransitionRulesUpdate({required this.workflows});

  factory WorkflowTransitionRulesUpdate.fromJson(Map<String, Object?> json) {
    return WorkflowTransitionRulesUpdate(
      workflows: (json[r'workflows'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRules.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var workflows = this.workflows;

    final json = <String, Object?>{};
    json[r'workflows'] = workflows.map((i) => i.toJson()).toList();
    return json;
  }

  WorkflowTransitionRulesUpdate copyWith(
      {List<WorkflowTransitionRules>? workflows}) {
    return WorkflowTransitionRulesUpdate(
      workflows: workflows ?? this.workflows,
    );
  }
}

/// Details of any errors encountered while updating workflow transition rules
/// for a workflow.
class WorkflowTransitionRulesUpdateErrorDetails {
  /// A list of transition rule update errors, indexed by the transition rule
  /// ID. Any transition rule that appears here wasn't updated.
  final Map<String, dynamic> ruleUpdateErrors;

  /// The list of errors that specify why the workflow update failed. The
  /// workflow was not updated if the list contains any entries.
  final List<String> updateErrors;
  final WorkflowId workflowId;

  WorkflowTransitionRulesUpdateErrorDetails(
      {required this.ruleUpdateErrors,
      required this.updateErrors,
      required this.workflowId});

  factory WorkflowTransitionRulesUpdateErrorDetails.fromJson(
      Map<String, Object?> json) {
    return WorkflowTransitionRulesUpdateErrorDetails(
      ruleUpdateErrors:
          json[r'ruleUpdateErrors'] as Map<String, Object?>? ?? {},
      updateErrors: (json[r'updateErrors'] as List<Object?>?)
              ?.map((i) => i as String? ?? '')
              .toList() ??
          [],
      workflowId: WorkflowId.fromJson(
          json[r'workflowId'] as Map<String, Object?>? ?? const {}),
    );
  }

  Map<String, Object?> toJson() {
    var ruleUpdateErrors = this.ruleUpdateErrors;
    var updateErrors = this.updateErrors;
    var workflowId = this.workflowId;

    final json = <String, Object?>{};
    json[r'ruleUpdateErrors'] = ruleUpdateErrors;
    json[r'updateErrors'] = updateErrors;
    json[r'workflowId'] = workflowId.toJson();
    return json;
  }

  WorkflowTransitionRulesUpdateErrorDetails copyWith(
      {Map<String, dynamic>? ruleUpdateErrors,
      List<String>? updateErrors,
      WorkflowId? workflowId}) {
    return WorkflowTransitionRulesUpdateErrorDetails(
      ruleUpdateErrors: ruleUpdateErrors ?? this.ruleUpdateErrors,
      updateErrors: updateErrors ?? this.updateErrors,
      workflowId: workflowId ?? this.workflowId,
    );
  }
}

/// Details of any errors encountered while updating workflow transition rules.
class WorkflowTransitionRulesUpdateErrors {
  /// A list of workflows.
  final List<WorkflowTransitionRulesUpdateErrorDetails> updateResults;

  WorkflowTransitionRulesUpdateErrors({required this.updateResults});

  factory WorkflowTransitionRulesUpdateErrors.fromJson(
      Map<String, Object?> json) {
    return WorkflowTransitionRulesUpdateErrors(
      updateResults: (json[r'updateResults'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRulesUpdateErrorDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var updateResults = this.updateResults;

    final json = <String, Object?>{};
    json[r'updateResults'] = updateResults.map((i) => i.toJson()).toList();
    return json;
  }

  WorkflowTransitionRulesUpdateErrors copyWith(
      {List<WorkflowTransitionRulesUpdateErrorDetails>? updateResults}) {
    return WorkflowTransitionRulesUpdateErrors(
      updateResults: updateResults ?? this.updateResults,
    );
  }
}

/// The workflows that use this status. Only available if the `workflowUsages`
/// expand is requested.
class WorkflowUsages {
  /// Workflow ID.
  final String? workflowId;

  /// Workflow name.
  final String? workflowName;

  WorkflowUsages({this.workflowId, this.workflowName});

  factory WorkflowUsages.fromJson(Map<String, Object?> json) {
    return WorkflowUsages(
      workflowId: json[r'workflowId'] as String?,
      workflowName: json[r'workflowName'] as String?,
    );
  }

  Map<String, Object?> toJson() {
    var workflowId = this.workflowId;
    var workflowName = this.workflowName;

    final json = <String, Object?>{};
    if (workflowId != null) {
      json[r'workflowId'] = workflowId;
    }
    if (workflowName != null) {
      json[r'workflowName'] = workflowName;
    }
    return json;
  }

  WorkflowUsages copyWith({String? workflowId, String? workflowName}) {
    return WorkflowUsages(
      workflowId: workflowId ?? this.workflowId,
      workflowName: workflowName ?? this.workflowName,
    );
  }
}

/// Details of workflows and their transition rules to delete.
class WorkflowsWithTransitionRulesDetails {
  /// The list of workflows with transition rules to delete.
  final List<WorkflowTransitionRulesDetails> workflows;

  WorkflowsWithTransitionRulesDetails({required this.workflows});

  factory WorkflowsWithTransitionRulesDetails.fromJson(
      Map<String, Object?> json) {
    return WorkflowsWithTransitionRulesDetails(
      workflows: (json[r'workflows'] as List<Object?>?)
              ?.map((i) => WorkflowTransitionRulesDetails.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var workflows = this.workflows;

    final json = <String, Object?>{};
    json[r'workflows'] = workflows.map((i) => i.toJson()).toList();
    return json;
  }

  WorkflowsWithTransitionRulesDetails copyWith(
      {List<WorkflowTransitionRulesDetails>? workflows}) {
    return WorkflowsWithTransitionRulesDetails(
      workflows: workflows ?? this.workflows,
    );
  }
}

/// Details of a worklog.
class Worklog {
  /// Details of the user who created the worklog.
  final UserDetails? author;

  /// A comment about the worklog in
  /// [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/).
  /// Optional when creating or updating a worklog.
  final dynamic comment;

  /// The datetime on which the worklog was created.
  final DateTime? created;

  /// The ID of the worklog record.
  final String? id;

  /// The ID of the issue this worklog is for.
  final String? issueId;

  /// Details of properties for the worklog. Optional when creating or updating
  /// a worklog.
  final List<EntityProperty> properties;

  /// The URL of the worklog item.
  final String? self;

  /// The datetime on which the worklog effort was started. Required when
  /// creating a worklog. Optional when updating a worklog.
  final DateTime? started;

  /// The time spent working on the issue as days (#d), hours (#h), or minutes
  /// (#m or #). Required when creating a worklog if `timeSpentSeconds` isn't
  /// provided. Optional when updating a worklog. Cannot be provided if
  /// `timeSpentSecond` is provided.
  final String? timeSpent;

  /// The time in seconds spent working on the issue. Required when creating a
  /// worklog if `timeSpent` isn't provided. Optional when updating a worklog.
  /// Cannot be provided if `timeSpent` is provided.
  final int? timeSpentSeconds;

  /// Details of the user who last updated the worklog.
  final UserDetails? updateAuthor;

  /// The datetime on which the worklog was last updated.
  final DateTime? updated;

  /// Details about any restrictions in the visibility of the worklog. Optional
  /// when creating or updating a worklog.
  final Visibility? visibility;

  Worklog(
      {this.author,
      this.comment,
      this.created,
      this.id,
      this.issueId,
      List<EntityProperty>? properties,
      this.self,
      this.started,
      this.timeSpent,
      this.timeSpentSeconds,
      this.updateAuthor,
      this.updated,
      this.visibility})
      : properties = properties ?? [];

  factory Worklog.fromJson(Map<String, Object?> json) {
    return Worklog(
      author: json[r'author'] != null
          ? UserDetails.fromJson(json[r'author']! as Map<String, Object?>)
          : null,
      comment: json[r'comment'],
      created: DateTime.tryParse(json[r'created'] as String? ?? ''),
      id: json[r'id'] as String?,
      issueId: json[r'issueId'] as String?,
      properties: (json[r'properties'] as List<Object?>?)
              ?.map((i) => EntityProperty.fromJson(
                  i as Map<String, Object?>? ?? const {}))
              .toList() ??
          [],
      self: json[r'self'] as String?,
      started: DateTime.tryParse(json[r'started'] as String? ?? ''),
      timeSpent: json[r'timeSpent'] as String?,
      timeSpentSeconds: (json[r'timeSpentSeconds'] as num?)?.toInt(),
      updateAuthor: json[r'updateAuthor'] != null
          ? UserDetails.fromJson(json[r'updateAuthor']! as Map<String, Object?>)
          : null,
      updated: DateTime.tryParse(json[r'updated'] as String? ?? ''),
      visibility: json[r'visibility'] != null
          ? Visibility.fromJson(json[r'visibility']! as Map<String, Object?>)
          : null,
    );
  }

  Map<String, Object?> toJson() {
    var author = this.author;
    var comment = this.comment;
    var created = this.created;
    var id = this.id;
    var issueId = this.issueId;
    var properties = this.properties;
    var self = this.self;
    var started = this.started;
    var timeSpent = this.timeSpent;
    var timeSpentSeconds = this.timeSpentSeconds;
    var updateAuthor = this.updateAuthor;
    var updated = this.updated;
    var visibility = this.visibility;

    final json = <String, Object?>{};
    if (author != null) {
      json[r'author'] = author.toJson();
    }
    if (comment != null) {
      json[r'comment'] = comment;
    }
    if (created != null) {
      json[r'created'] = created.toIso8601String();
    }
    if (id != null) {
      json[r'id'] = id;
    }
    if (issueId != null) {
      json[r'issueId'] = issueId;
    }
    json[r'properties'] = properties.map((i) => i.toJson()).toList();
    if (self != null) {
      json[r'self'] = self;
    }
    if (started != null) {
      json[r'started'] = started.toIso8601String();
    }
    if (timeSpent != null) {
      json[r'timeSpent'] = timeSpent;
    }
    if (timeSpentSeconds != null) {
      json[r'timeSpentSeconds'] = timeSpentSeconds;
    }
    if (updateAuthor != null) {
      json[r'updateAuthor'] = updateAuthor.toJson();
    }
    if (updated != null) {
      json[r'updated'] = updated.toIso8601String();
    }
    if (visibility != null) {
      json[r'visibility'] = visibility.toJson();
    }
    return json;
  }

  Worklog copyWith(
      {UserDetails? author,
      dynamic comment,
      DateTime? created,
      String? id,
      String? issueId,
      List<EntityProperty>? properties,
      String? self,
      DateTime? started,
      String? timeSpent,
      int? timeSpentSeconds,
      UserDetails? updateAuthor,
      DateTime? updated,
      Visibility? visibility}) {
    return Worklog(
      author: author ?? this.author,
      comment: comment ?? this.comment,
      created: created ?? this.created,
      id: id ?? this.id,
      issueId: issueId ?? this.issueId,
      properties: properties ?? this.properties,
      self: self ?? this.self,
      started: started ?? this.started,
      timeSpent: timeSpent ?? this.timeSpent,
      timeSpentSeconds: timeSpentSeconds ?? this.timeSpentSeconds,
      updateAuthor: updateAuthor ?? this.updateAuthor,
      updated: updated ?? this.updated,
      visibility: visibility ?? this.visibility,
    );
  }
}

class WorklogIdsRequestBean {
  /// A list of worklog IDs.
  final List<int> ids;

  WorklogIdsRequestBean({required this.ids});

  factory WorklogIdsRequestBean.fromJson(Map<String, Object?> json) {
    return WorklogIdsRequestBean(
      ids: (json[r'ids'] as List<Object?>?)
              ?.map((i) => (i as num?)?.toInt() ?? 0)
              .toList() ??
          [],
    );
  }

  Map<String, Object?> toJson() {
    var ids = this.ids;

    final json = <String, Object?>{};
    json[r'ids'] = ids;
    return json;
  }

  WorklogIdsRequestBean copyWith({List<int>? ids}) {
    return WorklogIdsRequestBean(
      ids: ids ?? this.ids,
    );
  }
}
